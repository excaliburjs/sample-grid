{"mappings":"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","sources":["node_modules/@parcel/runtime-js/lib/helpers/bundle-manifest.js","node_modules/@parcel/runtime-js/lib/runtime-3e98e8c846e5ea7b.js","node_modules/excalibur/build/node_modules/core-js/es/array/sort.js","node_modules/excalibur/build/node_modules/core-js/es/object/keys.js","node_modules/excalibur/build/node_modules/core-js/internals/a-callable.js","node_modules/excalibur/build/node_modules/core-js/internals/an-object.js","node_modules/excalibur/build/node_modules/core-js/internals/array-includes.js","node_modules/excalibur/build/node_modules/core-js/internals/array-method-is-strict.js","node_modules/excalibur/build/node_modules/core-js/internals/array-slice-simple.js","node_modules/excalibur/build/node_modules/core-js/internals/array-sort.js","node_modules/excalibur/build/node_modules/core-js/internals/classof-raw.js","node_modules/excalibur/build/node_modules/core-js/internals/classof.js","node_modules/excalibur/build/node_modules/core-js/internals/copy-constructor-properties.js","node_modules/excalibur/build/node_modules/core-js/internals/create-non-enumerable-property.js","node_modules/excalibur/build/node_modules/core-js/internals/create-property-descriptor.js","node_modules/excalibur/build/node_modules/core-js/internals/create-property.js","node_modules/excalibur/build/node_modules/core-js/internals/define-built-in.js","node_modules/excalibur/build/node_modules/core-js/internals/descriptors.js","node_modules/excalibur/build/node_modules/core-js/internals/document-create-element.js","node_modules/excalibur/build/node_modules/core-js/internals/engine-ff-version.js","node_modules/excalibur/build/node_modules/core-js/internals/engine-is-ie-or-edge.js","node_modules/excalibur/build/node_modules/core-js/internals/engine-user-agent.js","node_modules/excalibur/build/node_modules/core-js/internals/engine-v8-version.js","node_modules/excalibur/build/node_modules/core-js/internals/engine-webkit-version.js","node_modules/excalibur/build/node_modules/core-js/internals/entry-unbind.js","node_modules/excalibur/build/node_modules/core-js/internals/enum-bug-keys.js","node_modules/excalibur/build/node_modules/core-js/internals/export.js","node_modules/excalibur/build/node_modules/core-js/internals/fails.js","node_modules/excalibur/build/node_modules/core-js/internals/function-bind-native.js","node_modules/excalibur/build/node_modules/core-js/internals/function-call.js","node_modules/excalibur/build/node_modules/core-js/internals/function-name.js","node_modules/excalibur/build/node_modules/core-js/internals/function-uncurry-this.js","node_modules/excalibur/build/node_modules/core-js/internals/get-built-in.js","node_modules/excalibur/build/node_modules/core-js/internals/get-method.js","node_modules/excalibur/build/node_modules/core-js/internals/global.js","node_modules/excalibur/build/node_modules/core-js/internals/has-own-property.js","node_modules/excalibur/build/node_modules/core-js/internals/hidden-keys.js","node_modules/excalibur/build/node_modules/core-js/internals/ie8-dom-define.js","node_modules/excalibur/build/node_modules/core-js/internals/indexed-object.js","node_modules/excalibur/build/node_modules/core-js/internals/inspect-source.js","node_modules/excalibur/build/node_modules/core-js/internals/internal-state.js","node_modules/excalibur/build/node_modules/core-js/internals/is-callable.js","node_modules/excalibur/build/node_modules/core-js/internals/is-forced.js","node_modules/excalibur/build/node_modules/core-js/internals/is-object.js","node_modules/excalibur/build/node_modules/core-js/internals/is-pure.js","node_modules/excalibur/build/node_modules/core-js/internals/is-symbol.js","node_modules/excalibur/build/node_modules/core-js/internals/length-of-array-like.js","node_modules/excalibur/build/node_modules/core-js/internals/make-built-in.js","node_modules/excalibur/build/node_modules/core-js/internals/native-symbol.js","node_modules/excalibur/build/node_modules/core-js/internals/native-weak-map.js","node_modules/excalibur/build/node_modules/core-js/internals/object-define-property.js","node_modules/excalibur/build/node_modules/core-js/internals/object-get-own-property-descriptor.js","node_modules/excalibur/build/node_modules/core-js/internals/object-get-own-property-names.js","node_modules/excalibur/build/node_modules/core-js/internals/object-get-own-property-symbols.js","node_modules/excalibur/build/node_modules/core-js/internals/object-is-prototype-of.js","node_modules/excalibur/build/node_modules/core-js/internals/object-keys-internal.js","node_modules/excalibur/build/node_modules/core-js/internals/object-keys.js","node_modules/excalibur/build/node_modules/core-js/internals/object-property-is-enumerable.js","node_modules/excalibur/build/node_modules/core-js/internals/ordinary-to-primitive.js","node_modules/excalibur/build/node_modules/core-js/internals/own-keys.js","node_modules/excalibur/build/node_modules/core-js/internals/path.js","node_modules/excalibur/build/node_modules/core-js/internals/require-object-coercible.js","node_modules/excalibur/build/node_modules/core-js/internals/set-global.js","node_modules/excalibur/build/node_modules/core-js/internals/shared-key.js","node_modules/excalibur/build/node_modules/core-js/internals/shared-store.js","node_modules/excalibur/build/node_modules/core-js/internals/shared.js","node_modules/excalibur/build/node_modules/core-js/internals/to-absolute-index.js","node_modules/excalibur/build/node_modules/core-js/internals/to-indexed-object.js","node_modules/excalibur/build/node_modules/core-js/internals/to-integer-or-infinity.js","node_modules/excalibur/build/node_modules/core-js/internals/to-length.js","node_modules/excalibur/build/node_modules/core-js/internals/to-object.js","node_modules/excalibur/build/node_modules/core-js/internals/to-primitive.js","node_modules/excalibur/build/node_modules/core-js/internals/to-property-key.js","node_modules/excalibur/build/node_modules/core-js/internals/to-string-tag-support.js","node_modules/excalibur/build/node_modules/core-js/internals/to-string.js","node_modules/excalibur/build/node_modules/core-js/internals/try-to-string.js","node_modules/excalibur/build/node_modules/core-js/internals/uid.js","node_modules/excalibur/build/node_modules/core-js/internals/use-symbol-as-uid.js","node_modules/excalibur/build/node_modules/core-js/internals/v8-prototype-define-bug.js","node_modules/excalibur/build/node_modules/core-js/internals/well-known-symbol.js","node_modules/excalibur/build/node_modules/core-js/modules/es.array.sort.js","node_modules/excalibur/build/node_modules/core-js/modules/es.object.keys.js","node_modules/excalibur/build/esm/webpack:/Loader.css","node_modules/excalibur/build/esm/webpack:/Util/Toaster.css","node_modules/excalibur/build/node_modules/css-loader/dist/runtime/api.js","node_modules/excalibur/build/node_modules/css-loader/dist/runtime/sourceMaps.js","node_modules/excalibur/build/esm/webpack:/webpack/bootstrap","node_modules/excalibur/build/esm/webpack:/webpack/runtime/compat get default export","node_modules/excalibur/build/esm/webpack:/webpack/runtime/define property getters","node_modules/excalibur/build/esm/webpack:/webpack/runtime/global","node_modules/excalibur/build/esm/webpack:/webpack/runtime/hasOwnProperty shorthand","node_modules/excalibur/build/esm/webpack:/webpack/runtime/make namespace object","node_modules/excalibur/build/esm/webpack:/Color.ts","node_modules/excalibur/build/esm/webpack:/Math/Random.ts","node_modules/excalibur/build/esm/webpack:/Polyfill.ts","node_modules/excalibur/build/esm/webpack:/Flags.ts","node_modules/excalibur/build/esm/webpack:/Id.ts","node_modules/excalibur/build/esm/webpack:/Math/vector.ts","node_modules/excalibur/build/esm/webpack:/Util/Log.ts","node_modules/excalibur/build/esm/webpack:/Collision/Side.ts","node_modules/excalibur/build/esm/webpack:/Collision/BoundingBox.ts","node_modules/excalibur/build/esm/webpack:/Util/Util.ts","node_modules/excalibur/build/esm/webpack:/Math/util.ts","node_modules/excalibur/build/esm/webpack:/Math/matrix.ts","node_modules/excalibur/build/esm/webpack:/Graphics/Context/transform-stack.ts","node_modules/excalibur/build/esm/webpack:/Graphics/Context/state-stack.ts","node_modules/excalibur/build/esm/webpack:/Events.ts","node_modules/excalibur/build/esm/webpack:/Graphics/Graphic.ts","node_modules/excalibur/build/esm/webpack:/EventDispatcher.ts","node_modules/excalibur/build/esm/webpack:/Resources/Resource.ts","node_modules/excalibur/build/esm/webpack:/Util/Watch.ts","node_modules/excalibur/build/esm/webpack:/Graphics/Sprite.ts","node_modules/excalibur/build/esm/webpack:/Graphics/Filtering.ts","node_modules/excalibur/build/esm/webpack:/Graphics/Context/webgl-util.ts","node_modules/excalibur/build/esm/webpack:/Graphics/Context/texture-loader.ts","node_modules/excalibur/build/esm/webpack:/Graphics/ImageSource.ts","node_modules/excalibur/build/esm/webpack:/Graphics/SpriteSheet.ts","node_modules/excalibur/build/esm/webpack:/Graphics/SpriteFont.ts","node_modules/excalibur/build/esm/webpack:/Graphics/Context/debug-text.ts","node_modules/excalibur/build/esm/webpack:/Graphics/Context/render-source.ts","node_modules/excalibur/build/esm/webpack:/Graphics/Context/render-target.ts","node_modules/excalibur/build/esm/webpack:/Graphics/Context/webgl-adapter.ts","node_modules/excalibur/build/esm/webpack:/Graphics/Context/shader.ts","node_modules/excalibur/build/esm/webpack:/Graphics/Context/vertex-buffer.ts","node_modules/excalibur/build/esm/webpack:/Graphics/Context/vertex-layout.ts","node_modules/excalibur/build/esm/webpack:/Graphics/GraphicsDiagnostics.ts","node_modules/excalibur/build/esm/webpack:/Graphics/Context/line-renderer/line-renderer.ts","node_modules/excalibur/build/esm/webpack:/Graphics/Context/point-renderer/point-vertex.glsl","node_modules/excalibur/build/esm/webpack:/Graphics/Context/point-renderer/point-fragment.glsl","node_modules/excalibur/build/esm/webpack:/Graphics/Context/point-renderer/point-renderer.ts","node_modules/excalibur/build/esm/webpack:/Graphics/Context/screen-pass-painter/screen-fragment.glsl","node_modules/excalibur/build/esm/webpack:/Graphics/Context/screen-pass-painter/screen-pass-painter.ts","node_modules/excalibur/build/esm/webpack:/Graphics/Context/quad-index-buffer.ts","node_modules/excalibur/build/esm/webpack:/Graphics/Context/image-renderer/image-renderer.ts","node_modules/excalibur/build/esm/webpack:/Graphics/Context/rectangle-renderer/rectangle-renderer.frag.glsl","node_modules/excalibur/build/esm/webpack:/Graphics/Context/rectangle-renderer/rectangle-renderer.ts","node_modules/excalibur/build/esm/webpack:/Graphics/Context/circle-renderer/circle-renderer.ts","node_modules/excalibur/build/esm/webpack:/Util/Pool.ts","node_modules/excalibur/build/esm/webpack:/Graphics/Context/draw-call.ts","node_modules/excalibur/build/esm/webpack:/Graphics/Context/ExcaliburGraphicsContextWebGL.ts","node_modules/excalibur/build/esm/webpack:/Graphics/Context/ExcaliburGraphicsContext2DCanvas.ts","node_modules/excalibur/build/esm/webpack:/Screen.ts","node_modules/excalibur/build/esm/webpack:/Resources/Sound/AudioContext.ts","node_modules/excalibur/build/esm/webpack:/Util/WebAudio.ts","node_modules/excalibur/build/esm/webpack:/Class.ts","node_modules/excalibur/build/esm/webpack:/Util/DrawUtil.ts","node_modules/excalibur/build/esm/webpack:/Graphics/Raster.ts","node_modules/excalibur/build/esm/webpack:/Loader.logo.png","node_modules/excalibur/build/esm/webpack:/Graphics/Canvas.ts","node_modules/excalibur/build/esm/webpack:/Loader.ts","node_modules/excalibur/build/esm/webpack:/Util/Detector.ts","node_modules/excalibur/build/esm/webpack:/Collision/CollisionType.ts","node_modules/excalibur/build/esm/webpack:/Util/Decorators.ts","node_modules/excalibur/build/esm/webpack:/Collision/Physics.ts","node_modules/excalibur/build/esm/webpack:/Math/vector-view.ts","node_modules/excalibur/build/esm/webpack:/EntityComponentSystem/Component.ts","node_modules/excalibur/build/esm/webpack:/Util/Observable.ts","node_modules/excalibur/build/esm/webpack:/EntityComponentSystem/Components/TransformComponent.ts","node_modules/excalibur/build/esm/webpack:/EntityComponentSystem/Components/MotionComponent.ts","node_modules/excalibur/build/esm/webpack:/Collision/Group/CollisionGroup.ts","node_modules/excalibur/build/esm/webpack:/Collision/Detection/Pair.ts","node_modules/excalibur/build/esm/webpack:/Math/projection.ts","node_modules/excalibur/build/esm/webpack:/Collision/Detection/DynamicTree.ts","node_modules/excalibur/build/esm/webpack:/Math/ray.ts","node_modules/excalibur/build/esm/webpack:/Collision/Detection/DynamicTreeCollisionProcessor.ts","node_modules/excalibur/build/esm/webpack:/Collision/Colliders/Collider.ts","node_modules/excalibur/build/esm/webpack:/Collision/Colliders/CompositeCollider.ts","node_modules/excalibur/build/esm/webpack:/Math/line-segment.ts","node_modules/excalibur/build/esm/webpack:/Collision/Colliders/ClosestLineJumpTable.ts","node_modules/excalibur/build/esm/webpack:/Collision/Colliders/CircleCollider.ts","node_modules/excalibur/build/esm/webpack:/Collision/Detection/CollisionContact.ts","node_modules/excalibur/build/esm/webpack:/Collision/Colliders/SeparatingAxis.ts","node_modules/excalibur/build/esm/webpack:/Collision/Colliders/CollisionJumpTable.ts","node_modules/excalibur/build/esm/webpack:/Collision/Colliders/EdgeCollider.ts","node_modules/excalibur/build/esm/webpack:/Collision/Colliders/PolygonCollider.ts","node_modules/excalibur/build/esm/webpack:/Collision/Colliders/Shape.ts","node_modules/excalibur/build/esm/webpack:/Collision/ColliderComponent.ts","node_modules/excalibur/build/esm/webpack:/Collision/BodyComponent.ts","node_modules/excalibur/build/esm/webpack:/EntityComponentSystem/Entity.ts","node_modules/excalibur/build/esm/webpack:/Graphics/GraphicsComponent.ts","node_modules/excalibur/build/esm/webpack:/Graphics/Rectangle.ts","node_modules/excalibur/build/esm/webpack:/Graphics/Circle.ts","node_modules/excalibur/build/esm/webpack:/Input/PointerComponent.ts","node_modules/excalibur/build/esm/webpack:/Util/EasingFunctions.ts","node_modules/excalibur/build/esm/webpack:/Actions/ActionQueue.ts","node_modules/excalibur/build/esm/webpack:/Actions/Action/Repeat.ts","node_modules/excalibur/build/esm/webpack:/Actions/Action/RepeatForever.ts","node_modules/excalibur/build/esm/webpack:/Actions/Action/MoveBy.ts","node_modules/excalibur/build/esm/webpack:/Actions/Action/MoveTo.ts","node_modules/excalibur/build/esm/webpack:/Actions/RotationType.ts","node_modules/excalibur/build/esm/webpack:/Actions/Action/RotateTo.ts","node_modules/excalibur/build/esm/webpack:/Actions/Action/RotateBy.ts","node_modules/excalibur/build/esm/webpack:/Actions/Action/ScaleTo.ts","node_modules/excalibur/build/esm/webpack:/Actions/Action/ScaleBy.ts","node_modules/excalibur/build/esm/webpack:/Actions/Action/CallMethod.ts","node_modules/excalibur/build/esm/webpack:/Actions/Action/EaseTo.ts","node_modules/excalibur/build/esm/webpack:/Actions/Action/Blink.ts","node_modules/excalibur/build/esm/webpack:/Actions/Action/Fade.ts","node_modules/excalibur/build/esm/webpack:/Actions/Action/Delay.ts","node_modules/excalibur/build/esm/webpack:/Actions/Action/Die.ts","node_modules/excalibur/build/esm/webpack:/Actions/Action/Follow.ts","node_modules/excalibur/build/esm/webpack:/Actions/Action/Meet.ts","node_modules/excalibur/build/esm/webpack:/Actions/ActionContext.ts","node_modules/excalibur/build/esm/webpack:/Actions/ActionsComponent.ts","node_modules/excalibur/build/esm/webpack:/Graphics/FontCommon.ts","node_modules/excalibur/build/esm/webpack:/Graphics/Font.ts","node_modules/excalibur/build/esm/webpack:/Graphics/Text.ts","node_modules/excalibur/build/esm/webpack:/Trigger.ts","node_modules/excalibur/build/esm/webpack:/Graphics/Animation.ts","node_modules/excalibur/build/esm/webpack:/Graphics/GraphicsGroup.ts","node_modules/excalibur/build/esm/webpack:/Input/Keyboard.ts","node_modules/excalibur/build/esm/webpack:/Actor.ts","node_modules/excalibur/build/esm/webpack:/ScreenElement.ts","node_modules/excalibur/build/esm/webpack:/Timer.ts","node_modules/excalibur/build/esm/webpack:/Graphics/ParallaxComponent.ts","node_modules/excalibur/build/esm/webpack:/Graphics/DebugGraphicsComponent.ts","node_modules/excalibur/build/esm/webpack:/TileMap/TileMap.ts","node_modules/excalibur/build/esm/webpack:/Camera.ts","node_modules/excalibur/build/esm/webpack:/EntityComponentSystem/System.ts","node_modules/excalibur/build/esm/webpack:/EntityComponentSystem/EntityManager.ts","node_modules/excalibur/build/esm/webpack:/EntityComponentSystem/Util.ts","node_modules/excalibur/build/esm/webpack:/EntityComponentSystem/Query.ts","node_modules/excalibur/build/esm/webpack:/EntityComponentSystem/QueryManager.ts","node_modules/excalibur/build/esm/webpack:/EntityComponentSystem/SystemManager.ts","node_modules/excalibur/build/esm/webpack:/EntityComponentSystem/World.ts","node_modules/excalibur/build/esm/webpack:/Collision/Integrator.ts","node_modules/excalibur/build/esm/webpack:/Collision/MotionSystem.ts","node_modules/excalibur/build/esm/webpack:/Collision/Solver/Solver.ts","node_modules/excalibur/build/esm/webpack:/Collision/Solver/ArcadeSolver.ts","node_modules/excalibur/build/esm/webpack:/Collision/Solver/ContactConstraintPoint.ts","node_modules/excalibur/build/esm/webpack:/Collision/Solver/RealisticSolver.ts","node_modules/excalibur/build/esm/webpack:/Collision/CollisionSystem.ts","node_modules/excalibur/build/esm/webpack:/Configurable.ts","node_modules/excalibur/build/esm/webpack:/Particles.ts","node_modules/excalibur/build/esm/webpack:/Graphics/GraphicsSystem.ts","node_modules/excalibur/build/esm/webpack:/Debug/DebugSystem.ts","node_modules/excalibur/build/esm/webpack:/Input/PointerSystem.ts","node_modules/excalibur/build/esm/webpack:/Actions/ActionsSystem.ts","node_modules/excalibur/build/esm/webpack:/TileMap/IsometricEntityComponent.ts","node_modules/excalibur/build/esm/webpack:/TileMap/IsometricEntitySystem.ts","node_modules/excalibur/build/esm/webpack:/Graphics/OffscreenSystem.ts","node_modules/excalibur/build/esm/webpack:/Scene.ts","node_modules/excalibur/build/esm/webpack:/Graphics/PostProcessor/ColorBlindnessMode.ts","node_modules/excalibur/build/esm/webpack:/Graphics/PostProcessor/ScreenShader.ts","node_modules/excalibur/build/esm/webpack:/Graphics/PostProcessor/ColorBlindnessPostProcessor.ts","node_modules/excalibur/build/esm/webpack:/Debug/DebugFlags.ts","node_modules/excalibur/build/esm/webpack:/Debug/Debug.ts","node_modules/excalibur/build/esm/webpack:/Input/PointerScope.ts","node_modules/excalibur/build/esm/webpack:/Input/Gamepad.ts","node_modules/excalibur/build/esm/webpack:/Util/Browser.ts","node_modules/excalibur/build/esm/webpack:/Math/global-coordinates.ts","node_modules/excalibur/build/esm/webpack:/Input/PointerEvent.ts","node_modules/excalibur/build/esm/webpack:/Input/WheelEvent.ts","node_modules/excalibur/build/esm/webpack:/Input/PointerAbstraction.ts","node_modules/excalibur/build/esm/webpack:/Input/PointerButton.ts","node_modules/excalibur/build/esm/webpack:/Input/PointerType.ts","node_modules/excalibur/build/esm/webpack:/Input/PointerEventReceiver.ts","node_modules/excalibur/build/esm/webpack:/Util/Fps.ts","node_modules/excalibur/build/esm/webpack:/Util/Clock.ts","node_modules/excalibur/build/esm/webpack:/Util/Toaster.ts","node_modules/excalibur/build/esm/webpack:/Engine.ts","node_modules/excalibur/build/esm/webpack:/Events/MediaEvents.ts","node_modules/excalibur/build/esm/webpack:/Label.ts","node_modules/excalibur/build/esm/webpack:/TileMap/IsometricMap.ts","node_modules/excalibur/build/esm/webpack:/Collision/Group/CollisionGroupManager.ts","node_modules/excalibur/build/esm/webpack:/Interfaces/AudioImplementation.ts","node_modules/excalibur/build/esm/webpack:/Interfaces/LifecycleEvents.ts","node_modules/excalibur/build/esm/webpack:/Resources/Sound/WebAudioInstance.ts","node_modules/excalibur/build/esm/webpack:/Util/Sound.ts","node_modules/excalibur/build/esm/webpack:/Resources/Sound/Sound.ts","node_modules/excalibur/build/esm/webpack:/Resources/Gif.ts","node_modules/excalibur/build/esm/webpack:/Graphics/Line.ts","node_modules/excalibur/build/esm/webpack:/Graphics/Polygon.ts","node_modules/excalibur/build/esm/webpack:/index.ts","node_modules/@parcel/runtime-js/lib/runtime-1f5dcfab3d3390af.js","node_modules/@parcel/runtime-js/lib/runtime-d4bbab3a98c6143a.js","node_modules/@parcel/runtime-js/lib/runtime-10d9a65c0c7883f5.js","node_modules/@parcel/runtime-js/lib/runtime-6bbf6452a7393a1c.js","node_modules/@parcel/runtime-js/lib/runtime-4c1ae4ead4b043dc.js","node_modules/@parcel/runtime-js/lib/runtime-03ac81f06ee2e936.js","node_modules/@parcel/runtime-js/lib/runtime-95eec85ddf6c2d34.js","src/resources.ts","src/beetle.ts","src/dirt-grid.ts","src/main.ts","src/level.ts"],"sourcesContent":["\"use strict\";\n\nvar mapping = {};\n\nfunction register(pairs) {\n  var keys = Object.keys(pairs);\n\n  for (var i = 0; i < keys.length; i++) {\n    mapping[keys[i]] = pairs[keys[i]];\n  }\n}\n\nfunction resolve(id) {\n  var resolved = mapping[id];\n\n  if (resolved == null) {\n    throw new Error('Could not resolve bundle with id ' + id);\n  }\n\n  return resolved;\n}\n\nmodule.exports.register = register;\nmodule.exports.resolve = resolve;","require('./helpers/bundle-manifest').register(JSON.parse(\"{\\\"aT88m\\\":\\\"index.171a732f.js\\\",\\\"f10Mh\\\":\\\"beetle.12385627.png\\\",\\\"1E0I3\\\":\\\"dirt_front.8970e25e.png\\\",\\\"38rEr\\\":\\\"dirt_back.db9f073c.png\\\",\\\"hcv2s\\\":\\\"dig.32a53bd9.wav\\\",\\\"jDWyM\\\":\\\"dig.dae650da.mp3\\\",\\\"lxy2T\\\":\\\"clank.3e05cde9.wav\\\",\\\"kicyl\\\":\\\"clank.b08da7b3.mp3\\\"}\"));","require('../../modules/es.array.sort');\nvar entryUnbind = require('../../internals/entry-unbind');\n\nmodule.exports = entryUnbind('Array', 'sort');\n","require('../../modules/es.object.keys');\nvar path = require('../../internals/path');\n\nmodule.exports = path.Object.keys;\n","var global = require('../internals/global');\nvar isCallable = require('../internals/is-callable');\nvar tryToString = require('../internals/try-to-string');\n\nvar TypeError = global.TypeError;\n\n// `Assert: IsCallable(argument) is true`\nmodule.exports = function (argument) {\n  if (isCallable(argument)) return argument;\n  throw TypeError(tryToString(argument) + ' is not a function');\n};\n","var global = require('../internals/global');\nvar isObject = require('../internals/is-object');\n\nvar String = global.String;\nvar TypeError = global.TypeError;\n\n// `Assert: Type(argument) is Object`\nmodule.exports = function (argument) {\n  if (isObject(argument)) return argument;\n  throw TypeError(String(argument) + ' is not an object');\n};\n","var toIndexedObject = require('../internals/to-indexed-object');\nvar toAbsoluteIndex = require('../internals/to-absolute-index');\nvar lengthOfArrayLike = require('../internals/length-of-array-like');\n\n// `Array.prototype.{ indexOf, includes }` methods implementation\nvar createMethod = function (IS_INCLUDES) {\n  return function ($this, el, fromIndex) {\n    var O = toIndexedObject($this);\n    var length = lengthOfArrayLike(O);\n    var index = toAbsoluteIndex(fromIndex, length);\n    var value;\n    // Array#includes uses SameValueZero equality algorithm\n    // eslint-disable-next-line no-self-compare -- NaN check\n    if (IS_INCLUDES && el != el) while (length > index) {\n      value = O[index++];\n      // eslint-disable-next-line no-self-compare -- NaN check\n      if (value != value) return true;\n    // Array#indexOf ignores holes, Array#includes - not\n    } else for (;length > index; index++) {\n      if ((IS_INCLUDES || index in O) && O[index] === el) return IS_INCLUDES || index || 0;\n    } return !IS_INCLUDES && -1;\n  };\n};\n\nmodule.exports = {\n  // `Array.prototype.includes` method\n  // https://tc39.es/ecma262/#sec-array.prototype.includes\n  includes: createMethod(true),\n  // `Array.prototype.indexOf` method\n  // https://tc39.es/ecma262/#sec-array.prototype.indexof\n  indexOf: createMethod(false)\n};\n","'use strict';\nvar fails = require('../internals/fails');\n\nmodule.exports = function (METHOD_NAME, argument) {\n  var method = [][METHOD_NAME];\n  return !!method && fails(function () {\n    // eslint-disable-next-line no-useless-call -- required for testing\n    method.call(null, argument || function () { return 1; }, 1);\n  });\n};\n","var global = require('../internals/global');\nvar toAbsoluteIndex = require('../internals/to-absolute-index');\nvar lengthOfArrayLike = require('../internals/length-of-array-like');\nvar createProperty = require('../internals/create-property');\n\nvar Array = global.Array;\nvar max = Math.max;\n\nmodule.exports = function (O, start, end) {\n  var length = lengthOfArrayLike(O);\n  var k = toAbsoluteIndex(start, length);\n  var fin = toAbsoluteIndex(end === undefined ? length : end, length);\n  var result = Array(max(fin - k, 0));\n  for (var n = 0; k < fin; k++, n++) createProperty(result, n, O[k]);\n  result.length = n;\n  return result;\n};\n","var arraySlice = require('../internals/array-slice-simple');\n\nvar floor = Math.floor;\n\nvar mergeSort = function (array, comparefn) {\n  var length = array.length;\n  var middle = floor(length / 2);\n  return length < 8 ? insertionSort(array, comparefn) : merge(\n    array,\n    mergeSort(arraySlice(array, 0, middle), comparefn),\n    mergeSort(arraySlice(array, middle), comparefn),\n    comparefn\n  );\n};\n\nvar insertionSort = function (array, comparefn) {\n  var length = array.length;\n  var i = 1;\n  var element, j;\n\n  while (i < length) {\n    j = i;\n    element = array[i];\n    while (j && comparefn(array[j - 1], element) > 0) {\n      array[j] = array[--j];\n    }\n    if (j !== i++) array[j] = element;\n  } return array;\n};\n\nvar merge = function (array, left, right, comparefn) {\n  var llength = left.length;\n  var rlength = right.length;\n  var lindex = 0;\n  var rindex = 0;\n\n  while (lindex < llength || rindex < rlength) {\n    array[lindex + rindex] = (lindex < llength && rindex < rlength)\n      ? comparefn(left[lindex], right[rindex]) <= 0 ? left[lindex++] : right[rindex++]\n      : lindex < llength ? left[lindex++] : right[rindex++];\n  } return array;\n};\n\nmodule.exports = mergeSort;\n","var uncurryThis = require('../internals/function-uncurry-this');\n\nvar toString = uncurryThis({}.toString);\nvar stringSlice = uncurryThis(''.slice);\n\nmodule.exports = function (it) {\n  return stringSlice(toString(it), 8, -1);\n};\n","var global = require('../internals/global');\nvar TO_STRING_TAG_SUPPORT = require('../internals/to-string-tag-support');\nvar isCallable = require('../internals/is-callable');\nvar classofRaw = require('../internals/classof-raw');\nvar wellKnownSymbol = require('../internals/well-known-symbol');\n\nvar TO_STRING_TAG = wellKnownSymbol('toStringTag');\nvar Object = global.Object;\n\n// ES3 wrong here\nvar CORRECT_ARGUMENTS = classofRaw(function () { return arguments; }()) == 'Arguments';\n\n// fallback for IE11 Script Access Denied error\nvar tryGet = function (it, key) {\n  try {\n    return it[key];\n  } catch (error) { /* empty */ }\n};\n\n// getting tag from ES6+ `Object.prototype.toString`\nmodule.exports = TO_STRING_TAG_SUPPORT ? classofRaw : function (it) {\n  var O, tag, result;\n  return it === undefined ? 'Undefined' : it === null ? 'Null'\n    // @@toStringTag case\n    : typeof (tag = tryGet(O = Object(it), TO_STRING_TAG)) == 'string' ? tag\n    // builtinTag case\n    : CORRECT_ARGUMENTS ? classofRaw(O)\n    // ES3 arguments fallback\n    : (result = classofRaw(O)) == 'Object' && isCallable(O.callee) ? 'Arguments' : result;\n};\n","var hasOwn = require('../internals/has-own-property');\nvar ownKeys = require('../internals/own-keys');\nvar getOwnPropertyDescriptorModule = require('../internals/object-get-own-property-descriptor');\nvar definePropertyModule = require('../internals/object-define-property');\n\nmodule.exports = function (target, source, exceptions) {\n  var keys = ownKeys(source);\n  var defineProperty = definePropertyModule.f;\n  var getOwnPropertyDescriptor = getOwnPropertyDescriptorModule.f;\n  for (var i = 0; i < keys.length; i++) {\n    var key = keys[i];\n    if (!hasOwn(target, key) && !(exceptions && hasOwn(exceptions, key))) {\n      defineProperty(target, key, getOwnPropertyDescriptor(source, key));\n    }\n  }\n};\n","var DESCRIPTORS = require('../internals/descriptors');\nvar definePropertyModule = require('../internals/object-define-property');\nvar createPropertyDescriptor = require('../internals/create-property-descriptor');\n\nmodule.exports = DESCRIPTORS ? function (object, key, value) {\n  return definePropertyModule.f(object, key, createPropertyDescriptor(1, value));\n} : function (object, key, value) {\n  object[key] = value;\n  return object;\n};\n","module.exports = function (bitmap, value) {\n  return {\n    enumerable: !(bitmap & 1),\n    configurable: !(bitmap & 2),\n    writable: !(bitmap & 4),\n    value: value\n  };\n};\n","'use strict';\nvar toPropertyKey = require('../internals/to-property-key');\nvar definePropertyModule = require('../internals/object-define-property');\nvar createPropertyDescriptor = require('../internals/create-property-descriptor');\n\nmodule.exports = function (object, key, value) {\n  var propertyKey = toPropertyKey(key);\n  if (propertyKey in object) definePropertyModule.f(object, propertyKey, createPropertyDescriptor(0, value));\n  else object[propertyKey] = value;\n};\n","var global = require('../internals/global');\nvar isCallable = require('../internals/is-callable');\nvar createNonEnumerableProperty = require('../internals/create-non-enumerable-property');\nvar makeBuiltIn = require('../internals/make-built-in');\nvar setGlobal = require('../internals/set-global');\n\nmodule.exports = function (O, key, value, options) {\n  var unsafe = options ? !!options.unsafe : false;\n  var simple = options ? !!options.enumerable : false;\n  var noTargetGet = options ? !!options.noTargetGet : false;\n  var name = options && options.name !== undefined ? options.name : key;\n  if (isCallable(value)) makeBuiltIn(value, name, options);\n  if (O === global) {\n    if (simple) O[key] = value;\n    else setGlobal(key, value);\n    return O;\n  } else if (!unsafe) {\n    delete O[key];\n  } else if (!noTargetGet && O[key]) {\n    simple = true;\n  }\n  if (simple) O[key] = value;\n  else createNonEnumerableProperty(O, key, value);\n  return O;\n};\n","var fails = require('../internals/fails');\n\n// Detect IE8's incomplete defineProperty implementation\nmodule.exports = !fails(function () {\n  // eslint-disable-next-line es-x/no-object-defineproperty -- required for testing\n  return Object.defineProperty({}, 1, { get: function () { return 7; } })[1] != 7;\n});\n","var global = require('../internals/global');\nvar isObject = require('../internals/is-object');\n\nvar document = global.document;\n// typeof document.createElement is 'object' in old IE\nvar EXISTS = isObject(document) && isObject(document.createElement);\n\nmodule.exports = function (it) {\n  return EXISTS ? document.createElement(it) : {};\n};\n","var userAgent = require('../internals/engine-user-agent');\n\nvar firefox = userAgent.match(/firefox\\/(\\d+)/i);\n\nmodule.exports = !!firefox && +firefox[1];\n","var UA = require('../internals/engine-user-agent');\n\nmodule.exports = /MSIE|Trident/.test(UA);\n","var getBuiltIn = require('../internals/get-built-in');\n\nmodule.exports = getBuiltIn('navigator', 'userAgent') || '';\n","var global = require('../internals/global');\nvar userAgent = require('../internals/engine-user-agent');\n\nvar process = global.process;\nvar Deno = global.Deno;\nvar versions = process && process.versions || Deno && Deno.version;\nvar v8 = versions && versions.v8;\nvar match, version;\n\nif (v8) {\n  match = v8.split('.');\n  // in old Chrome, versions of V8 isn't V8 = Chrome / 10\n  // but their correct versions are not interesting for us\n  version = match[0] > 0 && match[0] < 4 ? 1 : +(match[0] + match[1]);\n}\n\n// BrowserFS NodeJS `process` polyfill incorrectly set `.v8` to `0.0`\n// so check `userAgent` even if `.v8` exists, but 0\nif (!version && userAgent) {\n  match = userAgent.match(/Edge\\/(\\d+)/);\n  if (!match || match[1] >= 74) {\n    match = userAgent.match(/Chrome\\/(\\d+)/);\n    if (match) version = +match[1];\n  }\n}\n\nmodule.exports = version;\n","var userAgent = require('../internals/engine-user-agent');\n\nvar webkit = userAgent.match(/AppleWebKit\\/(\\d+)\\./);\n\nmodule.exports = !!webkit && +webkit[1];\n","var global = require('../internals/global');\nvar uncurryThis = require('../internals/function-uncurry-this');\n\nmodule.exports = function (CONSTRUCTOR, METHOD) {\n  return uncurryThis(global[CONSTRUCTOR].prototype[METHOD]);\n};\n","// IE8- don't enum bug keys\nmodule.exports = [\n  'constructor',\n  'hasOwnProperty',\n  'isPrototypeOf',\n  'propertyIsEnumerable',\n  'toLocaleString',\n  'toString',\n  'valueOf'\n];\n","var global = require('../internals/global');\nvar getOwnPropertyDescriptor = require('../internals/object-get-own-property-descriptor').f;\nvar createNonEnumerableProperty = require('../internals/create-non-enumerable-property');\nvar defineBuiltIn = require('../internals/define-built-in');\nvar setGlobal = require('../internals/set-global');\nvar copyConstructorProperties = require('../internals/copy-constructor-properties');\nvar isForced = require('../internals/is-forced');\n\n/*\n  options.target      - name of the target object\n  options.global      - target is the global object\n  options.stat        - export as static methods of target\n  options.proto       - export as prototype methods of target\n  options.real        - real prototype method for the `pure` version\n  options.forced      - export even if the native feature is available\n  options.bind        - bind methods to the target, required for the `pure` version\n  options.wrap        - wrap constructors to preventing global pollution, required for the `pure` version\n  options.unsafe      - use the simple assignment of property instead of delete + defineProperty\n  options.sham        - add a flag to not completely full polyfills\n  options.enumerable  - export as enumerable property\n  options.noTargetGet - prevent calling a getter on target\n  options.name        - the .name of the function if it does not match the key\n*/\nmodule.exports = function (options, source) {\n  var TARGET = options.target;\n  var GLOBAL = options.global;\n  var STATIC = options.stat;\n  var FORCED, target, key, targetProperty, sourceProperty, descriptor;\n  if (GLOBAL) {\n    target = global;\n  } else if (STATIC) {\n    target = global[TARGET] || setGlobal(TARGET, {});\n  } else {\n    target = (global[TARGET] || {}).prototype;\n  }\n  if (target) for (key in source) {\n    sourceProperty = source[key];\n    if (options.noTargetGet) {\n      descriptor = getOwnPropertyDescriptor(target, key);\n      targetProperty = descriptor && descriptor.value;\n    } else targetProperty = target[key];\n    FORCED = isForced(GLOBAL ? key : TARGET + (STATIC ? '.' : '#') + key, options.forced);\n    // contained in target\n    if (!FORCED && targetProperty !== undefined) {\n      if (typeof sourceProperty == typeof targetProperty) continue;\n      copyConstructorProperties(sourceProperty, targetProperty);\n    }\n    // add a flag to not completely full polyfills\n    if (options.sham || (targetProperty && targetProperty.sham)) {\n      createNonEnumerableProperty(sourceProperty, 'sham', true);\n    }\n    defineBuiltIn(target, key, sourceProperty, options);\n  }\n};\n","module.exports = function (exec) {\n  try {\n    return !!exec();\n  } catch (error) {\n    return true;\n  }\n};\n","var fails = require('../internals/fails');\n\nmodule.exports = !fails(function () {\n  // eslint-disable-next-line es-x/no-function-prototype-bind -- safe\n  var test = (function () { /* empty */ }).bind();\n  // eslint-disable-next-line no-prototype-builtins -- safe\n  return typeof test != 'function' || test.hasOwnProperty('prototype');\n});\n","var NATIVE_BIND = require('../internals/function-bind-native');\n\nvar call = Function.prototype.call;\n\nmodule.exports = NATIVE_BIND ? call.bind(call) : function () {\n  return call.apply(call, arguments);\n};\n","var DESCRIPTORS = require('../internals/descriptors');\nvar hasOwn = require('../internals/has-own-property');\n\nvar FunctionPrototype = Function.prototype;\n// eslint-disable-next-line es-x/no-object-getownpropertydescriptor -- safe\nvar getDescriptor = DESCRIPTORS && Object.getOwnPropertyDescriptor;\n\nvar EXISTS = hasOwn(FunctionPrototype, 'name');\n// additional protection from minified / mangled / dropped function names\nvar PROPER = EXISTS && (function something() { /* empty */ }).name === 'something';\nvar CONFIGURABLE = EXISTS && (!DESCRIPTORS || (DESCRIPTORS && getDescriptor(FunctionPrototype, 'name').configurable));\n\nmodule.exports = {\n  EXISTS: EXISTS,\n  PROPER: PROPER,\n  CONFIGURABLE: CONFIGURABLE\n};\n","var NATIVE_BIND = require('../internals/function-bind-native');\n\nvar FunctionPrototype = Function.prototype;\nvar bind = FunctionPrototype.bind;\nvar call = FunctionPrototype.call;\nvar uncurryThis = NATIVE_BIND && bind.bind(call, call);\n\nmodule.exports = NATIVE_BIND ? function (fn) {\n  return fn && uncurryThis(fn);\n} : function (fn) {\n  return fn && function () {\n    return call.apply(fn, arguments);\n  };\n};\n","var global = require('../internals/global');\nvar isCallable = require('../internals/is-callable');\n\nvar aFunction = function (argument) {\n  return isCallable(argument) ? argument : undefined;\n};\n\nmodule.exports = function (namespace, method) {\n  return arguments.length < 2 ? aFunction(global[namespace]) : global[namespace] && global[namespace][method];\n};\n","var aCallable = require('../internals/a-callable');\n\n// `GetMethod` abstract operation\n// https://tc39.es/ecma262/#sec-getmethod\nmodule.exports = function (V, P) {\n  var func = V[P];\n  return func == null ? undefined : aCallable(func);\n};\n","var check = function (it) {\n  return it && it.Math == Math && it;\n};\n\n// https://github.com/zloirock/core-js/issues/86#issuecomment-115759028\nmodule.exports =\n  // eslint-disable-next-line es-x/no-global-this -- safe\n  check(typeof globalThis == 'object' && globalThis) ||\n  check(typeof window == 'object' && window) ||\n  // eslint-disable-next-line no-restricted-globals -- safe\n  check(typeof self == 'object' && self) ||\n  check(typeof global == 'object' && global) ||\n  // eslint-disable-next-line no-new-func -- fallback\n  (function () { return this; })() || Function('return this')();\n","var uncurryThis = require('../internals/function-uncurry-this');\nvar toObject = require('../internals/to-object');\n\nvar hasOwnProperty = uncurryThis({}.hasOwnProperty);\n\n// `HasOwnProperty` abstract operation\n// https://tc39.es/ecma262/#sec-hasownproperty\n// eslint-disable-next-line es-x/no-object-hasown -- safe\nmodule.exports = Object.hasOwn || function hasOwn(it, key) {\n  return hasOwnProperty(toObject(it), key);\n};\n","module.exports = {};\n","var DESCRIPTORS = require('../internals/descriptors');\nvar fails = require('../internals/fails');\nvar createElement = require('../internals/document-create-element');\n\n// Thanks to IE8 for its funny defineProperty\nmodule.exports = !DESCRIPTORS && !fails(function () {\n  // eslint-disable-next-line es-x/no-object-defineproperty -- required for testing\n  return Object.defineProperty(createElement('div'), 'a', {\n    get: function () { return 7; }\n  }).a != 7;\n});\n","var global = require('../internals/global');\nvar uncurryThis = require('../internals/function-uncurry-this');\nvar fails = require('../internals/fails');\nvar classof = require('../internals/classof-raw');\n\nvar Object = global.Object;\nvar split = uncurryThis(''.split);\n\n// fallback for non-array-like ES3 and non-enumerable old V8 strings\nmodule.exports = fails(function () {\n  // throws an error in rhino, see https://github.com/mozilla/rhino/issues/346\n  // eslint-disable-next-line no-prototype-builtins -- safe\n  return !Object('z').propertyIsEnumerable(0);\n}) ? function (it) {\n  return classof(it) == 'String' ? split(it, '') : Object(it);\n} : Object;\n","var uncurryThis = require('../internals/function-uncurry-this');\nvar isCallable = require('../internals/is-callable');\nvar store = require('../internals/shared-store');\n\nvar functionToString = uncurryThis(Function.toString);\n\n// this helper broken in `core-js@3.4.1-3.4.4`, so we can't use `shared` helper\nif (!isCallable(store.inspectSource)) {\n  store.inspectSource = function (it) {\n    return functionToString(it);\n  };\n}\n\nmodule.exports = store.inspectSource;\n","var NATIVE_WEAK_MAP = require('../internals/native-weak-map');\nvar global = require('../internals/global');\nvar uncurryThis = require('../internals/function-uncurry-this');\nvar isObject = require('../internals/is-object');\nvar createNonEnumerableProperty = require('../internals/create-non-enumerable-property');\nvar hasOwn = require('../internals/has-own-property');\nvar shared = require('../internals/shared-store');\nvar sharedKey = require('../internals/shared-key');\nvar hiddenKeys = require('../internals/hidden-keys');\n\nvar OBJECT_ALREADY_INITIALIZED = 'Object already initialized';\nvar TypeError = global.TypeError;\nvar WeakMap = global.WeakMap;\nvar set, get, has;\n\nvar enforce = function (it) {\n  return has(it) ? get(it) : set(it, {});\n};\n\nvar getterFor = function (TYPE) {\n  return function (it) {\n    var state;\n    if (!isObject(it) || (state = get(it)).type !== TYPE) {\n      throw TypeError('Incompatible receiver, ' + TYPE + ' required');\n    } return state;\n  };\n};\n\nif (NATIVE_WEAK_MAP || shared.state) {\n  var store = shared.state || (shared.state = new WeakMap());\n  var wmget = uncurryThis(store.get);\n  var wmhas = uncurryThis(store.has);\n  var wmset = uncurryThis(store.set);\n  set = function (it, metadata) {\n    if (wmhas(store, it)) throw new TypeError(OBJECT_ALREADY_INITIALIZED);\n    metadata.facade = it;\n    wmset(store, it, metadata);\n    return metadata;\n  };\n  get = function (it) {\n    return wmget(store, it) || {};\n  };\n  has = function (it) {\n    return wmhas(store, it);\n  };\n} else {\n  var STATE = sharedKey('state');\n  hiddenKeys[STATE] = true;\n  set = function (it, metadata) {\n    if (hasOwn(it, STATE)) throw new TypeError(OBJECT_ALREADY_INITIALIZED);\n    metadata.facade = it;\n    createNonEnumerableProperty(it, STATE, metadata);\n    return metadata;\n  };\n  get = function (it) {\n    return hasOwn(it, STATE) ? it[STATE] : {};\n  };\n  has = function (it) {\n    return hasOwn(it, STATE);\n  };\n}\n\nmodule.exports = {\n  set: set,\n  get: get,\n  has: has,\n  enforce: enforce,\n  getterFor: getterFor\n};\n","// `IsCallable` abstract operation\n// https://tc39.es/ecma262/#sec-iscallable\nmodule.exports = function (argument) {\n  return typeof argument == 'function';\n};\n","var fails = require('../internals/fails');\nvar isCallable = require('../internals/is-callable');\n\nvar replacement = /#|\\.prototype\\./;\n\nvar isForced = function (feature, detection) {\n  var value = data[normalize(feature)];\n  return value == POLYFILL ? true\n    : value == NATIVE ? false\n    : isCallable(detection) ? fails(detection)\n    : !!detection;\n};\n\nvar normalize = isForced.normalize = function (string) {\n  return String(string).replace(replacement, '.').toLowerCase();\n};\n\nvar data = isForced.data = {};\nvar NATIVE = isForced.NATIVE = 'N';\nvar POLYFILL = isForced.POLYFILL = 'P';\n\nmodule.exports = isForced;\n","var isCallable = require('../internals/is-callable');\n\nmodule.exports = function (it) {\n  return typeof it == 'object' ? it !== null : isCallable(it);\n};\n","module.exports = false;\n","var global = require('../internals/global');\nvar getBuiltIn = require('../internals/get-built-in');\nvar isCallable = require('../internals/is-callable');\nvar isPrototypeOf = require('../internals/object-is-prototype-of');\nvar USE_SYMBOL_AS_UID = require('../internals/use-symbol-as-uid');\n\nvar Object = global.Object;\n\nmodule.exports = USE_SYMBOL_AS_UID ? function (it) {\n  return typeof it == 'symbol';\n} : function (it) {\n  var $Symbol = getBuiltIn('Symbol');\n  return isCallable($Symbol) && isPrototypeOf($Symbol.prototype, Object(it));\n};\n","var toLength = require('../internals/to-length');\n\n// `LengthOfArrayLike` abstract operation\n// https://tc39.es/ecma262/#sec-lengthofarraylike\nmodule.exports = function (obj) {\n  return toLength(obj.length);\n};\n","var fails = require('../internals/fails');\nvar isCallable = require('../internals/is-callable');\nvar hasOwn = require('../internals/has-own-property');\nvar DESCRIPTORS = require('../internals/descriptors');\nvar CONFIGURABLE_FUNCTION_NAME = require('../internals/function-name').CONFIGURABLE;\nvar inspectSource = require('../internals/inspect-source');\nvar InternalStateModule = require('../internals/internal-state');\n\nvar enforceInternalState = InternalStateModule.enforce;\nvar getInternalState = InternalStateModule.get;\n// eslint-disable-next-line es-x/no-object-defineproperty -- safe\nvar defineProperty = Object.defineProperty;\n\nvar CONFIGURABLE_LENGTH = DESCRIPTORS && !fails(function () {\n  return defineProperty(function () { /* empty */ }, 'length', { value: 8 }).length !== 8;\n});\n\nvar TEMPLATE = String(String).split('String');\n\nvar makeBuiltIn = module.exports = function (value, name, options) {\n  if (String(name).slice(0, 7) === 'Symbol(') {\n    name = '[' + String(name).replace(/^Symbol\\(([^)]*)\\)/, '$1') + ']';\n  }\n  if (options && options.getter) name = 'get ' + name;\n  if (options && options.setter) name = 'set ' + name;\n  if (!hasOwn(value, 'name') || (CONFIGURABLE_FUNCTION_NAME && value.name !== name)) {\n    defineProperty(value, 'name', { value: name, configurable: true });\n  }\n  if (CONFIGURABLE_LENGTH && options && hasOwn(options, 'arity') && value.length !== options.arity) {\n    defineProperty(value, 'length', { value: options.arity });\n  }\n  if (options && hasOwn(options, 'constructor') && options.constructor) {\n    if (DESCRIPTORS) try {\n      defineProperty(value, 'prototype', { writable: false });\n    } catch (error) { /* empty */ }\n  } else value.prototype = undefined;\n  var state = enforceInternalState(value);\n  if (!hasOwn(state, 'source')) {\n    state.source = TEMPLATE.join(typeof name == 'string' ? name : '');\n  } return value;\n};\n\n// add fake Function#toString for correct work wrapped methods / constructors with methods like LoDash isNative\n// eslint-disable-next-line no-extend-native -- required\nFunction.prototype.toString = makeBuiltIn(function toString() {\n  return isCallable(this) && getInternalState(this).source || inspectSource(this);\n}, 'toString');\n","/* eslint-disable es-x/no-symbol -- required for testing */\nvar V8_VERSION = require('../internals/engine-v8-version');\nvar fails = require('../internals/fails');\n\n// eslint-disable-next-line es-x/no-object-getownpropertysymbols -- required for testing\nmodule.exports = !!Object.getOwnPropertySymbols && !fails(function () {\n  var symbol = Symbol();\n  // Chrome 38 Symbol has incorrect toString conversion\n  // `get-own-property-symbols` polyfill symbols converted to object are not Symbol instances\n  return !String(symbol) || !(Object(symbol) instanceof Symbol) ||\n    // Chrome 38-40 symbols are not inherited from DOM collections prototypes to instances\n    !Symbol.sham && V8_VERSION && V8_VERSION < 41;\n});\n","var global = require('../internals/global');\nvar isCallable = require('../internals/is-callable');\nvar inspectSource = require('../internals/inspect-source');\n\nvar WeakMap = global.WeakMap;\n\nmodule.exports = isCallable(WeakMap) && /native code/.test(inspectSource(WeakMap));\n","var global = require('../internals/global');\nvar DESCRIPTORS = require('../internals/descriptors');\nvar IE8_DOM_DEFINE = require('../internals/ie8-dom-define');\nvar V8_PROTOTYPE_DEFINE_BUG = require('../internals/v8-prototype-define-bug');\nvar anObject = require('../internals/an-object');\nvar toPropertyKey = require('../internals/to-property-key');\n\nvar TypeError = global.TypeError;\n// eslint-disable-next-line es-x/no-object-defineproperty -- safe\nvar $defineProperty = Object.defineProperty;\n// eslint-disable-next-line es-x/no-object-getownpropertydescriptor -- safe\nvar $getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;\nvar ENUMERABLE = 'enumerable';\nvar CONFIGURABLE = 'configurable';\nvar WRITABLE = 'writable';\n\n// `Object.defineProperty` method\n// https://tc39.es/ecma262/#sec-object.defineproperty\nexports.f = DESCRIPTORS ? V8_PROTOTYPE_DEFINE_BUG ? function defineProperty(O, P, Attributes) {\n  anObject(O);\n  P = toPropertyKey(P);\n  anObject(Attributes);\n  if (typeof O === 'function' && P === 'prototype' && 'value' in Attributes && WRITABLE in Attributes && !Attributes[WRITABLE]) {\n    var current = $getOwnPropertyDescriptor(O, P);\n    if (current && current[WRITABLE]) {\n      O[P] = Attributes.value;\n      Attributes = {\n        configurable: CONFIGURABLE in Attributes ? Attributes[CONFIGURABLE] : current[CONFIGURABLE],\n        enumerable: ENUMERABLE in Attributes ? Attributes[ENUMERABLE] : current[ENUMERABLE],\n        writable: false\n      };\n    }\n  } return $defineProperty(O, P, Attributes);\n} : $defineProperty : function defineProperty(O, P, Attributes) {\n  anObject(O);\n  P = toPropertyKey(P);\n  anObject(Attributes);\n  if (IE8_DOM_DEFINE) try {\n    return $defineProperty(O, P, Attributes);\n  } catch (error) { /* empty */ }\n  if ('get' in Attributes || 'set' in Attributes) throw TypeError('Accessors not supported');\n  if ('value' in Attributes) O[P] = Attributes.value;\n  return O;\n};\n","var DESCRIPTORS = require('../internals/descriptors');\nvar call = require('../internals/function-call');\nvar propertyIsEnumerableModule = require('../internals/object-property-is-enumerable');\nvar createPropertyDescriptor = require('../internals/create-property-descriptor');\nvar toIndexedObject = require('../internals/to-indexed-object');\nvar toPropertyKey = require('../internals/to-property-key');\nvar hasOwn = require('../internals/has-own-property');\nvar IE8_DOM_DEFINE = require('../internals/ie8-dom-define');\n\n// eslint-disable-next-line es-x/no-object-getownpropertydescriptor -- safe\nvar $getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;\n\n// `Object.getOwnPropertyDescriptor` method\n// https://tc39.es/ecma262/#sec-object.getownpropertydescriptor\nexports.f = DESCRIPTORS ? $getOwnPropertyDescriptor : function getOwnPropertyDescriptor(O, P) {\n  O = toIndexedObject(O);\n  P = toPropertyKey(P);\n  if (IE8_DOM_DEFINE) try {\n    return $getOwnPropertyDescriptor(O, P);\n  } catch (error) { /* empty */ }\n  if (hasOwn(O, P)) return createPropertyDescriptor(!call(propertyIsEnumerableModule.f, O, P), O[P]);\n};\n","var internalObjectKeys = require('../internals/object-keys-internal');\nvar enumBugKeys = require('../internals/enum-bug-keys');\n\nvar hiddenKeys = enumBugKeys.concat('length', 'prototype');\n\n// `Object.getOwnPropertyNames` method\n// https://tc39.es/ecma262/#sec-object.getownpropertynames\n// eslint-disable-next-line es-x/no-object-getownpropertynames -- safe\nexports.f = Object.getOwnPropertyNames || function getOwnPropertyNames(O) {\n  return internalObjectKeys(O, hiddenKeys);\n};\n","// eslint-disable-next-line es-x/no-object-getownpropertysymbols -- safe\nexports.f = Object.getOwnPropertySymbols;\n","var uncurryThis = require('../internals/function-uncurry-this');\n\nmodule.exports = uncurryThis({}.isPrototypeOf);\n","var uncurryThis = require('../internals/function-uncurry-this');\nvar hasOwn = require('../internals/has-own-property');\nvar toIndexedObject = require('../internals/to-indexed-object');\nvar indexOf = require('../internals/array-includes').indexOf;\nvar hiddenKeys = require('../internals/hidden-keys');\n\nvar push = uncurryThis([].push);\n\nmodule.exports = function (object, names) {\n  var O = toIndexedObject(object);\n  var i = 0;\n  var result = [];\n  var key;\n  for (key in O) !hasOwn(hiddenKeys, key) && hasOwn(O, key) && push(result, key);\n  // Don't enum bug & hidden keys\n  while (names.length > i) if (hasOwn(O, key = names[i++])) {\n    ~indexOf(result, key) || push(result, key);\n  }\n  return result;\n};\n","var internalObjectKeys = require('../internals/object-keys-internal');\nvar enumBugKeys = require('../internals/enum-bug-keys');\n\n// `Object.keys` method\n// https://tc39.es/ecma262/#sec-object.keys\n// eslint-disable-next-line es-x/no-object-keys -- safe\nmodule.exports = Object.keys || function keys(O) {\n  return internalObjectKeys(O, enumBugKeys);\n};\n","'use strict';\nvar $propertyIsEnumerable = {}.propertyIsEnumerable;\n// eslint-disable-next-line es-x/no-object-getownpropertydescriptor -- safe\nvar getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;\n\n// Nashorn ~ JDK8 bug\nvar NASHORN_BUG = getOwnPropertyDescriptor && !$propertyIsEnumerable.call({ 1: 2 }, 1);\n\n// `Object.prototype.propertyIsEnumerable` method implementation\n// https://tc39.es/ecma262/#sec-object.prototype.propertyisenumerable\nexports.f = NASHORN_BUG ? function propertyIsEnumerable(V) {\n  var descriptor = getOwnPropertyDescriptor(this, V);\n  return !!descriptor && descriptor.enumerable;\n} : $propertyIsEnumerable;\n","var global = require('../internals/global');\nvar call = require('../internals/function-call');\nvar isCallable = require('../internals/is-callable');\nvar isObject = require('../internals/is-object');\n\nvar TypeError = global.TypeError;\n\n// `OrdinaryToPrimitive` abstract operation\n// https://tc39.es/ecma262/#sec-ordinarytoprimitive\nmodule.exports = function (input, pref) {\n  var fn, val;\n  if (pref === 'string' && isCallable(fn = input.toString) && !isObject(val = call(fn, input))) return val;\n  if (isCallable(fn = input.valueOf) && !isObject(val = call(fn, input))) return val;\n  if (pref !== 'string' && isCallable(fn = input.toString) && !isObject(val = call(fn, input))) return val;\n  throw TypeError(\"Can't convert object to primitive value\");\n};\n","var getBuiltIn = require('../internals/get-built-in');\nvar uncurryThis = require('../internals/function-uncurry-this');\nvar getOwnPropertyNamesModule = require('../internals/object-get-own-property-names');\nvar getOwnPropertySymbolsModule = require('../internals/object-get-own-property-symbols');\nvar anObject = require('../internals/an-object');\n\nvar concat = uncurryThis([].concat);\n\n// all object keys, includes non-enumerable and symbols\nmodule.exports = getBuiltIn('Reflect', 'ownKeys') || function ownKeys(it) {\n  var keys = getOwnPropertyNamesModule.f(anObject(it));\n  var getOwnPropertySymbols = getOwnPropertySymbolsModule.f;\n  return getOwnPropertySymbols ? concat(keys, getOwnPropertySymbols(it)) : keys;\n};\n","var global = require('../internals/global');\n\nmodule.exports = global;\n","var global = require('../internals/global');\n\nvar TypeError = global.TypeError;\n\n// `RequireObjectCoercible` abstract operation\n// https://tc39.es/ecma262/#sec-requireobjectcoercible\nmodule.exports = function (it) {\n  if (it == undefined) throw TypeError(\"Can't call method on \" + it);\n  return it;\n};\n","var global = require('../internals/global');\n\n// eslint-disable-next-line es-x/no-object-defineproperty -- safe\nvar defineProperty = Object.defineProperty;\n\nmodule.exports = function (key, value) {\n  try {\n    defineProperty(global, key, { value: value, configurable: true, writable: true });\n  } catch (error) {\n    global[key] = value;\n  } return value;\n};\n","var shared = require('../internals/shared');\nvar uid = require('../internals/uid');\n\nvar keys = shared('keys');\n\nmodule.exports = function (key) {\n  return keys[key] || (keys[key] = uid(key));\n};\n","var global = require('../internals/global');\nvar setGlobal = require('../internals/set-global');\n\nvar SHARED = '__core-js_shared__';\nvar store = global[SHARED] || setGlobal(SHARED, {});\n\nmodule.exports = store;\n","var IS_PURE = require('../internals/is-pure');\nvar store = require('../internals/shared-store');\n\n(module.exports = function (key, value) {\n  return store[key] || (store[key] = value !== undefined ? value : {});\n})('versions', []).push({\n  version: '3.22.5',\n  mode: IS_PURE ? 'pure' : 'global',\n  copyright: '© 2014-2022 Denis Pushkarev (zloirock.ru)',\n  license: 'https://github.com/zloirock/core-js/blob/v3.22.5/LICENSE',\n  source: 'https://github.com/zloirock/core-js'\n});\n","var toIntegerOrInfinity = require('../internals/to-integer-or-infinity');\n\nvar max = Math.max;\nvar min = Math.min;\n\n// Helper for a popular repeating case of the spec:\n// Let integer be ? ToInteger(index).\n// If integer < 0, let result be max((length + integer), 0); else let result be min(integer, length).\nmodule.exports = function (index, length) {\n  var integer = toIntegerOrInfinity(index);\n  return integer < 0 ? max(integer + length, 0) : min(integer, length);\n};\n","// toObject with fallback for non-array-like ES3 strings\nvar IndexedObject = require('../internals/indexed-object');\nvar requireObjectCoercible = require('../internals/require-object-coercible');\n\nmodule.exports = function (it) {\n  return IndexedObject(requireObjectCoercible(it));\n};\n","var ceil = Math.ceil;\nvar floor = Math.floor;\n\n// `ToIntegerOrInfinity` abstract operation\n// https://tc39.es/ecma262/#sec-tointegerorinfinity\nmodule.exports = function (argument) {\n  var number = +argument;\n  // eslint-disable-next-line no-self-compare -- safe\n  return number !== number || number === 0 ? 0 : (number > 0 ? floor : ceil)(number);\n};\n","var toIntegerOrInfinity = require('../internals/to-integer-or-infinity');\n\nvar min = Math.min;\n\n// `ToLength` abstract operation\n// https://tc39.es/ecma262/#sec-tolength\nmodule.exports = function (argument) {\n  return argument > 0 ? min(toIntegerOrInfinity(argument), 0x1FFFFFFFFFFFFF) : 0; // 2 ** 53 - 1 == 9007199254740991\n};\n","var global = require('../internals/global');\nvar requireObjectCoercible = require('../internals/require-object-coercible');\n\nvar Object = global.Object;\n\n// `ToObject` abstract operation\n// https://tc39.es/ecma262/#sec-toobject\nmodule.exports = function (argument) {\n  return Object(requireObjectCoercible(argument));\n};\n","var global = require('../internals/global');\nvar call = require('../internals/function-call');\nvar isObject = require('../internals/is-object');\nvar isSymbol = require('../internals/is-symbol');\nvar getMethod = require('../internals/get-method');\nvar ordinaryToPrimitive = require('../internals/ordinary-to-primitive');\nvar wellKnownSymbol = require('../internals/well-known-symbol');\n\nvar TypeError = global.TypeError;\nvar TO_PRIMITIVE = wellKnownSymbol('toPrimitive');\n\n// `ToPrimitive` abstract operation\n// https://tc39.es/ecma262/#sec-toprimitive\nmodule.exports = function (input, pref) {\n  if (!isObject(input) || isSymbol(input)) return input;\n  var exoticToPrim = getMethod(input, TO_PRIMITIVE);\n  var result;\n  if (exoticToPrim) {\n    if (pref === undefined) pref = 'default';\n    result = call(exoticToPrim, input, pref);\n    if (!isObject(result) || isSymbol(result)) return result;\n    throw TypeError(\"Can't convert object to primitive value\");\n  }\n  if (pref === undefined) pref = 'number';\n  return ordinaryToPrimitive(input, pref);\n};\n","var toPrimitive = require('../internals/to-primitive');\nvar isSymbol = require('../internals/is-symbol');\n\n// `ToPropertyKey` abstract operation\n// https://tc39.es/ecma262/#sec-topropertykey\nmodule.exports = function (argument) {\n  var key = toPrimitive(argument, 'string');\n  return isSymbol(key) ? key : key + '';\n};\n","var wellKnownSymbol = require('../internals/well-known-symbol');\n\nvar TO_STRING_TAG = wellKnownSymbol('toStringTag');\nvar test = {};\n\ntest[TO_STRING_TAG] = 'z';\n\nmodule.exports = String(test) === '[object z]';\n","var global = require('../internals/global');\nvar classof = require('../internals/classof');\n\nvar String = global.String;\n\nmodule.exports = function (argument) {\n  if (classof(argument) === 'Symbol') throw TypeError('Cannot convert a Symbol value to a string');\n  return String(argument);\n};\n","var global = require('../internals/global');\n\nvar String = global.String;\n\nmodule.exports = function (argument) {\n  try {\n    return String(argument);\n  } catch (error) {\n    return 'Object';\n  }\n};\n","var uncurryThis = require('../internals/function-uncurry-this');\n\nvar id = 0;\nvar postfix = Math.random();\nvar toString = uncurryThis(1.0.toString);\n\nmodule.exports = function (key) {\n  return 'Symbol(' + (key === undefined ? '' : key) + ')_' + toString(++id + postfix, 36);\n};\n","/* eslint-disable es-x/no-symbol -- required for testing */\nvar NATIVE_SYMBOL = require('../internals/native-symbol');\n\nmodule.exports = NATIVE_SYMBOL\n  && !Symbol.sham\n  && typeof Symbol.iterator == 'symbol';\n","var DESCRIPTORS = require('../internals/descriptors');\nvar fails = require('../internals/fails');\n\n// V8 ~ Chrome 36-\n// https://bugs.chromium.org/p/v8/issues/detail?id=3334\nmodule.exports = DESCRIPTORS && fails(function () {\n  // eslint-disable-next-line es-x/no-object-defineproperty -- required for testing\n  return Object.defineProperty(function () { /* empty */ }, 'prototype', {\n    value: 42,\n    writable: false\n  }).prototype != 42;\n});\n","var global = require('../internals/global');\nvar shared = require('../internals/shared');\nvar hasOwn = require('../internals/has-own-property');\nvar uid = require('../internals/uid');\nvar NATIVE_SYMBOL = require('../internals/native-symbol');\nvar USE_SYMBOL_AS_UID = require('../internals/use-symbol-as-uid');\n\nvar WellKnownSymbolsStore = shared('wks');\nvar Symbol = global.Symbol;\nvar symbolFor = Symbol && Symbol['for'];\nvar createWellKnownSymbol = USE_SYMBOL_AS_UID ? Symbol : Symbol && Symbol.withoutSetter || uid;\n\nmodule.exports = function (name) {\n  if (!hasOwn(WellKnownSymbolsStore, name) || !(NATIVE_SYMBOL || typeof WellKnownSymbolsStore[name] == 'string')) {\n    var description = 'Symbol.' + name;\n    if (NATIVE_SYMBOL && hasOwn(Symbol, name)) {\n      WellKnownSymbolsStore[name] = Symbol[name];\n    } else if (USE_SYMBOL_AS_UID && symbolFor) {\n      WellKnownSymbolsStore[name] = symbolFor(description);\n    } else {\n      WellKnownSymbolsStore[name] = createWellKnownSymbol(description);\n    }\n  } return WellKnownSymbolsStore[name];\n};\n","'use strict';\nvar $ = require('../internals/export');\nvar uncurryThis = require('../internals/function-uncurry-this');\nvar aCallable = require('../internals/a-callable');\nvar toObject = require('../internals/to-object');\nvar lengthOfArrayLike = require('../internals/length-of-array-like');\nvar toString = require('../internals/to-string');\nvar fails = require('../internals/fails');\nvar internalSort = require('../internals/array-sort');\nvar arrayMethodIsStrict = require('../internals/array-method-is-strict');\nvar FF = require('../internals/engine-ff-version');\nvar IE_OR_EDGE = require('../internals/engine-is-ie-or-edge');\nvar V8 = require('../internals/engine-v8-version');\nvar WEBKIT = require('../internals/engine-webkit-version');\n\nvar test = [];\nvar un$Sort = uncurryThis(test.sort);\nvar push = uncurryThis(test.push);\n\n// IE8-\nvar FAILS_ON_UNDEFINED = fails(function () {\n  test.sort(undefined);\n});\n// V8 bug\nvar FAILS_ON_NULL = fails(function () {\n  test.sort(null);\n});\n// Old WebKit\nvar STRICT_METHOD = arrayMethodIsStrict('sort');\n\nvar STABLE_SORT = !fails(function () {\n  // feature detection can be too slow, so check engines versions\n  if (V8) return V8 < 70;\n  if (FF && FF > 3) return;\n  if (IE_OR_EDGE) return true;\n  if (WEBKIT) return WEBKIT < 603;\n\n  var result = '';\n  var code, chr, value, index;\n\n  // generate an array with more 512 elements (Chakra and old V8 fails only in this case)\n  for (code = 65; code < 76; code++) {\n    chr = String.fromCharCode(code);\n\n    switch (code) {\n      case 66: case 69: case 70: case 72: value = 3; break;\n      case 68: case 71: value = 4; break;\n      default: value = 2;\n    }\n\n    for (index = 0; index < 47; index++) {\n      test.push({ k: chr + index, v: value });\n    }\n  }\n\n  test.sort(function (a, b) { return b.v - a.v; });\n\n  for (index = 0; index < test.length; index++) {\n    chr = test[index].k.charAt(0);\n    if (result.charAt(result.length - 1) !== chr) result += chr;\n  }\n\n  return result !== 'DGBEFHACIJK';\n});\n\nvar FORCED = FAILS_ON_UNDEFINED || !FAILS_ON_NULL || !STRICT_METHOD || !STABLE_SORT;\n\nvar getSortCompare = function (comparefn) {\n  return function (x, y) {\n    if (y === undefined) return -1;\n    if (x === undefined) return 1;\n    if (comparefn !== undefined) return +comparefn(x, y) || 0;\n    return toString(x) > toString(y) ? 1 : -1;\n  };\n};\n\n// `Array.prototype.sort` method\n// https://tc39.es/ecma262/#sec-array.prototype.sort\n$({ target: 'Array', proto: true, forced: FORCED }, {\n  sort: function sort(comparefn) {\n    if (comparefn !== undefined) aCallable(comparefn);\n\n    var array = toObject(this);\n\n    if (STABLE_SORT) return comparefn === undefined ? un$Sort(array) : un$Sort(array, comparefn);\n\n    var items = [];\n    var arrayLength = lengthOfArrayLike(array);\n    var itemsLength, index;\n\n    for (index = 0; index < arrayLength; index++) {\n      if (index in array) push(items, array[index]);\n    }\n\n    internalSort(items, getSortCompare(comparefn));\n\n    itemsLength = items.length;\n    index = 0;\n\n    while (index < itemsLength) array[index] = items[index++];\n    while (index < arrayLength) delete array[index++];\n\n    return array;\n  }\n});\n","var $ = require('../internals/export');\nvar toObject = require('../internals/to-object');\nvar nativeKeys = require('../internals/object-keys');\nvar fails = require('../internals/fails');\n\nvar FAILS_ON_PRIMITIVES = fails(function () { nativeKeys(1); });\n\n// `Object.keys` method\n// https://tc39.es/ecma262/#sec-object.keys\n$({ target: 'Object', stat: true, forced: FAILS_ON_PRIMITIVES }, {\n  keys: function keys(it) {\n    return nativeKeys(toObject(it));\n  }\n});\n","// Imports\nimport ___CSS_LOADER_API_SOURCEMAP_IMPORT___ from \"../../node_modules/css-loader/dist/runtime/sourceMaps.js\";\nimport ___CSS_LOADER_API_IMPORT___ from \"../../node_modules/css-loader/dist/runtime/api.js\";\nvar ___CSS_LOADER_EXPORT___ = ___CSS_LOADER_API_IMPORT___(___CSS_LOADER_API_SOURCEMAP_IMPORT___);\n// Module\n___CSS_LOADER_EXPORT___.push([module.id, \"/* Buttons styles start */\\r\\n\\r\\nbutton#excalibur-play {\\r\\n  display: inline-block;\\r\\n  position: relative;\\r\\n  z-index: 999;\\r\\n  border-radius: 6px;\\r\\n  border: none;\\r\\n  /*border: 3px solid;\\r\\n    border-color: white;\\r\\n    box-shadow: 0 0 10px #ccc;*/\\r\\n  padding: 1rem 1.5rem 1rem 4rem;\\r\\n  margin: 0;\\r\\n  text-decoration: none;\\r\\n  background: #00b233;\\r\\n  color: #ffffff;\\r\\n  font-family: sans-serif;\\r\\n  font-size: 2rem;\\r\\n  white-space: nowrap;\\r\\n  line-height: 1;\\r\\n  cursor: pointer;\\r\\n  text-align: center;\\r\\n  transition: background 250ms ease-in-out, transform 150ms ease;\\r\\n  -webkit-appearance: none;\\r\\n  -moz-appearance: none;\\r\\n\\r\\n  -webkit-animation: excalibur-button-fadein 200ms; /* Safari, Chrome and Opera > 12.1 */\\r\\n  -moz-animation: excalibur-button-fadein 200ms; /* Firefox < 16 */\\r\\n  -ms-animation: excalibur-button-fadein 200ms; /* Internet Explorer */\\r\\n  -o-animation: excalibur-button-fadein 200ms; /* Opera < 12.1 */\\r\\n  animation: excalibur-button-fadein 200ms;\\r\\n}\\r\\n\\r\\n/*\\r\\nbutton#excalibur-play {\\r\\n  display: none;\\r\\n}*/\\r\\n\\r\\nbutton#excalibur-play:after {\\r\\n  position: absolute;\\r\\n  content: '';\\r\\n  border: 8px solid;\\r\\n  border-color: transparent transparent transparent white;\\r\\n  left: 35px;\\r\\n  top: 24px;\\r\\n  width: 0;\\r\\n  height: 0;\\r\\n}\\r\\n\\r\\nbutton#excalibur-play:before {\\r\\n  position: absolute;\\r\\n  content: '';\\r\\n  border: 3px solid;\\r\\n  left: 19px;\\r\\n  top: 14px;\\r\\n  border-radius: 20px;\\r\\n  width: 30px;\\r\\n  height: 30px;\\r\\n}\\r\\n\\r\\nbutton#excalibur-play:hover,\\r\\nbutton#excalibur-play:focus {\\r\\n  background: #00982c;\\r\\n}\\r\\n\\r\\nbutton#excalibur-play:focus {\\r\\n  outline: 1px solid #fff;\\r\\n  outline-offset: -4px;\\r\\n}\\r\\n\\r\\nbutton#excalibur-play:active {\\r\\n  transform: scale(0.99);\\r\\n}\\r\\n\\r\\n@keyframes excalibur-button-fadein {\\r\\n  from {\\r\\n    opacity: 0;\\r\\n  }\\r\\n  to {\\r\\n    opacity: 1;\\r\\n  }\\r\\n}\\r\\n\\r\\n/* Firefox < 16 */\\r\\n@-moz-keyframes excalibur-button-fadein {\\r\\n  from {\\r\\n    opacity: 0;\\r\\n  }\\r\\n  to {\\r\\n    opacity: 1;\\r\\n  }\\r\\n}\\r\\n\\r\\n/* Safari, Chrome and Opera > 12.1 */\\r\\n@-webkit-keyframes excalibur-button-fadein {\\r\\n  from {\\r\\n    opacity: 0;\\r\\n  }\\r\\n  to {\\r\\n    opacity: 1;\\r\\n  }\\r\\n}\\r\\n\\r\\n/* Internet Explorer */\\r\\n@-ms-keyframes excalibur-button-fadein {\\r\\n  from {\\r\\n    opacity: 0;\\r\\n  }\\r\\n  to {\\r\\n    opacity: 1;\\r\\n  }\\r\\n}\\r\\n\\r\\n/* Opera < 12.1 */\\r\\n@-o-keyframes excalibur-button-fadein {\\r\\n  from {\\r\\n    opacity: 0;\\r\\n  }\\r\\n  to {\\r\\n    opacity: 1;\\r\\n  }\\r\\n}\\r\\n\", \"\",{\"version\":3,\"sources\":[\"webpack://./Loader.css\"],\"names\":[],\"mappings\":\"AAAA,yBAAyB;;AAEzB;EACE,qBAAqB;EACrB,kBAAkB;EAClB,YAAY;EACZ,kBAAkB;EAClB,YAAY;EACZ;;+BAE6B;EAC7B,8BAA8B;EAC9B,SAAS;EACT,qBAAqB;EACrB,mBAAmB;EACnB,cAAc;EACd,uBAAuB;EACvB,eAAe;EACf,mBAAmB;EACnB,cAAc;EACd,eAAe;EACf,kBAAkB;EAClB,8DAA8D;EAC9D,wBAAwB;EACxB,qBAAqB;;EAErB,gDAAgD,EAAE,oCAAoC;EACtF,6CAA6C,EAAE,iBAAiB;EAChE,4CAA4C,EAAE,sBAAsB;EACpE,2CAA2C,EAAE,iBAAiB;EAC9D,wCAAwC;AAC1C;;AAEA;;;EAGE;;AAEF;EACE,kBAAkB;EAClB,WAAW;EACX,iBAAiB;EACjB,uDAAuD;EACvD,UAAU;EACV,SAAS;EACT,QAAQ;EACR,SAAS;AACX;;AAEA;EACE,kBAAkB;EAClB,WAAW;EACX,iBAAiB;EACjB,UAAU;EACV,SAAS;EACT,mBAAmB;EACnB,WAAW;EACX,YAAY;AACd;;AAEA;;EAEE,mBAAmB;AACrB;;AAEA;EACE,uBAAuB;EACvB,oBAAoB;AACtB;;AAEA;EACE,sBAAsB;AACxB;;AAEA;EACE;IACE,UAAU;EACZ;EACA;IACE,UAAU;EACZ;AACF;;AAEA,iBAAiB;AACjB;EACE;IACE,UAAU;EACZ;EACA;IACE,UAAU;EACZ;AACF;;AAEA,oCAAoC;AACpC;EACE;IACE,UAAU;EACZ;EACA;IACE,UAAU;EACZ;AACF;;AAEA,sBAAsB;AACtB;EACE;IACE,UAAU;EACZ;EACA;IACE,UAAU;EACZ;AACF;;AAEA,iBAAiB;AACjB;EACE;IACE,UAAU;EACZ;EACA;IACE,UAAU;EACZ;AACF\",\"sourcesContent\":[\"/* Buttons styles start */\\r\\n\\r\\nbutton#excalibur-play {\\r\\n  display: inline-block;\\r\\n  position: relative;\\r\\n  z-index: 999;\\r\\n  border-radius: 6px;\\r\\n  border: none;\\r\\n  /*border: 3px solid;\\r\\n    border-color: white;\\r\\n    box-shadow: 0 0 10px #ccc;*/\\r\\n  padding: 1rem 1.5rem 1rem 4rem;\\r\\n  margin: 0;\\r\\n  text-decoration: none;\\r\\n  background: #00b233;\\r\\n  color: #ffffff;\\r\\n  font-family: sans-serif;\\r\\n  font-size: 2rem;\\r\\n  white-space: nowrap;\\r\\n  line-height: 1;\\r\\n  cursor: pointer;\\r\\n  text-align: center;\\r\\n  transition: background 250ms ease-in-out, transform 150ms ease;\\r\\n  -webkit-appearance: none;\\r\\n  -moz-appearance: none;\\r\\n\\r\\n  -webkit-animation: excalibur-button-fadein 200ms; /* Safari, Chrome and Opera > 12.1 */\\r\\n  -moz-animation: excalibur-button-fadein 200ms; /* Firefox < 16 */\\r\\n  -ms-animation: excalibur-button-fadein 200ms; /* Internet Explorer */\\r\\n  -o-animation: excalibur-button-fadein 200ms; /* Opera < 12.1 */\\r\\n  animation: excalibur-button-fadein 200ms;\\r\\n}\\r\\n\\r\\n/*\\r\\nbutton#excalibur-play {\\r\\n  display: none;\\r\\n}*/\\r\\n\\r\\nbutton#excalibur-play:after {\\r\\n  position: absolute;\\r\\n  content: '';\\r\\n  border: 8px solid;\\r\\n  border-color: transparent transparent transparent white;\\r\\n  left: 35px;\\r\\n  top: 24px;\\r\\n  width: 0;\\r\\n  height: 0;\\r\\n}\\r\\n\\r\\nbutton#excalibur-play:before {\\r\\n  position: absolute;\\r\\n  content: '';\\r\\n  border: 3px solid;\\r\\n  left: 19px;\\r\\n  top: 14px;\\r\\n  border-radius: 20px;\\r\\n  width: 30px;\\r\\n  height: 30px;\\r\\n}\\r\\n\\r\\nbutton#excalibur-play:hover,\\r\\nbutton#excalibur-play:focus {\\r\\n  background: #00982c;\\r\\n}\\r\\n\\r\\nbutton#excalibur-play:focus {\\r\\n  outline: 1px solid #fff;\\r\\n  outline-offset: -4px;\\r\\n}\\r\\n\\r\\nbutton#excalibur-play:active {\\r\\n  transform: scale(0.99);\\r\\n}\\r\\n\\r\\n@keyframes excalibur-button-fadein {\\r\\n  from {\\r\\n    opacity: 0;\\r\\n  }\\r\\n  to {\\r\\n    opacity: 1;\\r\\n  }\\r\\n}\\r\\n\\r\\n/* Firefox < 16 */\\r\\n@-moz-keyframes excalibur-button-fadein {\\r\\n  from {\\r\\n    opacity: 0;\\r\\n  }\\r\\n  to {\\r\\n    opacity: 1;\\r\\n  }\\r\\n}\\r\\n\\r\\n/* Safari, Chrome and Opera > 12.1 */\\r\\n@-webkit-keyframes excalibur-button-fadein {\\r\\n  from {\\r\\n    opacity: 0;\\r\\n  }\\r\\n  to {\\r\\n    opacity: 1;\\r\\n  }\\r\\n}\\r\\n\\r\\n/* Internet Explorer */\\r\\n@-ms-keyframes excalibur-button-fadein {\\r\\n  from {\\r\\n    opacity: 0;\\r\\n  }\\r\\n  to {\\r\\n    opacity: 1;\\r\\n  }\\r\\n}\\r\\n\\r\\n/* Opera < 12.1 */\\r\\n@-o-keyframes excalibur-button-fadein {\\r\\n  from {\\r\\n    opacity: 0;\\r\\n  }\\r\\n  to {\\r\\n    opacity: 1;\\r\\n  }\\r\\n}\\r\\n\"],\"sourceRoot\":\"\"}]);\n// Exports\nexport default ___CSS_LOADER_EXPORT___;\n","// Imports\nimport ___CSS_LOADER_API_SOURCEMAP_IMPORT___ from \"../../../node_modules/css-loader/dist/runtime/sourceMaps.js\";\nimport ___CSS_LOADER_API_IMPORT___ from \"../../../node_modules/css-loader/dist/runtime/api.js\";\nvar ___CSS_LOADER_EXPORT___ = ___CSS_LOADER_API_IMPORT___(___CSS_LOADER_API_SOURCEMAP_IMPORT___);\n// Module\n___CSS_LOADER_EXPORT___.push([module.id, \"\\r\\n#ex-toast-container {\\r\\n  position: absolute;\\r\\n  height: 0;\\r\\n  min-width: 50%;\\r\\n  left: 50%;\\r\\n  top: 0;\\r\\n}\\r\\n\\r\\n.ex-toast-message {\\r\\n  left: -50%;\\r\\n  position: relative;\\r\\n  display: flex;\\r\\n  justify-content: space-between;\\r\\n\\r\\n\\r\\n  padding: 10px;\\r\\n  margin-top: 5px;\\r\\n  font-size: 18px;\\r\\n  font-family: sans-serif;\\r\\n  border-radius: 6px;\\r\\n  border: 3px solid #b7b779;\\r\\n  background-color: rgb(253, 253, 192);\\r\\n}\\r\\n\\r\\n\\r\\n.ex-toast-message button {\\r\\n  align-self: flex-start;\\r\\n}\", \"\",{\"version\":3,\"sources\":[\"webpack://./Util/Toaster.css\"],\"names\":[],\"mappings\":\";AACA;EACE,kBAAkB;EAClB,SAAS;EACT,cAAc;EACd,SAAS;EACT,MAAM;AACR;;AAEA;EACE,UAAU;EACV,kBAAkB;EAClB,aAAa;EACb,8BAA8B;;;EAG9B,aAAa;EACb,eAAe;EACf,eAAe;EACf,uBAAuB;EACvB,kBAAkB;EAClB,yBAAyB;EACzB,oCAAoC;AACtC;;;AAGA;EACE,sBAAsB;AACxB\",\"sourcesContent\":[\"\\r\\n#ex-toast-container {\\r\\n  position: absolute;\\r\\n  height: 0;\\r\\n  min-width: 50%;\\r\\n  left: 50%;\\r\\n  top: 0;\\r\\n}\\r\\n\\r\\n.ex-toast-message {\\r\\n  left: -50%;\\r\\n  position: relative;\\r\\n  display: flex;\\r\\n  justify-content: space-between;\\r\\n\\r\\n\\r\\n  padding: 10px;\\r\\n  margin-top: 5px;\\r\\n  font-size: 18px;\\r\\n  font-family: sans-serif;\\r\\n  border-radius: 6px;\\r\\n  border: 3px solid #b7b779;\\r\\n  background-color: rgb(253, 253, 192);\\r\\n}\\r\\n\\r\\n\\r\\n.ex-toast-message button {\\r\\n  align-self: flex-start;\\r\\n}\"],\"sourceRoot\":\"\"}]);\n// Exports\nexport default ___CSS_LOADER_EXPORT___;\n","\"use strict\";\n\n/*\n  MIT License http://www.opensource.org/licenses/mit-license.php\n  Author Tobias Koppers @sokra\n*/\nmodule.exports = function (cssWithMappingToString) {\n  var list = []; // return the list of modules as css string\n\n  list.toString = function toString() {\n    return this.map(function (item) {\n      var content = \"\";\n      var needLayer = typeof item[5] !== \"undefined\";\n\n      if (item[4]) {\n        content += \"@supports (\".concat(item[4], \") {\");\n      }\n\n      if (item[2]) {\n        content += \"@media \".concat(item[2], \" {\");\n      }\n\n      if (needLayer) {\n        content += \"@layer\".concat(item[5].length > 0 ? \" \".concat(item[5]) : \"\", \" {\");\n      }\n\n      content += cssWithMappingToString(item);\n\n      if (needLayer) {\n        content += \"}\";\n      }\n\n      if (item[2]) {\n        content += \"}\";\n      }\n\n      if (item[4]) {\n        content += \"}\";\n      }\n\n      return content;\n    }).join(\"\");\n  }; // import a list of modules into the list\n\n\n  list.i = function i(modules, media, dedupe, supports, layer) {\n    if (typeof modules === \"string\") {\n      modules = [[null, modules, undefined]];\n    }\n\n    var alreadyImportedModules = {};\n\n    if (dedupe) {\n      for (var k = 0; k < this.length; k++) {\n        var id = this[k][0];\n\n        if (id != null) {\n          alreadyImportedModules[id] = true;\n        }\n      }\n    }\n\n    for (var _k = 0; _k < modules.length; _k++) {\n      var item = [].concat(modules[_k]);\n\n      if (dedupe && alreadyImportedModules[item[0]]) {\n        continue;\n      }\n\n      if (typeof layer !== \"undefined\") {\n        if (typeof item[5] === \"undefined\") {\n          item[5] = layer;\n        } else {\n          item[1] = \"@layer\".concat(item[5].length > 0 ? \" \".concat(item[5]) : \"\", \" {\").concat(item[1], \"}\");\n          item[5] = layer;\n        }\n      }\n\n      if (media) {\n        if (!item[2]) {\n          item[2] = media;\n        } else {\n          item[1] = \"@media \".concat(item[2], \" {\").concat(item[1], \"}\");\n          item[2] = media;\n        }\n      }\n\n      if (supports) {\n        if (!item[4]) {\n          item[4] = \"\".concat(supports);\n        } else {\n          item[1] = \"@supports (\".concat(item[4], \") {\").concat(item[1], \"}\");\n          item[4] = supports;\n        }\n      }\n\n      list.push(item);\n    }\n  };\n\n  return list;\n};","\"use strict\";\n\nmodule.exports = function (item) {\n  var content = item[1];\n  var cssMapping = item[3];\n\n  if (!cssMapping) {\n    return content;\n  }\n\n  if (typeof btoa === \"function\") {\n    var base64 = btoa(unescape(encodeURIComponent(JSON.stringify(cssMapping))));\n    var data = \"sourceMappingURL=data:application/json;charset=utf-8;base64,\".concat(base64);\n    var sourceMapping = \"/*# \".concat(data, \" */\");\n    var sourceURLs = cssMapping.sources.map(function (source) {\n      return \"/*# sourceURL=\".concat(cssMapping.sourceRoot || \"\").concat(source, \" */\");\n    });\n    return [content].concat(sourceURLs).concat([sourceMapping]).join(\"\\n\");\n  }\n\n  return [content].join(\"\\n\");\n};","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\tid: moduleId,\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// getDefaultExport function for compatibility with non-harmony modules\n__webpack_require__.n = (module) => {\n\tvar getter = module && module.__esModule ?\n\t\t() => (module['default']) :\n\t\t() => (module);\n\t__webpack_require__.d(getter, { a: getter });\n\treturn getter;\n};","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.g = (function() {\n\tif (typeof globalThis === 'object') return globalThis;\n\ttry {\n\t\treturn this || new Function('return this')();\n\t} catch (e) {\n\t\tif (typeof window === 'object') return window;\n\t}\n})();","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","\r\n/**\r\n * Provides standard colors (e.g. [[Color.Black]])\r\n * but you can also create custom colors using RGB, HSL, or Hex. Also provides\r\n * useful color operations like [[Color.lighten]], [[Color.darken]], and more.\r\n */\r\nexport class Color {\r\n  /**\r\n   * Red channel\r\n   */\r\n  public r: number;\r\n  /**\r\n   * Green channel\r\n   */\r\n  public g: number;\r\n  /**\r\n   * Blue channel\r\n   */\r\n  public b: number;\r\n  /**\r\n   * Alpha channel (between 0 and 1)\r\n   */\r\n  public a: number;\r\n\r\n  /**\r\n   * Hue\r\n   */\r\n  public h: number;\r\n  /**\r\n   * Saturation\r\n   */\r\n  public s: number;\r\n  /**\r\n   * Lightness\r\n   */\r\n  public l: number;\r\n\r\n  /**\r\n   * Creates a new instance of Color from an r, g, b, a\r\n   *\r\n   * @param r  The red component of color (0-255)\r\n   * @param g  The green component of color (0-255)\r\n   * @param b  The blue component of color (0-255)\r\n   * @param a  The alpha component of color (0-1.0)\r\n   */\r\n  constructor(r: number, g: number, b: number, a?: number) {\r\n    this.r = r;\r\n    this.g = g;\r\n    this.b = b;\r\n    this.a = a != null ? a : 1;\r\n  }\r\n\r\n  /**\r\n   * Creates a new instance of Color from an r, g, b, a\r\n   *\r\n   * @param r  The red component of color (0-255)\r\n   * @param g  The green component of color (0-255)\r\n   * @param b  The blue component of color (0-255)\r\n   * @param a  The alpha component of color (0-1.0)\r\n   */\r\n  public static fromRGB(r: number, g: number, b: number, a?: number): Color {\r\n    return new Color(r, g, b, a);\r\n  }\r\n\r\n  /**\r\n   * Creates a new instance of Color from a rgb string\r\n   *\r\n   * @param string  CSS color string of the form rgba(255, 255, 255, 1) or rgb(255, 255, 255)\r\n   */\r\n  public static fromRGBString(string: string): Color {\r\n    const rgbaRegEx: RegExp = /^rgba?\\((\\d+),\\s*(\\d+),\\s*(\\d+)(?:,\\s*(\\d+(?:\\.\\d+)?))?\\)/i;\r\n    let match = null;\r\n    if ((match = string.match(rgbaRegEx))) {\r\n      const r = parseInt(match[1], 10);\r\n      const g = parseInt(match[2], 10);\r\n      const b = parseInt(match[3], 10);\r\n      let a = 1;\r\n      if (match[4]) {\r\n        a = parseFloat(match[4]);\r\n      }\r\n      return new Color(r, g, b, a);\r\n    } else {\r\n      throw new Error('Invalid rgb/a string: ' + string);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Creates a new instance of Color from a hex string\r\n   *\r\n   * @param hex  CSS color string of the form #ffffff, the alpha component is optional\r\n   */\r\n  public static fromHex(hex: string): Color {\r\n    const hexRegEx: RegExp = /^#?([0-9a-f]{2})([0-9a-f]{2})([0-9a-f]{2})([0-9a-f]{2})?$/i;\r\n    let match = null;\r\n    if ((match = hex.match(hexRegEx))) {\r\n      const r = parseInt(match[1], 16);\r\n      const g = parseInt(match[2], 16);\r\n      const b = parseInt(match[3], 16);\r\n      let a = 1;\r\n      if (match[4]) {\r\n        a = parseInt(match[4], 16) / 255;\r\n      }\r\n      return new Color(r, g, b, a);\r\n    } else {\r\n      throw new Error('Invalid hex string: ' + hex);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Creates a new instance of Color from hsla values\r\n   *\r\n   * @param h  Hue is represented [0-1]\r\n   * @param s  Saturation is represented [0-1]\r\n   * @param l  Luminance is represented [0-1]\r\n   * @param a  Alpha is represented [0-1]\r\n   */\r\n  public static fromHSL(h: number, s: number, l: number, a: number = 1.0): Color {\r\n    const temp = new HSLColor(h, s, l, a);\r\n    return temp.toRGBA();\r\n  }\r\n\r\n  /**\r\n   * Lightens the current color by a specified amount\r\n   *\r\n   * @param factor  The amount to lighten by [0-1]\r\n   */\r\n  public lighten(factor: number = 0.1): Color {\r\n    const temp = HSLColor.fromRGBA(this.r, this.g, this.b, this.a);\r\n    temp.l += (1 - temp.l) * factor;\r\n    return temp.toRGBA();\r\n  }\r\n\r\n  /**\r\n   * Darkens the current color by a specified amount\r\n   *\r\n   * @param factor  The amount to darken by [0-1]\r\n   */\r\n  public darken(factor: number = 0.1): Color {\r\n    const temp = HSLColor.fromRGBA(this.r, this.g, this.b, this.a);\r\n    temp.l -= temp.l * factor;\r\n    return temp.toRGBA();\r\n  }\r\n\r\n  /**\r\n   * Saturates the current color by a specified amount\r\n   *\r\n   * @param factor  The amount to saturate by [0-1]\r\n   */\r\n  public saturate(factor: number = 0.1): Color {\r\n    const temp = HSLColor.fromRGBA(this.r, this.g, this.b, this.a);\r\n    temp.s += temp.s * factor;\r\n    return temp.toRGBA();\r\n  }\r\n\r\n  /**\r\n   * Desaturates the current color by a specified amount\r\n   *\r\n   * @param factor  The amount to desaturate by [0-1]\r\n   */\r\n  public desaturate(factor: number = 0.1): Color {\r\n    const temp = HSLColor.fromRGBA(this.r, this.g, this.b, this.a);\r\n    temp.s -= temp.s * factor;\r\n    return temp.toRGBA();\r\n  }\r\n\r\n  /**\r\n   * Multiplies a color by another, results in a darker color\r\n   *\r\n   * @param color  The other color\r\n   */\r\n  public multiply(color: Color): Color {\r\n    const newR = (((color.r / 255) * this.r) / 255) * 255;\r\n    const newG = (((color.g / 255) * this.g) / 255) * 255;\r\n    const newB = (((color.b / 255) * this.b) / 255) * 255;\r\n    const newA = color.a * this.a;\r\n    return new Color(newR, newG, newB, newA);\r\n  }\r\n\r\n  /**\r\n   * Screens a color by another, results in a lighter color\r\n   *\r\n   * @param color  The other color\r\n   */\r\n  public screen(color: Color): Color {\r\n    const color1 = color.invert();\r\n    const color2 = color.invert();\r\n    return color1.multiply(color2).invert();\r\n  }\r\n\r\n  /**\r\n   * Inverts the current color\r\n   */\r\n  public invert(): Color {\r\n    return new Color(255 - this.r, 255 - this.g, 255 - this.b, 1.0 - this.a);\r\n  }\r\n\r\n  /**\r\n   * Averages the current color with another\r\n   *\r\n   * @param color  The other color\r\n   */\r\n  public average(color: Color): Color {\r\n    const newR = (color.r + this.r) / 2;\r\n    const newG = (color.g + this.g) / 2;\r\n    const newB = (color.b + this.b) / 2;\r\n    const newA = (color.a + this.a) / 2;\r\n    return new Color(newR, newG, newB, newA);\r\n  }\r\n\r\n  public equal(color: Color): boolean {\r\n    return this.toString() === color.toString();\r\n  }\r\n\r\n  /**\r\n   * Returns a CSS string representation of a color.\r\n   *\r\n   * @param format Color representation, accepts: rgb, hsl, or hex\r\n   */\r\n  public toString(format: 'rgb' | 'hsl' | 'hex' = 'rgb') {\r\n    switch (format) {\r\n      case 'rgb':\r\n        return this.toRGBA();\r\n      case 'hsl':\r\n        return this.toHSLA();\r\n      case 'hex':\r\n        return this.toHex();\r\n      default:\r\n        throw new Error('Invalid Color format');\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Returns Hex Value of a color component\r\n   * @param c color component\r\n   * @see https://stackoverflow.com/questions/5623838/rgb-to-hex-and-hex-to-rgb\r\n   */\r\n  private _componentToHex(c: number) {\r\n    const hex = c.toString(16);\r\n    return hex.length === 1 ? '0' + hex : hex;\r\n  }\r\n\r\n  /**\r\n   * Return Hex representation of a color.\r\n   */\r\n  public toHex() {\r\n    return '#' + this._componentToHex(this.r) + this._componentToHex(this.g) + this._componentToHex(this.b);\r\n  }\r\n\r\n  /**\r\n   * Return RGBA representation of a color.\r\n   */\r\n  public toRGBA() {\r\n    const result = String(this.r.toFixed(0)) + ', ' + String(this.g.toFixed(0)) + ', ' + String(this.b.toFixed(0));\r\n    if (this.a !== undefined || this.a !== null) {\r\n      return 'rgba(' + result + ', ' + String(this.a) + ')';\r\n    }\r\n    return 'rgb(' + result + ')';\r\n  }\r\n\r\n  /**\r\n   * Return HSLA representation of a color.\r\n   */\r\n  public toHSLA() {\r\n    return HSLColor.fromRGBA(this.r, this.g, this.b, this.a).toString();\r\n  }\r\n\r\n  /**\r\n   * Returns a CSS string representation of a color.\r\n   */\r\n  public fillStyle() {\r\n    return this.toString();\r\n  }\r\n\r\n  /**\r\n   * Returns a clone of the current color.\r\n   */\r\n  public clone(): Color {\r\n    return new Color(this.r, this.g, this.b, this.a);\r\n  }\r\n\r\n  /**\r\n   * Black (#000000)\r\n   */\r\n  public static get Black(): Color {\r\n    return Color.fromHex('#000000');\r\n  }\r\n\r\n  /**\r\n   * White (#FFFFFF)\r\n   */\r\n  public static get White(): Color {\r\n    return Color.fromHex('#FFFFFF');\r\n  }\r\n\r\n  /**\r\n   * Gray (#808080)\r\n   */\r\n  public static get Gray(): Color {\r\n    return Color.fromHex('#808080');\r\n  }\r\n\r\n  /**\r\n   * Light gray (#D3D3D3)\r\n   */\r\n  public static get LightGray(): Color {\r\n    return Color.fromHex('#D3D3D3');\r\n  }\r\n\r\n  /**\r\n   * Dark gray (#A9A9A9)\r\n   */\r\n  public static get DarkGray(): Color {\r\n    return Color.fromHex('#A9A9A9');\r\n  }\r\n\r\n  /**\r\n   * Yellow (#FFFF00)\r\n   */\r\n  public static get Yellow(): Color {\r\n    return Color.fromHex('#FFFF00');\r\n  }\r\n\r\n  /**\r\n   * Orange (#FFA500)\r\n   */\r\n  public static get Orange(): Color {\r\n    return Color.fromHex('#FFA500');\r\n  }\r\n\r\n  /**\r\n   * Red (#FF0000)\r\n   */\r\n  public static get Red(): Color {\r\n    return Color.fromHex('#FF0000');\r\n  }\r\n\r\n  /**\r\n   * Vermilion (#FF5B31)\r\n   */\r\n  public static get Vermilion(): Color {\r\n    return Color.fromHex('#FF5B31');\r\n  }\r\n\r\n  /**\r\n   * Rose (#FF007F)\r\n   */\r\n  public static get Rose(): Color {\r\n    return Color.fromHex('#FF007F');\r\n  }\r\n\r\n  /**\r\n   * Magenta (#FF00FF)\r\n   */\r\n  public static get Magenta(): Color {\r\n    return Color.fromHex('#FF00FF');\r\n  }\r\n\r\n  /**\r\n   * Violet (#7F00FF)\r\n   */\r\n  public static get Violet(): Color {\r\n    return Color.fromHex('#7F00FF');\r\n  }\r\n\r\n  /**\r\n   * Blue (#0000FF)\r\n   */\r\n  public static get Blue(): Color {\r\n    return Color.fromHex('#0000FF');\r\n  }\r\n\r\n  /**\r\n   * Azure (#007FFF)\r\n   */\r\n  public static get Azure(): Color {\r\n    return Color.fromHex('#007FFF');\r\n  }\r\n\r\n  /**\r\n   * Cyan (#00FFFF)\r\n   */\r\n  public static get Cyan(): Color {\r\n    return Color.fromHex('#00FFFF');\r\n  }\r\n\r\n  /**\r\n   * Viridian (#59978F)\r\n   */\r\n  public static get Viridian(): Color {\r\n    return Color.fromHex('#59978F');\r\n  }\r\n\r\n  /**\r\n   * Green (#00FF00)\r\n   */\r\n  public static get Green(): Color {\r\n    return Color.fromHex('#00FF00');\r\n  }\r\n\r\n  /**\r\n   * Chartreuse (#7FFF00)\r\n   */\r\n  public static get Chartreuse(): Color {\r\n    return Color.fromHex('#7FFF00');\r\n  }\r\n\r\n  /**\r\n   * Transparent (#FFFFFF00)\r\n   */\r\n  public static get Transparent(): Color {\r\n    return Color.fromHex('#FFFFFF00');\r\n  }\r\n\r\n  /**\r\n   * ExcaliburBlue (#176BAA)\r\n   */\r\n  public static get ExcaliburBlue(): Color {\r\n    return Color.fromHex('#176BAA');\r\n  }\r\n}\r\n\r\n/**\r\n * Internal HSL Color representation\r\n *\r\n * http://en.wikipedia.org/wiki/HSL_and_HSV\r\n * http://axonflux.com/handy-rgb-to-hsl-and-rgb-to-hsv-color-model-c\r\n */\r\nclass HSLColor {\r\n  constructor(public h: number, public s: number, public l: number, public a: number) {}\r\n\r\n  public static hue2rgb(p: number, q: number, t: number): number {\r\n    if (t < 0) {\r\n      t += 1;\r\n    }\r\n    if (t > 1) {\r\n      t -= 1;\r\n    }\r\n    if (t < 1 / 6) {\r\n      return p + (q - p) * 6 * t;\r\n    }\r\n    if (t < 1 / 2) {\r\n      return q;\r\n    }\r\n    if (t < 2 / 3) {\r\n      return p + (q - p) * (2 / 3 - t) * 6;\r\n    }\r\n    return p;\r\n  }\r\n\r\n  public static fromRGBA(r: number, g: number, b: number, a: number): HSLColor {\r\n    r /= 255;\r\n    g /= 255;\r\n    b /= 255;\r\n    const max = Math.max(r, g, b),\r\n      min = Math.min(r, g, b);\r\n    let h, s;\r\n    const l = (max + min) / 2;\r\n\r\n    if (max === min) {\r\n      h = s = 0; // achromatic\r\n    } else {\r\n      const d = max - min;\r\n      s = l > 0.5 ? d / (2 - max - min) : d / (max + min);\r\n      switch (max) {\r\n        case r:\r\n          h = (g - b) / d + (g < b ? 6 : 0);\r\n          break;\r\n        case g:\r\n          h = (b - r) / d + 2;\r\n          break;\r\n        case b:\r\n          h = (r - g) / d + 4;\r\n          break;\r\n      }\r\n      h /= 6;\r\n    }\r\n\r\n    return new HSLColor(h, s, l, a);\r\n  }\r\n\r\n  public toRGBA(): Color {\r\n    let r: number, g: number, b: number;\r\n\r\n    if (this.s === 0) {\r\n      r = g = b = this.l; // achromatic\r\n    } else {\r\n      const q = this.l < 0.5 ? this.l * (1 + this.s) : this.l + this.s - this.l * this.s;\r\n      const p = 2 * this.l - q;\r\n      r = HSLColor.hue2rgb(p, q, this.h + 1 / 3);\r\n      g = HSLColor.hue2rgb(p, q, this.h);\r\n      b = HSLColor.hue2rgb(p, q, this.h - 1 / 3);\r\n    }\r\n\r\n    return new Color(r * 255, g * 255, b * 255, this.a);\r\n  }\r\n\r\n  public toString(): string {\r\n    const h = this.h.toFixed(0),\r\n      s = this.s.toFixed(0),\r\n      l = this.l.toFixed(0),\r\n      a = this.a.toFixed(0);\r\n    return `hsla(${h}, ${s}, ${l}, ${a})`;\r\n  }\r\n}\r\n","/**\r\n * @module\r\n * Pseudo-Random Utility\r\n *\r\n * A pseudo-random utility to add seeded random support for help in\r\n * generating things like terrain or reproducible randomness. Uses the\r\n * [Mersenne Twister](https://en.wikipedia.org/wiki/Mersenne_Twister) algorithm.\r\n */\r\n\r\n/**\r\n * 32-bit mask\r\n */\r\nconst BITMASK32: number = 0xffffffff;\r\n\r\n/**\r\n * Pseudo-random number generator following the Mersenne_Twister algorithm. Given a seed this generator will produce the same sequence\r\n * of numbers each time it is called.\r\n * See https://en.wikipedia.org/wiki/Mersenne_Twister for more details.\r\n * Uses the MT19937-32 (2002) implementation documented here http://www.math.sci.hiroshima-u.ac.jp/~m-mat/MT/MT2002/emt19937ar.html\r\n *\r\n * Api inspired by http://chancejs.com/# https://github.com/chancejs/chancejs\r\n */\r\nexport class Random {\r\n  // Separation point of one one word, the number of bits in the lower bitmask 0 <= r <= w-1\r\n  private _lowerMask: number = 0x7fffffff; // 31 bits same as _r\r\n  private _upperMask: number = 0x80000000; // 34 high bits\r\n\r\n  // Word size, 64 bits\r\n  private _w: number = 32;\r\n\r\n  // Degree of recurrence\r\n  private _n: number = 624;\r\n\r\n  // Middle word, an offset used in the recurrence defining the series x, 1<=m<n\r\n  private _m: number = 397;\r\n  // coefficients of teh rational normal form twist matrix\r\n  private _a: number = 0x9908b0df;\r\n\r\n  // tempering bit shifts and masks\r\n  private _u: number = 11;\r\n  private _s: number = 7;\r\n  private _b: number = 0x9d2c5680;\r\n  private _t: number = 15;\r\n  private _c: number = 0xefc60000;\r\n  private _l: number = 18;\r\n  private _f: number = 1812433253;\r\n\r\n  private _mt: number[];\r\n\r\n  private _index: number;\r\n\r\n  /**\r\n   * If no seed is specified, the Date.now() is used\r\n   */\r\n  constructor(public seed?: number) {\r\n    this._mt = new Array<number>(this._n);\r\n    // need to mask to support higher bit machines\r\n    this._mt[0] = (seed || Date.now()) >>> 0;\r\n\r\n    for (let i = 1; i < this._n; i++) {\r\n      const s = this._mt[i - 1] ^ (this._mt[i - 1] >>> (this._w - 2));\r\n      // numbers are bigger than the JS max safe int, add in 16-bit chunks to prevent IEEE rounding errors on high bits\r\n      this._mt[i] = (((this._f * ((s & 0xffff0000) >>> 16)) << 16) + this._f * (s & 0xffff) + i) >>> 0;\r\n    }\r\n    this._index = this._n;\r\n  }\r\n\r\n  /**\r\n   * Apply the twist\r\n   */\r\n  private _twist(): void {\r\n    const mag01 = [0x0, this._a];\r\n    let y = 0,\r\n      i = 0;\r\n    for (; i < this._n - this._m; i++) {\r\n      y = (this._mt[i] & this._upperMask) | (this._mt[i + 1] & this._lowerMask);\r\n      this._mt[i] = this._mt[i + this._m] ^ (y >>> 1) ^ (mag01[y & 0x1] & BITMASK32);\r\n    }\r\n    for (; i < this._n - 1; i++) {\r\n      y = (this._mt[i] & this._upperMask) | (this._mt[i + 1] & this._lowerMask);\r\n      this._mt[i] = this._mt[i + (this._m - this._n)] ^ (y >>> 1) ^ (mag01[y & 0x1] & BITMASK32);\r\n    }\r\n    y = (this._mt[this._n - 1] & this._upperMask) | (this._mt[0] & this._lowerMask);\r\n    this._mt[this._n - 1] = this._mt[this._m - 1] ^ (y >>> 1) ^ (mag01[y & 0x1] & BITMASK32);\r\n\r\n    this._index = 0;\r\n  }\r\n\r\n  /**\r\n   * Return next 32 bit integer number in sequence\r\n   */\r\n  public nextInt(): number {\r\n    if (this._index >= this._n) {\r\n      this._twist();\r\n    }\r\n\r\n    let y = this._mt[this._index++];\r\n\r\n    y ^= y >>> this._u;\r\n    y ^= (y << this._s) & this._b;\r\n    y ^= (y << this._t) & this._c;\r\n    y ^= y >>> this._l;\r\n\r\n    return y >>> 0;\r\n  }\r\n\r\n  /**\r\n   * Return a random floating point number between [0, 1)\r\n   */\r\n  public next(): number {\r\n    return this.nextInt() * (1.0 / 4294967296.0); // divided by 2^32\r\n  }\r\n\r\n  /**\r\n   * Return a random floating point in range [min, max) min is included, max is not included\r\n   */\r\n  public floating(min: number, max: number): number {\r\n    return (max - min) * this.next() + min;\r\n  }\r\n\r\n  /**\r\n   * Return a random integer in range [min, max] min is included, max is included.\r\n   * Implemented with rejection sampling, see https://medium.com/@betable/tifu-by-using-math-random-f1c308c4fd9d#.i13tdiu5a\r\n   */\r\n  public integer(min: number, max: number): number {\r\n    return Math.floor((max - min + 1) * this.next() + min);\r\n  }\r\n\r\n  /**\r\n   * Returns true or false randomly with 50/50 odds by default.\r\n   * By default the likelihood of returning a true is .5 (50%).\r\n   * @param likelihood takes values between [0, 1]\r\n   */\r\n  public bool(likelihood: number = 0.5): boolean {\r\n    return this.next() <= likelihood;\r\n  }\r\n\r\n  /**\r\n   * Returns one element from an array at random\r\n   */\r\n  public pickOne<T>(array: Array<T>): T {\r\n    return array[this.integer(0, array.length - 1)];\r\n  }\r\n\r\n  /**\r\n   * Returns a new array random picking elements from the original\r\n   * @param array Original array to pick from\r\n   * @param numPicks can be any positive number\r\n   * @param allowDuplicates indicates whether the returned set is allowed duplicates (it does not mean there will always be duplicates\r\n   * just that it is possible)\r\n   */\r\n  public pickSet<T>(array: Array<T>, numPicks: number, allowDuplicates: boolean = false): Array<T> {\r\n    if (allowDuplicates) {\r\n      return this._pickSetWithDuplicates(array, numPicks);\r\n    } else {\r\n      return this._pickSetWithoutDuplicates(array, numPicks);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Returns a new array randomly picking elements in the original (not reused)\r\n   * @param array Array to pick elements out of\r\n   * @param numPicks must be less than or equal to the number of elements in the array.\r\n   */\r\n  private _pickSetWithoutDuplicates<T>(array: Array<T>, numPicks: number): Array<T> {\r\n    if (numPicks > array.length || numPicks < 0) {\r\n      throw new Error('Invalid number of elements to pick, must pick a value 0 < n <= length');\r\n    }\r\n    if (numPicks === array.length) {\r\n      return array;\r\n    }\r\n\r\n    const result: Array<T> = new Array<T>(numPicks);\r\n    let currentPick = 0;\r\n    const tempArray = array.slice(0);\r\n    while (currentPick < numPicks) {\r\n      const index = this.integer(0, tempArray.length - 1);\r\n      result[currentPick++] = tempArray[index];\r\n      tempArray.splice(index, 1);\r\n    }\r\n\r\n    return result;\r\n  }\r\n\r\n  /**\r\n   * Returns a new array random picking elements from the original allowing duplicates\r\n   * @param array Array to pick elements out of\r\n   * @param numPicks can be any positive number\r\n   */\r\n  private _pickSetWithDuplicates<T>(array: Array<T>, numPicks: number): Array<T> {\r\n    // Typescript numbers are all floating point, so do we add check for int? (or floor the input?)\r\n    if (numPicks < 0) {\r\n      throw new Error('Invalid number of elements to pick, must pick a value 0 <= n < MAX_INT');\r\n    }\r\n    const result = new Array<T>(numPicks);\r\n    for (let i = 0; i < numPicks; i++) {\r\n      result[i] = this.pickOne(array);\r\n    }\r\n    return result;\r\n  }\r\n\r\n  /**\r\n   * Returns a new array that has its elements shuffled. Using the Fisher/Yates method\r\n   * https://en.wikipedia.org/wiki/Fisher%E2%80%93Yates_shuffle\r\n   */\r\n  public shuffle<T>(array: Array<T>): Array<T> {\r\n    const tempArray = array.slice(0);\r\n    let swap: T = null;\r\n    for (let i = 0; i < tempArray.length - 2; i++) {\r\n      const randomIndex = this.integer(i, tempArray.length - 1);\r\n      swap = tempArray[i];\r\n      tempArray[i] = tempArray[randomIndex];\r\n      tempArray[randomIndex] = swap;\r\n    }\r\n\r\n    return tempArray;\r\n  }\r\n\r\n  /**\r\n   * Generate a list of random integer numbers\r\n   * @param length the length of the final array\r\n   * @param min the minimum integer number to generate inclusive\r\n   * @param max the maximum integer number to generate inclusive\r\n   */\r\n  public range(length: number, min: number, max: number): Array<number> {\r\n    const result: Array<number> = new Array(length);\r\n    for (let i = 0; i < length; i++) {\r\n      result[i] = this.integer(min, max);\r\n    }\r\n    return result;\r\n  }\r\n\r\n  /**\r\n   * Returns the result of a d4 dice roll\r\n   */\r\n  public d4() {\r\n    return this.integer(1, 4);\r\n  }\r\n\r\n  /**\r\n   * Returns the result of a d6 dice roll\r\n   */\r\n  public d6() {\r\n    return this.integer(1, 6);\r\n  }\r\n\r\n  /**\r\n   * Returns the result of a d8 dice roll\r\n   */\r\n  public d8() {\r\n    return this.integer(1, 8);\r\n  }\r\n\r\n  /**\r\n   * Returns the result of a d10 dice roll\r\n   */\r\n  public d10() {\r\n    return this.integer(1, 10);\r\n  }\r\n\r\n  /**\r\n   * Returns the result of a d12 dice roll\r\n   */\r\n  public d12() {\r\n    return this.integer(1, 12);\r\n  }\r\n\r\n  /**\r\n   * Returns the result of a d20 dice roll\r\n   */\r\n  public d20() {\r\n    return this.integer(1, 20);\r\n  }\r\n}\r\n","import 'core-js/es/array/sort';\r\nimport 'core-js/es/object/keys';\r\n\r\n/**\r\n * Polyfill adding function\r\n */\r\nexport function polyfill() {\r\n  /* istanbul ignore next */\r\n  if (typeof window === 'undefined') {\r\n    window = <any>{\r\n      audioContext: function () {\r\n        return;\r\n      }\r\n    };\r\n  }\r\n  /* istanbul ignore next */\r\n  if (typeof window !== 'undefined' && !window.requestAnimationFrame) {\r\n    (<any>window).requestAnimationFrame =\r\n      (<any>window).webkitRequestAnimationFrame ||\r\n      (<any>window).mozRequestAnimationFrame ||\r\n      function (callback: Function) {\r\n        window.setInterval(callback, 1000 / 60);\r\n      };\r\n  }\r\n  /* istanbul ignore next */\r\n  if (typeof window !== 'undefined' && !window.cancelAnimationFrame) {\r\n    (<any>window).cancelAnimationFrame =\r\n      (<any>window).webkitCancelAnimationFrame ||\r\n      (<any>window).mozCancelAnimationFrame ||\r\n      function () {\r\n        return;\r\n      };\r\n  }\r\n  /* istanbul ignore next */\r\n  if (typeof window !== 'undefined' && !(<any>window).AudioContext) {\r\n    if ((<any>window).webkitAudioContext) {\r\n      const ctx = (<any>window).webkitAudioContext;\r\n      const replaceMe = ctx.prototype.decodeAudioData;\r\n      (<any>window).webkitAudioContext.prototype.decodeAudioData = function (arrayBuffer: ArrayBuffer) {\r\n        return new Promise((resolve, reject) => {\r\n          replaceMe.call(this, arrayBuffer, resolve, reject);\r\n        });\r\n      };\r\n    }\r\n\r\n    (<any>window).AudioContext =\r\n      (<any>window).AudioContext ||\r\n      (<any>window).webkitAudioContext ||\r\n      (<any>window).mozAudioContext ||\r\n      (<any>window).msAudioContext ||\r\n      (<any>window).oAudioContext;\r\n  }\r\n\r\n  /* istanbul ignore next */\r\n  if (typeof window !== 'undefined' && !(<any>window).devicePixelRatio) {\r\n    (<any>window).devicePixelRatio = window.devicePixelRatio || 1;\r\n  }\r\n}\r\n","\r\n/**\r\n * Flags is a feature flag implementation for Excalibur. They can only be operated **before [[Engine]] construction**\r\n * after which they are frozen and are read-only.\r\n *\r\n * Flags are used to enable experimental or preview features in Excalibur.\r\n */\r\nexport class Flags {\r\n  private static _FROZEN = false;\r\n  private static _FLAGS: Record<string, boolean> = {};\r\n\r\n\r\n  /**\r\n   * Force excalibur to load the Canvas 2D graphics context fallback\r\n   *\r\n   * @warning not all features of excalibur are supported in the Canvas 2D fallback\r\n   */\r\n  public static useCanvasGraphicsContext() {\r\n    Flags.enable('use-canvas-context');\r\n  }\r\n\r\n  /**\r\n   * Freeze all flag modifications making them readonly\r\n   */\r\n  public static freeze() {\r\n    Flags._FROZEN = true;\r\n  }\r\n\r\n  /**\r\n   * Resets internal flag state, not meant to be called by users. Only used for testing.\r\n   *\r\n   * Calling this in your game is UNSUPPORTED\r\n   * @internal\r\n   */\r\n  public static _reset() {\r\n    Flags._FROZEN = false;\r\n    Flags._FLAGS = {};\r\n  }\r\n  /**\r\n   * Enable a specific feature flag by name. **Note: can only be set before [[Engine]] constructor time**\r\n   * @param flagName\r\n   */\r\n  public static enable(flagName: string): void {\r\n    if (this._FROZEN) {\r\n      throw Error('Feature flags can only be enabled before Engine constructor time');\r\n    }\r\n    Flags._FLAGS[flagName] = true;\r\n  }\r\n\r\n  /**\r\n   * Disable a specific feature flag by name. **Note: can only be set before [[Engine]] constructor time**\r\n   * @param flagName\r\n   */\r\n  public static disable(flagName: string): void {\r\n    if (this._FROZEN) {\r\n      throw Error('Feature flags can only be disabled before Engine constructor time');\r\n    }\r\n    Flags._FLAGS[flagName] = false;\r\n  }\r\n\r\n  /**\r\n   * Check if a flag is enabled. If the flag is disabled or does not exist `false` is returned\r\n   * @param flagName\r\n   */\r\n  public static isEnabled(flagName: string): boolean {\r\n    return !!Flags._FLAGS[flagName];\r\n  }\r\n\r\n  /**\r\n   * Show a list of currently known flags\r\n   */\r\n  public static show(): string[] {\r\n    return Object.keys(Flags._FLAGS);\r\n  }\r\n}\r\n","export type Id<T extends string> = {\r\n  type: T,\r\n  value: number\r\n};\r\n\r\n/**\r\n * Create a branded ID type from a number\r\n */\r\nexport function createId<T extends string>(type: T, value: number): Id<T> {\r\n  return { type, value };\r\n};\r\n","import { Clonable } from '../Interfaces/Clonable';\r\n\r\n/**\r\n * A 2D vector on a plane.\r\n */\r\n\r\nexport class Vector implements Clonable<Vector> {\r\n  /**\r\n   * A (0, 0) vector\r\n   */\r\n  public static get Zero() {\r\n    return new Vector(0, 0);\r\n  }\r\n\r\n  /**\r\n   * A (1, 1) vector\r\n   */\r\n  public static get One() {\r\n    return new Vector(1, 1);\r\n  }\r\n\r\n  /**\r\n   * A (0.5, 0.5) vector\r\n   */\r\n  public static get Half() {\r\n    return new Vector(0.5, 0.5);\r\n  }\r\n\r\n  /**\r\n   * A unit vector pointing up (0, -1)\r\n   */\r\n  public static get Up() {\r\n    return new Vector(0, -1);\r\n  }\r\n\r\n  /**\r\n   * A unit vector pointing down (0, 1)\r\n   */\r\n  public static get Down() {\r\n    return new Vector(0, 1);\r\n  }\r\n\r\n  /**\r\n   * A unit vector pointing left (-1, 0)\r\n   */\r\n  public static get Left() {\r\n    return new Vector(-1, 0);\r\n  }\r\n  /**\r\n   * A unit vector pointing right (1, 0)\r\n   */\r\n  public static get Right() {\r\n    return new Vector(1, 0);\r\n  }\r\n\r\n  /**\r\n   * Returns a vector of unit length in the direction of the specified angle in Radians.\r\n   * @param angle The angle to generate the vector\r\n   */\r\n  public static fromAngle(angle: number) {\r\n    return new Vector(Math.cos(angle), Math.sin(angle));\r\n  }\r\n\r\n  /**\r\n   * Checks if vector is not null, undefined, or if any of its components are NaN or Infinity.\r\n   */\r\n  public static isValid(vec: Vector) {\r\n    if (vec === null || vec === undefined) {\r\n      return false;\r\n    }\r\n    if (isNaN(vec.x) || isNaN(vec.y)) {\r\n      return false;\r\n    }\r\n\r\n    if (vec.x === Infinity || vec.y === Infinity || vec.x === -Infinity || vec.y === -Infinity) {\r\n      return false;\r\n    }\r\n\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * Calculates distance between two Vectors\r\n   * @param vec1\r\n   * @param vec2\r\n   */\r\n  public static distance(vec1: Vector, vec2: Vector) {\r\n    return Math.sqrt(Math.pow(vec1.x - vec2.x, 2) + Math.pow(vec1.y - vec2.y, 2));\r\n  }\r\n\r\n  public static min(vec1: Vector, vec2: Vector) {\r\n    return new Vector(Math.min(vec1.x, vec2.x), Math.min(vec1.y, vec2.y));\r\n  }\r\n\r\n  public static max(vec1: Vector, vec2: Vector) {\r\n    return new Vector(Math.max(vec1.x, vec2.x), Math.max(vec1.y, vec2.y));\r\n  }\r\n\r\n  /**\r\n   * @param x  X component of the Vector\r\n   * @param y  Y component of the Vector\r\n   */\r\n  constructor(x: number, y: number) {\r\n    this._x = x;\r\n    this._y = y;\r\n  }\r\n\r\n  protected _x = 0;\r\n  /**\r\n   * Get the x component of the vector\r\n   */\r\n  public get x(): number {\r\n    return this._x;\r\n  }\r\n\r\n  /**\r\n   * Set the x component, THIS MUTATES the current vector. It is usually better to create a new vector.\r\n   * @warning **Be very careful setting components on shared vectors, mutating shared vectors can cause hard to find bugs**\r\n   */\r\n  public set x(val: number) {\r\n    this._x = val;\r\n  }\r\n\r\n  protected _y = 0;\r\n  /**\r\n   * Get the y component of the vector\r\n   */\r\n  public get y(): number {\r\n    return this._y;\r\n  }\r\n\r\n  /**\r\n   * Set the y component, THIS MUTATES the current vector. It is usually better to create a new vector.\r\n   * @warning **Be very careful setting components on shared vectors, mutating shared vectors can cause hard to find bugs**\r\n   */\r\n  public set y(val: number) {\r\n    this._y = val;\r\n  }\r\n\r\n  /**\r\n   * Sets the x and y components at once, THIS MUTATES the current vector. It is usually better to create a new vector.\r\n   *\r\n   * @warning **Be very careful using this, mutating vectors can cause hard to find bugs**\r\n   */\r\n  setTo(x: number, y: number) {\r\n    (this.x as number) = x;\r\n    (this.y as number) = y;\r\n  }\r\n\r\n  /**\r\n   * Compares this point against another and tests for equality\r\n   * @param vector The other point to compare to\r\n   * @param tolerance Amount of euclidean distance off we are willing to tolerate\r\n   */\r\n  public equals(vector: Vector, tolerance: number = 0.001): boolean {\r\n    return Math.abs(this.x - vector.x) <= tolerance && Math.abs(this.y - vector.y) <= tolerance;\r\n  }\r\n\r\n  /**\r\n   * The distance to another vector. If no other Vector is specified, this will return the [[magnitude]].\r\n   * @param v  The other vector. Leave blank to use origin vector.\r\n   */\r\n  public distance(v?: Vector): number {\r\n    if (!v) {\r\n      v = Vector.Zero;\r\n    }\r\n    return Math.sqrt(Math.pow(this.x - v.x, 2) + Math.pow(this.y - v.y, 2));\r\n  }\r\n\r\n  public squareDistance(v?: Vector): number {\r\n    if (!v) {\r\n      v = Vector.Zero;\r\n    }\r\n    return Math.pow(this.x - v.x, 2) + Math.pow(this.y - v.y, 2);\r\n  }\r\n\r\n  /**\r\n   * The size (magnitude) of the Vector\r\n   */\r\n  public get size(): number {\r\n    return this.distance();\r\n  }\r\n\r\n  /**\r\n   * Setting the size mutates the current vector\r\n   *\r\n   * @warning Can be used to set the size of the vector, **be very careful using this, mutating vectors can cause hard to find bugs**\r\n   */\r\n  public set size(newLength: number) {\r\n    const v = this.normalize().scale(newLength);\r\n    this.setTo(v.x, v.y);\r\n  }\r\n\r\n  /**\r\n   * Normalizes a vector to have a magnitude of 1.\r\n   */\r\n  public normalize(): Vector {\r\n    const d = this.distance();\r\n    if (d > 0) {\r\n      return new Vector(this.x / d, this.y / d);\r\n    } else {\r\n      return new Vector(0, 1);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Returns the average (midpoint) between the current point and the specified\r\n   */\r\n  public average(vec: Vector): Vector {\r\n    return this.add(vec).scale(0.5);\r\n  }\r\n\r\n  /**\r\n   * Scales a vector's by a factor of size\r\n   * @param size  The factor to scale the magnitude by\r\n   */\r\n  public scale(scale: Vector): Vector;\r\n  public scale(size: number): Vector;\r\n  public scale(sizeOrScale: number | Vector): Vector {\r\n    if (sizeOrScale instanceof Vector) {\r\n      return new Vector(this.x * sizeOrScale.x, this.y * sizeOrScale.y);\r\n    } else {\r\n      return new Vector(this.x * sizeOrScale, this.y * sizeOrScale);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Adds one vector to another\r\n   * @param v The vector to add\r\n   */\r\n  public add(v: Vector): Vector {\r\n    return new Vector(this.x + v.x, this.y + v.y);\r\n  }\r\n\r\n  /**\r\n   * Subtracts a vector from another, if you subtract vector `B.sub(A)` the resulting vector points from A -> B\r\n   * @param v The vector to subtract\r\n   */\r\n  public sub(v: Vector): Vector {\r\n    return new Vector(this.x - v.x, this.y - v.y);\r\n  }\r\n\r\n  /**\r\n   * Adds one vector to this one modifying the original\r\n   * @param v The vector to add\r\n   * @warning Be very careful using this, mutating vectors can cause hard to find bugs\r\n   */\r\n  public addEqual(v: Vector): Vector {\r\n    this.setTo(this.x + v.x, this.y + v.y);\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Subtracts a vector from this one modifying the original\r\n   * @param v The vector to subtract\r\n   * @warning Be very careful using this, mutating vectors can cause hard to find bugs\r\n   */\r\n  public subEqual(v: Vector): Vector {\r\n    this.setTo(this.x - v.x, this.y - v.y);\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Scales this vector by a factor of size and modifies the original\r\n   * @warning Be very careful using this, mutating vectors can cause hard to find bugs\r\n   */\r\n  public scaleEqual(size: number): Vector {\r\n    this.setTo(this.x * size, this.y * size);\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Performs a dot product with another vector\r\n   * @param v  The vector to dot\r\n   */\r\n  public dot(v: Vector): number {\r\n    return this.x * v.x + this.y * v.y;\r\n  }\r\n\r\n  /**\r\n   * Performs a 2D cross product with scalar. 2D cross products with a scalar return a vector.\r\n   * @param v  The scalar to cross\r\n   */\r\n  public cross(v: number): Vector;\r\n  /**\r\n   * Performs a 2D cross product with another vector. 2D cross products return a scalar value not a vector.\r\n   * @param v  The vector to cross\r\n   */\r\n  public cross(v: Vector): number;\r\n  public cross(v: any): any {\r\n    if (v instanceof Vector) {\r\n      return this.x * v.y - this.y * v.x;\r\n    } else if (typeof v === 'number') {\r\n      return new Vector(v * this.y, -v * this.x);\r\n    }\r\n  }\r\n\r\n  static cross(num: number, vec: Vector): Vector {\r\n    return new Vector(-num * vec.y, num * vec.x);\r\n  }\r\n\r\n  /**\r\n   * Returns the perpendicular vector to this one\r\n   */\r\n  public perpendicular(): Vector {\r\n    return new Vector(this.y, -this.x);\r\n  }\r\n\r\n  /**\r\n   * Returns the normal vector to this one, same as the perpendicular of length 1\r\n   */\r\n  public normal(): Vector {\r\n    return this.perpendicular().normalize();\r\n  }\r\n\r\n  /**\r\n   * Negate the current vector\r\n   */\r\n  public negate(): Vector {\r\n    return this.scale(-1);\r\n  }\r\n\r\n  /**\r\n   * Returns the angle of this vector.\r\n   */\r\n  public toAngle(): number {\r\n    return Math.atan2(this.y, this.x);\r\n  }\r\n\r\n  /**\r\n   * Rotates the current vector around a point by a certain number of\r\n   * degrees in radians\r\n   */\r\n  public rotate(angle: number, anchor?: Vector): Vector {\r\n    if (!anchor) {\r\n      anchor = new Vector(0, 0);\r\n    }\r\n    const sinAngle = Math.sin(angle);\r\n    const cosAngle = Math.cos(angle);\r\n    const x = cosAngle * (this.x - anchor.x) - sinAngle * (this.y - anchor.y) + anchor.x;\r\n    const y = sinAngle * (this.x - anchor.x) + cosAngle * (this.y - anchor.y) + anchor.y;\r\n    return new Vector(x, y);\r\n  }\r\n\r\n  /**\r\n   * Creates new vector that has the same values as the previous.\r\n   */\r\n  public clone(): Vector {\r\n    return new Vector(this.x, this.y);\r\n  }\r\n\r\n  /**\r\n   * Returns a string representation of the vector.\r\n   */\r\n  public toString(fixed?: number): string {\r\n    if (fixed) {\r\n      return `(${this.x.toFixed(fixed)}, ${this.y.toFixed(fixed)})`;\r\n    }\r\n    return `(${this.x}, ${this.y})`;\r\n  }\r\n}\r\n\r\n/**\r\n * Shorthand for creating new Vectors - returns a new Vector instance with the\r\n * provided X and Y components.\r\n *\r\n * @param x  X component of the Vector\r\n * @param y  Y component of the Vector\r\n */\r\nexport function vec(x: number, y: number): Vector {\r\n  return new Vector(x, y);\r\n}\r\n","/* eslint-disable no-console */\r\n/**\r\n * Logging level that Excalibur will tag\r\n */\r\nexport enum LogLevel {\r\n  Debug,\r\n  Info,\r\n  Warn,\r\n  Error,\r\n  Fatal\r\n}\r\n\r\n/**\r\n * Static singleton that represents the logging facility for Excalibur.\r\n * Excalibur comes built-in with a [[ConsoleAppender]] and [[ScreenAppender]].\r\n * Derive from [[Appender]] to create your own logging appenders.\r\n */\r\nexport class Logger {\r\n  private static _INSTANCE: Logger = null;\r\n  private _appenders: Appender[] = [];\r\n\r\n  constructor() {\r\n    if (Logger._INSTANCE) {\r\n      throw new Error('Logger is a singleton');\r\n    }\r\n    Logger._INSTANCE = this;\r\n    // Default console appender\r\n    Logger._INSTANCE.addAppender(new ConsoleAppender());\r\n    return Logger._INSTANCE;\r\n  }\r\n\r\n  /**\r\n   * Gets or sets the default logging level. Excalibur will only log\r\n   * messages if equal to or above this level. Default: [[LogLevel.Info]]\r\n   */\r\n  public defaultLevel: LogLevel = LogLevel.Info;\r\n\r\n  /**\r\n   * Gets the current static instance of Logger\r\n   */\r\n  public static getInstance(): Logger {\r\n    if (Logger._INSTANCE == null) {\r\n      Logger._INSTANCE = new Logger();\r\n    }\r\n    return Logger._INSTANCE;\r\n  }\r\n\r\n  /**\r\n   * Adds a new [[Appender]] to the list of appenders to write to\r\n   */\r\n  public addAppender(appender: Appender): void {\r\n    this._appenders.push(appender);\r\n  }\r\n\r\n  /**\r\n   * Clears all appenders from the logger\r\n   */\r\n  public clearAppenders(): void {\r\n    this._appenders.length = 0;\r\n  }\r\n\r\n  /**\r\n   * Logs a message at a given LogLevel\r\n   * @param level  The LogLevel`to log the message at\r\n   * @param args   An array of arguments to write to an appender\r\n   */\r\n  private _log(level: LogLevel, args: any[]): void {\r\n    if (level == null) {\r\n      level = this.defaultLevel;\r\n    }\r\n\r\n    const len = this._appenders.length;\r\n\r\n    for (let i = 0; i < len; i++) {\r\n      if (level >= this.defaultLevel) {\r\n        this._appenders[i].log(level, args);\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Writes a log message at the [[LogLevel.Debug]] level\r\n   * @param args  Accepts any number of arguments\r\n   */\r\n  public debug(...args: any[]): void {\r\n    this._log(LogLevel.Debug, args);\r\n  }\r\n\r\n  /**\r\n   * Writes a log message at the [[LogLevel.Info]] level\r\n   * @param args  Accepts any number of arguments\r\n   */\r\n  public info(...args: any[]): void {\r\n    this._log(LogLevel.Info, args);\r\n  }\r\n\r\n  /**\r\n   * Writes a log message at the [[LogLevel.Warn]] level\r\n   * @param args  Accepts any number of arguments\r\n   */\r\n  public warn(...args: any[]): void {\r\n    this._log(LogLevel.Warn, args);\r\n  }\r\n\r\n  /**\r\n   * Writes a log message at the [[LogLevel.Error]] level\r\n   * @param args  Accepts any number of arguments\r\n   */\r\n  public error(...args: any[]): void {\r\n    this._log(LogLevel.Error, args);\r\n  }\r\n\r\n  /**\r\n   * Writes a log message at the [[LogLevel.Fatal]] level\r\n   * @param args  Accepts any number of arguments\r\n   */\r\n  public fatal(...args: any[]): void {\r\n    this._log(LogLevel.Fatal, args);\r\n  }\r\n}\r\n\r\n/**\r\n * Contract for any log appender (such as console/screen)\r\n */\r\nexport interface Appender {\r\n  /**\r\n   * Logs a message at the given [[LogLevel]]\r\n   * @param level  Level to log at\r\n   * @param args   Arguments to log\r\n   */\r\n  log(level: LogLevel, args: any[]): void;\r\n}\r\n\r\n/**\r\n * Console appender for browsers (i.e. `console.log`)\r\n */\r\nexport class ConsoleAppender implements Appender {\r\n  /**\r\n   * Logs a message at the given [[LogLevel]]\r\n   * @param level  Level to log at\r\n   * @param args   Arguments to log\r\n   */\r\n  public log(level: LogLevel, args: any[]): void {\r\n    // Check for console support\r\n    if (!console && !console.log && console.warn && console.error) {\r\n      // todo maybe do something better than nothing\r\n      return;\r\n    }\r\n\r\n    // Create a new console args array\r\n    const consoleArgs: any[] = [];\r\n    consoleArgs.unshift.apply(consoleArgs, args);\r\n    consoleArgs.unshift('[' + LogLevel[level] + '] : ');\r\n\r\n    if (level < LogLevel.Warn) {\r\n      // Call .log for Debug/Info\r\n      if (console.log.apply) {\r\n        // this is required on some older browsers that don't support apply on console.log :(\r\n        console.log.apply(console, consoleArgs);\r\n      } else {\r\n        console.log(consoleArgs.join(' '));\r\n      }\r\n    } else if (level < LogLevel.Error) {\r\n      // Call .warn for Warn\r\n      if (console.warn.apply) {\r\n        console.warn.apply(console, consoleArgs);\r\n      } else {\r\n        console.warn(consoleArgs.join(' '));\r\n      }\r\n    } else {\r\n      // Call .error for Error/Fatal\r\n      if (console.error.apply) {\r\n        console.error.apply(console, consoleArgs);\r\n      } else {\r\n        console.error(consoleArgs.join(' '));\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n * On-screen (canvas) appender\r\n */\r\nexport class ScreenAppender implements Appender {\r\n  // @todo Clean this up\r\n\r\n  private _messages: string[] = [];\r\n  private _canvas: HTMLCanvasElement;\r\n  private _ctx: CanvasRenderingContext2D;\r\n\r\n  /**\r\n   * @param width   Width of the screen appender in pixels\r\n   * @param height  Height of the screen appender in pixels\r\n   */\r\n  constructor(width?: number, height?: number) {\r\n    this._canvas = <HTMLCanvasElement>document.createElement('canvas');\r\n    this._canvas.width = width || window.innerWidth;\r\n    this._canvas.height = height || window.innerHeight;\r\n    this._canvas.style.position = 'absolute';\r\n    // eslint-disable-next-line\r\n    this._ctx = <CanvasRenderingContext2D>this._canvas.getContext('2d'); // eslint-disable-line\r\n    document.body.appendChild(this._canvas);\r\n  }\r\n\r\n  /**\r\n   * Logs a message at the given [[LogLevel]]\r\n   * @param level  Level to log at\r\n   * @param args   Arguments to log\r\n   */\r\n  public log(level: LogLevel, args: any[]): void {\r\n    const message = args.join(',');\r\n\r\n    this._ctx.clearRect(0, 0, this._canvas.width, this._canvas.height);\r\n\r\n    this._messages.unshift('[' + LogLevel[level] + '] : ' + message);\r\n\r\n    let pos = 10;\r\n    let opacity = 1.0;\r\n    for (let i = 0; i < this._messages.length; i++) {\r\n      this._ctx.fillStyle = 'rgba(255,255,255,' + opacity.toFixed(2) + ')';\r\n      this._ctx.fillText(this._messages[i], 200, pos);\r\n      pos += 10;\r\n      opacity = opacity > 0 ? opacity - 0.05 : 0;\r\n    }\r\n  }\r\n}\r\n","import { Vector } from '../Math/vector';\r\n\r\n/**\r\n * An enum that describes the sides of an axis aligned box for collision\r\n */\r\nexport enum Side {\r\n  None = 'None',\r\n  Top = 'Top',\r\n  Bottom = 'Bottom',\r\n  Left = 'Left',\r\n  Right = 'Right'\r\n}\r\n\r\nexport module Side {\r\n  /**\r\n   * Returns the opposite side from the current\r\n   */\r\n  export function getOpposite(side: Side): Side {\r\n    if (side === Side.Top) {\r\n      return Side.Bottom;\r\n    }\r\n    if (side === Side.Bottom) {\r\n      return Side.Top;\r\n    }\r\n    if (side === Side.Left) {\r\n      return Side.Right;\r\n    }\r\n    if (side === Side.Right) {\r\n      return Side.Left;\r\n    }\r\n\r\n    return Side.None;\r\n  }\r\n\r\n  /**\r\n   * Given a vector, return the Side most in that direction (via dot product)\r\n   */\r\n  export function fromDirection(direction: Vector): Side {\r\n    const directions = [Vector.Left, Vector.Right, Vector.Up, Vector.Down];\r\n    const directionEnum = [Side.Left, Side.Right, Side.Top, Side.Bottom];\r\n\r\n    let max = -Number.MAX_VALUE;\r\n    let maxIndex = -1;\r\n    for (let i = 0; i < directions.length; i++) {\r\n      if (directions[i].dot(direction) > max) {\r\n        max = directions[i].dot(direction);\r\n        maxIndex = i;\r\n      }\r\n    }\r\n    return directionEnum[maxIndex];\r\n  }\r\n}\r\n","import { vec, Vector } from '../Math/vector';\r\nimport { Ray } from '../Math/ray';\r\nimport { Color } from '../Color';\r\nimport { Side } from './Side';\r\nimport { ExcaliburGraphicsContext } from '../Graphics/Context/ExcaliburGraphicsContext';\r\nimport { Matrix } from '../Math/matrix';\r\n\r\nexport interface BoundingBoxOptions {\r\n  left: number;\r\n  right: number;\r\n  top: number;\r\n  bottom: number;\r\n}\r\n\r\n/**\r\n * Axis Aligned collision primitive for Excalibur.\r\n */\r\nexport class BoundingBox {\r\n  public top: number;\r\n  public right: number;\r\n  public bottom: number;\r\n  public left: number;\r\n\r\n  /**\r\n   * Constructor allows passing of either an object with all coordinate components,\r\n   * or the coordinate components passed separately.\r\n   * @param leftOrOptions    Either x coordinate of the left edge or an options object\r\n   * containing the four coordinate components.\r\n   * @param top     y coordinate of the top edge\r\n   * @param right   x coordinate of the right edge\r\n   * @param bottom  y coordinate of the bottom edge\r\n   */\r\n  constructor(leftOrOptions: number | BoundingBoxOptions = 0, top: number = 0, right: number = 0, bottom: number = 0) {\r\n    if (typeof leftOrOptions === 'object') {\r\n      this.left = leftOrOptions.left;\r\n      this.top = leftOrOptions.top;\r\n      this.right = leftOrOptions.right;\r\n      this.bottom = leftOrOptions.bottom;\r\n    } else if (typeof leftOrOptions === 'number') {\r\n      this.left = leftOrOptions;\r\n      this.top = top;\r\n      this.right = right;\r\n      this.bottom = bottom;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Returns a new instance of [[BoundingBox]] that is a copy of the current instance\r\n   */\r\n  public clone(): BoundingBox {\r\n    return new BoundingBox(this.left, this.top, this.right, this.bottom);\r\n  }\r\n\r\n  /**\r\n   * Given bounding box A & B, returns the side relative to A when intersection is performed.\r\n   * @param intersection Intersection vector between 2 bounding boxes\r\n   */\r\n  public static getSideFromIntersection(intersection: Vector): Side {\r\n    if (!intersection) {\r\n      return Side.None;\r\n    }\r\n    if (intersection) {\r\n      if (Math.abs(intersection.x) > Math.abs(intersection.y)) {\r\n        if (intersection.x < 0) {\r\n          return Side.Right;\r\n        }\r\n        return Side.Left;\r\n      } else {\r\n        if (intersection.y < 0) {\r\n          return Side.Bottom;\r\n        }\r\n        return Side.Top;\r\n      }\r\n    }\r\n    return Side.None;\r\n  }\r\n\r\n  public static fromPoints(points: Vector[]): BoundingBox {\r\n    let minX = Infinity;\r\n    let minY = Infinity;\r\n    let maxX = -Infinity;\r\n    let maxY = -Infinity;\r\n    for (let i = 0; i < points.length; i++) {\r\n      if (points[i].x < minX) {\r\n        minX = points[i].x;\r\n      }\r\n      if (points[i].x > maxX) {\r\n        maxX = points[i].x;\r\n      }\r\n      if (points[i].y < minY) {\r\n        minY = points[i].y;\r\n      }\r\n      if (points[i].y > maxY) {\r\n        maxY = points[i].y;\r\n      }\r\n    }\r\n    return new BoundingBox(minX, minY, maxX, maxY);\r\n  }\r\n\r\n  public static fromDimension(width: number, height: number, anchor: Vector = Vector.Half, pos: Vector = Vector.Zero) {\r\n    return new BoundingBox(\r\n      -width * anchor.x + pos.x,\r\n      -height * anchor.y + pos.y,\r\n      width - width * anchor.x + pos.x,\r\n      height - height * anchor.y + pos.y\r\n    );\r\n  }\r\n\r\n  /**\r\n   * Returns the calculated width of the bounding box\r\n   */\r\n  public get width() {\r\n    return this.right - this.left;\r\n  }\r\n\r\n  /**\r\n   * Returns the calculated height of the bounding box\r\n   */\r\n  public get height() {\r\n    return this.bottom - this.top;\r\n  }\r\n\r\n  /**\r\n   * Return whether the bounding box has zero dimensions in height,width or both\r\n   */\r\n  public hasZeroDimensions() {\r\n    return this.width === 0 || this.height === 0;\r\n  }\r\n\r\n  /**\r\n   * Returns the center of the bounding box\r\n   */\r\n  public get center(): Vector {\r\n    return new Vector((this.left + this.right) / 2, (this.top + this.bottom) / 2);\r\n  }\r\n\r\n  public translate(pos: Vector): BoundingBox {\r\n    return new BoundingBox(this.left + pos.x, this.top + pos.y, this.right + pos.x, this.bottom + pos.y);\r\n  }\r\n\r\n  /**\r\n   * Rotates a bounding box by and angle and around a point, if no point is specified (0, 0) is used by default. The resulting bounding\r\n   * box is also axis-align. This is useful when a new axis-aligned bounding box is needed for rotated geometry.\r\n   */\r\n  public rotate(angle: number, point: Vector = Vector.Zero): BoundingBox {\r\n    const points = this.getPoints().map((p) => p.rotate(angle, point));\r\n    return BoundingBox.fromPoints(points);\r\n  }\r\n\r\n  /**\r\n   * Scale a bounding box by a scale factor, optionally provide a point\r\n   * @param scale\r\n   * @param point\r\n   */\r\n  public scale(scale: Vector, point: Vector = Vector.Zero): BoundingBox {\r\n    const shifted = this.translate(point);\r\n    return new BoundingBox(shifted.left * scale.x, shifted.top * scale.y, shifted.right * scale.x, shifted.bottom * scale.y);\r\n  }\r\n\r\n  /**\r\n   * Transform the axis aligned bounding box by a [[Matrix]], producing a new axis aligned bounding box\r\n   * @param matrix\r\n   */\r\n  public transform(matrix: Matrix) {\r\n    const matFirstColumn = vec(matrix.data[0], matrix.data[1]);\r\n    const xa = matFirstColumn.scale(this.left);\r\n    const xb = matFirstColumn.scale(this.right);\r\n\r\n    const matSecondColumn = vec(matrix.data[4], matrix.data[5]);\r\n    const ya = matSecondColumn.scale(this.top);\r\n    const yb = matSecondColumn.scale(this.bottom);\r\n\r\n    const matrixPos = matrix.getPosition();\r\n    const topLeft = Vector.min(xa, xb).add(Vector.min(ya, yb)).add(matrixPos);\r\n    const bottomRight = Vector.max(xa, xb).add(Vector.max(ya, yb)).add(matrixPos);\r\n\r\n    return new BoundingBox({\r\n      left: topLeft.x,\r\n      top: topLeft.y,\r\n      right: bottomRight.x,\r\n      bottom: bottomRight.y\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Returns the perimeter of the bounding box\r\n   */\r\n  public getPerimeter(): number {\r\n    const wx = this.width;\r\n    const wy = this.height;\r\n    return 2 * (wx + wy);\r\n  }\r\n\r\n  public getPoints(): Vector[] {\r\n    const results = [];\r\n    results.push(new Vector(this.left, this.top));\r\n    results.push(new Vector(this.right, this.top));\r\n    results.push(new Vector(this.right, this.bottom));\r\n    results.push(new Vector(this.left, this.bottom));\r\n    return results;\r\n  }\r\n\r\n  /**\r\n   * Determines whether a ray intersects with a bounding box\r\n   */\r\n  public rayCast(ray: Ray, farClipDistance = Infinity): boolean {\r\n    // algorithm from https://tavianator.com/fast-branchless-raybounding-box-intersections/\r\n    let tmin = -Infinity;\r\n    let tmax = +Infinity;\r\n\r\n    const xinv = ray.dir.x === 0 ? Number.MAX_VALUE : 1 / ray.dir.x;\r\n    const yinv = ray.dir.y === 0 ? Number.MAX_VALUE : 1 / ray.dir.y;\r\n\r\n    const tx1 = (this.left - ray.pos.x) * xinv;\r\n    const tx2 = (this.right - ray.pos.x) * xinv;\r\n    tmin = Math.min(tx1, tx2);\r\n    tmax = Math.max(tx1, tx2);\r\n\r\n    const ty1 = (this.top - ray.pos.y) * yinv;\r\n    const ty2 = (this.bottom - ray.pos.y) * yinv;\r\n    tmin = Math.max(tmin, Math.min(ty1, ty2));\r\n    tmax = Math.min(tmax, Math.max(ty1, ty2));\r\n\r\n    return tmax >= Math.max(0, tmin) && tmin < farClipDistance;\r\n  }\r\n\r\n  public rayCastTime(ray: Ray, farClipDistance = Infinity): number {\r\n    // algorithm from https://tavianator.com/fast-branchless-raybounding-box-intersections/\r\n    let tmin = -Infinity;\r\n    let tmax = +Infinity;\r\n\r\n    const xinv = ray.dir.x === 0 ? Number.MAX_VALUE : 1 / ray.dir.x;\r\n    const yinv = ray.dir.y === 0 ? Number.MAX_VALUE : 1 / ray.dir.y;\r\n\r\n    const tx1 = (this.left - ray.pos.x) * xinv;\r\n    const tx2 = (this.right - ray.pos.x) * xinv;\r\n    tmin = Math.min(tx1, tx2);\r\n    tmax = Math.max(tx1, tx2);\r\n\r\n    const ty1 = (this.top - ray.pos.y) * yinv;\r\n    const ty2 = (this.bottom - ray.pos.y) * yinv;\r\n    tmin = Math.max(tmin, Math.min(ty1, ty2));\r\n    tmax = Math.min(tmax, Math.max(ty1, ty2));\r\n\r\n    if (tmax >= Math.max(0, tmin) && tmin < farClipDistance) {\r\n      return tmin;\r\n    }\r\n    return -1;\r\n  }\r\n\r\n  /**\r\n   * Tests whether a point is contained within the bounding box\r\n   * @param p  The point to test\r\n   */\r\n  public contains(p: Vector): boolean;\r\n\r\n  /**\r\n   * Tests whether another bounding box is totally contained in this one\r\n   * @param bb  The bounding box to test\r\n   */\r\n  public contains(bb: BoundingBox): boolean;\r\n  public contains(val: any): boolean {\r\n    if (val instanceof Vector) {\r\n      return this.left <= val.x && this.top <= val.y && this.bottom >= val.y && this.right >= val.x;\r\n    } else if (val instanceof BoundingBox) {\r\n      if (this.left <= val.left && this.top <= val.top && val.bottom <= this.bottom && val.right <= this.right) {\r\n        return true;\r\n      }\r\n      return false;\r\n    }\r\n    return false;\r\n  }\r\n\r\n  /**\r\n   * Combines this bounding box and another together returning a new bounding box\r\n   * @param other  The bounding box to combine\r\n   */\r\n  public combine(other: BoundingBox): BoundingBox {\r\n    const compositeBB = new BoundingBox(\r\n      Math.min(this.left, other.left),\r\n      Math.min(this.top, other.top),\r\n      Math.max(this.right, other.right),\r\n      Math.max(this.bottom, other.bottom)\r\n    );\r\n    return compositeBB;\r\n  }\r\n\r\n  public get dimensions(): Vector {\r\n    return new Vector(this.width, this.height);\r\n  }\r\n\r\n  /**\r\n   * Returns true if the bounding boxes overlap.\r\n   * @param other\r\n   */\r\n  public overlaps(other: BoundingBox): boolean {\r\n    if (other.hasZeroDimensions()){\r\n      return this.contains(other);\r\n    }\r\n    if (this.hasZeroDimensions()) {\r\n      return other.contains(this);\r\n    }\r\n    const totalBoundingBox = this.combine(other);\r\n    return totalBoundingBox.width < other.width + this.width &&\r\n           totalBoundingBox.height < other.height + this.height;\r\n  }\r\n\r\n  /**\r\n   * Test wether this bounding box intersects with another returning\r\n   * the intersection vector that can be used to resolve the collision. If there\r\n   * is no intersection null is returned.\r\n   *\r\n   * @param other  Other [[BoundingBox]] to test intersection with\r\n   * @returns A Vector in the direction of the current BoundingBox, this <- other\r\n   */\r\n  public intersect(other: BoundingBox): Vector {\r\n    const totalBoundingBox = this.combine(other);\r\n\r\n    // If the total bounding box is less than or equal the sum of the 2 bounds then there is collision\r\n    if (\r\n      totalBoundingBox.width < other.width + this.width &&\r\n      totalBoundingBox.height < other.height + this.height &&\r\n      !totalBoundingBox.dimensions.equals(other.dimensions) &&\r\n      !totalBoundingBox.dimensions.equals(this.dimensions)\r\n    ) {\r\n      // collision\r\n      let overlapX = 0;\r\n      // right edge is between the other's left and right edge\r\n      /**\r\n       *     +-this-+\r\n       *     |      |\r\n       *     |    +-other-+\r\n       *     +----|-+     |\r\n       *          |       |\r\n       *          +-------+\r\n       *         <---\r\n       *          ^ overlap\r\n       */\r\n      if (this.right >= other.left && this.right <= other.right) {\r\n        overlapX = other.left - this.right;\r\n        // right edge is past the other's right edge\r\n        /**\r\n         *     +-other-+\r\n         *     |       |\r\n         *     |    +-this-+\r\n         *     +----|--+   |\r\n         *          |      |\r\n         *          +------+\r\n         *          --->\r\n         *          ^ overlap\r\n         */\r\n      } else {\r\n        overlapX = other.right - this.left;\r\n      }\r\n\r\n      let overlapY = 0;\r\n      // top edge is between the other's top and bottom edge\r\n      /**\r\n       *     +-other-+\r\n       *     |       |\r\n       *     |    +-this-+   | <- overlap\r\n       *     +----|--+   |   |\r\n       *          |      |  \\ /\r\n       *          +------+   '\r\n       */\r\n      if (this.top <= other.bottom && this.top >= other.top) {\r\n        overlapY = other.bottom - this.top;\r\n        // top edge is above the other top edge\r\n        /**\r\n         *     +-this-+         .\r\n         *     |      |        / \\\r\n         *     |    +-other-+   | <- overlap\r\n         *     +----|-+     |   |\r\n         *          |       |\r\n         *          +-------+\r\n         */\r\n      } else {\r\n        overlapY = other.top - this.bottom;\r\n      }\r\n\r\n      if (Math.abs(overlapX) < Math.abs(overlapY)) {\r\n        return new Vector(overlapX, 0);\r\n      } else {\r\n        return new Vector(0, overlapY);\r\n      }\r\n      // Case of total containment of one bounding box by another\r\n    } else if (totalBoundingBox.dimensions.equals(other.dimensions) || totalBoundingBox.dimensions.equals(this.dimensions)) {\r\n      let overlapX = 0;\r\n      // this is wider than the other\r\n      if (this.width - other.width >= 0) {\r\n        // This right edge is closest to the others right edge\r\n        if (this.right - other.right <= other.left - this.left) {\r\n          overlapX = other.left - this.right;\r\n          // This left edge is closest to the others left edge\r\n        } else {\r\n          overlapX = other.right - this.left;\r\n        }\r\n        // other is wider than this\r\n      } else {\r\n        // This right edge is closest to the others right edge\r\n        if (other.right - this.right <= this.left - other.left) {\r\n          overlapX = this.left - other.right;\r\n          // This left edge is closest to the others left edge\r\n        } else {\r\n          overlapX = this.right - other.left;\r\n        }\r\n      }\r\n\r\n      let overlapY = 0;\r\n      // this is taller than other\r\n      if (this.height - other.height >= 0) {\r\n        // The bottom edge is closest to the others bottom edge\r\n        if (this.bottom - other.bottom <= other.top - this.top) {\r\n          overlapY = other.top - this.bottom;\r\n        } else {\r\n          overlapY = other.bottom - this.top;\r\n        }\r\n        // other is taller than this\r\n      } else {\r\n        // The bottom edge is closest to the others bottom edge\r\n        if (other.bottom - this.bottom <= this.top - other.top) {\r\n          overlapY = this.top - other.bottom;\r\n        } else {\r\n          overlapY = this.bottom - other.top;\r\n        }\r\n      }\r\n\r\n      if (Math.abs(overlapX) < Math.abs(overlapY)) {\r\n        return new Vector(overlapX, 0);\r\n      } else {\r\n        return new Vector(0, overlapY);\r\n      }\r\n    } else {\r\n      return null;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Test whether the bounding box has intersected with another bounding box, returns the side of the current bb that intersected.\r\n   * @param bb The other actor to test\r\n   */\r\n  public intersectWithSide(bb: BoundingBox): Side {\r\n    const intersect = this.intersect(bb);\r\n    return BoundingBox.getSideFromIntersection(intersect);\r\n  }\r\n\r\n  /**\r\n   * Draw a debug bounding box\r\n   * @param ex\r\n   * @param color\r\n   */\r\n  public draw(ex: ExcaliburGraphicsContext, color: Color = Color.Yellow) {\r\n    ex.debug.drawRect(this.left, this.top, this.width, this.height, { color });\r\n  }\r\n}\r\n","import { Vector } from '../Math/vector';\r\nimport { Clock } from './Clock';\r\n\r\n/**\r\n * Find the screen position of an HTML element\r\n */\r\nexport function getPosition(el: HTMLElement): Vector {\r\n  let oLeft: number = 0,\r\n    oTop: number = 0;\r\n\r\n  const calcOffsetLeft = (parent: HTMLElement) => {\r\n    oLeft += parent.offsetLeft;\r\n\r\n    if (parent.offsetParent) {\r\n      calcOffsetLeft(<HTMLElement>parent.offsetParent);\r\n    }\r\n  };\r\n  const calcOffsetTop = (parent: HTMLElement) => {\r\n    oTop += parent.offsetTop;\r\n    if (parent.offsetParent) {\r\n      calcOffsetTop(<HTMLElement>parent.offsetParent);\r\n    }\r\n  };\r\n\r\n  calcOffsetLeft(el);\r\n  calcOffsetTop(el);\r\n\r\n  return new Vector(oLeft, oTop);\r\n}\r\n\r\n/**\r\n * Add an item to an array list if it doesn't already exist. Returns true if added, false if not and already exists in the array.\r\n * @deprecated Will be removed in v0.26.0\r\n */\r\nexport function addItemToArray<T>(item: T, array: T[]): boolean {\r\n  if (array.indexOf(item) === -1) {\r\n    array.push(item);\r\n    return true;\r\n  }\r\n  return false;\r\n}\r\n\r\n/**\r\n * Remove an item from an list\r\n * @deprecated Will be removed in v0.26.0\r\n */\r\nexport function removeItemFromArray<T>(item: T, array: T[]): boolean {\r\n  let index = -1;\r\n  if ((index = array.indexOf(item)) > -1) {\r\n    array.splice(index, 1);\r\n    return true;\r\n  }\r\n\r\n  return false;\r\n}\r\n\r\n/**\r\n * See if an array contains something\r\n */\r\nexport function contains(array: Array<any>, obj: any): boolean {\r\n  for (let i = 0; i < array.length; i++) {\r\n    if (array[i] === obj) {\r\n      return true;\r\n    }\r\n  }\r\n  return false;\r\n}\r\n\r\n/**\r\n * Used for exhaustive checks at compile time\r\n */\r\nexport function fail(message: never): never {\r\n  throw new Error(message);\r\n}\r\n\r\n/**\r\n * Create a promise that resolves after a certain number of milliseconds\r\n *\r\n * It is strongly recommended you pass the excalibur clock so delays are bound to the\r\n * excalibur clock which would be unaffected by stop/pause.\r\n * @param milliseconds\r\n * @param clock\r\n */\r\nexport function delay(milliseconds: number, clock?: Clock): Promise<void> {\r\n  const schedule = clock?.schedule.bind(clock) ?? setTimeout;\r\n  return new Promise<void>(resolve => {\r\n    schedule(() => {\r\n      resolve();\r\n    }, milliseconds);\r\n  });\r\n}\r\n","import { Random } from './Random';\r\n\r\n/**\r\n * Two PI constant\r\n */\r\nexport const TwoPI: number = Math.PI * 2;\r\n\r\n/**\r\n * Returns the fractional part of a number\r\n * @param x\r\n */\r\nexport function frac(x: number): number {\r\n  if (x >= 0) {\r\n    return x - Math.floor(x);\r\n  } else {\r\n    return x - Math.ceil(x);\r\n  }\r\n}\r\n\r\n/**\r\n * Returns the sign of a number, if 0 returns 0\r\n */\r\nexport function sign(val: number): number {\r\n  if (val === 0) {\r\n    return 0;\r\n  }\r\n  return val < 0 ? -1 : 1;\r\n};\r\n\r\n/**\r\n * Clamps a value between a min and max inclusive\r\n */\r\nexport function clamp(val: number, min: number, max: number) {\r\n  return Math.min(Math.max(min, val), max);\r\n}\r\n\r\n\r\n/**\r\n * Convert an angle to be the equivalent in the range [0, 2PI]\r\n */\r\nexport function canonicalizeAngle(angle: number): number {\r\n  let tmpAngle = angle;\r\n  if (angle > TwoPI) {\r\n    while (tmpAngle > TwoPI) {\r\n      tmpAngle -= TwoPI;\r\n    }\r\n  }\r\n\r\n  if (angle < 0) {\r\n    while (tmpAngle < 0) {\r\n      tmpAngle += TwoPI;\r\n    }\r\n  }\r\n  return tmpAngle;\r\n}\r\n\r\n/**\r\n * Convert radians to degrees\r\n */\r\nexport function toDegrees(radians: number): number {\r\n  return (180 / Math.PI) * radians;\r\n}\r\n\r\n/**\r\n * Convert degrees to radians\r\n */\r\nexport function toRadians(degrees: number): number {\r\n  return (degrees / 180) * Math.PI;\r\n}\r\n\r\n/**\r\n * Generate a range of numbers\r\n * For example: range(0, 5) -> [0, 1, 2, 3, 4, 5]\r\n * @param from inclusive\r\n * @param to inclusive\r\n */\r\nexport const range = (from: number, to: number) => Array.from(new Array(to - from + 1), (_x, i) => i + from);\r\n\r\n/**\r\n * Find a random floating point number in range\r\n */\r\nexport function randomInRange(min: number, max: number, random: Random = new Random()): number {\r\n  return random ? random.floating(min, max) : min + Math.random() * (max - min);\r\n}\r\n\r\n/**\r\n * Find a random integer in a range\r\n */\r\nexport function randomIntInRange(min: number, max: number, random: Random = new Random()): number {\r\n  return random ? random.integer(min, max) : Math.round(randomInRange(min, max));\r\n}","import { sign } from './util';\r\nimport { Vector, vec } from './vector';\r\nimport { canonicalizeAngle } from './util';\r\n\r\nexport enum MatrixLocations {\r\n  X = 12,\r\n  Y = 13\r\n}\r\n\r\n/**\r\n * Excalibur Matrix helper for 4x4 matrices\r\n *\r\n * Useful for webgl 4x4 matrices\r\n */\r\nexport class Matrix {\r\n  /**\r\n   *  4x4 matrix in column major order\r\n   *\r\n   * |         |         |          |          |\r\n   * | ------- | ------- | -------- |          |\r\n   * | data[0] | data[4] | data[8]  | data[12] |\r\n   * | data[1] | data[5] | data[9]  | data[13] |\r\n   * | data[2] | data[6] | data[10] | data[14] |\r\n   * | data[3] | data[7] | data[11] | data[15] |\r\n   *\r\n   */\r\n  public data: Float32Array = new Float32Array(16);\r\n\r\n  /**\r\n   * Creates an orthographic (flat non-perspective) projection\r\n   * https://en.wikipedia.org/wiki/Orthographic_projection\r\n   * @param left\r\n   * @param right\r\n   * @param bottom\r\n   * @param top\r\n   * @param near\r\n   * @param far\r\n   */\r\n  public static ortho(left: number, right: number, bottom: number, top: number, near: number, far: number): Matrix {\r\n    const mat = new Matrix();\r\n    mat.data[0] = 2 / (right - left);\r\n    mat.data[1] = 0;\r\n    mat.data[2] = 0;\r\n    mat.data[3] = 0;\r\n\r\n    mat.data[4] = 0;\r\n    mat.data[5] = 2 / (top - bottom);\r\n    mat.data[6] = 0;\r\n    mat.data[7] = 0;\r\n\r\n    mat.data[8] = 0;\r\n    mat.data[9] = 0;\r\n    mat.data[10] = -2 / (far - near);\r\n    mat.data[11] = 0;\r\n\r\n    mat.data[12] = -(right + left) / (right - left);\r\n    mat.data[13] = -(top + bottom) / (top - bottom);\r\n    mat.data[14] = -(far + near) / (far - near);\r\n    mat.data[15] = 1;\r\n    return mat;\r\n  }\r\n\r\n  /**\r\n   * Creates a new Matrix with the same data as the current 4x4\r\n   */\r\n  public clone(dest?: Matrix): Matrix {\r\n    const mat = dest || new Matrix();\r\n    mat.data[0] = this.data[0];\r\n    mat.data[1] = this.data[1];\r\n    mat.data[2] = this.data[2];\r\n    mat.data[3] = this.data[3];\r\n\r\n    mat.data[4] = this.data[4];\r\n    mat.data[5] = this.data[5];\r\n    mat.data[6] = this.data[6];\r\n    mat.data[7] = this.data[7];\r\n\r\n    mat.data[8] = this.data[8];\r\n    mat.data[9] = this.data[9];\r\n    mat.data[10] = this.data[10];\r\n    mat.data[11] = this.data[11];\r\n\r\n    mat.data[12] = this.data[12];\r\n    mat.data[13] = this.data[13];\r\n    mat.data[14] = this.data[14];\r\n    mat.data[15] = this.data[15];\r\n    return mat;\r\n  }\r\n\r\n  /**\r\n   * Converts the current matrix into a DOMMatrix\r\n   *\r\n   * This is useful when working with the browser Canvas context\r\n   * @returns {DOMMatrix} DOMMatrix\r\n   */\r\n  public toDOMMatrix(): DOMMatrix {\r\n    return new DOMMatrix([...this.data]);\r\n  }\r\n\r\n  /**\r\n   * Creates a new identity matrix (a matrix that when applied does nothing)\r\n   */\r\n  public static identity(): Matrix {\r\n    const mat = new Matrix();\r\n    mat.data[0] = 1;\r\n    mat.data[1] = 0;\r\n    mat.data[2] = 0;\r\n    mat.data[3] = 0;\r\n\r\n    mat.data[4] = 0;\r\n    mat.data[5] = 1;\r\n    mat.data[6] = 0;\r\n    mat.data[7] = 0;\r\n\r\n    mat.data[8] = 0;\r\n    mat.data[9] = 0;\r\n    mat.data[10] = 1;\r\n    mat.data[11] = 0;\r\n\r\n    mat.data[12] = 0;\r\n    mat.data[13] = 0;\r\n    mat.data[14] = 0;\r\n    mat.data[15] = 1;\r\n    return mat;\r\n  }\r\n\r\n  /**\r\n   * Resets the current matrix to the identity matrix, mutating it\r\n   * @returns {Matrix} Current matrix as identity\r\n   */\r\n  public reset(): Matrix {\r\n    const mat = this;\r\n    mat.data[0] = 1;\r\n    mat.data[1] = 0;\r\n    mat.data[2] = 0;\r\n    mat.data[3] = 0;\r\n\r\n    mat.data[4] = 0;\r\n    mat.data[5] = 1;\r\n    mat.data[6] = 0;\r\n    mat.data[7] = 0;\r\n\r\n    mat.data[8] = 0;\r\n    mat.data[9] = 0;\r\n    mat.data[10] = 1;\r\n    mat.data[11] = 0;\r\n\r\n    mat.data[12] = 0;\r\n    mat.data[13] = 0;\r\n    mat.data[14] = 0;\r\n    mat.data[15] = 1;\r\n    return mat;\r\n  }\r\n\r\n  /**\r\n   * Creates a brand new translation matrix at the specified 3d point\r\n   * @param x\r\n   * @param y\r\n   */\r\n  public static translation(x: number, y: number): Matrix {\r\n    const mat = Matrix.identity();\r\n    mat.data[12] = x;\r\n    mat.data[13] = y;\r\n    return mat;\r\n  }\r\n\r\n  /**\r\n   * Creates a brand new scaling matrix with the specified scaling factor\r\n   * @param sx\r\n   * @param sy\r\n   */\r\n  public static scale(sx: number, sy: number): Matrix {\r\n    const mat = Matrix.identity();\r\n    mat.data[0] = sx;\r\n    mat.data[5] = sy;\r\n    mat.data[10] = 1;\r\n    mat.data[15] = 1;\r\n    return mat;\r\n  }\r\n\r\n  /**\r\n   * Creates a brand new rotation matrix with the specified angle\r\n   * @param angleRadians\r\n   */\r\n  public static rotation(angleRadians: number): Matrix {\r\n    const mat = Matrix.identity();\r\n    mat.data[0] = Math.cos(angleRadians);\r\n    mat.data[4] = -Math.sin(angleRadians);\r\n    mat.data[1] = Math.sin(angleRadians);\r\n    mat.data[5] = Math.cos(angleRadians);\r\n    return mat;\r\n  }\r\n\r\n  /**\r\n   * Multiply the current matrix by a vector producing a new vector\r\n   * @param vector\r\n   * @param dest\r\n   */\r\n  multiply(vector: Vector, dest?: Vector): Vector;\r\n  /**\r\n   * Multiply the current matrix by another matrix producing a new matrix\r\n   * @param matrix\r\n   * @param dest\r\n   */\r\n  multiply(matrix: Matrix, dest?: Matrix): Matrix;\r\n  multiply(vectorOrMatrix: Vector | Matrix, dest?: Vector | Matrix): Vector | Matrix {\r\n    if (vectorOrMatrix instanceof Vector) {\r\n      const result = (dest as Vector) || new Vector(0, 0);\r\n      const vector = vectorOrMatrix;\r\n      // these shenanigans are to allow dest and vector to be the same instance\r\n      const resultX = vector.x * this.data[0] + vector.y * this.data[4] + this.data[12];\r\n      const resultY = vector.x * this.data[1] + vector.y * this.data[5] + this.data[13];\r\n\r\n      result.x = resultX;\r\n      result.y = resultY;\r\n      return result;\r\n    } else {\r\n      const result = (dest as Matrix) || new Matrix();\r\n      const other = vectorOrMatrix;\r\n      const a11 = this.data[0];\r\n      const a21 = this.data[1];\r\n      const a31 = this.data[2];\r\n      const a41 = this.data[3];\r\n\r\n      const a12 = this.data[4];\r\n      const a22 = this.data[5];\r\n      const a32 = this.data[6];\r\n      const a42 = this.data[7];\r\n\r\n      const a13 = this.data[8];\r\n      const a23 = this.data[9];\r\n      const a33 = this.data[10];\r\n      const a43 = this.data[11];\r\n\r\n      const a14 = this.data[12];\r\n      const a24 = this.data[13];\r\n      const a34 = this.data[14];\r\n      const a44 = this.data[15];\r\n\r\n      const b11 = other.data[0];\r\n      const b21 = other.data[1];\r\n      const b31 = other.data[2];\r\n      const b41 = other.data[3];\r\n\r\n      const b12 = other.data[4];\r\n      const b22 = other.data[5];\r\n      const b32 = other.data[6];\r\n      const b42 = other.data[7];\r\n\r\n      const b13 = other.data[8];\r\n      const b23 = other.data[9];\r\n      const b33 = other.data[10];\r\n      const b43 = other.data[11];\r\n\r\n      const b14 = other.data[12];\r\n      const b24 = other.data[13];\r\n      const b34 = other.data[14];\r\n      const b44 = other.data[15];\r\n\r\n      result.data[0] = a11 * b11 + a12 * b21 + a13 * b31 + a14 * b41;\r\n      result.data[1] = a21 * b11 + a22 * b21 + a23 * b31 + a24 * b41;\r\n      result.data[2] = a31 * b11 + a32 * b21 + a33 * b31 + a34 * b41;\r\n      result.data[3] = a41 * b11 + a42 * b21 + a43 * b31 + a44 * b41;\r\n\r\n      result.data[4] = a11 * b12 + a12 * b22 + a13 * b32 + a14 * b42;\r\n      result.data[5] = a21 * b12 + a22 * b22 + a23 * b32 + a24 * b42;\r\n      result.data[6] = a31 * b12 + a32 * b22 + a33 * b32 + a34 * b42;\r\n      result.data[7] = a41 * b12 + a42 * b22 + a43 * b32 + a44 * b42;\r\n\r\n      result.data[8] = a11 * b13 + a12 * b23 + a13 * b33 + a14 * b43;\r\n      result.data[9] = a21 * b13 + a22 * b23 + a23 * b33 + a24 * b43;\r\n      result.data[10] = a31 * b13 + a32 * b23 + a33 * b33 + a34 * b43;\r\n      result.data[11] = a41 * b13 + a42 * b23 + a43 * b33 + a44 * b43;\r\n\r\n      result.data[12] = a11 * b14 + a12 * b24 + a13 * b34 + a14 * b44;\r\n      result.data[13] = a21 * b14 + a22 * b24 + a23 * b34 + a24 * b44;\r\n      result.data[14] = a31 * b14 + a32 * b24 + a33 * b34 + a34 * b44;\r\n      result.data[15] = a41 * b14 + a42 * b24 + a43 * b34 + a44 * b44;\r\n\r\n      const s = this.getScale();\r\n      result._scaleSignX = sign(s.x) * sign(result._scaleSignX);\r\n      result._scaleSignY = sign(s.y) * sign(result._scaleSignY);\r\n\r\n      return result;\r\n    }\r\n  }\r\n\r\n\r\n  /**\r\n   * Applies translation to the current matrix mutating it\r\n   * @param x\r\n   * @param y\r\n   */\r\n  translate(x: number, y: number) {\r\n    const a11 = this.data[0];\r\n    const a21 = this.data[1];\r\n    const a31 = this.data[2];\r\n    const a41 = this.data[3];\r\n\r\n    const a12 = this.data[4];\r\n    const a22 = this.data[5];\r\n    const a32 = this.data[6];\r\n    const a42 = this.data[7];\r\n\r\n    const a13 = this.data[8];\r\n    const a23 = this.data[9];\r\n    const a33 = this.data[10];\r\n    const a43 = this.data[11];\r\n\r\n    const a14 = this.data[12];\r\n    const a24 = this.data[13];\r\n    const a34 = this.data[14];\r\n    const a44 = this.data[15];\r\n\r\n    // Doesn't change z\r\n    const z = 0;\r\n    const w = 1;\r\n    this.data[12] = a11 * x + a12 * y + a13 * z + a14 * w;\r\n    this.data[13] = a21 * x + a22 * y + a23 * z + a24 * w;\r\n    this.data[14] = a31 * x + a32 * y + a33 * z + a34 * w;\r\n    this.data[15] = a41 * x + a42 * y + a43 * z + a44 * w;\r\n\r\n    return this;\r\n  }\r\n\r\n  public setPosition(x: number, y: number) {\r\n    this.data[12] = x;\r\n    this.data[13] = y;\r\n  }\r\n\r\n  public getPosition(): Vector {\r\n    return vec(this.data[12], this.data[13]);\r\n  }\r\n\r\n  /**\r\n   * Applies rotation to the current matrix mutating it\r\n   * @param angle in Radians\r\n   */\r\n  rotate(angle: number) {\r\n    const a11 = this.data[0];\r\n    const a21 = this.data[1];\r\n    const a31 = this.data[2];\r\n    const a41 = this.data[3];\r\n\r\n    const a12 = this.data[4];\r\n    const a22 = this.data[5];\r\n    const a32 = this.data[6];\r\n    const a42 = this.data[7];\r\n\r\n    const sine = Math.sin(angle);\r\n    const cosine = Math.cos(angle);\r\n\r\n    this.data[0] = cosine * a11 + sine * a12;\r\n    this.data[1] = cosine * a21 + sine * a22;\r\n    this.data[2] = cosine * a31 + sine * a32;\r\n    this.data[3] = cosine * a41 + sine * a42;\r\n\r\n    this.data[4] = cosine * a12 - sine * a11;\r\n    this.data[5] = cosine * a22 - sine * a21;\r\n    this.data[6] = cosine * a32 - sine * a31;\r\n    this.data[7] = cosine * a42 - sine * a41;\r\n\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Applies scaling to the current matrix mutating it\r\n   * @param x\r\n   * @param y\r\n   */\r\n  scale(x: number, y: number) {\r\n    const a11 = this.data[0];\r\n    const a21 = this.data[1];\r\n    const a31 = this.data[2];\r\n    const a41 = this.data[3];\r\n\r\n    const a12 = this.data[4];\r\n    const a22 = this.data[5];\r\n    const a32 = this.data[6];\r\n    const a42 = this.data[7];\r\n\r\n    this.data[0] = a11 * x;\r\n    this.data[1] = a21 * x;\r\n    this.data[2] = a31 * x;\r\n    this.data[3] = a41 * x;\r\n\r\n    this.data[4] = a12 * y;\r\n    this.data[5] = a22 * y;\r\n    this.data[6] = a32 * y;\r\n    this.data[7] = a42 * y;\r\n\r\n    return this;\r\n  }\r\n\r\n  public setRotation(angle: number) {\r\n    const currentScale = this.getScale();\r\n    const sine = Math.sin(angle);\r\n    const cosine = Math.cos(angle);\r\n\r\n    this.data[0] = cosine * currentScale.x;\r\n    this.data[1] = sine * currentScale.y;\r\n    this.data[4] = -sine * currentScale.x;\r\n    this.data[5] = cosine * currentScale.y;\r\n  }\r\n\r\n  public getRotation(): number {\r\n    const angle = Math.atan2(this.data[1] / this.getScaleY(), this.data[0] / this.getScaleX());\r\n    return canonicalizeAngle(angle);\r\n  }\r\n\r\n  public getScaleX(): number {\r\n    // absolute scale of the matrix (we lose sign so need to add it back)\r\n    const xscale = vec(this.data[0], this.data[4]).size;\r\n    return this._scaleSignX * xscale;\r\n  }\r\n\r\n  public getScaleY(): number {\r\n    // absolute scale of the matrix (we lose sign so need to add it back)\r\n    const yscale = vec(this.data[1], this.data[5]).size;\r\n    return this._scaleSignY * yscale;\r\n  }\r\n\r\n  /**\r\n   * Get the scale of the matrix\r\n   */\r\n  public getScale(): Vector {\r\n    return vec(this.getScaleX(), this.getScaleY());\r\n  }\r\n\r\n  private _scaleSignX = 1;\r\n  public setScaleX(val: number) {\r\n    this._scaleSignX = sign(val);\r\n    // negative scale acts like a 180 rotation, so flip\r\n    const xscale = vec(this.data[0] * this._scaleSignX, this.data[4] * this._scaleSignX).normalize();\r\n    this.data[0] = xscale.x * val;\r\n    this.data[4] = xscale.y * val;\r\n  }\r\n\r\n  private _scaleSignY = 1;\r\n  public setScaleY(val: number) {\r\n    this._scaleSignY = sign(val);\r\n    // negative scale acts like a 180 rotation, so flip\r\n    const yscale = vec(this.data[1] * this._scaleSignY, this.data[5] * this._scaleSignY).normalize();\r\n    this.data[1] = yscale.x * val;\r\n    this.data[5] = yscale.y * val;\r\n  }\r\n\r\n  public setScale(scale: Vector) {\r\n    this.setScaleX(scale.x);\r\n    this.setScaleY(scale.y);\r\n  }\r\n\r\n  /**\r\n   * Determinant of the upper left 2x2 matrix\r\n   */\r\n  public getBasisDeterminant() {\r\n    return this.data[0] * this.data[5] - this.data[1] * this.data[4];\r\n  }\r\n\r\n  /**\r\n   * Return the affine inverse, optionally store it in a target matrix.\r\n   *\r\n   * It's recommended you call .reset() the target unless you know what you're doing\r\n   * @param target\r\n   */\r\n  public getAffineInverse(target?: Matrix): Matrix {\r\n    // See http://negativeprobability.blogspot.com/2011/11/affine-transformations-and-their.html\r\n    // See https://www.mathsisfun.com/algebra/matrix-inverse.html\r\n    // Since we are actually only doing 2D transformations we can use this hack\r\n    // We don't actually use the 3rd or 4th dimension\r\n\r\n    const det = this.getBasisDeterminant();\r\n    const inverseDet = 1 / det; // todo zero check\r\n    const a = this.data[0];\r\n    const b = this.data[4];\r\n    const c = this.data[1];\r\n    const d = this.data[5];\r\n\r\n    const m = target || Matrix.identity();\r\n    // inverts rotation and scale\r\n    m.data[0] = d * inverseDet;\r\n    m.data[1] = -c * inverseDet;\r\n    m.data[4] = -b * inverseDet;\r\n    m.data[5] = a * inverseDet;\r\n\r\n    const tx = this.data[12];\r\n    const ty = this.data[13];\r\n    // invert translation\r\n    // transform translation into the matrix basis created by rot/scale\r\n    m.data[12] = -(tx * m.data[0] + ty * m.data[4]);\r\n    m.data[13] = -(tx * m.data[1] + ty * m.data[5]);\r\n\r\n    return m;\r\n  }\r\n\r\n  public isIdentity(): boolean {\r\n    return (\r\n      this.data[0] === 1 &&\r\n      this.data[1] === 0 &&\r\n      this.data[2] === 0 &&\r\n      this.data[3] === 0 &&\r\n      this.data[4] === 0 &&\r\n      this.data[5] === 1 &&\r\n      this.data[6] === 0 &&\r\n      this.data[7] === 0 &&\r\n      this.data[8] === 0 &&\r\n      this.data[9] === 0 &&\r\n      this.data[10] === 1 &&\r\n      this.data[11] === 0 &&\r\n      this.data[12] === 0 &&\r\n      this.data[13] === 0 &&\r\n      this.data[14] === 0 &&\r\n      this.data[15] === 1\r\n    );\r\n  }\r\n\r\n  public toString() {\r\n    return `\r\n[${this.data[0]} ${this.data[4]} ${this.data[8]} ${this.data[12]}]\r\n[${this.data[1]} ${this.data[5]} ${this.data[9]} ${this.data[13]}]\r\n[${this.data[2]} ${this.data[6]} ${this.data[10]} ${this.data[14]}]\r\n[${this.data[3]} ${this.data[7]} ${this.data[11]} ${this.data[15]}]\r\n`;\r\n  }\r\n}\r\n","import { Matrix } from '../../Math/matrix';\r\n\r\nexport class TransformStack {\r\n  private _transforms: Matrix[] = [];\r\n  private _currentTransform: Matrix = Matrix.identity();\r\n\r\n  public save(): void {\r\n    this._transforms.push(this._currentTransform);\r\n    this._currentTransform = this._currentTransform.clone();\r\n  }\r\n\r\n  public restore(): void {\r\n    this._currentTransform = this._transforms.pop();\r\n  }\r\n\r\n  public translate(x: number, y: number): Matrix {\r\n    return this._currentTransform.translate(x, y);\r\n  }\r\n\r\n  public rotate(angle: number): Matrix {\r\n    return this._currentTransform.rotate(angle);\r\n  }\r\n\r\n  public scale(x: number, y: number): Matrix {\r\n    return this._currentTransform.scale(x, y);\r\n  }\r\n\r\n  public set current(matrix: Matrix) {\r\n    this._currentTransform = matrix;\r\n  }\r\n\r\n  public get current(): Matrix {\r\n    return this._currentTransform;\r\n  }\r\n}\r\n","import { ExcaliburGraphicsContextState } from './ExcaliburGraphicsContext';\r\n\r\nexport class StateStack {\r\n  private _states: ExcaliburGraphicsContextState[] = [];\r\n  private _currentState: ExcaliburGraphicsContextState = this._getDefaultState();\r\n\r\n  private _getDefaultState() {\r\n    return {\r\n      opacity: 1,\r\n      z: 0\r\n    };\r\n  }\r\n\r\n  private _cloneState() {\r\n    return {\r\n      opacity: this._currentState.opacity,\r\n      z: this._currentState.z\r\n    };\r\n  }\r\n\r\n  public save(): void {\r\n    this._states.push(this._currentState);\r\n    this._currentState = this._cloneState();\r\n  }\r\n\r\n  public restore(): void {\r\n    this._currentState = this._states.pop();\r\n  }\r\n\r\n  public get current(): ExcaliburGraphicsContextState {\r\n    return this._currentState;\r\n  }\r\n\r\n  public set current(val: ExcaliburGraphicsContextState) {\r\n    this._currentState = val;\r\n  }\r\n}\r\n","import { Scene } from './Scene';\r\nimport { Vector } from './Math/vector';\r\nimport { Actor } from './Actor';\r\nimport { Trigger } from './Trigger';\r\nimport { FrameStats } from './Debug';\r\nimport { Engine } from './Engine';\r\nimport { TileMap } from './TileMap';\r\nimport { Side } from './Collision/Side';\r\nimport * as Input from './Input/Index';\r\nimport { CollisionContact } from './Collision/Detection/CollisionContact';\r\nimport { Collider } from './Collision/Colliders/Collider';\r\nimport { Entity } from './EntityComponentSystem/Entity';\r\nimport { OnInitialize, OnPreUpdate, OnPostUpdate } from './Interfaces/LifecycleEvents';\r\nimport { BodyComponent } from './Collision/BodyComponent';\r\nimport { ExcaliburGraphicsContext } from './Graphics';\r\n\r\nexport enum EventTypes {\r\n  Kill = 'kill',\r\n  PreKill = 'prekill',\r\n  PostKill = 'postkill',\r\n\r\n  PreDraw = 'predraw',\r\n  PostDraw = 'postdraw',\r\n\r\n  PreDebugDraw = 'predebugdraw',\r\n  PostDebugDraw = 'postdebugdraw',\r\n\r\n  PreUpdate = 'preupdate',\r\n  PostUpdate = 'postupdate',\r\n\r\n  PreFrame = 'preframe',\r\n  PostFrame = 'postframe',\r\n\r\n  PreCollision = 'precollision',\r\n  CollisionStart = 'collisionstart',\r\n  CollisionEnd = 'collisionend',\r\n  PostCollision = 'postcollision',\r\n\r\n  Initialize = 'initialize',\r\n  Activate = 'activate',\r\n  Deactivate = 'deactivate',\r\n\r\n  ExitViewport = 'exitviewport',\r\n  EnterViewport = 'enterviewport',\r\n\r\n  ExitTrigger = 'exit',\r\n  EnterTrigger = 'enter',\r\n\r\n  Connect = 'connect',\r\n  Disconnect = 'disconnect',\r\n  Button = 'button',\r\n  Axis = 'axis',\r\n\r\n  Subscribe = 'subscribe',\r\n  Unsubscribe = 'unsubscribe',\r\n\r\n  Visible = 'visible',\r\n  Hidden = 'hidden',\r\n  Start = 'start',\r\n  Stop = 'stop',\r\n\r\n  PointerUp = 'pointerup',\r\n  PointerDown = 'pointerdown',\r\n  PointerMove = 'pointermove',\r\n  PointerEnter = 'pointerenter',\r\n  PointerLeave = 'pointerleave',\r\n  PointerCancel = 'pointercancel',\r\n  PointerWheel = 'pointerwheel',\r\n\r\n  Up = 'up',\r\n  Down = 'down',\r\n  Move = 'move',\r\n  Enter = 'enter',\r\n  Leave = 'leave',\r\n  Cancel = 'cancel',\r\n  Wheel = 'wheel',\r\n\r\n  Press = 'press',\r\n  Release = 'release',\r\n  Hold = 'hold',\r\n\r\n  PointerDragStart = 'pointerdragstart',\r\n  PointerDragEnd = 'pointerdragend',\r\n  PointerDragEnter = 'pointerdragenter',\r\n  PointerDragLeave = 'pointerdragleave',\r\n  PointerDragMove = 'pointerdragmove'\r\n}\r\n\r\n/* istanbul ignore next */\r\n/* compiler only: these are internal to lib */\r\nexport type kill = 'kill';\r\nexport type prekill = 'prekill';\r\nexport type postkill = 'postkill';\r\n\r\nexport type predraw = 'predraw';\r\nexport type postdraw = 'postdraw';\r\n\r\nexport type predebugdraw = 'predebugdraw';\r\nexport type postdebugdraw = 'postdebugdraw';\r\n\r\nexport type preupdate = 'preupdate';\r\nexport type postupdate = 'postupdate';\r\n\r\nexport type preframe = 'preframe';\r\nexport type postframe = 'postframe';\r\n\r\nexport type precollision = 'precollision';\r\nexport type collisionstart = 'collisionstart';\r\nexport type collisionend = 'collisionend';\r\nexport type postcollision = 'postcollision';\r\n\r\nexport type initialize = 'initialize';\r\nexport type activate = 'activate';\r\nexport type deactivate = 'deactivate';\r\n\r\nexport type exitviewport = 'exitviewport';\r\nexport type enterviewport = 'enterviewport';\r\n\r\nexport type exittrigger = 'exit';\r\nexport type entertrigger = 'enter';\r\n\r\nexport type connect = 'connect';\r\nexport type disconnect = 'disconnect';\r\nexport type button = 'button';\r\nexport type axis = 'axis';\r\n\r\nexport type subscribe = 'subscribe';\r\nexport type unsubscribe = 'unsubscribe';\r\n\r\nexport type visible = 'visible';\r\nexport type hidden = 'hidden';\r\nexport type start = 'start';\r\nexport type stop = 'stop';\r\n\r\nexport type pointerup = 'pointerup';\r\nexport type pointerdown = 'pointerdown';\r\nexport type pointermove = 'pointermove';\r\nexport type pointerenter = 'pointerenter';\r\nexport type pointerleave = 'pointerleave';\r\nexport type pointercancel = 'pointercancel';\r\nexport type pointerwheel = 'pointerwheel';\r\n\r\nexport type up = 'up';\r\nexport type down = 'down';\r\nexport type move = 'move';\r\nexport type enter = 'enter';\r\nexport type leave = 'leave';\r\nexport type cancel = 'cancel';\r\nexport type wheel = 'wheel';\r\n\r\nexport type press = 'press';\r\nexport type release = 'release';\r\nexport type hold = 'hold';\r\n\r\nexport type pointerdragstart = 'pointerdragstart';\r\nexport type pointerdragend = 'pointerdragend';\r\nexport type pointerdragenter = 'pointerdragenter';\r\nexport type pointerdragleave = 'pointerdragleave';\r\nexport type pointerdragmove = 'pointerdragmove';\r\n\r\n/**\r\n * Base event type in Excalibur that all other event types derive from. Not all event types are thrown on all Excalibur game objects,\r\n * some events are unique to a type, others are not.\r\n *\r\n */\r\nexport class GameEvent<T, U = T> {\r\n  /**\r\n   * Target object for this event.\r\n   */\r\n  public target: T;\r\n\r\n  /**\r\n   * Other target object for this event\r\n   */\r\n  public other: U | null;\r\n\r\n  /**\r\n   * If set to false, prevents event from propagating to other actors. If true it will be propagated\r\n   * to all actors that apply.\r\n   */\r\n  public get bubbles(): boolean {\r\n    return this._bubbles;\r\n  }\r\n\r\n  public set bubbles(value: boolean) {\r\n    this._bubbles = value;\r\n  }\r\n\r\n  private _bubbles: boolean = true;\r\n  /**\r\n   * Prevents event from bubbling\r\n   */\r\n  public stopPropagation() {\r\n    this.bubbles = false;\r\n  }\r\n}\r\n\r\n/**\r\n * The 'kill' event is emitted on actors when it is killed. The target is the actor that was killed.\r\n */\r\nexport class KillEvent extends GameEvent<Actor> {\r\n  constructor(public target: Actor) {\r\n    super();\r\n  }\r\n}\r\n\r\n/**\r\n * The 'prekill' event is emitted directly before an actor is killed.\r\n */\r\nexport class PreKillEvent extends GameEvent<Actor> {\r\n  constructor(public target: Actor) {\r\n    super();\r\n  }\r\n}\r\n\r\n/**\r\n * The 'postkill' event is emitted directly after the actor is killed.\r\n */\r\nexport class PostKillEvent extends GameEvent<Actor> {\r\n  constructor(public target: Actor) {\r\n    super();\r\n  }\r\n}\r\n\r\n/**\r\n * The 'start' event is emitted on engine when has started and is ready for interaction.\r\n */\r\nexport class GameStartEvent extends GameEvent<Engine> {\r\n  constructor(public target: Engine) {\r\n    super();\r\n  }\r\n}\r\n\r\n/**\r\n * The 'stop' event is emitted on engine when has been stopped and will no longer take input, update or draw.\r\n */\r\nexport class GameStopEvent extends GameEvent<Engine> {\r\n  constructor(public target: Engine) {\r\n    super();\r\n  }\r\n}\r\n\r\n/**\r\n * The 'predraw' event is emitted on actors, scenes, and engine before drawing starts. Actors' predraw happens inside their graphics\r\n * transform so that all drawing takes place with the actor as the origin.\r\n *\r\n */\r\nexport class PreDrawEvent extends GameEvent<Entity | Scene | Engine | TileMap> {\r\n  constructor(public ctx: ExcaliburGraphicsContext, public delta: number, public target: Entity | Scene | Engine | TileMap) {\r\n    super();\r\n  }\r\n}\r\n\r\n/**\r\n * The 'postdraw' event is emitted on actors, scenes, and engine after drawing finishes. Actors' postdraw happens inside their graphics\r\n * transform so that all drawing takes place with the actor as the origin.\r\n *\r\n */\r\nexport class PostDrawEvent extends GameEvent<Entity | Scene | Engine | TileMap> {\r\n  constructor(public ctx: ExcaliburGraphicsContext, public delta: number, public target: Entity | Scene | Engine | TileMap) {\r\n    super();\r\n  }\r\n}\r\n\r\n/**\r\n * The 'predebugdraw' event is emitted on actors, scenes, and engine before debug drawing starts.\r\n */\r\nexport class PreDebugDrawEvent extends GameEvent<Entity | Actor | Scene | Engine> {\r\n  constructor(public ctx: ExcaliburGraphicsContext, public target: Entity | Actor | Scene | Engine) {\r\n    super();\r\n  }\r\n}\r\n\r\n/**\r\n * The 'postdebugdraw' event is emitted on actors, scenes, and engine after debug drawing starts.\r\n */\r\nexport class PostDebugDrawEvent extends GameEvent<Entity | Actor | Scene | Engine> {\r\n  constructor(public ctx: ExcaliburGraphicsContext, public target: Entity | Actor | Scene | Engine) {\r\n    super();\r\n  }\r\n}\r\n\r\n/**\r\n * The 'preupdate' event is emitted on actors, scenes, camera, and engine before the update starts.\r\n */\r\nexport class PreUpdateEvent<T extends OnPreUpdate = Entity> extends GameEvent<T> {\r\n  constructor(public engine: Engine, public delta: number, public target: T) {\r\n    super();\r\n  }\r\n}\r\n\r\n/**\r\n * The 'postupdate' event is emitted on actors, scenes, camera, and engine after the update ends.\r\n */\r\nexport class PostUpdateEvent<T extends OnPostUpdate = Entity> extends GameEvent<T> {\r\n  constructor(public engine: Engine, public delta: number, public target: T) {\r\n    super();\r\n  }\r\n}\r\n\r\n/**\r\n * The 'preframe' event is emitted on the engine, before the frame begins.\r\n */\r\nexport class PreFrameEvent extends GameEvent<Engine> {\r\n  constructor(public engine: Engine, public prevStats: FrameStats) {\r\n    super();\r\n    this.target = engine;\r\n  }\r\n}\r\n\r\n/**\r\n * The 'postframe' event is emitted on the engine, after a frame ends.\r\n */\r\nexport class PostFrameEvent extends GameEvent<Engine> {\r\n  constructor(public engine: Engine, public stats: FrameStats) {\r\n    super();\r\n    this.target = engine;\r\n  }\r\n}\r\n\r\n/**\r\n * Event received when a gamepad is connected to Excalibur. [[Gamepads]] receives this event.\r\n */\r\nexport class GamepadConnectEvent extends GameEvent<Input.Gamepad> {\r\n  constructor(public index: number, public gamepad: Input.Gamepad) {\r\n    super();\r\n    this.target = gamepad;\r\n  }\r\n}\r\n\r\n/**\r\n * Event received when a gamepad is disconnected from Excalibur. [[Gamepads]] receives this event.\r\n */\r\nexport class GamepadDisconnectEvent extends GameEvent<Input.Gamepad> {\r\n  constructor(public index: number, public gamepad: Input.Gamepad) {\r\n    super();\r\n    this.target = gamepad;\r\n  }\r\n}\r\n\r\n/**\r\n * Gamepad button event. See [[Gamepads]] for information on responding to controller input. [[Gamepad]] instances receive this event;\r\n */\r\nexport class GamepadButtonEvent extends GameEvent<Input.Gamepad> {\r\n  /**\r\n   * @param button  The Gamepad button\r\n   * @param value   A numeric value between 0 and 1\r\n   */\r\n  constructor(public button: Input.Buttons, public value: number, public target: Input.Gamepad) {\r\n    super();\r\n  }\r\n}\r\n\r\n/**\r\n * Gamepad axis event. See [[Gamepads]] for information on responding to controller input. [[Gamepad]] instances receive this event;\r\n */\r\nexport class GamepadAxisEvent extends GameEvent<Input.Gamepad> {\r\n  /**\r\n   * @param axis  The Gamepad axis\r\n   * @param value A numeric value between -1 and 1\r\n   */\r\n  constructor(public axis: Input.Axes, public value: number, public target: Input.Gamepad) {\r\n    super();\r\n  }\r\n}\r\n\r\n/**\r\n * Subscribe event thrown when handlers for events other than subscribe are added. Meta event that is received by\r\n * [[EventDispatcher|event dispatchers]].\r\n */\r\nexport class SubscribeEvent<T> extends GameEvent<T> {\r\n  constructor(public topic: string, public handler: (event: GameEvent<T>) => void) {\r\n    super();\r\n  }\r\n}\r\n\r\n/**\r\n * Unsubscribe event thrown when handlers for events other than unsubscribe are removed. Meta event that is received by\r\n * [[EventDispatcher|event dispatchers]].\r\n */\r\nexport class UnsubscribeEvent<T> extends GameEvent<T> {\r\n  constructor(public topic: string, public handler: (event: GameEvent<T>) => void) {\r\n    super();\r\n  }\r\n}\r\n\r\n/**\r\n * Event received by the [[Engine]] when the browser window is visible on a screen.\r\n */\r\nexport class VisibleEvent extends GameEvent<Engine> {\r\n  constructor(public target: Engine) {\r\n    super();\r\n  }\r\n}\r\n\r\n/**\r\n * Event received by the [[Engine]] when the browser window is hidden from all screens.\r\n */\r\nexport class HiddenEvent extends GameEvent<Engine> {\r\n  constructor(public target: Engine) {\r\n    super();\r\n  }\r\n}\r\n\r\n/**\r\n * Event thrown on an [[Actor|actor]] when a collision will occur this frame if it resolves\r\n */\r\nexport class PreCollisionEvent<T extends BodyComponent | Collider | Entity = Actor> extends GameEvent<T> {\r\n  /**\r\n   * @param actor         The actor the event was thrown on\r\n   * @param other         The actor that will collided with the current actor\r\n   * @param side          The side that will be collided with the current actor\r\n   * @param intersection  Intersection vector\r\n   */\r\n  constructor(actor: T, public other: T, public side: Side, public intersection: Vector) {\r\n    super();\r\n    this.target = actor;\r\n  }\r\n}\r\n\r\n/**\r\n * Event thrown on an [[Actor|actor]] when a collision has been resolved (body reacted) this frame\r\n */\r\nexport class PostCollisionEvent<T extends Collider | Entity = Actor> extends GameEvent<T> {\r\n  /**\r\n   * @param actor         The actor the event was thrown on\r\n   * @param other         The actor that did collide with the current actor\r\n   * @param side          The side that did collide with the current actor\r\n   * @param intersection  Intersection vector\r\n   */\r\n  constructor(actor: T, public other: T, public side: Side, public intersection: Vector) {\r\n    super();\r\n    this.target = actor;\r\n  }\r\n\r\n  public get actor() {\r\n    return this.target;\r\n  }\r\n\r\n  public set actor(actor: T) {\r\n    this.target = actor;\r\n  }\r\n}\r\n\r\nexport class ContactStartEvent<T> {\r\n  constructor(public target: T, public other: T, public contact: CollisionContact) {}\r\n}\r\n\r\nexport class ContactEndEvent<T> {\r\n  constructor(public target: T, public other: T) {}\r\n}\r\n\r\nexport class CollisionPreSolveEvent<T> {\r\n  constructor(public target: T, public other: T, public side: Side, public intersection: Vector, public contact: CollisionContact) {}\r\n}\r\n\r\nexport class CollisionPostSolveEvent<T> {\r\n  constructor(public target: T, public other: T, public side: Side, public intersection: Vector, public contact: CollisionContact) {}\r\n}\r\n\r\n/**\r\n * Event thrown the first time an [[Actor|actor]] collides with another, after an actor is in contact normal collision events are fired.\r\n */\r\nexport class CollisionStartEvent<T extends BodyComponent | Collider | Entity = Actor> extends GameEvent<T> {\r\n  /**\r\n   *\r\n   * @param actor\r\n   * @param other\r\n   * @param contact\r\n   */\r\n  constructor(actor: T, public other: T, public contact: CollisionContact) {\r\n    super();\r\n    this.target = actor;\r\n  }\r\n\r\n  public get actor() {\r\n    return this.target;\r\n  }\r\n\r\n  public set actor(actor: T) {\r\n    this.target = actor;\r\n  }\r\n}\r\n\r\n/**\r\n * Event thrown when the [[Actor|actor]] is no longer colliding with another\r\n */\r\nexport class CollisionEndEvent<T extends BodyComponent | Collider | Entity = Actor> extends GameEvent<T> {\r\n  /**\r\n   *\r\n   */\r\n  constructor(actor: T, public other: T) {\r\n    super();\r\n    this.target = actor;\r\n  }\r\n\r\n  public get actor() {\r\n    return this.target;\r\n  }\r\n\r\n  public set actor(actor: T) {\r\n    this.target = actor;\r\n  }\r\n}\r\n\r\n/**\r\n * Event thrown on an [[Actor]] and a [[Scene]] only once before the first update call\r\n */\r\nexport class InitializeEvent<T extends OnInitialize = Entity> extends GameEvent<T> {\r\n  /**\r\n   * @param engine  The reference to the current engine\r\n   */\r\n  constructor(public engine: Engine, public target: T) {\r\n    super();\r\n  }\r\n}\r\n\r\n/**\r\n * Event thrown on a [[Scene]] on activation\r\n */\r\nexport class ActivateEvent extends GameEvent<Scene> {\r\n  /**\r\n   * @param oldScene  The reference to the old scene\r\n   */\r\n  constructor(public oldScene: Scene, public target: Scene) {\r\n    super();\r\n  }\r\n}\r\n\r\n/**\r\n * Event thrown on a [[Scene]] on deactivation\r\n */\r\nexport class DeactivateEvent extends GameEvent<Scene> {\r\n  /**\r\n   * @param newScene  The reference to the new scene\r\n   */\r\n  constructor(public newScene: Scene, public target: Scene) {\r\n    super();\r\n  }\r\n}\r\n\r\n/**\r\n * Event thrown on an [[Actor]] when it completely leaves the screen.\r\n */\r\nexport class ExitViewPortEvent extends GameEvent<Entity> {\r\n  constructor(public target: Entity) {\r\n    super();\r\n  }\r\n}\r\n\r\n/**\r\n * Event thrown on an [[Actor]] when it completely leaves the screen.\r\n */\r\nexport class EnterViewPortEvent extends GameEvent<Entity> {\r\n  constructor(public target: Entity) {\r\n    super();\r\n  }\r\n}\r\n\r\nexport class EnterTriggerEvent extends GameEvent<Actor> {\r\n  constructor(public target: Trigger, public actor: Actor) {\r\n    super();\r\n  }\r\n}\r\n\r\nexport class ExitTriggerEvent extends GameEvent<Actor> {\r\n  constructor(public target: Trigger, public actor: Actor) {\r\n    super();\r\n  }\r\n}\r\n","import { Vector, vec } from '../Math/vector';\r\nimport { ExcaliburGraphicsContext } from './Context/ExcaliburGraphicsContext';\r\nimport { BoundingBox } from '../Collision/BoundingBox';\r\nimport { Matrix } from '..';\r\nimport { watch } from '../Util/Watch';\r\n\r\nexport interface GraphicOptions {\r\n  /**\r\n   * The width of the graphic\r\n   */\r\n  width?: number;\r\n  /**\r\n   * The height of the graphic\r\n   */\r\n  height?: number;\r\n  /**\r\n   * SHould the graphic be flipped horizontally\r\n   */\r\n  flipHorizontal?: boolean;\r\n  /**\r\n   * Should the graphic be flipped vertically\r\n   */\r\n  flipVertical?: boolean;\r\n  /**\r\n   * The rotation of the graphic\r\n   */\r\n  rotation?: number;\r\n  /**\r\n   * The scale of the graphic\r\n   */\r\n  scale?: Vector;\r\n  /**\r\n   * The opacity of the graphic\r\n   */\r\n  opacity?: number;\r\n  /**\r\n   * The origin of the drawing in pixels to use when applying transforms, by default it will be the center of the image\r\n   */\r\n  origin?: Vector;\r\n}\r\n\r\n/**\r\n * A Graphic is the base Excalibur primitive for something that can be drawn to the [[ExcaliburGraphicsContext]].\r\n * [[Sprite]], [[Animation]], [[GraphicsGroup]], [[Canvas]], [[Rectangle]], [[Circle]], and [[Polygon]] all derive from the\r\n * [[Graphic]] abstract class.\r\n *\r\n * Implementors of a Graphic must override the abstract [[Graphic._drawImage]] method to render an image to the graphics context. Graphic\r\n * handles all the position, rotation, and scale transformations in [[Graphic._preDraw]] and [[Graphic._postDraw]]\r\n */\r\nexport abstract class Graphic {\r\n  private static _ID: number = 0;\r\n  readonly id = Graphic._ID++;\r\n\r\n  public transform: Matrix = Matrix.identity();\r\n  private _transformStale = true;\r\n  public isStale() {\r\n    return this._transformStale;\r\n  }\r\n\r\n  /**\r\n   * Gets or sets wether to show debug information about the graphic\r\n   */\r\n  public showDebug: boolean = false;\r\n\r\n\r\n  private _flipHorizontal = false;\r\n  /**\r\n   * Gets or sets the flipHorizontal, which will flip the graphic horizontally (across the y axis)\r\n   */\r\n  public get flipHorizontal(): boolean {\r\n    return this._flipHorizontal;\r\n  }\r\n\r\n  public set flipHorizontal(value: boolean) {\r\n    this._flipHorizontal = value;\r\n    this._transformStale = true;\r\n  }\r\n\r\n  private _flipVertical = false;\r\n  /**\r\n   * Gets or sets the flipVertical, which will flip the graphic vertically (across the x axis)\r\n   */\r\n  public get flipVertical(): boolean {\r\n    return this._flipVertical;\r\n  }\r\n\r\n  public set flipVertical(value: boolean) {\r\n    this._flipVertical = value;\r\n    this._transformStale = true;\r\n  }\r\n\r\n  private _rotation = 0;\r\n  /**\r\n   * Gets or sets the rotation of the graphic\r\n   */\r\n  public get rotation(): number {\r\n    return this._rotation;\r\n  }\r\n\r\n  public set rotation(value: number) {\r\n    this._rotation = value;\r\n    this._transformStale = true;\r\n  }\r\n\r\n  /**\r\n   * Gets or sets the opacity of the graphic, 0 is transparent, 1 is solid (opaque).\r\n   */\r\n  public opacity: number = 1;\r\n\r\n  private _scale = Vector.One;\r\n  /**\r\n   * Gets or sets the scale of the graphic, this affects the width and\r\n   */\r\n  public get scale() {\r\n    return this._scale;\r\n  }\r\n\r\n  public set scale(value: Vector) {\r\n    this._scale = watch(value, () => {\r\n      this._transformStale = true;\r\n    });\r\n    this._transformStale = true;\r\n  }\r\n\r\n  private _origin: Vector | null = null;\r\n  /**\r\n   * Gets or sets the origin of the graphic, if not set the center of the graphic is the origin\r\n   */\r\n  public get origin(): Vector | null {\r\n    return this._origin;\r\n  }\r\n\r\n  public set origin(value: Vector | null) {\r\n    this._origin = watch(value, () => {\r\n      this._transformStale = true;\r\n    });\r\n    this._transformStale = true;\r\n  }\r\n\r\n  constructor(options?: GraphicOptions) {\r\n    if (options) {\r\n      this.origin = options.origin ?? this.origin;\r\n      this.flipHorizontal = options.flipHorizontal ?? this.flipHorizontal;\r\n      this.flipVertical = options.flipVertical ?? this.flipVertical;\r\n      this.rotation = options.rotation ?? this.rotation;\r\n      this.opacity = options.opacity ?? this.opacity;\r\n      this.scale = options.scale ?? this.scale;\r\n    }\r\n  }\r\n\r\n  public cloneGraphicOptions(): GraphicOptions {\r\n    return {\r\n      origin: this.origin ? this.origin.clone() : null,\r\n      flipHorizontal: this.flipHorizontal,\r\n      flipVertical: this.flipVertical,\r\n      rotation: this.rotation,\r\n      opacity: this.opacity,\r\n      scale: this.scale ? this.scale.clone() : null\r\n    };\r\n  }\r\n\r\n  private _width: number = 0;\r\n\r\n  /**\r\n   * Gets or sets the width of the graphic (always positive)\r\n   */\r\n  public get width() {\r\n    return Math.abs(this._width * this.scale.x);\r\n  }\r\n\r\n  private _height: number = 0;\r\n\r\n  /**\r\n   * Gets or sets the height of the graphic (always positive)\r\n   */\r\n  public get height() {\r\n    return Math.abs(this._height * this.scale.y);\r\n  }\r\n\r\n  public set width(value: number) {\r\n    this._width = value;\r\n    this._transformStale = true;\r\n  }\r\n\r\n  public set height(value: number) {\r\n    this._height = value;\r\n    this._transformStale = true;\r\n  }\r\n\r\n  /**\r\n   * Gets a copy of the bounds in pixels occupied by the graphic on the the screen. This includes scale.\r\n   */\r\n  public get localBounds(): BoundingBox {\r\n    return BoundingBox.fromDimension(this.width, this.height, Vector.Zero);\r\n  }\r\n\r\n  /**\r\n   * Draw the whole graphic to the context including transform\r\n   * @param ex The excalibur graphics context\r\n   * @param x\r\n   * @param y\r\n   */\r\n  public draw(ex: ExcaliburGraphicsContext, x: number, y: number): void {\r\n    this._preDraw(ex, x, y);\r\n    this._drawImage(ex, 0, 0);\r\n    this._postDraw(ex);\r\n  }\r\n\r\n  /**\r\n   * Meant to be overridden by the graphic implementation to draw the underlying image (HTMLCanvasElement or HTMLImageElement)\r\n   * to the graphics context without transform. Transformations like position, rotation, and scale are handled by [[Graphic._preDraw]]\r\n   * and [[Graphic._postDraw]]\r\n   * @param ex The excalibur graphics context\r\n   * @param x\r\n   * @param y\r\n   */\r\n  protected abstract _drawImage(ex: ExcaliburGraphicsContext, x: number, y: number): void;\r\n\r\n  /**\r\n   * Apply affine transformations to the graphics context to manipulate the graphic before [[Graphic._drawImage]]\r\n   * @param ex\r\n   * @param x\r\n   * @param y\r\n   */\r\n  protected _preDraw(ex: ExcaliburGraphicsContext, x: number, y: number): void {\r\n    ex.save();\r\n    ex.translate(x, y);\r\n    if (this._transformStale) {\r\n      this.transform.reset();\r\n      this.transform.scale(Math.abs(this.scale.x), Math.abs(this.scale.y));\r\n      this._rotate(this.transform);\r\n      this._flip(this.transform);\r\n      this._transformStale = false;\r\n    }\r\n    ex.multiply(this.transform);\r\n    // it is important to multiply alphas so graphics respect the current context\r\n    ex.opacity = ex.opacity * this.opacity;\r\n  }\r\n\r\n  protected _rotate(ex: ExcaliburGraphicsContext | Matrix) {\r\n    const scaleDirX = this.scale.x > 0 ? 1 : -1;\r\n    const scaleDirY = this.scale.y > 0 ? 1 : -1;\r\n    const origin = this.origin ?? vec(this.width / 2, this.height / 2);\r\n    ex.translate(origin.x, origin.y);\r\n    ex.rotate(this.rotation);\r\n    // This is for handling direction changes 1 or -1, that way we don't have mismatched translates()\r\n    ex.scale(scaleDirX, scaleDirY);\r\n    ex.translate(-origin.x, -origin.y);\r\n  }\r\n\r\n  protected _flip(ex: ExcaliburGraphicsContext | Matrix) {\r\n    if (this.flipHorizontal) {\r\n      ex.translate(this.width / this.scale.x, 0);\r\n      ex.scale(-1, 1);\r\n    }\r\n\r\n    if (this.flipVertical) {\r\n      ex.translate(0, this.height / this.scale.y);\r\n      ex.scale(1, -1);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Apply any additional work after [[Graphic._drawImage]] and restore the context state.\r\n   * @param ex\r\n   */\r\n  protected _postDraw(ex: ExcaliburGraphicsContext): void {\r\n    if (this.showDebug) {\r\n      ex.debug.drawRect(0, 0, this.width, this.height);\r\n    }\r\n    ex.restore();\r\n  }\r\n\r\n  /**\r\n   * Returns a new instance of the graphic that has the same properties\r\n   */\r\n  abstract clone(): Graphic;\r\n}\r\n","import { GameEvent, SubscribeEvent, UnsubscribeEvent } from './Events';\r\nimport { Eventable } from './Interfaces/Evented';\r\n\r\nexport class EventDispatcher<T = any> implements Eventable {\r\n  private _handlers: { [key: string]: { (event: GameEvent<T>): void }[] } = {};\r\n  private _wiredEventDispatchers: Eventable[] = [];\r\n\r\n  /**\r\n   * Clears any existing handlers or wired event dispatchers on this event dispatcher\r\n   */\r\n  public clear() {\r\n    this._handlers = {};\r\n    this._wiredEventDispatchers = [];\r\n  }\r\n\r\n  /**\r\n   * Emits an event for target\r\n   * @param eventName  The name of the event to publish\r\n   * @param event      Optionally pass an event data object to the handler\r\n   */\r\n  public emit(eventName: string, event: GameEvent<T>) {\r\n    if (!eventName) {\r\n      // key not mapped\r\n      return;\r\n    }\r\n    eventName = eventName.toLowerCase();\r\n    if (!event) {\r\n      event = new GameEvent();\r\n    }\r\n    let i: number, len: number;\r\n\r\n    if (this._handlers[eventName]) {\r\n      i = 0;\r\n      len = this._handlers[eventName].length;\r\n\r\n      for (i; i < len; i++) {\r\n        this._handlers[eventName][i](event);\r\n      }\r\n    }\r\n\r\n    i = 0;\r\n    len = this._wiredEventDispatchers.length;\r\n\r\n    for (i; i < len; i++) {\r\n      this._wiredEventDispatchers[i].emit(eventName, event);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Subscribe an event handler to a particular event name, multiple handlers per event name are allowed.\r\n   * @param eventName  The name of the event to subscribe to\r\n   * @param handler    The handler callback to fire on this event\r\n   */\r\n  public on(eventName: string, handler: (event: GameEvent<T>) => void) {\r\n    eventName = eventName.toLowerCase();\r\n    if (!this._handlers[eventName]) {\r\n      this._handlers[eventName] = [];\r\n    }\r\n    this._handlers[eventName].push(handler);\r\n\r\n    // meta event handlers\r\n    if (eventName !== 'unsubscribe' && eventName !== 'subscribe') {\r\n      this.emit('subscribe', new SubscribeEvent(eventName, handler));\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Unsubscribe an event handler(s) from an event. If a specific handler\r\n   * is specified for an event, only that handler will be unsubscribed.\r\n   * Otherwise all handlers will be unsubscribed for that event.\r\n   *\r\n   * @param eventName  The name of the event to unsubscribe\r\n   * @param handler    Optionally the specific handler to unsubscribe\r\n   */\r\n  public off(eventName: string, handler?: (event: GameEvent<T>) => void) {\r\n    eventName = eventName.toLowerCase();\r\n    const eventHandlers = this._handlers[eventName];\r\n\r\n    if (eventHandlers) {\r\n      // if no explicit handler is give with the event name clear all handlers\r\n      if (!handler) {\r\n        this._handlers[eventName].length = 0;\r\n      } else {\r\n        const index = eventHandlers.indexOf(handler);\r\n        this._handlers[eventName].splice(index, 1);\r\n      }\r\n    }\r\n    // meta event handlers\r\n    if (eventName !== 'unsubscribe' && eventName !== 'subscribe') {\r\n      this.emit('unsubscribe', new UnsubscribeEvent(eventName, handler));\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Once listens to an event one time, then unsubscribes from that event\r\n   *\r\n   * @param eventName The name of the event to subscribe to once\r\n   * @param handler   The handler of the event that will be auto unsubscribed\r\n   */\r\n  public once(eventName: string, handler: (event: GameEvent<T>) => void) {\r\n    const metaHandler = (event: GameEvent<T>) => {\r\n      const ev = event || new GameEvent();\r\n      this.off(eventName, handler);\r\n      handler(ev);\r\n    };\r\n\r\n    this.on(eventName, metaHandler);\r\n  }\r\n\r\n  /**\r\n   * Wires this event dispatcher to also receive events from another\r\n   */\r\n  public wire(eventDispatcher: EventDispatcher): void {\r\n    eventDispatcher._wiredEventDispatchers.push(this);\r\n  }\r\n\r\n  /**\r\n   * Unwires this event dispatcher from another\r\n   */\r\n  public unwire(eventDispatcher: EventDispatcher): void {\r\n    const index = eventDispatcher._wiredEventDispatchers.indexOf(this);\r\n    if (index > -1) {\r\n      eventDispatcher._wiredEventDispatchers.splice(index, 1);\r\n    }\r\n  }\r\n}\r\n","import { Loadable } from '../Interfaces/Loadable';\r\nimport { Logger } from '../Util/Log';\r\nimport { EventDispatcher } from '../EventDispatcher';\r\n\r\n/**\r\n * The [[Resource]] type allows games built in Excalibur to load generic resources.\r\n * For any type of remote resource it is recommended to use [[Resource]] for preloading.\r\n */\r\nexport class Resource<T> implements Loadable<T> {\r\n  public data: T = null;\r\n  public logger: Logger = Logger.getInstance();\r\n  public events: EventDispatcher = new EventDispatcher();\r\n\r\n  /**\r\n   * @param path          Path to the remote resource\r\n   * @param responseType  The type to expect as a response: \"\" | \"arraybuffer\" | \"blob\" | \"document\" | \"json\" | \"text\";\r\n   * @param bustCache     Whether or not to cache-bust requests\r\n   */\r\n  constructor(\r\n    public path: string,\r\n    public responseType: '' | 'arraybuffer' | 'blob' | 'document' | 'json' | 'text',\r\n    public bustCache: boolean = true\r\n  ) {}\r\n\r\n  /**\r\n   * Returns true if the Resource is completely loaded and is ready\r\n   * to be drawn.\r\n   */\r\n  public isLoaded(): boolean {\r\n    return this.data !== null;\r\n  }\r\n\r\n\r\n  private _cacheBust(uri: string): string {\r\n    const query: RegExp = /\\?\\w*=\\w*/;\r\n    if (query.test(uri)) {\r\n      uri += '&__=' + Date.now();\r\n    } else {\r\n      uri += '?__=' + Date.now();\r\n    }\r\n    return uri;\r\n  }\r\n  /**\r\n   * Begin loading the resource and returns a promise to be resolved on completion\r\n   */\r\n  public load(): Promise<T> {\r\n    return new Promise((resolve, reject) => {\r\n      // Exit early if we already have data\r\n      if (this.data !== null) {\r\n        this.logger.debug('Already have data for resource', this.path);\r\n        this.events.emit('complete', this.data as any);\r\n        resolve(this.data);\r\n        return;\r\n      }\r\n\r\n      const request = new XMLHttpRequest();\r\n      request.open('GET', this.bustCache ? this._cacheBust(this.path) : this.path, true);\r\n      request.responseType = this.responseType;\r\n      request.addEventListener('loadstart', (e) => this.events.emit('loadstart', e as any));\r\n      request.addEventListener('progress', (e) => this.events.emit('progress', e as any));\r\n      request.addEventListener('error', (e) => this.events.emit('error', e as any));\r\n      request.addEventListener('load', (e) => this.events.emit('load', e as any));\r\n      request.addEventListener('load', () => {\r\n        // XHR on file:// success status is 0, such as with PhantomJS\r\n        if (request.status !== 0 && request.status !== 200) {\r\n          this.logger.error('Failed to load resource ', this.path, ' server responded with error code', request.status);\r\n          this.events.emit('error', request.response);\r\n          reject(new Error(request.statusText));\r\n          return;\r\n        }\r\n\r\n        this.data = request.response;\r\n        this.events.emit('complete', this.data as any);\r\n        this.logger.debug('Completed loading resource', this.path);\r\n        resolve(this.data);\r\n      });\r\n      request.send();\r\n    });\r\n  }\r\n}\r\n","/**\r\n * Watch an object with a proxy, only fires if property value is different\r\n */\r\nexport function watch<T extends object>(type: T, change: (type: T) => any): T {\r\n  if (!type) {\r\n    return type;\r\n  }\r\n  if ((type as any).__isProxy === undefined) {\r\n    // expando hack to mark a proxy\r\n    return new Proxy(type, {\r\n      set: (obj, prop, value) => {\r\n        // The default behavior to store the value\r\n        if ((obj as any)[prop] !== value) {\r\n          (obj as any)[prop] = value;\r\n          // Avoid watching private junk\r\n          if (typeof prop === 'string') {\r\n            if (prop[0] !== '_') {\r\n              change(obj);\r\n            }\r\n          }\r\n        }\r\n        // Indicate success\r\n        return true;\r\n      },\r\n      get: (obj, prop) => {\r\n        if (prop !== '__isProxy') {\r\n          return (obj as any)[prop];\r\n        }\r\n        return true;\r\n      }\r\n    });\r\n  }\r\n  return type;\r\n}\r\n\r\n/**\r\n * Watch an object with a proxy, fires change on any property value change\r\n */\r\nexport function watchAny<T extends object>(type: T, change: (type: T) => any): T {\r\n  if (!type) {\r\n    return type;\r\n  }\r\n  if ((type as any).__isProxy === undefined) {\r\n    // expando hack to mark a proxy\r\n    return new Proxy(type, {\r\n      set: (obj, prop, value) => {\r\n        // The default behavior to store the value\r\n        (obj as any)[prop] = value;\r\n        // Avoid watching private junk\r\n        if (typeof prop === 'string') {\r\n          if (prop[0] !== '_') {\r\n            change(obj);\r\n          }\r\n        }\r\n\r\n        // Indicate success\r\n        return true;\r\n      },\r\n      get: (obj, prop) => {\r\n        if (prop !== '__isProxy') {\r\n          return (obj as any)[prop];\r\n        }\r\n        return true;\r\n      }\r\n    });\r\n  }\r\n  return type;\r\n}\r\n","import { Graphic, GraphicOptions } from './Graphic';\r\nimport { ImageSource } from './ImageSource';\r\nimport { ExcaliburGraphicsContext } from './Context/ExcaliburGraphicsContext';\r\n\r\nexport type SourceView = { x: number; y: number; width: number; height: number };\r\nexport type DestinationSize = { width: number; height: number };\r\n\r\nexport interface SpriteOptions {\r\n  /**\r\n   * Image to create a sprite from\r\n   */\r\n  image: ImageSource;\r\n  /**\r\n   * By default the source is the entire dimension of the [[ImageSource]]\r\n   */\r\n  sourceView?: { x: number; y: number; width: number; height: number };\r\n  /**\r\n   * By default the size of the final sprite is the size of the [[ImageSource]]\r\n   */\r\n  destSize?: { width: number; height: number };\r\n}\r\n\r\nexport class Sprite extends Graphic {\r\n  public image: ImageSource;\r\n  public sourceView: SourceView;\r\n  public destSize: DestinationSize;\r\n  private _dirty = true;\r\n\r\n  public static from(image: ImageSource): Sprite {\r\n    return new Sprite({\r\n      image: image\r\n    });\r\n  }\r\n\r\n  constructor(options: GraphicOptions & SpriteOptions) {\r\n    super(options);\r\n    this.image = options.image;\r\n    const { width, height } = options;\r\n    this.sourceView = options.sourceView ?? { x: 0, y: 0, width: width ?? 0, height: height ?? 0 };\r\n    this.destSize = options.destSize ?? { width: width ?? 0, height: height ?? 0 };\r\n    this._updateSpriteDimensions();\r\n    this.image.ready.then(() => {\r\n      this._updateSpriteDimensions();\r\n    });\r\n  }\r\n\r\n  public override get width(): number {\r\n    return Math.abs(this.destSize.width * this.scale.x);\r\n  }\r\n\r\n  public override get height(): number {\r\n    return Math.abs(this.destSize.height * this.scale.y);\r\n  }\r\n\r\n  public override set width(newWidth: number) {\r\n    newWidth /= Math.abs(this.scale.x);\r\n    this.destSize.width = newWidth;\r\n    super.width = Math.ceil(this.destSize.width);\r\n  }\r\n\r\n  public override set height(newHeight: number) {\r\n    newHeight /= Math.abs(this.scale.y);\r\n    this.destSize.height = newHeight;\r\n    super.height = Math.ceil(this.destSize.height);\r\n  }\r\n\r\n  private _updateSpriteDimensions() {\r\n    const { width: nativeWidth, height: nativeHeight } = this.image;\r\n    // This code uses || to avoid 0's\r\n    // If the source is not specified, use the native dimension\r\n    this.sourceView.width = this.sourceView?.width || nativeWidth;\r\n    this.sourceView.height = this.sourceView?.height || nativeHeight;\r\n\r\n    // If the destination is not specified, use the source if specified, then native\r\n    this.destSize.width = this.destSize?.width || this.sourceView?.width || nativeWidth;\r\n    this.destSize.height = this.destSize?.height || this.sourceView?.height || nativeHeight;\r\n\r\n    this.width = Math.ceil(this.destSize.width) * this.scale.x;\r\n    this.height = Math.ceil(this.destSize.height) * this.scale.y;\r\n  }\r\n\r\n  protected _preDraw(ex: ExcaliburGraphicsContext, x: number, y: number): void {\r\n    if (this.image.isLoaded() && this._dirty) {\r\n      this._dirty = false;\r\n      this._updateSpriteDimensions();\r\n    }\r\n    super._preDraw(ex, x, y);\r\n  }\r\n\r\n  public _drawImage(ex: ExcaliburGraphicsContext, x: number, y: number): void {\r\n    if (this.image.isLoaded()) {\r\n      ex.drawImage(\r\n        this.image.image,\r\n        this.sourceView.x,\r\n        this.sourceView.y,\r\n        this.sourceView.width,\r\n        this.sourceView.height,\r\n        x,\r\n        y,\r\n        this.destSize.width,\r\n        this.destSize.height\r\n      );\r\n    }\r\n  }\r\n\r\n  public clone(): Sprite {\r\n    return new Sprite({\r\n      image: this.image,\r\n      sourceView: { ...this.sourceView },\r\n      destSize: { ...this.destSize },\r\n      ...this.cloneGraphicOptions()\r\n    });\r\n  }\r\n}\r\n","\r\n/**\r\n * Describes the different image filtering modes\r\n */\r\nexport enum ImageFiltering {\r\n\r\n  /**\r\n   * Pixel is useful when you do not want smoothing aka antialiasing applied to your graphics.\r\n   *\r\n   * Useful for Pixel art aesthetics.\r\n   */\r\n  Pixel = 'Pixel',\r\n\r\n  /**\r\n   * Blended is useful when you have high resolution artwork and would like it blended and smoothed\r\n   */\r\n  Blended = 'Blended'\r\n}","/**\r\n * Checks if the current number is a power of two\r\n */\r\nexport function isPowerOfTwo(x: number): boolean {\r\n  return (x & (x - 1)) === 0;\r\n}\r\n\r\n/**\r\n * Returns the next highest power of two\r\n */\r\nexport function nextHighestPowerOfTwo(x: number): number {\r\n  --x;\r\n  for (let i = 1; i < 32; i <<= 1) {\r\n    x = x | (x >> i);\r\n  }\r\n  return x + 1;\r\n}\r\n\r\n/**\r\n * Returns the input number if a power of two, otherwise the next highest power of two\r\n */\r\nexport function ensurePowerOfTwo(x: number): number {\r\n  if (!isPowerOfTwo(x)) {\r\n    return nextHighestPowerOfTwo(x);\r\n  }\r\n  return x;\r\n}\r\n\r\n/**\r\n * Return the size of the GlType in bytes\r\n * @param gl\r\n * @param type\r\n */\r\nexport function getGlTypeSizeBytes(gl: WebGLRenderingContext, type: number): number {\r\n  switch (type) {\r\n    case gl.FLOAT:\r\n      return 4;\r\n    case gl.SHORT:\r\n      return 2;\r\n    case gl.UNSIGNED_SHORT:\r\n      return 2;\r\n    case gl.BYTE:\r\n      return 1;\r\n    case gl.UNSIGNED_BYTE:\r\n      return 1;\r\n    default:\r\n      return 1;\r\n  }\r\n}\r\n\r\n\r\n/**\r\n * Based on the type return the number of attribute components\r\n *\r\n * https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/vertexAttribPointer\r\n * @param gl\r\n * @param type\r\n */\r\nexport function getAttributeComponentSize(gl: WebGLRenderingContext, type: number): number {\r\n  switch (type) {\r\n    case gl.LOW_FLOAT:\r\n    case gl.HIGH_FLOAT:\r\n    case gl.FLOAT:\r\n      return 1;\r\n    case gl.FLOAT_VEC2:\r\n      return 2;\r\n    case gl.FLOAT_VEC3:\r\n      return 3;\r\n    case gl.FLOAT_VEC4:\r\n      return 4;\r\n    case gl.BYTE:\r\n      return 1;\r\n    case gl.UNSIGNED_BYTE:\r\n      return 1;\r\n    case gl.UNSIGNED_SHORT:\r\n    case gl.SHORT:\r\n      return 1;\r\n    default:\r\n      return 1;\r\n  }\r\n}\r\n\r\n/**\r\n * Based on the attribute return the corresponding supported attrib pointer type\r\n * https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/vertexAttribPointer\r\n *\r\n * @param gl\r\n * @param type\r\n */\r\nexport function getAttributePointerType(gl: WebGLRenderingContext, type: number) {\r\n  switch (type) {\r\n    case gl.LOW_FLOAT:\r\n    case gl.HIGH_FLOAT:\r\n    case gl.FLOAT:\r\n    case gl.FLOAT_VEC2:\r\n    case gl.FLOAT_VEC3:\r\n    case gl.FLOAT_VEC4:\r\n      return gl.FLOAT;\r\n    case gl.BYTE:\r\n      return gl.BYTE;\r\n    case gl.UNSIGNED_BYTE:\r\n      return gl.UNSIGNED_BYTE;\r\n    case gl.SHORT:\r\n      return gl.SHORT;\r\n    case gl.UNSIGNED_SHORT:\r\n      return gl.UNSIGNED_SHORT;\r\n    default:\r\n      return gl.FLOAT;\r\n  }\r\n}","import { Logger } from '../../Util/Log';\r\nimport { ImageFiltering } from '../Filtering';\r\nimport { HTMLImageSource } from './ExcaliburGraphicsContext';\r\nimport { ensurePowerOfTwo, isPowerOfTwo } from './webgl-util';\r\n\r\n/**\r\n * Manages loading image sources into webgl textures, a unique id is associated with all sources\r\n */\r\nexport class TextureLoader {\r\n  private static _LOGGER = Logger.getInstance();\r\n  /**\r\n   * Sets the default filtering for the Excalibur texture loader, default [[ImageFiltering.Blended]]\r\n   */\r\n  public static filtering: ImageFiltering = ImageFiltering.Blended;\r\n  private static _POT_CANVAS = document.createElement('canvas');\r\n  private static _POT_CTX = TextureLoader._POT_CANVAS.getContext('2d');\r\n\r\n  private static _GL: WebGLRenderingContext;\r\n\r\n  private static _TEXTURE_MAP = new Map<HTMLImageSource, WebGLTexture>();\r\n\r\n  private static _MAX_TEXTURE_SIZE: number  = 0;\r\n\r\n  public static register(context: WebGLRenderingContext): void {\r\n    TextureLoader._GL = context;\r\n    TextureLoader._MAX_TEXTURE_SIZE = context.getParameter(context.MAX_TEXTURE_SIZE);\r\n  }\r\n\r\n  /**\r\n   * Get the WebGL Texture from a source image\r\n   * @param image\r\n   */\r\n  public static get(image: HTMLImageSource): WebGLTexture {\r\n    return TextureLoader._TEXTURE_MAP.get(image);\r\n  }\r\n\r\n  /**\r\n   * Returns whether a source image has been loaded as a texture\r\n   * @param image\r\n   */\r\n  public static has(image: HTMLImageSource): boolean {\r\n    return TextureLoader._TEXTURE_MAP.has(image);\r\n  }\r\n\r\n  /**\r\n   * Loads a graphic into webgl and returns it's texture info, a webgl context must be previously registered\r\n   * @param image Source graphic\r\n   * @param filtering {ImageFiltering} The ImageFiltering mode to apply to the loaded texture\r\n   * @param forceUpdate Optionally force a texture to be reloaded, useful if the source graphic has changed\r\n   */\r\n  public static load(image: HTMLImageSource, filtering?: ImageFiltering, forceUpdate = false): WebGLTexture {\r\n    // Ignore loading if webgl is not registered\r\n    const gl = TextureLoader._GL;\r\n    if (!gl) {\r\n      return null;\r\n    }\r\n\r\n    let tex: WebGLTexture = null;\r\n    // If reuse the texture if it's from the same source\r\n    if (TextureLoader.has(image)) {\r\n      tex = TextureLoader.get(image);\r\n    }\r\n\r\n    // Update existing webgl texture and return early\r\n    if (tex) {\r\n      if (forceUpdate) {\r\n        gl.bindTexture(gl.TEXTURE_2D, tex);\r\n        const source = TextureLoader.toPowerOfTwoImage(image);\r\n        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, source);\r\n      }\r\n      return tex;\r\n    }\r\n\r\n    // No texture exists create a new one\r\n    tex = gl.createTexture();\r\n    const source = TextureLoader.toPowerOfTwoImage(image);\r\n\r\n    TextureLoader.checkImageSizeSupportedAndLog(image);\r\n\r\n    gl.bindTexture(gl.TEXTURE_2D, tex);\r\n\r\n    gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, true);\r\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\r\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\r\n\r\n    // NEAREST for pixel art, LINEAR for hi-res\r\n    const filterMode = filtering ?? TextureLoader.filtering;\r\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, filterMode === ImageFiltering.Pixel ? gl.NEAREST : gl.LINEAR);\r\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, filterMode === ImageFiltering.Pixel ? gl.NEAREST : gl.LINEAR);\r\n\r\n    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, source);\r\n\r\n    TextureLoader._TEXTURE_MAP.set(image, tex);\r\n    return tex;\r\n  }\r\n\r\n  public static delete(image: HTMLImageSource): void {\r\n    // Ignore loading if webgl is not registered\r\n    const gl = TextureLoader._GL;\r\n    if (!gl) {\r\n      return null;\r\n    }\r\n\r\n    let tex: WebGLTexture = null;\r\n    if (TextureLoader.has(image)) {\r\n      tex = TextureLoader.get(image);\r\n      gl.deleteTexture(tex);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Converts source images into power of two images, WebGL only supports POT images\r\n   * https://www.khronos.org/webgl/wiki/WebGL_and_OpenGL_Differences#Non-Power_of_Two_Texture_Support\r\n   * @param image\r\n   */\r\n  public static toPowerOfTwoImage(image: HTMLImageSource): HTMLImageSource {\r\n    const potCanvas = TextureLoader._POT_CANVAS;\r\n    const potCtx = TextureLoader._POT_CTX;\r\n    if (!isPowerOfTwo(image.width) || !isPowerOfTwo(image.height)) {\r\n      // Scale up the texture to the next highest power of two dimensions.\r\n\r\n      potCanvas.width = ensurePowerOfTwo(image.width);\r\n      potCanvas.height = ensurePowerOfTwo(image.height);\r\n      potCtx.imageSmoothingEnabled = false;\r\n      potCtx.clearRect(0, 0, potCanvas.width, potCanvas.height);\r\n      potCtx.drawImage(image, 0, 0, image.width, image.height);\r\n      image = potCanvas;\r\n    }\r\n    return image;\r\n  }\r\n\r\n  /**\r\n   * Takes an image and returns if it meets size criteria for hardware\r\n   * @param image\r\n   * @returns if the image will be supported at runtime\r\n   */\r\n  public static checkImageSizeSupportedAndLog(image: HTMLImageSource) {\r\n    const originalSrc = image.dataset.originalSrc ?? 'internal canvas bitmap';\r\n    if (image.width > TextureLoader._MAX_TEXTURE_SIZE || image.height > TextureLoader._MAX_TEXTURE_SIZE) {\r\n      TextureLoader._LOGGER.error(\r\n        `The image [${originalSrc}] provided to Excalibur is too large for the device's maximum texture size of `+\r\n        `(${TextureLoader._MAX_TEXTURE_SIZE}x${TextureLoader._MAX_TEXTURE_SIZE}) please resize to an image `\r\n        +`for excalibur to render properly.\\n\\nImages will likely render as black rectangles.\\n\\n`+\r\n        `Read more here: https://developer.mozilla.org/en-US/docs/Web/API/WebGL_API/WebGL_best_practices#understand_system_limits`);\r\n      return false;\r\n    } else if (image.width > 4096 || image.height > 4096) {\r\n      // https://developer.mozilla.org/en-US/docs/Web/API/WebGL_API/WebGL_best_practices#understand_system_limits\r\n      TextureLoader._LOGGER.warn(\r\n        `The image [${originalSrc}] provided to excalibur is too large may not work on all mobile devices, `+\r\n        `it is recommended you resize images to a maximum (4096x4096).\\n\\n` +\r\n        `Images will likely render as black rectangles on some mobile platforms.\\n\\n` +\r\n        `Read more here: https://developer.mozilla.org/en-US/docs/Web/API/WebGL_API/WebGL_best_practices#understand_system_limits`);\r\n    }\r\n    return true;\r\n  }\r\n}\r\n","import { Resource } from '../Resources/Resource';\r\nimport { Sprite } from './Sprite';\r\nimport { Loadable } from '../Interfaces/Index';\r\nimport { Logger } from '../Util/Log';\r\nimport { TextureLoader } from '.';\r\nimport { ImageFiltering } from './Filtering';\r\n\r\nexport class ImageSource implements Loadable<HTMLImageElement> {\r\n  private _logger = Logger.getInstance();\r\n  private _resource: Resource<Blob>;\r\n  private _filtering: ImageFiltering;\r\n\r\n  /**\r\n   * The original size of the source image in pixels\r\n   */\r\n  public get width() {\r\n    return this.image.naturalWidth;\r\n  }\r\n\r\n  /**\r\n   * The original height of the source image in pixels\r\n   */\r\n  public get height() {\r\n    return this.image.naturalHeight;\r\n  }\r\n\r\n  private _src: string;\r\n  /**\r\n   * Returns true if the Texture is completely loaded and is ready\r\n   * to be drawn.\r\n   */\r\n  public isLoaded(): boolean {\r\n    if (!this._src) {\r\n      // this boosts speed of access\r\n      this._src = this.data.src;\r\n    }\r\n    return !!this._src;\r\n  }\r\n\r\n  /**\r\n   * Access to the underlying html image element\r\n   */\r\n  public data: HTMLImageElement = new Image();\r\n  public get image(): HTMLImageElement {\r\n    return this.data;\r\n  }\r\n\r\n  /**\r\n   * Promise the resolves when the image is loaded and ready for use, does not initiate loading\r\n   */\r\n  public ready: Promise<HTMLImageElement>;\r\n  private _loadedResolve: (value?: HTMLImageElement | PromiseLike<HTMLImageElement>) => void;\r\n\r\n  /**\r\n   * The path to the image, can also be a data url like 'data:image/'\r\n   * @param path {string} Path to the image resource relative from the HTML document hosting the game, or absolute\r\n   * @param bustCache {boolean} Should excalibur add a cache busting querystring?\r\n   * @param filtering {ImageFiltering} Optionally override the image filtering set by [[EngineOptions.antialiasing]]\r\n   */\r\n  constructor(public readonly path: string, bustCache: boolean = false, filtering?: ImageFiltering) {\r\n    this._resource = new Resource(path, 'blob', bustCache);\r\n    this._filtering = filtering;\r\n    if (path.endsWith('.svg') || path.endsWith('.gif')) {\r\n      this._logger.warn(`Image type is not fully supported, you may have mixed results ${path}. Fully supported: jpg, bmp, and png`);\r\n    }\r\n    this.ready = new Promise<HTMLImageElement>((resolve) => {\r\n      this._loadedResolve = resolve;\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Begins loading the image and returns a promise that resolves when the image is loaded\r\n   */\r\n  async load(): Promise<HTMLImageElement> {\r\n    if (this.isLoaded()) {\r\n      return this.data;\r\n    }\r\n    try {\r\n      // Load base64 or blob if needed\r\n      let url: string;\r\n      if (!this.path.includes('data:image/')) {\r\n        const blob = await this._resource.load();\r\n        url = URL.createObjectURL(blob);\r\n      } else {\r\n        url = this.path;\r\n      }\r\n\r\n      // Decode the image\r\n      const image = new Image();\r\n      image.src = url;\r\n      image.setAttribute('data-original-src', this.path);\r\n      await image.decode();\r\n\r\n      // Set results\r\n      this.data = image;\r\n    } catch (error) {\r\n      throw `Error loading ImageSource from path '${this.path}' with error [${error.message}]`;\r\n    }\r\n    TextureLoader.load(this.data, this._filtering);\r\n    // todo emit complete\r\n    this._loadedResolve(this.data);\r\n    return this.data;\r\n  }\r\n\r\n  /**\r\n   * Build a sprite from this ImageSource\r\n   */\r\n  public toSprite(): Sprite {\r\n    return Sprite.from(this);\r\n  }\r\n\r\n  /**\r\n   * Unload images from memory\r\n   */\r\n  unload(): void {\r\n    this.data = new Image();\r\n  }\r\n}\r\n","import { ImageSource } from './ImageSource';\r\nimport { SourceView, Sprite } from './Sprite';\r\nimport { Logger } from '../Util/Log';\r\n\r\n/**\r\n * Specify sprite sheet spacing options, useful if your sprites are not tightly packed\r\n * and have space between them.\r\n */\r\nexport interface SpriteSheetSpacingDimensions {\r\n  /**\r\n   * The starting point to offset and start slicing the sprite sheet from the top left of the image.\r\n   * Default is (0, 0)\r\n   */\r\n  originOffset?: { x?: number, y?: number };\r\n\r\n  /**\r\n   * The margin between sprites.\r\n   * Default is (0, 0)\r\n   */\r\n  margin?: {x?: number, y?: number};\r\n}\r\n\r\n/**\r\n * Sprite sheet options for slicing up images\r\n */\r\nexport interface SpriteSheetGridOptions {\r\n  /**\r\n   * Source image to use for each sprite\r\n   */\r\n  image: ImageSource;\r\n  /**\r\n   * Grid definition for the sprite sheet\r\n   */\r\n  grid: {\r\n    /**\r\n     * Number of rows in the sprite sheet\r\n     */\r\n    rows: number;\r\n    /**\r\n     * Number of columns in the sprite sheet\r\n     */\r\n    columns: number;\r\n    /**\r\n     * Width of each individual sprite\r\n     */\r\n    spriteWidth: number;\r\n    /**\r\n     * Height of each individual sprite\r\n     */\r\n    spriteHeight: number;\r\n  };\r\n  /**\r\n   * Optionally specify any spacing information between sprites\r\n   */\r\n  spacing?: SpriteSheetSpacingDimensions;\r\n}\r\n\r\nexport interface SpriteSheetSparseOptions {\r\n  /**\r\n   * Source image to use for each sprite\r\n   */\r\n  image: ImageSource;\r\n  /**\r\n   * List of source view rectangles to create a sprite sheet from\r\n   */\r\n  sourceViews: SourceView[];\r\n}\r\n\r\nexport interface SpriteSheetOptions {\r\n  /**\r\n   * Source sprites for the sprite sheet\r\n   */\r\n  sprites: Sprite[];\r\n  /**\r\n   * Optionally specify the number of rows in a sprite sheet (default 1 row)\r\n   */\r\n  rows?: number;\r\n  /**\r\n   * Optionally specify the number of columns in a sprite sheet (default sprites.length)\r\n   */\r\n  columns?: number;\r\n}\r\n\r\n/**\r\n * Represents a collection of sprites from a source image with some organization in a grid\r\n */\r\nexport class SpriteSheet {\r\n  private _logger = Logger.getInstance();\r\n  public readonly sprites: Sprite[] = [];\r\n  public readonly rows: number;\r\n  public readonly columns: number;\r\n\r\n  /**\r\n   * Build a new sprite sheet from a list of sprites\r\n   *\r\n   * Use [[SpriteSheet.fromImageSource]] to create a SpriteSheet from an [[ImageSource]] organized in a grid\r\n   * @param options\r\n   */\r\n  constructor(options: SpriteSheetOptions) {\r\n    const { sprites, rows, columns } = options;\r\n    this.sprites = sprites;\r\n    this.rows = rows ?? 1;\r\n    this.columns = columns ?? this.sprites.length;\r\n  }\r\n\r\n  /**\r\n   * Find a sprite by their x/y position in the SpriteSheet, for example `getSprite(0, 0)` is the [[Sprite]] in the top-left\r\n   * @param x\r\n   * @param y\r\n   */\r\n  public getSprite(x: number, y: number): Sprite | null {\r\n    if (x >= this.columns || x < 0) {\r\n      this._logger.warn(`No sprite exists in the SpriteSheet at (${x}, ${y}), x: ${x} should be between 0 and ${this.columns - 1}`);\r\n      return null;\r\n    }\r\n    if (y >= this.rows || y < 0) {\r\n      this._logger.warn(`No sprite exists in the SpriteSheet at (${x}, ${y}), y: ${y} should be between 0 and ${this.rows - 1}`);\r\n      return null;\r\n    }\r\n    const spriteIndex = x + y * this.columns;\r\n    return this.sprites[spriteIndex];\r\n  }\r\n\r\n  /**\r\n   * Create a sprite sheet from a sparse set of [[SourceView]] rectangles\r\n   * @param options\r\n   */\r\n  public static fromImageSourceWithSourceViews(options: SpriteSheetSparseOptions): SpriteSheet {\r\n    const sprites: Sprite[] = options.sourceViews.map(sourceView => {\r\n      return new Sprite({\r\n        image: options.image,\r\n        sourceView\r\n      });\r\n    });\r\n    return new SpriteSheet({sprites});\r\n  }\r\n\r\n  /**\r\n   * Create a SpriteSheet from an [[ImageSource]] organized in a grid\r\n   *\r\n   * Example:\r\n   * ```\r\n   * const spriteSheet = SpriteSheet.fromImageSource({\r\n   *   image: imageSource,\r\n   *   grid: {\r\n   *     rows: 5,\r\n   *     columns: 2,\r\n   *     spriteWidth: 32, // pixels\r\n   *     spriteHeight: 32 // pixels\r\n   *   },\r\n   *   // Optionally specify spacing\r\n   *   spacing: {\r\n   *     // pixels from the top left to start the sprite parsing\r\n   *     originOffset: {\r\n   *       x: 5,\r\n   *       y: 5\r\n   *     },\r\n   *     // pixels between each sprite while parsing\r\n   *     margin: {\r\n   *       x: 1,\r\n   *       y: 1\r\n   *     }\r\n   *   }\r\n   * })\r\n   * ```\r\n   *\r\n   * @param options\r\n   */\r\n  public static fromImageSource(options: SpriteSheetGridOptions): SpriteSheet {\r\n    const sprites: Sprite[] = [];\r\n    options.spacing = options.spacing ?? {};\r\n    const {\r\n      image,\r\n      grid: { rows, columns: cols, spriteWidth, spriteHeight },\r\n      spacing: { originOffset, margin }\r\n    } = options;\r\n    const offsetDefaults = { x: 0, y: 0, ...originOffset};\r\n    const marginDefaults = { x: 0, y: 0, ...margin};\r\n    for (let x = 0; x < cols; x++) {\r\n      for (let y = 0; y < rows; y++) {\r\n        sprites[x + y * cols] = new Sprite({\r\n          image: image,\r\n          sourceView: {\r\n            x: x * spriteWidth + marginDefaults.x * x + offsetDefaults.x,\r\n            y: y * spriteHeight + marginDefaults.y * y + offsetDefaults.y,\r\n            width: spriteWidth,\r\n            height: spriteHeight\r\n          },\r\n          destSize: { height: spriteHeight, width: spriteWidth }\r\n        });\r\n      }\r\n    }\r\n    return new SpriteSheet({\r\n      sprites: sprites,\r\n      rows: rows,\r\n      columns: cols\r\n    });\r\n  }\r\n}\r\n","import { Vector } from '../Math/vector';\r\nimport { Logger } from '../Util/Log';\r\nimport { ExcaliburGraphicsContext } from './Context/ExcaliburGraphicsContext';\r\nimport { FontRenderer } from './FontCommon';\r\nimport { Graphic, GraphicOptions } from './Graphic';\r\nimport { Sprite } from './Sprite';\r\nimport { SpriteSheet } from './SpriteSheet';\r\nimport { BoundingBox, Color } from '..';\r\n\r\nexport interface SpriteFontOptions {\r\n  /**\r\n   * Alphabet string in spritesheet order (default is row column order)\r\n   * example: 'abcdefghijklmnopqrstuvwxyz'\r\n   */\r\n  alphabet: string;\r\n  /**\r\n   * [[SpriteSheet]] to source character sprites from\r\n   */\r\n  spriteSheet: SpriteSheet;\r\n  /**\r\n   * Optionally ignore case in the supplied text;\r\n   */\r\n  caseInsensitive?: boolean;\r\n  /**\r\n   * Optionally adjust the spacing between character sprites\r\n   */\r\n  spacing?: number;\r\n  /**\r\n   * Optionally specify a \"shadow\"\r\n   */\r\n  shadow?: { offset: Vector };\r\n}\r\n\r\nexport class SpriteFont extends Graphic implements FontRenderer {\r\n  private _text: string = '';\r\n  public alphabet: string = '';\r\n  public spriteSheet: SpriteSheet;\r\n\r\n  public shadow: { offset: Vector } = null;\r\n  public caseInsensitive = false;\r\n  public spacing: number = 0;\r\n\r\n  private _logger = Logger.getInstance();\r\n\r\n  constructor(options: SpriteFontOptions & GraphicOptions) {\r\n    super(options);\r\n    const { alphabet, spriteSheet, caseInsensitive, spacing, shadow } = options;\r\n    this.alphabet = alphabet;\r\n    this.spriteSheet = spriteSheet;\r\n    this.caseInsensitive = caseInsensitive ?? this.caseInsensitive;\r\n    this.spacing = spacing ?? this.spacing;\r\n    this.shadow = shadow ?? this.shadow;\r\n  }\r\n\r\n  private _alreadyWarnedAlphabet = false;\r\n  private _alreadyWarnedSpriteSheet = false;\r\n  private _getCharacterSprites(text: string): Sprite[] {\r\n    const results: Sprite[] = [];\r\n    // handle case insensitive\r\n    const textToRender = this.caseInsensitive ? text.toLocaleLowerCase() : text;\r\n    const alphabet = this.caseInsensitive ? this.alphabet.toLocaleLowerCase() : this.alphabet;\r\n\r\n    // for each letter in text\r\n    for (let letterIndex = 0; letterIndex < textToRender.length; letterIndex++) {\r\n      // find the sprite index in alphabet , if there is an error pick the first\r\n      const letter = textToRender[letterIndex];\r\n      let spriteIndex = alphabet.indexOf(letter);\r\n      if (spriteIndex === -1) {\r\n        spriteIndex = 0;\r\n        if (!this._alreadyWarnedAlphabet) {\r\n          this._logger.warn(`SpriteFont - Cannot find letter '${letter}' in configured alphabet '${alphabet}'.`);\r\n          this._logger.warn('There maybe be more issues in the SpriteFont configuration. No additional warnings will be logged.');\r\n          this._alreadyWarnedAlphabet = true;\r\n        }\r\n      }\r\n\r\n      const letterSprite = this.spriteSheet.sprites[spriteIndex];\r\n      if (letterSprite) {\r\n        results.push(letterSprite);\r\n      } else {\r\n        if (!this._alreadyWarnedSpriteSheet) {\r\n          this._logger.warn(`SpriteFont - Cannot find sprite for '${letter}' at index '${spriteIndex}' in configured SpriteSheet`);\r\n          this._logger.warn('There maybe be more issues in the SpriteFont configuration. No additional warnings will be logged.');\r\n          this._alreadyWarnedSpriteSheet = true;\r\n        }\r\n      }\r\n    }\r\n    return results;\r\n  }\r\n\r\n  public measureText(text: string): BoundingBox {\r\n    const lines = text.split('\\n');\r\n    const maxWidthLine = lines.reduce((a, b) => {\r\n      return a.length > b.length ? a : b;\r\n    });\r\n    const sprites = this._getCharacterSprites(maxWidthLine);\r\n    let width = 0;\r\n    let height = 0;\r\n    for (const sprite of sprites) {\r\n      width += sprite.width + this.spacing;\r\n      height = Math.max(height, sprite.height);\r\n    }\r\n    return BoundingBox.fromDimension(width, height * lines.length, Vector.Zero);\r\n  }\r\n\r\n  protected _drawImage(ex: ExcaliburGraphicsContext, x: number, y: number): void {\r\n    let xCursor = 0;\r\n    let yCursor = 0;\r\n    let height = 0;\r\n    const lines = this._text.split('\\n');\r\n    for (const line of lines) {\r\n      for (const sprite of this._getCharacterSprites(line)) {\r\n        // draw it in the right spot and increase the cursor by sprite width\r\n        sprite.draw(ex, x + xCursor, y + yCursor);\r\n        xCursor += sprite.width + this.spacing;\r\n        height = Math.max(height, sprite.height);\r\n      }\r\n      xCursor = 0;\r\n      yCursor += height;\r\n    }\r\n  }\r\n\r\n  render(ex: ExcaliburGraphicsContext, text: string, _color: Color, x: number, y: number) {\r\n    // SpriteFont doesn't support _color, yet...\r\n    this._text = text;\r\n    const bounds = this.measureText(text);\r\n    this.width = bounds.width;\r\n    this.height = bounds.height;\r\n    if (this.shadow) {\r\n      ex.save();\r\n      ex.translate(this.shadow.offset.x, this.shadow.offset.y);\r\n      this.draw(ex, x, y);\r\n      ex.restore();\r\n    }\r\n\r\n    this.draw(ex, x, y);\r\n  }\r\n\r\n  clone(): SpriteFont {\r\n    return new SpriteFont({\r\n      alphabet: this.alphabet,\r\n      spriteSheet: this.spriteSheet,\r\n      spacing: this.spacing\r\n    });\r\n  }\r\n}\r\n","import { ExcaliburGraphicsContext, ImageSource, SpriteFont, SpriteSheet } from '..';\r\nimport { Vector } from '../..';\r\nimport debugFont from './debug-font.png';\r\n\r\n/**\r\n * Internal debugtext helper\r\n */\r\nexport class DebugText {\r\n  constructor() {\r\n    this.load();\r\n  }\r\n\r\n  /**\r\n   * base64 font\r\n   */\r\n  public readonly fontSheet = debugFont;\r\n  public size: number = 16;\r\n  private _imageSource: ImageSource;\r\n  private _spriteSheet: SpriteSheet;\r\n  private _spriteFont: SpriteFont;\r\n  public load() {\r\n    this._imageSource = new ImageSource(this.fontSheet);\r\n    return this._imageSource.load().then(() => {\r\n      this._spriteSheet = SpriteSheet.fromImageSource({\r\n        image: this._imageSource,\r\n        grid: {\r\n          rows: 3,\r\n          columns: 16,\r\n          spriteWidth: 16,\r\n          spriteHeight: 16\r\n        }\r\n      });\r\n      this._spriteFont = new SpriteFont({\r\n        alphabet: '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ,!\\'&.\"?-()+ ',\r\n        caseInsensitive: true,\r\n        spriteSheet: this._spriteSheet,\r\n        spacing: -6\r\n      });\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Writes debug text using the built in sprint font\r\n   * @param ctx\r\n   * @param text\r\n   * @param pos\r\n   */\r\n  public write(ctx: ExcaliburGraphicsContext, text: string, pos: Vector) {\r\n    if (this._imageSource.isLoaded()) {\r\n      this._spriteFont.render(ctx, text, null, pos.x, pos.y);\r\n    }\r\n  }\r\n}\r\n","export class RenderSource {\r\n  constructor(\r\n    private _gl: WebGLRenderingContext,\r\n    private _texture: WebGLTexture) {}\r\n\r\n  public use() {\r\n    const gl = this._gl;\r\n    gl.activeTexture(gl.TEXTURE0);\r\n    gl.bindTexture(gl.TEXTURE_2D, this._texture);\r\n  }\r\n\r\n  public disable() {\r\n    const gl = this._gl;\r\n    gl.bindTexture(gl.TEXTURE_2D, null);\r\n  }\r\n}","import { RenderSource } from './render-source';\r\n\r\nexport class RenderTarget {\r\n  width: number;\r\n  height: number;\r\n  private _gl: WebGLRenderingContext;\r\n  constructor(options: {gl: WebGLRenderingContext, width: number, height: number}) {\r\n    this.width = options.width;\r\n    this.height = options.height;\r\n    this._gl = options.gl;\r\n    this._setupFramebuffer();\r\n  }\r\n\r\n  setResolution(width: number, height: number) {\r\n    const gl = this._gl;\r\n    this.width = width;\r\n    this.height = height;\r\n    gl.bindTexture(gl.TEXTURE_2D, this._frameTexture);\r\n    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, this.width, this.height, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);\r\n  }\r\n\r\n  private _frameBuffer: WebGLFramebuffer;\r\n  public get frameBuffer() {\r\n    return this._frameBuffer;\r\n  }\r\n  private _frameTexture: WebGLTexture;\r\n  public get frameTexture() {\r\n    return this._frameTexture;\r\n  }\r\n  private _setupFramebuffer() {\r\n    // Allocates frame buffer\r\n    const gl = this._gl;\r\n    this._frameTexture = gl.createTexture();\r\n    gl.bindTexture(gl.TEXTURE_2D, this._frameTexture);\r\n    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, this.width, this.height, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);\r\n\r\n    // set the filtering so we don't need mips\r\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);\r\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);\r\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\r\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\r\n\r\n\r\n    // attach the texture as the first color attachment\r\n    const attachmentPoint = gl.COLOR_ATTACHMENT0;\r\n\r\n    // After this bind all draw calls will draw to this framebuffer texture\r\n    this._frameBuffer = gl.createFramebuffer();\r\n    gl.bindFramebuffer(gl.FRAMEBUFFER, this._frameBuffer);\r\n    gl.framebufferTexture2D(gl.FRAMEBUFFER, attachmentPoint, gl.TEXTURE_2D, this._frameTexture, 0);\r\n    // Reset after initialized\r\n    this.disable();\r\n  }\r\n\r\n  public toRenderSource() {\r\n    const source = new RenderSource(this._gl, this._frameTexture);\r\n    return source;\r\n  }\r\n\r\n  /**\r\n   * When called, all drawing gets redirected to this render target\r\n   */\r\n  public use() {\r\n    const gl = this._gl;\r\n    gl.bindFramebuffer(gl.FRAMEBUFFER, this._frameBuffer);\r\n    // very important to set the viewport to the size of the framebuffer texture\r\n    gl.viewport(0, 0, this.width, this.height);\r\n  }\r\n\r\n  /**\r\n   * When called, all drawing is sent back to the canvas\r\n   */\r\n  public disable() {\r\n    const gl = this._gl;\r\n    // passing null switches rendering back to the canvas\r\n    gl.bindFramebuffer(gl.FRAMEBUFFER, null);\r\n    gl.bindTexture(gl.TEXTURE_2D, null);\r\n  }\r\n}","\r\n/**\r\n * Must be accessed after Engine construction time to ensure the context has been created\r\n */\r\nexport class ExcaliburWebGLContextAccessor {\r\n  private static _GL: WebGL2RenderingContext;\r\n  public static clear() {\r\n    ExcaliburWebGLContextAccessor._GL = null;\r\n  }\r\n  public static register(gl: WebGL2RenderingContext) {\r\n    ExcaliburWebGLContextAccessor._GL = gl;\r\n  }\r\n  // current webgl context\r\n  public static get gl(): WebGL2RenderingContext {\r\n    if (!ExcaliburWebGLContextAccessor._GL) {\r\n      throw Error('Attempted gl access before init');\r\n    }\r\n    return ExcaliburWebGLContextAccessor._GL;\r\n  }\r\n}","import { Vector } from '../..';\r\nimport { Matrix } from '../../Math/matrix';\r\nimport { ExcaliburWebGLContextAccessor } from './webgl-adapter';\r\nimport { getAttributeComponentSize, getAttributePointerType } from './webgl-util';\r\n\r\nexport type UniformTypeNames =\r\n  'uniform1f' |\r\n  'uniform1i' |\r\n  'uniform2f' |\r\n  'uniform2i' |\r\n  'uniform3f' |\r\n  'uniform3i' |\r\n  'uniform4f' |\r\n  'uniform4i' |\r\n  'uniform1fv' |\r\n  'uniform1iv' |\r\n  'uniform2fv' |\r\n  'uniform2iv' |\r\n  'uniform3fv' |\r\n  'uniform3iv' |\r\n  'uniform4fv' |\r\n  'uniform4iv' |\r\n  'uniformMatrix2fv' |\r\n  'uniformMatrix3fv' |\r\n  'uniformMatrix4fv';\r\n\r\ntype RemoveFirstFromTuple<T extends any[]> =\r\n  T['length'] extends 0 ? undefined :\r\n    (((...b: T) => void) extends (a: any, ...b: infer I) => void ? I : [])\r\n\r\ntype UniformParameters<TUniformType extends UniformTypeNames> = RemoveFirstFromTuple<Parameters<WebGLRenderingContext[TUniformType]>>\r\n\r\nexport interface UniformDefinition {\r\n  name: string;\r\n  glType: number;\r\n  location: WebGLUniformLocation;\r\n}\r\n\r\n\r\nexport interface VertexAttributeDefinition {\r\n  /**\r\n   * string name of the attribute in the shader program, commonly `a_nameofmyvariable`\r\n   */\r\n  name: string;\r\n  /**\r\n   * Number of components for a given attribute\r\n   * Must be 1, 2, 3, or 4\r\n   *\r\n   * For example a vec4 attribute would be `4` floats, so 4\r\n   */\r\n  size: number;\r\n  /**\r\n   * Supported types in webgl 1\r\n   * * gl.BYTE\r\n   * * gl.SHORT\r\n   * * gl.UNSIGNED_BYTE\r\n   * * gl.UNSIGNED_SHORT\r\n   * * gl.FLOAT\r\n   * https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/vertexAttribPointer\r\n   */\r\n  glType: number;\r\n  /**\r\n   * Is the attribute normalized between (0-1)\r\n   */\r\n  normalized: boolean;\r\n  /**\r\n   * Location index in the shader program\r\n   */\r\n  location: number;\r\n}\r\n\r\nexport interface ShaderOptions {\r\n  vertexSource: string;\r\n  fragmentSource: string;\r\n}\r\n\r\nexport class Shader {\r\n  private static _ACTIVE_SHADER_INSTANCE: Shader = null;\r\n  private _gl: WebGLRenderingContext = ExcaliburWebGLContextAccessor.gl;\r\n  public program: WebGLProgram;\r\n  public uniforms: { [variableName: string]: UniformDefinition } = {};\r\n  public attributes: { [variableName: string]: VertexAttributeDefinition } = {};\r\n  private _compiled = false;\r\n  public readonly vertexSource: string;\r\n  public readonly fragmentSource: string;\r\n\r\n  public get compiled() {\r\n    return this._compiled;\r\n  }\r\n\r\n  /**\r\n   * Create a shader program in excalibur\r\n   * @param options specify shader vertex and fragment source\r\n   */\r\n  constructor(options?: ShaderOptions) {\r\n    const { vertexSource, fragmentSource } = options;\r\n    this.vertexSource = vertexSource;\r\n    this.fragmentSource = fragmentSource;\r\n  }\r\n\r\n  /**\r\n   * Binds the shader program\r\n   */\r\n  use() {\r\n    const gl = this._gl;\r\n    gl.useProgram(this.program);\r\n    Shader._ACTIVE_SHADER_INSTANCE = this;\r\n  }\r\n\r\n  isCurrentlyBound() {\r\n    return Shader._ACTIVE_SHADER_INSTANCE === this;\r\n  }\r\n\r\n  /**\r\n   * Compile the current shader against a webgl context\r\n   */\r\n  compile(): WebGLProgram {\r\n    const gl = this._gl;\r\n    const vertexShader = this._compileShader(gl, this.vertexSource, gl.VERTEX_SHADER);\r\n    const fragmentShader = this._compileShader(gl, this.fragmentSource, gl.FRAGMENT_SHADER);\r\n    this.program = this._createProgram(gl, vertexShader, fragmentShader);\r\n\r\n    const attributes = this.getAttributes();\r\n    for (const attribute of attributes) {\r\n      this.attributes[attribute.name] = attribute;\r\n    }\r\n    const uniforms = this.getUniforms();\r\n    for (const uniform of uniforms) {\r\n      this.uniforms[uniform.name] = uniform;\r\n    }\r\n\r\n    this._compiled = true;\r\n    return this.program;\r\n  }\r\n\r\n  getUniforms(): UniformDefinition[] {\r\n    const gl = this._gl;\r\n    const uniformCount = gl.getProgramParameter(this.program, gl.ACTIVE_UNIFORMS);\r\n    const uniforms: UniformDefinition[] = [];\r\n    for (let i = 0; i < uniformCount; i++) {\r\n      const uniform = gl.getActiveUniform(this.program, i);\r\n      const uniformLocation = gl.getUniformLocation(this.program, uniform.name);\r\n      uniforms.push({\r\n        name: uniform.name,\r\n        glType: uniform.type,\r\n        location: uniformLocation\r\n      });\r\n    }\r\n    return uniforms;\r\n  }\r\n\r\n  getAttributes(): VertexAttributeDefinition[] {\r\n    const gl = this._gl;\r\n    const attributeCount = gl.getProgramParameter(this.program, gl.ACTIVE_ATTRIBUTES);\r\n    const attributes: VertexAttributeDefinition[] = [];\r\n    for (let i = 0; i < attributeCount; i++) {\r\n      const attribute = gl.getActiveAttrib(this.program, i);\r\n      const attributeLocation = gl.getAttribLocation(this.program, attribute.name);\r\n      attributes.push({\r\n        name: attribute.name,\r\n        glType: getAttributePointerType(gl, attribute.type),\r\n        size: getAttributeComponentSize(gl, attribute.type),\r\n        location: attributeLocation,\r\n        normalized: false\r\n      });\r\n    }\r\n    return attributes;\r\n  }\r\n\r\n  /**\r\n   * Set a texture in a gpu texture slot\r\n   * @param slotNumber\r\n   * @param texture\r\n   */\r\n  setTexture(slotNumber: number, texture: WebGLTexture) {\r\n    const gl = this._gl;\r\n    gl.activeTexture(gl.TEXTURE0 + slotNumber);\r\n    gl.bindTexture(gl.TEXTURE_2D, texture);\r\n  }\r\n\r\n  /**\r\n   * Set an integer uniform for the current shader\r\n   *\r\n   * **Important** Must call ex.Shader.use() before setting a uniform!\r\n   *\r\n   * @param name\r\n   * @param value\r\n   */\r\n  setUniformInt(name: string, value: number) {\r\n    this.setUniform('uniform1i', name, ~~value);\r\n  }\r\n\r\n  /**\r\n   * Set an integer array uniform for the current shader\r\n   *\r\n   * **Important** Must call ex.Shader.use() before setting a uniform!\r\n   *\r\n   * @param name\r\n   * @param value\r\n   */\r\n  setUniformIntArray(name: string, value: number[]) {\r\n    this.setUniform('uniform1iv', name, value);\r\n  }\r\n\r\n  /**\r\n   * Set a boolean uniform for the current shader\r\n   *\r\n   * **Important** Must call ex.Shader.use() before setting a uniform!\r\n   *\r\n   * @param name\r\n   * @param value\r\n   */\r\n  setUniformBoolean(name: string, value: boolean) {\r\n    this.setUniform('uniform1i', name, value ? 1 : 0);\r\n  }\r\n\r\n  /**\r\n   * Set a float uniform for the current shader\r\n   *\r\n   * **Important** Must call ex.Shader.use() before setting a uniform!\r\n   *\r\n   * @param name\r\n   * @param value\r\n   */\r\n  setUniformFloat(name: string, value: number) {\r\n    this.setUniform('uniform1f', name, value);\r\n  }\r\n\r\n  /**\r\n   * Set a float array uniform for the current shader\r\n   *\r\n   * **Important** Must call ex.Shader.use() before setting a uniform!\r\n   *\r\n   * @param name\r\n   * @param value\r\n   */\r\n  setUniformFloatArray(name: string, value: number[]) {\r\n    this.setUniform('uniform1fv', name, value);\r\n  }\r\n\r\n  /**\r\n   * Set a [[Vector]] uniform for the current shader\r\n   *\r\n   * **Important** Must call ex.Shader.use() before setting a uniform!\r\n   *\r\n   * @param name\r\n   * @param value\r\n   */\r\n  setUniformFloatVector(name: string, value: Vector) {\r\n    this.setUniform('uniform2f', name, value.x, value.y);\r\n  }\r\n\r\n  /**\r\n   * Set an [[Matrix]] uniform for the current shader\r\n   *\r\n   * **Important** Must call ex.Shader.use() before setting a uniform!\r\n   *\r\n   * @param name\r\n   * @param value\r\n   */\r\n  setUniformMatrix(name: string, value: Matrix) {\r\n    this.setUniform('uniformMatrix4fv', name, false, value.data);\r\n  }\r\n\r\n  /**\r\n   * Set any available uniform type in webgl\r\n   *\r\n   * For example setUniform('uniformMatrix2fv', 'u_my2x2_mat`, ...);\r\n   */\r\n  setUniform<TUniformType extends UniformTypeNames>(uniformType: TUniformType, name: string, ...value: UniformParameters<TUniformType>) {\r\n    if (!this._compiled) {\r\n      throw Error(`Must compile shader before setting a uniform ${uniformType}:${name}`);\r\n    }\r\n    if (!this.isCurrentlyBound()) {\r\n      throw Error('Currently accessed shader instance is not the current active shader in WebGL,' +\r\n      ' must call `shader.use()` before setting uniforms');\r\n    }\r\n    const gl = this._gl;\r\n    const location = gl.getUniformLocation(this.program, name);\r\n    if (location) {\r\n      const args = [location, ...value];\r\n      this._gl[uniformType].apply(this._gl, args);\r\n    } else {\r\n      throw Error(`Uniform ${uniformType}:${name} doesn\\'t exist or is not used in the shader source code,`+\r\n      ' unused uniforms are optimized away by most browsers');\r\n    }\r\n  }\r\n\r\n  private _createProgram(gl: WebGLRenderingContext, vertexShader: WebGLShader, fragmentShader: WebGLShader): WebGLProgram {\r\n    const program = gl.createProgram();\r\n    if (program === null) {\r\n      throw Error('Could not create graphics shader program');\r\n    }\r\n\r\n    // attach the shaders.\r\n    gl.attachShader(program, vertexShader);\r\n    gl.attachShader(program, fragmentShader);\r\n\r\n    // link the program.\r\n    gl.linkProgram(program);\r\n\r\n    const success = gl.getProgramParameter(program, gl.LINK_STATUS);\r\n    if (!success) {\r\n      throw Error(`Could not link the program: [${gl.getProgramInfoLog(program)}]`);\r\n    }\r\n\r\n    return program;\r\n  }\r\n\r\n  private _compileShader(gl: WebGLRenderingContext, source: string, type: number): WebGLShader {\r\n    const typeName = gl.VERTEX_SHADER === type ? 'vertex' : 'fragment';\r\n    const shader = gl.createShader(type);\r\n    if (shader === null) {\r\n      throw Error(`Could not build shader: [${source}]`);\r\n    }\r\n\r\n    gl.shaderSource(shader, source);\r\n    gl.compileShader(shader);\r\n\r\n    const success = gl.getShaderParameter(shader, gl.COMPILE_STATUS);\r\n    if (!success) {\r\n      const errorInfo = gl.getShaderInfoLog(shader);\r\n      throw Error(`Could not compile ${typeName} shader:\\n\\n${errorInfo}${this._processSourceForError(source, errorInfo)}`);\r\n    }\r\n    return shader;\r\n  }\r\n\r\n  private _processSourceForError(source: string, errorInfo: string) {\r\n    const lines = source.split('\\n');\r\n    const errorLineStart = errorInfo.search(/\\d:\\d/);\r\n    const errorLineEnd = errorInfo.indexOf(' ', errorLineStart);\r\n    const [_, error2] = errorInfo.slice(errorLineStart, errorLineEnd).split(':').map(v => Number(v));\r\n    for (let i = 0; i < lines.length; i++) {\r\n      lines[i] = `${i+1}: ${lines[i]}${error2 === (i+1)? ' <----- ERROR!' : ''}`;\r\n    }\r\n\r\n    return '\\n\\nSource:\\n' + lines.join('\\n');\r\n  }\r\n}","import { ExcaliburWebGLContextAccessor } from './webgl-adapter';\r\n\r\nexport interface VertexBufferOptions {\r\n  /**\r\n   * Size in number of floats, so [4.2, 4.0, 2.1] is size = 3\r\n   *\r\n   * Ignored if data is passed directly\r\n   */\r\n  size?: number;\r\n  /**\r\n   * If the vertices never change switching 'static' can be more efficient on the gpu\r\n   *\r\n   * Default is 'dynamic'\r\n   */\r\n  type?: 'static' | 'dynamic';\r\n\r\n  /**\r\n   * Optionally pass pre-seeded data, size parameter is ignored\r\n   */\r\n  data?: Float32Array\r\n}\r\n\r\n/**\r\n * Helper around vertex buffer to simplify creating and uploading geometry\r\n *\r\n * Under the hood uses Float32Array\r\n */\r\nexport class VertexBuffer {\r\n  private _gl: WebGL2RenderingContext = ExcaliburWebGLContextAccessor.gl;\r\n\r\n  /**\r\n   * Access to the webgl buffer handle\r\n   */\r\n  public readonly buffer: WebGLBuffer;\r\n  /**\r\n   * Access to the raw data of the vertex buffer\r\n   */\r\n  public readonly bufferData: Float32Array;\r\n\r\n  /**\r\n   * If the vertices never change switching 'static' can be more efficient on the gpu\r\n   *\r\n   * Default is 'dynamic'\r\n   */\r\n  public type: 'static' | 'dynamic' = 'dynamic';\r\n\r\n  constructor(options: VertexBufferOptions) {\r\n    const { size, type, data } = options;\r\n    this.buffer = this._gl.createBuffer();\r\n    if (!data && !size) {\r\n      throw Error('Must either provide data or a size to the VertexBuffer');\r\n    }\r\n\r\n    if (!data) {\r\n      this.bufferData = new Float32Array(size);\r\n    } else {\r\n      this.bufferData = data;\r\n    }\r\n    this.type = type ?? this.type;\r\n    // Allocate buffer\r\n    const gl = this._gl;\r\n    gl.bindBuffer(gl.ARRAY_BUFFER, this.buffer);\r\n    gl.bufferData(gl.ARRAY_BUFFER, this.bufferData, this.type === 'static' ? gl.STATIC_DRAW : gl.DYNAMIC_DRAW);\r\n  }\r\n\r\n  /**\r\n   * Bind this vertex buffer\r\n   */\r\n  bind() {\r\n    const gl = this._gl;\r\n    gl.bindBuffer(gl.ARRAY_BUFFER, this.buffer);\r\n\r\n  }\r\n\r\n  /**\r\n   * Upload vertex buffer geometry to the GPU\r\n   */\r\n  upload(count?: number) {\r\n    const gl = this._gl;\r\n    gl.bindBuffer(gl.ARRAY_BUFFER, this.buffer);\r\n    if (count) {\r\n      gl.bufferSubData(gl.ARRAY_BUFFER, 0, this.bufferData, 0, count);\r\n    } else {\r\n      // TODO always use bufferSubData? need to perf test it\r\n      gl.bufferData(gl.ARRAY_BUFFER, this.bufferData, this.type === 'static' ? gl.STATIC_DRAW : gl.DYNAMIC_DRAW);\r\n    }\r\n  }\r\n}","import { Logger } from '../..';\r\nimport { Shader, VertexAttributeDefinition } from './shader';\r\nimport { VertexBuffer } from './vertex-buffer';\r\nimport { ExcaliburWebGLContextAccessor } from './webgl-adapter';\r\nimport { getGlTypeSizeBytes } from './webgl-util';\r\n\r\n\r\nexport interface VertexLayoutOptions {\r\n  /**\r\n   * Shader that this layout will be for\r\n   */\r\n  shader: Shader;\r\n  /**\r\n   * Vertex buffer to use for vertex data\r\n   */\r\n  vertexBuffer: VertexBuffer,\r\n  /**\r\n   * Specify the attributes that will exist in the vertex buffer\r\n   *\r\n   * **Important** must specify them in the order that they will be in the vertex buffer!!\r\n   */\r\n  attributes: [name: string, numberOfComponents: number][]\r\n}\r\n\r\n/**\r\n * Helper around creating vertex attributes in a given [[VertexBuffer]], this is useful for describing\r\n * the memory layout for your vertices inside a particular buffer\r\n *\r\n * Note: This helper assumes interleaved attributes in one [[VertexBuffer]], not many.\r\n *\r\n * Working with `gl.vertexAttribPointer` can be tricky, and this attempts to double check you\r\n */\r\nexport class VertexLayout {\r\n  private _gl: WebGLRenderingContext = ExcaliburWebGLContextAccessor.gl;\r\n  private _logger = Logger.getInstance();\r\n  private _shader: Shader;\r\n  private _layout: VertexAttributeDefinition[] = [];\r\n  private _attributes: [name: string, numberOfComponents: number][] = [];\r\n  private _vertexBuffer: VertexBuffer;\r\n  public get vertexBuffer() {\r\n    return this._vertexBuffer;\r\n  }\r\n\r\n  public get attributes(): readonly [name: string, numberOfComponents: number][] {\r\n    return this._attributes;\r\n  }\r\n\r\n  constructor(options: VertexLayoutOptions) {\r\n    const {shader, vertexBuffer, attributes} = options;\r\n    this._vertexBuffer = vertexBuffer;\r\n    this._attributes = attributes;\r\n    this._shader = shader;\r\n    this.initialize();\r\n  }\r\n\r\n  private _vertexTotalSizeBytes = 0;\r\n  /**\r\n   * Total number of bytes that the vertex will take up\r\n   */\r\n  public get totalVertexSizeBytes(): number {\r\n    return this._vertexTotalSizeBytes;\r\n  }\r\n\r\n  /**\r\n   * Layouts need shader locations and must be bound to a shader\r\n   */\r\n  initialize() {\r\n    if (!this._shader.compiled) {\r\n      throw Error('Shader not compiled, shader must be compiled before defining a vertex layout');\r\n    }\r\n    this._layout.length = 0;\r\n    const shaderAttributes = this._shader.attributes;\r\n    for (const attribute of this._attributes) {\r\n      const attrib = shaderAttributes[attribute[0]];\r\n      if (!attrib) {\r\n        throw Error(`The attribute named: ${attribute[0]} size ${attribute[1]}`+\r\n        ` not found in the shader source code:\\n ${this._shader.vertexSource}`);\r\n      }\r\n      if (attrib.size !== attribute[1]) {\r\n        throw Error(`VertexLayout size definition for attribute: [${attribute[0]}, ${attribute[1]}],`\r\n        +` doesnt match shader source size ${attrib.size}:\\n ${this._shader.vertexSource}`);\r\n      }\r\n      this._layout.push(attrib);\r\n    }\r\n\r\n    // calc size\r\n    let componentsPerVertex = 0;\r\n    for (const vertAttribute of this._layout) {\r\n      const typeSize = getGlTypeSizeBytes(this._gl, vertAttribute.glType);\r\n      this._vertexTotalSizeBytes += typeSize * vertAttribute.size;\r\n      componentsPerVertex += vertAttribute.size;\r\n    }\r\n\r\n    if (this._vertexBuffer.bufferData.length % componentsPerVertex !== 0) {\r\n      this._logger.warn(`The vertex component size (${componentsPerVertex})  does divide evenly into the specified vertex buffer`\r\n      +` (${this._vertexBuffer.bufferData.length})`);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Bind this layout with it's associated vertex buffer\r\n   *\r\n   * @param uploadBuffer Optionally indicate you wish to upload the buffer to the GPU associated with this layout\r\n   */\r\n  use(uploadBuffer = false, count?: number) {\r\n    const gl = this._gl;\r\n    if (!this._shader.isCurrentlyBound()) {\r\n      throw Error('Shader associated with this vertex layout is not active! Call shader.use() before layout.use()');\r\n    }\r\n    this._vertexBuffer.bind();\r\n    if (uploadBuffer) {\r\n      this._vertexBuffer.upload(count);\r\n    }\r\n    let offset = 0;\r\n    // TODO switch to VAOs if the extension is\r\n    for (const vert of this._layout) {\r\n      gl.vertexAttribPointer(vert.location, vert.size, vert.glType, vert.normalized, this.totalVertexSizeBytes, offset);\r\n      gl.enableVertexAttribArray(vert.location);\r\n      offset += getGlTypeSizeBytes(gl, vert.glType) * vert.size;\r\n    }\r\n  }\r\n}","export class GraphicsDiagnostics {\r\n  public static DrawCallCount: number = 0;\r\n  public static DrawnImagesCount: number = 0;\r\n  public static clear(): void {\r\n    GraphicsDiagnostics.DrawCallCount = 0;\r\n    GraphicsDiagnostics.DrawnImagesCount = 0;\r\n  }\r\n}\r\n","import { Vector } from '../../../Math/vector';\r\nimport { Color } from '../../../Color';\r\nimport lineVertexSource from './line-vertex.glsl';\r\nimport lineFragmentSource from './line-fragment.glsl';\r\nimport { ExcaliburGraphicsContextWebGL } from '../ExcaliburGraphicsContextWebGL';\r\nimport { RendererPlugin } from '../renderer';\r\nimport { Shader, VertexBuffer, VertexLayout } from '../..';\r\nimport { GraphicsDiagnostics } from '../../GraphicsDiagnostics';\r\n\r\nexport class LineRenderer implements RendererPlugin {\r\n  public readonly type = 'ex.line';\r\n  public priority: number = 0;\r\n  private _context: ExcaliburGraphicsContextWebGL;\r\n  private _gl: WebGLRenderingContext;\r\n  private _shader: Shader;\r\n  private _maxLines: number = 10922;\r\n  private _vertexBuffer: VertexBuffer;\r\n  private _layout: VertexLayout;\r\n  private _vertexIndex = 0;\r\n  private _lineCount = 0;\r\n  initialize(gl: WebGLRenderingContext, context: ExcaliburGraphicsContextWebGL): void {\r\n    this._gl = gl;\r\n    this._context = context;\r\n    this._shader = new Shader({\r\n      vertexSource: lineVertexSource,\r\n      fragmentSource: lineFragmentSource\r\n    });\r\n    this._shader.compile();\r\n    this._shader.use();\r\n\r\n    this._shader.setUniformMatrix('u_matrix', this._context.ortho);\r\n\r\n    this._vertexBuffer = new VertexBuffer({\r\n      size: 6 * 2 * this._maxLines,\r\n      type: 'dynamic'\r\n    });\r\n\r\n    this._layout = new VertexLayout({\r\n      vertexBuffer: this._vertexBuffer,\r\n      shader: this._shader,\r\n      attributes: [\r\n        ['a_position', 2],\r\n        ['a_color', 4]\r\n      ]\r\n    });\r\n  }\r\n\r\n  draw(start: Vector, end: Vector, color: Color): void {\r\n    // Force a render if the batch is full\r\n    if (this._isFull()) {\r\n      this.flush();\r\n    }\r\n\r\n    this._lineCount++;\r\n\r\n    const transform = this._context.getTransform();\r\n    const finalStart = transform.multiply(start);\r\n    const finalEnd = transform.multiply(end);\r\n\r\n\r\n    const vertexBuffer = this._vertexBuffer.bufferData;\r\n    // Start\r\n    vertexBuffer[this._vertexIndex++] = finalStart.x;\r\n    vertexBuffer[this._vertexIndex++] = finalStart.y;\r\n    vertexBuffer[this._vertexIndex++] = color.r / 255;\r\n    vertexBuffer[this._vertexIndex++] = color.g / 255;\r\n    vertexBuffer[this._vertexIndex++] = color.b / 255;\r\n    vertexBuffer[this._vertexIndex++] = color.a;\r\n\r\n    // End\r\n    vertexBuffer[this._vertexIndex++] = finalEnd.x;\r\n    vertexBuffer[this._vertexIndex++] = finalEnd.y;\r\n    vertexBuffer[this._vertexIndex++] = color.r / 255;\r\n    vertexBuffer[this._vertexIndex++] = color.g / 255;\r\n    vertexBuffer[this._vertexIndex++] = color.b / 255;\r\n    vertexBuffer[this._vertexIndex++] = color.a;\r\n  }\r\n\r\n  private _isFull() {\r\n    if (this._lineCount >= this._maxLines) {\r\n      return true;\r\n    }\r\n    return false;\r\n  }\r\n\r\n  hasPendingDraws(): boolean {\r\n    return this._lineCount !== 0;\r\n  }\r\n\r\n  flush(): void {\r\n    // nothing to draw early exit\r\n    if (this._lineCount === 0) {\r\n      return;\r\n    }\r\n\r\n    const gl = this._gl;\r\n    this._shader.use();\r\n    this._layout.use(true);\r\n\r\n    this._shader.setUniformMatrix('u_matrix', this._context.ortho);\r\n\r\n    gl.drawArrays(gl.LINES, 0, this._lineCount * 2); // 2 verts per line\r\n\r\n    GraphicsDiagnostics.DrawnImagesCount += this._lineCount;\r\n    GraphicsDiagnostics.DrawCallCount++;\r\n\r\n    // reset\r\n    this._vertexIndex = 0;\r\n    this._lineCount = 0;\r\n  }\r\n}\r\n","export default \"#version 300 es\\r\\nin vec2 a_position;\\r\\nin vec4 a_color;\\r\\nin float a_size;\\r\\nout lowp vec4 v_color;\\r\\nuniform mat4 u_matrix;\\r\\n\\r\\nvoid main() {\\r\\n  gl_Position = u_matrix * vec4(a_position, 0.0, 1.0);\\r\\n  gl_PointSize = a_size * 2.0;\\r\\n  v_color = a_color;\\r\\n}\";","export default \"#version 300 es\\r\\n\\r\\nprecision mediump float;\\r\\nin lowp vec4 v_color;\\r\\n\\r\\nout vec4 fragColor;\\r\\n\\r\\nvoid main() {\\r\\n  float r = 0.0, delta = 0.0, alpha = 1.0;\\r\\n  vec2 cxy = 2.0 * gl_PointCoord - 1.0;\\r\\n  r = dot(cxy, cxy);\\r\\n\\r\\n  delta = fwidth(r);\\r\\n  alpha = 1.0 - smoothstep(1.0 - delta, 1.0 + delta, r);\\r\\n  // \\\"premultiply\\\" the color by alpha\\r\\n  vec4 color = v_color;\\r\\n  color.a = color.a * alpha;\\r\\n  color.rgb = color.rgb * color.a;\\r\\n  fragColor = color;\\r\\n}\";","import pointVertexSource from './point-vertex.glsl';\r\nimport pointFragmentSource from './point-fragment.glsl';\r\nimport { Vector } from '../../../Math/vector';\r\nimport { Color } from '../../../Color';\r\nimport { ExcaliburGraphicsContextWebGL } from '../ExcaliburGraphicsContextWebGL';\r\nimport { RendererPlugin } from '../renderer';\r\nimport { Shader } from '../shader';\r\nimport { VertexBuffer } from '../vertex-buffer';\r\nimport { VertexLayout } from '../vertex-layout';\r\nimport { GraphicsDiagnostics } from '../../GraphicsDiagnostics';\r\n\r\nexport class PointRenderer implements RendererPlugin {\r\n  public readonly type = 'ex.point';\r\n  public priority: number = 0;\r\n  private _shader: Shader;\r\n  private _maxPoints: number = 10922;\r\n  private _buffer: VertexBuffer;\r\n  private _layout: VertexLayout;\r\n  private _gl: WebGLRenderingContext;\r\n  private _context: ExcaliburGraphicsContextWebGL;\r\n  private _pointCount: number = 0;\r\n  private _vertexIndex: number = 0;\r\n  initialize(gl: WebGLRenderingContext, context: ExcaliburGraphicsContextWebGL): void {\r\n    this._gl = gl;\r\n    this._context = context;\r\n    this._shader = new Shader({\r\n      vertexSource: pointVertexSource,\r\n      fragmentSource: pointFragmentSource\r\n    });\r\n    this._shader.compile();\r\n    this._shader.use();\r\n    this._shader.setUniformMatrix('u_matrix', this._context.ortho);\r\n    this._buffer = new VertexBuffer({\r\n      size: 7 * this._maxPoints,\r\n      type: 'dynamic'\r\n    });\r\n\r\n    this._layout = new VertexLayout({\r\n      shader: this._shader,\r\n      vertexBuffer: this._buffer,\r\n      attributes: [\r\n        ['a_position', 2],\r\n        ['a_color', 4],\r\n        ['a_size', 1]\r\n      ]\r\n    });\r\n  }\r\n\r\n  draw(point: Vector, color: Color, size: number): void {\r\n    // Force a render if the batch is full\r\n    if (this._isFull()) {\r\n      this.flush();\r\n    }\r\n\r\n    this._pointCount++;\r\n\r\n    const transform = this._context.getTransform();\r\n    const opacity = this._context.opacity;\r\n\r\n    const finalPoint = transform.multiply(point);\r\n\r\n    const vertexBuffer = this._buffer.bufferData;\r\n    vertexBuffer[this._vertexIndex++] = finalPoint.x;\r\n    vertexBuffer[this._vertexIndex++] = finalPoint.y;\r\n    vertexBuffer[this._vertexIndex++] = color.r / 255;\r\n    vertexBuffer[this._vertexIndex++] = color.g / 255;\r\n    vertexBuffer[this._vertexIndex++] = color.b / 255;\r\n    vertexBuffer[this._vertexIndex++] = color.a * opacity;\r\n    vertexBuffer[this._vertexIndex++] = size * Math.max(transform.getScaleX(), transform.getScaleY());\r\n  }\r\n\r\n  private _isFull() {\r\n    if (this._pointCount >= this._maxPoints) {\r\n      return true;\r\n    }\r\n    return false;\r\n  }\r\n\r\n  hasPendingDraws(): boolean {\r\n    return this._pointCount !== 0;\r\n  }\r\n\r\n  flush(): void {\r\n    // nothing to draw early exit\r\n    if (this._pointCount === 0) {\r\n      return;\r\n    }\r\n\r\n    const gl = this._gl;\r\n    this._shader.use();\r\n    this._layout.use(true);\r\n\r\n    this._shader.setUniformMatrix('u_matrix', this._context.ortho);\r\n\r\n    gl.drawArrays(gl.POINTS, 0, this._pointCount);\r\n\r\n    GraphicsDiagnostics.DrawnImagesCount += this._pointCount;\r\n    GraphicsDiagnostics.DrawCallCount++;\r\n\r\n    this._pointCount = 0;\r\n    this._vertexIndex = 0;\r\n  }\r\n}\r\n","export default \"#version 300 es\\r\\nprecision mediump float;\\r\\n\\r\\n// Passed in from the vertex shader.\\r\\nin vec2 v_texcoord;\\r\\n\\r\\n// The texture.\\r\\nuniform sampler2D u_texture;\\r\\n\\r\\nout vec4 fragColor;\\r\\n\\r\\nvoid main() {\\r\\n   fragColor = texture(u_texture, v_texcoord);\\r\\n}\";","\r\nimport screenVertex from './screen-vertex.glsl';\r\nimport screenFragment from './screen-fragment.glsl';\r\nimport { Shader } from '../shader';\r\nimport { VertexBuffer } from '../vertex-buffer';\r\nimport { VertexLayout } from '../vertex-layout';\r\nimport { PostProcessor } from '../../PostProcessor/PostProcessor';\r\n\r\n/**\r\n * This is responsible for painting the entire screen during the render passes\r\n */\r\nexport class ScreenPassPainter {\r\n  private _gl: WebGLRenderingContext;\r\n  private _shader: Shader;\r\n  private _buffer: VertexBuffer;\r\n  private _layout: VertexLayout;\r\n  constructor(gl: WebGLRenderingContext) {\r\n    this._gl = gl;\r\n    this._shader = new Shader({\r\n      vertexSource: screenVertex,\r\n      fragmentSource: screenFragment\r\n    });\r\n    this._shader.compile();\r\n    // Setup memory layout\r\n    this._buffer = new VertexBuffer({\r\n      type: 'static',\r\n      // clip space quad + uv since we don't need a camera\r\n      data: new Float32Array([\r\n        -1, -1,          0, 0,\r\n        -1, 1,           0, 1,\r\n        1, -1,           1, 0,\r\n\r\n        1, -1,            1, 0,\r\n        -1, 1,           0, 1,\r\n        1, 1,            1, 1\r\n      ])\r\n    });\r\n    this._layout = new VertexLayout({\r\n      shader: this._shader,\r\n      vertexBuffer: this._buffer,\r\n      attributes: [\r\n        ['a_position', 2],\r\n        ['a_texcoord', 2]\r\n      ]\r\n    });\r\n    this._buffer.upload();\r\n  }\r\n\r\n  renderWithPostProcessor(postprocessor: PostProcessor): void {\r\n    const gl = this._gl;\r\n    postprocessor.getShader().use();\r\n    postprocessor.getLayout().use();\r\n    gl.drawArrays(gl.TRIANGLES, 0, 6);\r\n  }\r\n\r\n  renderToScreen(): void {\r\n    const gl = this._gl;\r\n    this._shader.use();\r\n    this._layout.use();\r\n    gl.drawArrays(gl.TRIANGLES, 0, 6);\r\n  }\r\n}","import { Logger } from '../..';\r\nimport { ExcaliburWebGLContextAccessor } from './webgl-adapter';\r\n\r\n/**\r\n * Helper that defines and index buffer for quad geometry\r\n *\r\n * Index buffers allow you to save space in vertex buffers when you share vertices in geometry\r\n * it is almost always worth it in terms of performance to use an index buffer.\r\n */\r\nexport class QuadIndexBuffer {\r\n  private _gl: WebGL2RenderingContext = ExcaliburWebGLContextAccessor.gl;\r\n  private _logger: Logger = Logger.getInstance();\r\n  /**\r\n   * Access to the webgl buffer handle\r\n   */\r\n  public buffer: WebGLBuffer;\r\n  /**\r\n   * Access to the raw data of the index buffer\r\n   */\r\n  public bufferData: Uint16Array | Uint32Array;\r\n  /**\r\n   * Depending on the browser this is either gl.UNSIGNED_SHORT or gl.UNSIGNED_INT\r\n   */\r\n  public bufferGlType: number;\r\n\r\n  /**\r\n   * @param numberOfQuads Specify the max number of quads you want to draw\r\n   * @param useUint16 Optionally force a uint16 buffer\r\n   */\r\n  constructor(numberOfQuads: number, useUint16?: boolean) {\r\n    const gl = this._gl;\r\n    this.buffer = gl.createBuffer();\r\n    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.buffer);\r\n\r\n    const totalVertices = numberOfQuads * 6;\r\n\r\n    if (!useUint16) {\r\n      this.bufferData = new Uint32Array(totalVertices);\r\n    } else {\r\n      // fall back to using gl.UNSIGNED_SHORT or tell the user they are out of luck\r\n      const maxUint16 = 65_535;\r\n      const maxUint16Index = Math.floor((maxUint16 - 1) / 4); // max quads\r\n\r\n      this.bufferGlType = gl.UNSIGNED_SHORT;\r\n      this.bufferData = new Uint16Array(totalVertices);\r\n      // TODO Should we error if this happens?? maybe not might crash mid game\r\n      if (numberOfQuads > maxUint16Index) {\r\n        this._logger.warn(\r\n          `Total quads exceeds hardware index buffer limit (uint16), max(${maxUint16Index}) requested quads(${numberOfQuads})`);\r\n      }\r\n    }\r\n\r\n\r\n    let currentQuad = 0;\r\n    for (let i = 0; i < totalVertices; i += 6) {\r\n      // first triangle\r\n      this.bufferData[i + 0] = currentQuad + 0;\r\n      this.bufferData[i + 1] = currentQuad + 1;\r\n      this.bufferData[i + 2] = currentQuad + 2;\r\n      // second triangle\r\n      this.bufferData[i + 3] = currentQuad + 2;\r\n      this.bufferData[i + 4] = currentQuad + 1;\r\n      this.bufferData[i + 5] = currentQuad + 3;\r\n      currentQuad += 4;\r\n    }\r\n    gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, this.bufferData, gl.STATIC_DRAW);\r\n  }\r\n\r\n  public get size() {\r\n    return this.bufferData.length;\r\n  }\r\n\r\n  /**\r\n   * Upload data to the GPU\r\n   */\r\n  public upload() {\r\n    const gl = this._gl;\r\n    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.buffer);\r\n    gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, this.bufferData, gl.STATIC_DRAW);\r\n  }\r\n\r\n  /**\r\n   * Bind this index buffer\r\n   */\r\n  public bind() {\r\n    const gl = this._gl;\r\n    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.buffer);\r\n  }\r\n}","import { vec } from '../../../Math/vector';\r\nimport { GraphicsDiagnostics } from '../../GraphicsDiagnostics';\r\nimport { HTMLImageSource } from '../ExcaliburGraphicsContext';\r\nimport { ExcaliburGraphicsContextWebGL } from '../ExcaliburGraphicsContextWebGL';\r\nimport { QuadIndexBuffer } from '../quad-index-buffer';\r\nimport { RendererPlugin } from '../renderer';\r\nimport { Shader } from '../shader';\r\nimport { TextureLoader } from '../texture-loader';\r\nimport { VertexBuffer } from '../vertex-buffer';\r\nimport { VertexLayout } from '../vertex-layout';\r\nimport { ensurePowerOfTwo } from '../webgl-util';\r\nimport frag from './image-renderer.frag.glsl';\r\nimport vert from './image-renderer.vert.glsl';\r\n\r\nexport class ImageRenderer implements RendererPlugin {\r\n  public readonly type = 'ex.image';\r\n  public priority: number = 0;\r\n\r\n  private _maxImages: number = 10922; // max(uint16) / 6 verts\r\n  private _maxTextures: number = 0;\r\n\r\n  private _context: ExcaliburGraphicsContextWebGL;\r\n  private _gl: WebGLRenderingContext;\r\n  private _shader: Shader;\r\n  private _buffer: VertexBuffer;\r\n  private _layout: VertexLayout;\r\n  private _quads: QuadIndexBuffer;\r\n\r\n  // Per flush vars\r\n  private _imageCount: number = 0;\r\n  private _textures: WebGLTexture[] = [];\r\n  private _vertexIndex: number = 0;\r\n\r\n  initialize(gl: WebGLRenderingContext, context: ExcaliburGraphicsContextWebGL): void {\r\n    this._gl = gl;\r\n    this._context = context;\r\n    // Transform shader source\r\n    // FIXME: PIXEL 6 complains `ERROR: Expression too complex.` if we use it's reported max texture units, 125 seems to work for now...\r\n    this._maxTextures = Math.min(gl.getParameter(gl.MAX_TEXTURE_IMAGE_UNITS), 125);\r\n    const transformedFrag = this._transformFragmentSource(frag, this._maxTextures);\r\n    // Compile shader\r\n    this._shader = new Shader({\r\n      fragmentSource: transformedFrag,\r\n      vertexSource: vert\r\n    });\r\n    this._shader.compile();\r\n\r\n    // setup uniforms\r\n    this._shader.use();\r\n    this._shader.setUniformMatrix('u_matrix', context.ortho);\r\n    // Initialize texture slots to [0, 1, 2, 3, 4, .... maxGPUTextures]\r\n    this._shader.setUniformIntArray(\r\n      'u_textures',\r\n      [...Array(this._maxTextures)].map((_, i) => i)\r\n    );\r\n\r\n    // Setup memory layout\r\n    this._buffer = new VertexBuffer({\r\n      size: 6 * 4 * this._maxImages, // 6 components * 4 verts\r\n      type: 'dynamic'\r\n    });\r\n    this._layout = new VertexLayout({\r\n      shader: this._shader,\r\n      vertexBuffer: this._buffer,\r\n      attributes: [\r\n        ['a_position', 2],\r\n        ['a_opacity', 1],\r\n        ['a_texcoord', 2],\r\n        ['a_textureIndex', 1]\r\n      ]\r\n    });\r\n\r\n    // Setup index buffer\r\n    this._quads = new QuadIndexBuffer(this._maxImages, true);\r\n  }\r\n\r\n  private _transformFragmentSource(source: string, maxTextures: number): string {\r\n    let newSource = source.replace('%%count%%', maxTextures.toString());\r\n    let texturePickerBuilder = '';\r\n    for (let i = 0; i < maxTextures; i++) {\r\n      if (i === 0) {\r\n        texturePickerBuilder += `if (v_textureIndex <= ${i}.5) {\\n`;\r\n      } else {\r\n        texturePickerBuilder += `   else if (v_textureIndex <= ${i}.5) {\\n`;\r\n      }\r\n      texturePickerBuilder += `      color = texture(u_textures[${i}], v_texcoord);\\n`;\r\n      texturePickerBuilder += `   }\\n`;\r\n    }\r\n    newSource = newSource.replace('%%texture_picker%%', texturePickerBuilder);\r\n    return newSource;\r\n  }\r\n\r\n  private _addImageAsTexture(image: HTMLImageSource) {\r\n    const texture = TextureLoader.load(image);\r\n    if (this._textures.indexOf(texture) === -1) {\r\n      this._textures.push(texture);\r\n    }\r\n  }\r\n\r\n  private _bindTextures(gl: WebGLRenderingContext) {\r\n    // Bind textures in the correct order\r\n    for (let i = 0; i < this._maxTextures; i++) {\r\n      gl.activeTexture(gl.TEXTURE0 + i);\r\n      gl.bindTexture(gl.TEXTURE_2D, this._textures[i] || this._textures[0]);\r\n    }\r\n  }\r\n\r\n  private _getTextureIdForImage(image: HTMLImageSource) {\r\n    if (image) {\r\n      return this._textures.indexOf(TextureLoader.get(image));\r\n    }\r\n    return -1;\r\n  }\r\n\r\n  private _isFull() {\r\n    if (this._imageCount >= this._maxImages) {\r\n      return true;\r\n    }\r\n    if (this._textures.length >= this._maxTextures) {\r\n      return true;\r\n    }\r\n    return false;\r\n  }\r\n\r\n\r\n  draw(image: HTMLImageSource,\r\n    sx: number,\r\n    sy: number,\r\n    swidth?: number,\r\n    sheight?: number,\r\n    dx?: number,\r\n    dy?: number,\r\n    dwidth?: number,\r\n    dheight?: number): void {\r\n\r\n    // Force a render if the batch is full\r\n    if (this._isFull()) {\r\n      this.flush();\r\n    }\r\n\r\n    this._imageCount++;\r\n    this._addImageAsTexture(image);\r\n\r\n    let width = image?.width || swidth || 0;\r\n    let height = image?.height || sheight || 0;\r\n    let view = [0, 0, swidth ?? image?.width ?? 0, sheight ?? image?.height ?? 0];\r\n    let dest = [sx ?? 1, sy ?? 1];\r\n    // If destination is specified, update view and dest\r\n    if (dx !== undefined && dy !== undefined && dwidth !== undefined && dheight !== undefined) {\r\n      view = [sx ?? 1, sy ?? 1, swidth ?? image?.width ?? 0, sheight ?? image?.height ?? 0];\r\n      dest = [dx, dy];\r\n      width = dwidth;\r\n      height = dheight;\r\n    }\r\n\r\n    sx = view[0];\r\n    sy = view[1];\r\n    const sw = view[2];\r\n    const sh = view[3];\r\n\r\n    // transform based on current context\r\n    const transform = this._context.getTransform();\r\n    const opacity = this._context.opacity;\r\n    const snapToPixel = this._context.snapToPixel;\r\n\r\n    let topLeft = vec(dest[0], dest[1]);\r\n    let topRight = vec(dest[0] + width, dest[1]);\r\n    let bottomLeft = vec(dest[0], dest[1] + height);\r\n    let bottomRight = vec(dest[0] + width, dest[1] + height);\r\n\r\n    topLeft = transform.multiply(topLeft);\r\n    topRight = transform.multiply(topRight);\r\n    bottomLeft = transform.multiply(bottomLeft);\r\n    bottomRight = transform.multiply(bottomRight);\r\n\r\n    if (snapToPixel) {\r\n      topLeft.x = ~~topLeft.x;\r\n      topLeft.y = ~~topLeft.y;\r\n\r\n      topRight.x = ~~topRight.x;\r\n      topRight.y = ~~topRight.y;\r\n\r\n      bottomLeft.x = ~~bottomLeft.x;\r\n      bottomLeft.y = ~~bottomLeft.y;\r\n\r\n      bottomRight.x = ~~bottomRight.x;\r\n      bottomRight.y = ~~bottomRight.y;\r\n    }\r\n\r\n    const textureId = this._getTextureIdForImage(image);\r\n    const potWidth = ensurePowerOfTwo(image.width || width);\r\n    const potHeight = ensurePowerOfTwo(image.height || height);\r\n\r\n    const uvx0 = (sx) / potWidth;\r\n    const uvy0 = (sy) / potHeight;\r\n    const uvx1 = (sx + sw - 0.01) / potWidth;\r\n    const uvy1 = (sy + sh - 0.01) / potHeight;\r\n\r\n    // update data\r\n    const vertexBuffer = this._layout.vertexBuffer.bufferData;\r\n\r\n    // (0, 0) - 0\r\n    vertexBuffer[this._vertexIndex++] = topLeft.x;\r\n    vertexBuffer[this._vertexIndex++] = topLeft.y;\r\n    vertexBuffer[this._vertexIndex++] = opacity;\r\n    vertexBuffer[this._vertexIndex++] = uvx0;\r\n    vertexBuffer[this._vertexIndex++] = uvy0;\r\n    vertexBuffer[this._vertexIndex++] = textureId;\r\n\r\n    // (0, 1) - 1\r\n    vertexBuffer[this._vertexIndex++] = bottomLeft.x;\r\n    vertexBuffer[this._vertexIndex++] = bottomLeft.y;\r\n    vertexBuffer[this._vertexIndex++] = opacity;\r\n    vertexBuffer[this._vertexIndex++] = uvx0;\r\n    vertexBuffer[this._vertexIndex++] = uvy1;\r\n    vertexBuffer[this._vertexIndex++] = textureId;\r\n\r\n    // (1, 0) - 2\r\n    vertexBuffer[this._vertexIndex++] = topRight.x;\r\n    vertexBuffer[this._vertexIndex++] = topRight.y;\r\n    vertexBuffer[this._vertexIndex++] = opacity;\r\n    vertexBuffer[this._vertexIndex++] = uvx1;\r\n    vertexBuffer[this._vertexIndex++] = uvy0;\r\n    vertexBuffer[this._vertexIndex++] = textureId;\r\n\r\n    // (1, 1) - 3\r\n    vertexBuffer[this._vertexIndex++] = bottomRight.x;\r\n    vertexBuffer[this._vertexIndex++] = bottomRight.y;\r\n    vertexBuffer[this._vertexIndex++] = opacity;\r\n    vertexBuffer[this._vertexIndex++] = uvx1;\r\n    vertexBuffer[this._vertexIndex++] = uvy1;\r\n    vertexBuffer[this._vertexIndex++] = textureId;\r\n  }\r\n\r\n  hasPendingDraws(): boolean {\r\n    return this._imageCount !== 0;\r\n  }\r\n\r\n  flush(): void {\r\n    // nothing to draw early exit\r\n    if (this._imageCount === 0) {\r\n      return;\r\n    }\r\n\r\n    const gl = this._gl;\r\n    // Bind the shader\r\n    this._shader.use();\r\n\r\n    // Bind the memory layout and upload data\r\n    this._layout.use(true, 4 * 6 * this._imageCount);\r\n\r\n    // Update ortho matrix uniform\r\n    this._shader.setUniformMatrix('u_matrix', this._context.ortho);\r\n\r\n    // Bind textures to\r\n    this._bindTextures(gl);\r\n\r\n    // Bind index buffer\r\n    this._quads.bind();\r\n\r\n    // Draw all the quads\r\n    gl.drawElements(gl.TRIANGLES, this._imageCount * 6, this._quads.bufferGlType, 0);\r\n\r\n    GraphicsDiagnostics.DrawnImagesCount += this._imageCount;\r\n    GraphicsDiagnostics.DrawCallCount++;\r\n\r\n    // Reset\r\n    this._imageCount = 0;\r\n    this._vertexIndex = 0;\r\n    this._textures.length = 0;\r\n  }\r\n}","export default \"#version 300 es\\r\\n\\r\\nprecision mediump float;\\r\\n\\r\\n// UV coord\\r\\nin vec2 v_uv;\\r\\n\\r\\nin vec2 v_size; // in pixels\\r\\n\\r\\n// Color coord to blend with image\\r\\nin lowp vec4 v_color;\\r\\n\\r\\n// Stroke color if used\\r\\nin lowp vec4 v_strokeColor;\\r\\n\\r\\n// Stroke thickness if used\\r\\nin lowp float v_strokeThickness; // in pixels\\r\\n\\r\\n// Opacity\\r\\nin float v_opacity;\\r\\n\\r\\nout vec4 fragColor;\\r\\n\\r\\nvoid main() {\\r\\n    // modified from https://stackoverflow.com/questions/59197671/glsl-rounded-rectangle-with-variable-border\\r\\n    vec2 uv = v_uv;\\r\\n    vec2 fragCoord = uv * v_size;\\r\\n    float maxX = v_size.x - v_strokeThickness;\\r\\n    float minX = v_strokeThickness;\\r\\n    float maxY = v_size.y - v_strokeThickness;\\r\\n    float minY = v_strokeThickness;\\r\\n\\r\\n    if (fragCoord.x < maxX && fragCoord.x > minX &&\\r\\n        fragCoord.y < maxY && fragCoord.y > minY) {\\r\\n      fragColor = v_color;\\r\\n    } else {\\r\\n      fragColor = v_strokeColor;\\r\\n    }\\r\\n    fragColor.a *= v_opacity;\\r\\n    fragColor.rgb *= fragColor.a;\\r\\n\\r\\n    // vec2 v2CenteredPos     = abs(fragCoord - v_size.xy / 2.0);\\r\\n    // vec2 v2HalfShapeSizePx = v_size.xy/2.0 - v_strokeThickness/2.0;\\r\\n\\r\\n    // float fHalfBorderDist      = 0.0;\\r\\n    // float fHalfBorderThickness = 0.0;\\r\\n\\r\\n    // if (fragCoord.x > max(v_radius, v_strokeThickness) && \\r\\n    //     fragCoord.x < v_size.x - max(v_radius, v_strokeThickness))\\r\\n    // {\\r\\n    //     fHalfBorderDist      = v2CenteredPos.y - v2HalfShapeSizePx.y;\\r\\n    //     fHalfBorderThickness = v_strokeThickness / 2.0;\\r\\n    // }\\r\\n    // else if (fragCoord.y > max(v_radius, v_strokeThickness) && \\r\\n    //          fragCoord.y < v_size.y - max(v_radius, v_strokeThickness))\\r\\n    // {\\r\\n    //     fHalfBorderDist      = v2CenteredPos.x - v2HalfShapeSizePx.x;\\r\\n    //     fHalfBorderThickness = v_strokeThickness / 2.0;\\r\\n    // }\\r\\n    // else\\r\\n    // {\\r\\n    //     vec2 edgeVec = max(vec2(0.0), v_radius - vec2(\\r\\n    //         uv.x > 0.5 ? v_size.x - fragCoord.x : fragCoord.x,\\r\\n    //         uv.y > 0.5 ? v_size.y - fragCoord.y : fragCoord.y));\\r\\n        \\r\\n    //     float ellipse_ab    = v_radius-v_strokeThickness;\\r\\n    //     vec2 ellipse_isect = (v_strokeThickness > v_radius || v_strokeThickness > v_radius) ? vec2(0.0) :\\r\\n    //                             edgeVec.xy * ellipse_ab*ellipse_ab / length(ellipse_ab*edgeVec.yx); \\r\\n            \\r\\n    //     fHalfBorderThickness = (v_radius - length(ellipse_isect)) / 2.0;\\r\\n    //     fHalfBorderDist      = length(edgeVec) - (v_radius - fHalfBorderThickness);\\r\\n    // }\\r\\n\\r\\n    // vec4 v4FromColor = v_strokeColor;\\r\\n    // v4FromColor.rgb *= v4FromColor.a;\\r\\n    // vec4 v4ToColor   = vec4(0.0); // background color is transparent\\r\\n    // if (fHalfBorderDist < 0.0) {\\r\\n    //     v4ToColor = v_color;\\r\\n    //     v4ToColor.rgb *= v4ToColor.a;\\r\\n    // }\\r\\n\\r\\n    // float mixPct = abs(fHalfBorderDist) - fHalfBorderThickness;\\r\\n\\r\\n    // vec4 finalColor = mix(v4FromColor, v4ToColor, mixPct);\\r\\n    // gl_FragColor = finalColor;\\r\\n}\";","import { Color } from '../../../Color';\r\nimport { vec, Vector } from '../../../Math/vector';\r\nimport { GraphicsDiagnostics } from '../../GraphicsDiagnostics';\r\nimport { ExcaliburGraphicsContextWebGL } from '../ExcaliburGraphicsContextWebGL';\r\nimport { QuadIndexBuffer } from '../quad-index-buffer';\r\nimport { RendererPlugin } from '../renderer';\r\nimport { Shader } from '../shader';\r\nimport { VertexBuffer } from '../vertex-buffer';\r\nimport { VertexLayout } from '../vertex-layout';\r\n\r\nimport frag from './rectangle-renderer.frag.glsl';\r\nimport vert from './rectangle-renderer.vert.glsl';\r\n\r\nexport class RectangleRenderer implements RendererPlugin {\r\n  public readonly type = 'ex.rectangle';\r\n  public priority: number = 0;\r\n\r\n  private _maxRectangles: number = 10922; // max(uint16) / 6 verts\r\n\r\n  private _shader: Shader;\r\n  private _gl: WebGLRenderingContext;\r\n  private _context: ExcaliburGraphicsContextWebGL;\r\n  private _buffer: VertexBuffer;\r\n  private _layout: VertexLayout;\r\n  private _quads: QuadIndexBuffer;\r\n  private _rectangleCount: number = 0;\r\n  private _vertexIndex: number = 0;\r\n\r\n\r\n  initialize(gl: WebGLRenderingContext, context: ExcaliburGraphicsContextWebGL): void {\r\n    this._gl = gl;\r\n    this._context = context;\r\n    // https://stackoverflow.com/questions/59197671/glsl-rounded-rectangle-with-variable-border\r\n    this._shader = new Shader({\r\n      fragmentSource: frag,\r\n      vertexSource: vert\r\n    });\r\n    this._shader.compile();\r\n\r\n    // setup uniforms\r\n    this._shader.use();\r\n    this._shader.setUniformMatrix('u_matrix', context.ortho);\r\n\r\n    this._buffer = new VertexBuffer({\r\n      size: 16 * 4 * this._maxRectangles,\r\n      type: 'dynamic'\r\n    });\r\n\r\n    this._layout = new VertexLayout({\r\n      shader: this._shader,\r\n      vertexBuffer: this._buffer,\r\n      attributes: [\r\n        ['a_position', 2],\r\n        ['a_uv', 2],\r\n        ['a_size', 2],\r\n        ['a_opacity', 1],\r\n        ['a_color', 4],\r\n        ['a_strokeColor', 4],\r\n        ['a_strokeThickness', 1]\r\n      ]\r\n    });\r\n    this._quads = new QuadIndexBuffer(this._maxRectangles, true);\r\n  }\r\n\r\n  private _isFull() {\r\n    if (this._rectangleCount >= this._maxRectangles) {\r\n      return true;\r\n    }\r\n    return false;\r\n  }\r\n\r\n  draw(...args: any[]): void {\r\n    if (args[0] instanceof Vector && args[1] instanceof Vector) {\r\n      this.drawLine.apply(this, args);\r\n    } else {\r\n      this.drawRectangle.apply(this, args);\r\n    }\r\n  }\r\n\r\n  drawLine(start: Vector, end: Vector, color: Color, thickness: number = 1) {\r\n\r\n    if (this._isFull()) {\r\n      this.flush();\r\n    }\r\n    this._rectangleCount++;\r\n\r\n    // transform based on current context\r\n    const transform = this._context.getTransform();\r\n    const opacity = this._context.opacity;\r\n\r\n    const dir = end.sub(start);\r\n    const length = dir.size;\r\n    const normal = dir.normalize().perpendicular();\r\n    const halfThick = thickness / 2;\r\n\r\n    /**\r\n     *    +---------------------^----------------------+\r\n     *    |                     | (normal)             |\r\n     *   (startx, starty)------------------>(endx, endy)\r\n     *    |                                            |\r\n     *    + -------------------------------------------+\r\n     */\r\n    const startTop = transform.multiply(normal.scale(halfThick).add(start));\r\n    const startBottom = transform.multiply(normal.scale(-halfThick).add(start));\r\n    const endTop = transform.multiply(normal.scale(halfThick).add(end));\r\n    const endBottom = transform.multiply(normal.scale(-halfThick).add(end));\r\n\r\n    // TODO uv could be static vertex buffer\r\n    const uvx0 = 0;\r\n    const uvy0 = 0;\r\n    const uvx1 = 1;\r\n    const uvy1 = 1;\r\n\r\n    const stroke = Color.Transparent;\r\n    const strokeThickness = 0;\r\n    const width = 1;\r\n\r\n    // update data\r\n    const vertexBuffer = this._layout.vertexBuffer.bufferData;\r\n\r\n    // (0, 0) - 0\r\n    vertexBuffer[this._vertexIndex++] = startTop.x;\r\n    vertexBuffer[this._vertexIndex++] = startTop.y;\r\n    vertexBuffer[this._vertexIndex++] = uvx0;\r\n    vertexBuffer[this._vertexIndex++] = uvy0;\r\n    vertexBuffer[this._vertexIndex++] = length;\r\n    vertexBuffer[this._vertexIndex++] = thickness;\r\n    vertexBuffer[this._vertexIndex++] = opacity;\r\n    vertexBuffer[this._vertexIndex++] = color.r / 255;\r\n    vertexBuffer[this._vertexIndex++] = color.g / 255;\r\n    vertexBuffer[this._vertexIndex++] = color.b / 255;\r\n    vertexBuffer[this._vertexIndex++] = color.a;\r\n    vertexBuffer[this._vertexIndex++] = stroke.r / 255;\r\n    vertexBuffer[this._vertexIndex++] = stroke.g / 255;\r\n    vertexBuffer[this._vertexIndex++] = stroke.b / 255;\r\n    vertexBuffer[this._vertexIndex++] = stroke.a;\r\n    vertexBuffer[this._vertexIndex++] = strokeThickness / width;\r\n\r\n    // (0, 1) - 1\r\n    vertexBuffer[this._vertexIndex++] = startBottom.x;\r\n    vertexBuffer[this._vertexIndex++] = startBottom.y;\r\n    vertexBuffer[this._vertexIndex++] = uvx0;\r\n    vertexBuffer[this._vertexIndex++] = uvy1;\r\n    vertexBuffer[this._vertexIndex++] = length;\r\n    vertexBuffer[this._vertexIndex++] = thickness;\r\n    vertexBuffer[this._vertexIndex++] = opacity;\r\n    vertexBuffer[this._vertexIndex++] = color.r / 255;\r\n    vertexBuffer[this._vertexIndex++] = color.g / 255;\r\n    vertexBuffer[this._vertexIndex++] = color.b / 255;\r\n    vertexBuffer[this._vertexIndex++] = color.a;\r\n    vertexBuffer[this._vertexIndex++] = stroke.r / 255;\r\n    vertexBuffer[this._vertexIndex++] = stroke.g / 255;\r\n    vertexBuffer[this._vertexIndex++] = stroke.b / 255;\r\n    vertexBuffer[this._vertexIndex++] = stroke.a;\r\n    vertexBuffer[this._vertexIndex++] = strokeThickness / width;\r\n\r\n    // (1, 0) - 2\r\n    vertexBuffer[this._vertexIndex++] = endTop.x;\r\n    vertexBuffer[this._vertexIndex++] = endTop.y;\r\n    vertexBuffer[this._vertexIndex++] = uvx1;\r\n    vertexBuffer[this._vertexIndex++] = uvy0;\r\n    vertexBuffer[this._vertexIndex++] = length;\r\n    vertexBuffer[this._vertexIndex++] = thickness;\r\n    vertexBuffer[this._vertexIndex++] = opacity;\r\n    vertexBuffer[this._vertexIndex++] = color.r / 255;\r\n    vertexBuffer[this._vertexIndex++] = color.g / 255;\r\n    vertexBuffer[this._vertexIndex++] = color.b / 255;\r\n    vertexBuffer[this._vertexIndex++] = color.a;\r\n    vertexBuffer[this._vertexIndex++] = stroke.r / 255;\r\n    vertexBuffer[this._vertexIndex++] = stroke.g / 255;\r\n    vertexBuffer[this._vertexIndex++] = stroke.b / 255;\r\n    vertexBuffer[this._vertexIndex++] = stroke.a;\r\n    vertexBuffer[this._vertexIndex++] = strokeThickness / width;\r\n\r\n    // (1, 1) - 3\r\n    vertexBuffer[this._vertexIndex++] = endBottom.x;\r\n    vertexBuffer[this._vertexIndex++] = endBottom.y;\r\n    vertexBuffer[this._vertexIndex++] = uvx1;\r\n    vertexBuffer[this._vertexIndex++] = uvy1;\r\n    vertexBuffer[this._vertexIndex++] = length;\r\n    vertexBuffer[this._vertexIndex++] = thickness;\r\n    vertexBuffer[this._vertexIndex++] = opacity;\r\n    vertexBuffer[this._vertexIndex++] = color.r / 255;\r\n    vertexBuffer[this._vertexIndex++] = color.g / 255;\r\n    vertexBuffer[this._vertexIndex++] = color.b / 255;\r\n    vertexBuffer[this._vertexIndex++] = color.a;\r\n    vertexBuffer[this._vertexIndex++] = stroke.r / 255;\r\n    vertexBuffer[this._vertexIndex++] = stroke.g / 255;\r\n    vertexBuffer[this._vertexIndex++] = stroke.b / 255;\r\n    vertexBuffer[this._vertexIndex++] = stroke.a;\r\n    vertexBuffer[this._vertexIndex++] = strokeThickness / width;\r\n  }\r\n\r\n  drawRectangle(\r\n    pos: Vector,\r\n    width: number,\r\n    height: number,\r\n    color: Color,\r\n    stroke: Color = Color.Transparent,\r\n    strokeThickness: number = 0): void {\r\n    if (this._isFull()) {\r\n      this.flush();\r\n    }\r\n    this._rectangleCount++;\r\n\r\n    // transform based on current context\r\n    const transform = this._context.getTransform();\r\n    const opacity = this._context.opacity;\r\n\r\n    const topLeft = transform.multiply(pos.add(vec(0, 0)));\r\n    const topRight = transform.multiply(pos.add(vec(width, 0)));\r\n    const bottomRight = transform.multiply(pos.add(vec(width, height)));\r\n    const bottomLeft = transform.multiply(pos.add(vec(0, height)));\r\n\r\n    // TODO uv could be static vertex buffer\r\n    const uvx0 = 0;\r\n    const uvy0 = 0;\r\n    const uvx1 = 1;\r\n    const uvy1 = 1;\r\n\r\n    // update data\r\n    const vertexBuffer = this._layout.vertexBuffer.bufferData;\r\n\r\n    // (0, 0) - 0\r\n    vertexBuffer[this._vertexIndex++] = topLeft.x;\r\n    vertexBuffer[this._vertexIndex++] = topLeft.y;\r\n    vertexBuffer[this._vertexIndex++] = uvx0;\r\n    vertexBuffer[this._vertexIndex++] = uvy0;\r\n    vertexBuffer[this._vertexIndex++] = width;\r\n    vertexBuffer[this._vertexIndex++] = height;\r\n    vertexBuffer[this._vertexIndex++] = opacity;\r\n    vertexBuffer[this._vertexIndex++] = color.r / 255;\r\n    vertexBuffer[this._vertexIndex++] = color.g / 255;\r\n    vertexBuffer[this._vertexIndex++] = color.b / 255;\r\n    vertexBuffer[this._vertexIndex++] = color.a;\r\n    vertexBuffer[this._vertexIndex++] = stroke.r / 255;\r\n    vertexBuffer[this._vertexIndex++] = stroke.g / 255;\r\n    vertexBuffer[this._vertexIndex++] = stroke.b / 255;\r\n    vertexBuffer[this._vertexIndex++] = stroke.a;\r\n    vertexBuffer[this._vertexIndex++] = strokeThickness;\r\n\r\n    // (0, 1) - 1\r\n    vertexBuffer[this._vertexIndex++] = bottomLeft.x;\r\n    vertexBuffer[this._vertexIndex++] = bottomLeft.y;\r\n    vertexBuffer[this._vertexIndex++] = uvx0;\r\n    vertexBuffer[this._vertexIndex++] = uvy1;\r\n    vertexBuffer[this._vertexIndex++] = width;\r\n    vertexBuffer[this._vertexIndex++] = height;\r\n    vertexBuffer[this._vertexIndex++] = opacity;\r\n    vertexBuffer[this._vertexIndex++] = color.r / 255;\r\n    vertexBuffer[this._vertexIndex++] = color.g / 255;\r\n    vertexBuffer[this._vertexIndex++] = color.b / 255;\r\n    vertexBuffer[this._vertexIndex++] = color.a;\r\n    vertexBuffer[this._vertexIndex++] = stroke.r / 255;\r\n    vertexBuffer[this._vertexIndex++] = stroke.g / 255;\r\n    vertexBuffer[this._vertexIndex++] = stroke.b / 255;\r\n    vertexBuffer[this._vertexIndex++] = stroke.a;\r\n    vertexBuffer[this._vertexIndex++] = strokeThickness;\r\n\r\n    // (1, 0) - 2\r\n    vertexBuffer[this._vertexIndex++] = topRight.x;\r\n    vertexBuffer[this._vertexIndex++] = topRight.y;\r\n    vertexBuffer[this._vertexIndex++] = uvx1;\r\n    vertexBuffer[this._vertexIndex++] = uvy0;\r\n    vertexBuffer[this._vertexIndex++] = width;\r\n    vertexBuffer[this._vertexIndex++] = height;\r\n    vertexBuffer[this._vertexIndex++] = opacity;\r\n    vertexBuffer[this._vertexIndex++] = color.r / 255;\r\n    vertexBuffer[this._vertexIndex++] = color.g / 255;\r\n    vertexBuffer[this._vertexIndex++] = color.b / 255;\r\n    vertexBuffer[this._vertexIndex++] = color.a;\r\n    vertexBuffer[this._vertexIndex++] = stroke.r / 255;\r\n    vertexBuffer[this._vertexIndex++] = stroke.g / 255;\r\n    vertexBuffer[this._vertexIndex++] = stroke.b / 255;\r\n    vertexBuffer[this._vertexIndex++] = stroke.a;\r\n    vertexBuffer[this._vertexIndex++] = strokeThickness;\r\n\r\n    // (1, 1) - 3\r\n    vertexBuffer[this._vertexIndex++] = bottomRight.x;\r\n    vertexBuffer[this._vertexIndex++] = bottomRight.y;\r\n    vertexBuffer[this._vertexIndex++] = uvx1;\r\n    vertexBuffer[this._vertexIndex++] = uvy1;\r\n    vertexBuffer[this._vertexIndex++] = width;\r\n    vertexBuffer[this._vertexIndex++] = height;\r\n    vertexBuffer[this._vertexIndex++] = opacity;\r\n    vertexBuffer[this._vertexIndex++] = color.r / 255;\r\n    vertexBuffer[this._vertexIndex++] = color.g / 255;\r\n    vertexBuffer[this._vertexIndex++] = color.b / 255;\r\n    vertexBuffer[this._vertexIndex++] = color.a;\r\n    vertexBuffer[this._vertexIndex++] = stroke.r / 255;\r\n    vertexBuffer[this._vertexIndex++] = stroke.g / 255;\r\n    vertexBuffer[this._vertexIndex++] = stroke.b / 255;\r\n    vertexBuffer[this._vertexIndex++] = stroke.a;\r\n    vertexBuffer[this._vertexIndex++] = strokeThickness;\r\n\r\n  }\r\n\r\n  hasPendingDraws(): boolean {\r\n    return this._rectangleCount !== 0;\r\n  }\r\n\r\n  flush(): void {\r\n    // nothing to draw early exit\r\n    if (this._rectangleCount === 0) {\r\n      return;\r\n    }\r\n\r\n    const gl = this._gl;\r\n    // Bind the shader\r\n    this._shader.use();\r\n\r\n    // Bind the memory layout and upload data\r\n    this._layout.use(true);\r\n\r\n    // Update ortho matrix uniform\r\n    this._shader.setUniformMatrix('u_matrix', this._context.ortho);\r\n\r\n    // Bind index buffer\r\n    this._quads.bind();\r\n\r\n    // Draw all the quads\r\n    gl.drawElements(gl.TRIANGLES, this._rectangleCount * 6, this._quads.bufferGlType, 0);\r\n\r\n    GraphicsDiagnostics.DrawnImagesCount += this._rectangleCount;\r\n    GraphicsDiagnostics.DrawCallCount++;\r\n\r\n    // Reset\r\n    this._rectangleCount = 0;\r\n    this._vertexIndex = 0;\r\n  }\r\n\r\n}","import { Color } from '../../../Color';\r\nimport { vec, Vector } from '../../../Math/vector';\r\nimport { GraphicsDiagnostics } from '../../GraphicsDiagnostics';\r\nimport { ExcaliburGraphicsContextWebGL } from '../ExcaliburGraphicsContextWebGL';\r\nimport { QuadIndexBuffer } from '../quad-index-buffer';\r\nimport { RendererPlugin } from '../renderer';\r\nimport { Shader } from '../shader';\r\nimport { VertexBuffer } from '../vertex-buffer';\r\nimport { VertexLayout } from '../vertex-layout';\r\n\r\nimport frag from './circle-renderer.frag.glsl';\r\nimport vert from './circle-renderer.vert.glsl';\r\n\r\nexport class CircleRenderer implements RendererPlugin {\r\n  public readonly type = 'ex.circle';\r\n  public priority: number = 0;\r\n\r\n  private _maxCircles: number = 10922; // max(uint16) / 6 verts\r\n\r\n  private _shader: Shader;\r\n  private _context: ExcaliburGraphicsContextWebGL;\r\n  private _gl: WebGLRenderingContext;\r\n  private _buffer: VertexBuffer;\r\n  private _layout: VertexLayout;\r\n  private _quads: QuadIndexBuffer;\r\n\r\n  private _circleCount: number = 0;\r\n  private _vertexIndex: number = 0;\r\n\r\n  initialize(gl: WebGLRenderingContext, context: ExcaliburGraphicsContextWebGL): void {\r\n    this._gl = gl;\r\n    this._context = context;\r\n    this._shader = new Shader({\r\n      fragmentSource: frag,\r\n      vertexSource: vert\r\n    });\r\n    this._shader.compile();\r\n\r\n    // setup uniforms\r\n    this._shader.use();\r\n    this._shader.setUniformMatrix('u_matrix', context.ortho);\r\n\r\n    this._buffer = new VertexBuffer({\r\n      size: 14 * 4 * this._maxCircles,\r\n      type: 'dynamic'\r\n    });\r\n\r\n    this._layout = new VertexLayout({\r\n      shader: this._shader,\r\n      vertexBuffer: this._buffer,\r\n      attributes: [\r\n        ['a_position', 2],\r\n        ['a_uv', 2],\r\n        ['a_opacity', 1],\r\n        ['a_color', 4],\r\n        ['a_strokeColor', 4],\r\n        ['a_strokeThickness', 1]\r\n      ]\r\n    });\r\n\r\n    this._quads = new QuadIndexBuffer(this._maxCircles, true);\r\n  }\r\n\r\n  private _isFull() {\r\n    if (this._circleCount >= this._maxCircles) {\r\n      return true;\r\n    }\r\n    return false;\r\n  }\r\n\r\n  draw(pos: Vector, radius: number, color: Color, stroke: Color = Color.Transparent, strokeThickness: number = 0): void {\r\n    if (this._isFull()) {\r\n      this.flush();\r\n    }\r\n    this._circleCount++;\r\n\r\n    // transform based on current context\r\n    const transform = this._context.getTransform();\r\n    const opacity = this._context.opacity;\r\n\r\n    const topLeft = transform.multiply(pos.add(vec(-radius, -radius)));\r\n    const topRight = transform.multiply(pos.add(vec(radius, -radius)));\r\n    const bottomRight = transform.multiply(pos.add(vec(radius, radius)));\r\n    const bottomLeft = transform.multiply(pos.add(vec(-radius, radius)));\r\n\r\n    // TODO UV could be static vertex buffer\r\n    const uvx0 = 0;\r\n    const uvy0 = 0;\r\n    const uvx1 = 1;\r\n    const uvy1 = 1;\r\n\r\n    // update data\r\n    const vertexBuffer = this._layout.vertexBuffer.bufferData;\r\n\r\n    // (0, 0) - 0\r\n    vertexBuffer[this._vertexIndex++] = topLeft.x;\r\n    vertexBuffer[this._vertexIndex++] = topLeft.y;\r\n    vertexBuffer[this._vertexIndex++] = uvx0;\r\n    vertexBuffer[this._vertexIndex++] = uvy0;\r\n    vertexBuffer[this._vertexIndex++] = opacity;\r\n    vertexBuffer[this._vertexIndex++] = color.r / 255;\r\n    vertexBuffer[this._vertexIndex++] = color.g / 255;\r\n    vertexBuffer[this._vertexIndex++] = color.b / 255;\r\n    vertexBuffer[this._vertexIndex++] = color.a;\r\n    vertexBuffer[this._vertexIndex++] = stroke.r / 255;\r\n    vertexBuffer[this._vertexIndex++] = stroke.g / 255;\r\n    vertexBuffer[this._vertexIndex++] = stroke.b / 255;\r\n    vertexBuffer[this._vertexIndex++] = stroke.a;\r\n    vertexBuffer[this._vertexIndex++] = strokeThickness / radius;\r\n\r\n    // (0, 1) - 1\r\n    vertexBuffer[this._vertexIndex++] = bottomLeft.x;\r\n    vertexBuffer[this._vertexIndex++] = bottomLeft.y;\r\n    vertexBuffer[this._vertexIndex++] = uvx0;\r\n    vertexBuffer[this._vertexIndex++] = uvy1;\r\n    vertexBuffer[this._vertexIndex++] = opacity;\r\n    vertexBuffer[this._vertexIndex++] = color.r / 255;\r\n    vertexBuffer[this._vertexIndex++] = color.g / 255;\r\n    vertexBuffer[this._vertexIndex++] = color.b / 255;\r\n    vertexBuffer[this._vertexIndex++] = color.a;\r\n    vertexBuffer[this._vertexIndex++] = stroke.r / 255;\r\n    vertexBuffer[this._vertexIndex++] = stroke.g / 255;\r\n    vertexBuffer[this._vertexIndex++] = stroke.b / 255;\r\n    vertexBuffer[this._vertexIndex++] = stroke.a;\r\n    vertexBuffer[this._vertexIndex++] = strokeThickness / radius;\r\n\r\n    // (1, 0) - 2\r\n    vertexBuffer[this._vertexIndex++] = topRight.x;\r\n    vertexBuffer[this._vertexIndex++] = topRight.y;\r\n    vertexBuffer[this._vertexIndex++] = uvx1;\r\n    vertexBuffer[this._vertexIndex++] = uvy0;\r\n    vertexBuffer[this._vertexIndex++] = opacity;\r\n    vertexBuffer[this._vertexIndex++] = color.r / 255;\r\n    vertexBuffer[this._vertexIndex++] = color.g / 255;\r\n    vertexBuffer[this._vertexIndex++] = color.b / 255;\r\n    vertexBuffer[this._vertexIndex++] = color.a;\r\n    vertexBuffer[this._vertexIndex++] = stroke.r / 255;\r\n    vertexBuffer[this._vertexIndex++] = stroke.g / 255;\r\n    vertexBuffer[this._vertexIndex++] = stroke.b / 255;\r\n    vertexBuffer[this._vertexIndex++] = stroke.a;\r\n    vertexBuffer[this._vertexIndex++] = strokeThickness / radius;\r\n\r\n    // (1, 1) - 3\r\n    vertexBuffer[this._vertexIndex++] = bottomRight.x;\r\n    vertexBuffer[this._vertexIndex++] = bottomRight.y;\r\n    vertexBuffer[this._vertexIndex++] = uvx1;\r\n    vertexBuffer[this._vertexIndex++] = uvy1;\r\n    vertexBuffer[this._vertexIndex++] = opacity;\r\n    vertexBuffer[this._vertexIndex++] = color.r / 255;\r\n    vertexBuffer[this._vertexIndex++] = color.g / 255;\r\n    vertexBuffer[this._vertexIndex++] = color.b / 255;\r\n    vertexBuffer[this._vertexIndex++] = color.a;\r\n    vertexBuffer[this._vertexIndex++] = stroke.r / 255;\r\n    vertexBuffer[this._vertexIndex++] = stroke.g / 255;\r\n    vertexBuffer[this._vertexIndex++] = stroke.b / 255;\r\n    vertexBuffer[this._vertexIndex++] = stroke.a;\r\n    vertexBuffer[this._vertexIndex++] = strokeThickness / radius;\r\n  }\r\n\r\n  hasPendingDraws(): boolean {\r\n    return this._circleCount !== 0;\r\n  }\r\n\r\n  flush(): void {\r\n    // nothing to draw early exit\r\n    if (this._circleCount === 0) {\r\n      return;\r\n    }\r\n\r\n    const gl = this._gl;\r\n    // Bind the shader\r\n    this._shader.use();\r\n\r\n    // Bind the memory layout and upload data\r\n    this._layout.use(true);\r\n\r\n    // Update ortho matrix uniform\r\n    this._shader.setUniformMatrix('u_matrix', this._context.ortho);\r\n\r\n    // Bind index buffer\r\n    this._quads.bind();\r\n\r\n    // Draw all the quads\r\n    gl.drawElements(gl.TRIANGLES, this._circleCount * 6, this._quads.bufferGlType, 0);\r\n\r\n    GraphicsDiagnostics.DrawnImagesCount += this._circleCount;\r\n    GraphicsDiagnostics.DrawCallCount++;\r\n\r\n    // Reset\r\n    this._circleCount = 0;\r\n    this._vertexIndex = 0;\r\n  }\r\n\r\n}","import { Logger } from '..';\r\nexport class Pool<Type> {\r\n  public totalAllocations = 0;\r\n  public index = 0;\r\n  public objects: Type[] = [];\r\n  public disableWarnings = false;\r\n  private _logger = Logger.getInstance();\r\n\r\n  constructor(\r\n    public builder: (...args: any[]) => Type,\r\n    public recycler: (instance: Type, ...args: any[]) => Type,\r\n    public maxObjects: number = 100\r\n  ) {}\r\n\r\n  /**\r\n   * Use many instances out of the in the context and return all to the pool.\r\n   *\r\n   * By returning values out of the context they will be un-hooked from the pool and are free to be passed to consumers\r\n   * @param context\r\n   */\r\n  using(context: (pool: Pool<Type>) => Type[] | void) {\r\n    const result = context(this);\r\n    if (result) {\r\n      return this.done(...result);\r\n    }\r\n    return this.done();\r\n  }\r\n\r\n  /**\r\n   * Use a single instance out of th pool and immediately return it to the pool\r\n   * @param context\r\n   */\r\n  borrow(context: (object: Type) => void) {\r\n    const object = this.get();\r\n    context(object);\r\n    this.index--;\r\n  }\r\n\r\n  /**\r\n   * Retrieve a value from the pool, will allocate a new instance if necessary or recycle from the pool\r\n   * @param args\r\n   */\r\n  get(...args: any[]): Type {\r\n    if (this.index === this.maxObjects) {\r\n      if (!this.disableWarnings) {\r\n        this._logger.warn('Max pooled objects reached, possible memory leak? Doubling');\r\n      }\r\n      this.maxObjects = this.maxObjects * 2;\r\n    }\r\n\r\n    if (this.objects[this.index]) {\r\n      // Pool has an available object already constructed\r\n      return this.recycler(this.objects[this.index++], ...args);\r\n    } else {\r\n      // New allocation\r\n      this.totalAllocations++;\r\n      const object = (this.objects[this.index++] = this.builder(...args));\r\n      return object;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Signals we are done with the pool objects for now, Reclaims all objects in the pool.\r\n   *\r\n   * If a list of pooled objects is passed to done they are un-hooked from the pool and are free\r\n   * to be passed to consumers\r\n   * @param objects A list of object to separate from the pool\r\n   */\r\n  done(...objects: Type[]): Type[];\r\n  done(): void;\r\n  done(...objects: Type[]): Type[] | void {\r\n    // All objects in pool now considered \"free\"\r\n    this.index = 0;\r\n    for (const object of objects) {\r\n      const poolIndex = this.objects.indexOf(object);\r\n      // Build a new object to take the pool place\r\n      this.objects[poolIndex] = (this as any).builder(); // TODO problematic 0-arg only support\r\n      this.totalAllocations++;\r\n    }\r\n    return objects;\r\n  }\r\n}\r\n","import { Matrix } from '../../Math/matrix';\r\nimport { ExcaliburGraphicsContextState } from './ExcaliburGraphicsContext';\r\n\r\nexport class DrawCall {\r\n  public z: number = 0;\r\n  public priority: number = 0;\r\n  public renderer: string;\r\n  public transform: Matrix = Matrix.identity();\r\n  public state: ExcaliburGraphicsContextState = {\r\n    z: 0,\r\n    opacity: 1\r\n  };\r\n  public args: any[];\r\n}","import {\r\n  ExcaliburGraphicsContext,\r\n  LineGraphicsOptions,\r\n  RectGraphicsOptions,\r\n  PointGraphicsOptions,\r\n  ExcaliburGraphicsContextOptions,\r\n  DebugDraw,\r\n  HTMLImageSource\r\n} from './ExcaliburGraphicsContext';\r\n\r\nimport { Matrix } from '../../Math/matrix';\r\nimport { TransformStack } from './transform-stack';\r\nimport { Vector, vec } from '../../Math/vector';\r\nimport { Color } from '../../Color';\r\nimport { StateStack } from './state-stack';\r\nimport { Logger } from '../../Util/Log';\r\nimport { DebugText } from './debug-text';\r\nimport { ScreenDimension } from '../../Screen';\r\nimport { RenderTarget } from './render-target';\r\nimport { PostProcessor } from '../PostProcessor/PostProcessor';\r\nimport { ExcaliburWebGLContextAccessor } from './webgl-adapter';\r\nimport { TextureLoader } from './texture-loader';\r\nimport { RendererPlugin } from './renderer';\r\n\r\n// renderers\r\nimport { LineRenderer } from './line-renderer/line-renderer';\r\nimport { PointRenderer } from './point-renderer/point-renderer';\r\nimport { ScreenPassPainter } from './screen-pass-painter/screen-pass-painter';\r\nimport { ImageRenderer } from './image-renderer/image-renderer';\r\nimport { RectangleRenderer } from './rectangle-renderer/rectangle-renderer';\r\nimport { CircleRenderer } from './circle-renderer/circle-renderer';\r\nimport { Pool } from '../../Util/Pool';\r\nimport { DrawCall } from './draw-call';\r\n\r\nclass ExcaliburGraphicsContextWebGLDebug implements DebugDraw {\r\n  private _debugText = new DebugText();\r\n  constructor(private _webglCtx: ExcaliburGraphicsContextWebGL) {}\r\n\r\n  /**\r\n   * Draw a debugging rectangle to the context\r\n   * @param x\r\n   * @param y\r\n   * @param width\r\n   * @param height\r\n   */\r\n  drawRect(x: number, y: number, width: number, height: number, rectOptions: RectGraphicsOptions = { color: Color.Black }): void {\r\n    this.drawLine(vec(x, y), vec(x + width, y), { ...rectOptions });\r\n    this.drawLine(vec(x + width, y), vec(x + width, y + height), { ...rectOptions });\r\n    this.drawLine(vec(x + width, y + height), vec(x, y + height), { ...rectOptions });\r\n    this.drawLine(vec(x, y + height), vec(x, y), { ...rectOptions });\r\n  }\r\n\r\n  /**\r\n   * Draw a debugging line to the context\r\n   * @param start\r\n   * @param end\r\n   * @param lineOptions\r\n   */\r\n  drawLine(start: Vector, end: Vector, lineOptions: LineGraphicsOptions = { color: Color.Black }): void {\r\n    this._webglCtx.draw<LineRenderer>('ex.line', start, end, lineOptions.color);\r\n  }\r\n\r\n  /**\r\n   * Draw a debugging point to the context\r\n   * @param point\r\n   * @param pointOptions\r\n   */\r\n  drawPoint(point: Vector, pointOptions: PointGraphicsOptions = { color: Color.Black, size: 5 }): void {\r\n    this._webglCtx.draw<PointRenderer>('ex.point', point, pointOptions.color, pointOptions.size);\r\n  }\r\n\r\n  drawText(text: string, pos: Vector) {\r\n    this._debugText.write(this._webglCtx, text, pos);\r\n  }\r\n}\r\n\r\nexport interface WebGLGraphicsContextInfo {\r\n  transform: TransformStack;\r\n  state: StateStack;\r\n  ortho: Matrix;\r\n  context: ExcaliburGraphicsContextWebGL;\r\n}\r\n\r\nexport class ExcaliburGraphicsContextWebGL implements ExcaliburGraphicsContext {\r\n  private _logger = Logger.getInstance();\r\n  private _renderers: Map<string, RendererPlugin> = new Map<string, RendererPlugin>();\r\n  private _isDrawLifecycle = false;\r\n  public useDrawSorting = true;\r\n\r\n  private _drawCallPool = new Pool<DrawCall>(\r\n    () => new DrawCall(),\r\n    (instance) => {\r\n      instance.priority = 0;\r\n      instance.z = 0;\r\n      instance.renderer = undefined;\r\n      instance.args = undefined;\r\n      return instance;\r\n    });\r\n  private _drawCalls: DrawCall[] = [];\r\n\r\n  // Main render target\r\n  private _renderTarget: RenderTarget;\r\n\r\n  // Postprocessing is a tuple with 2 render targets, these are flip-flopped during the postprocessing process\r\n  private _postProcessTargets: RenderTarget[] = [];\r\n\r\n  private _screenRenderer: ScreenPassPainter;\r\n\r\n  private _postprocessors: PostProcessor[] = [];\r\n  /**\r\n   * Meant for internal use only. Access the internal context at your own risk and no guarantees this will exist in the future.\r\n   * @internal\r\n   */\r\n  public __gl: WebGL2RenderingContext;\r\n\r\n  private _transform = new TransformStack();\r\n  private _state = new StateStack();\r\n  private _ortho!: Matrix;\r\n\r\n  public snapToPixel: boolean = true;\r\n\r\n  public smoothing: boolean = false;\r\n\r\n  public backgroundColor: Color = Color.ExcaliburBlue;\r\n\r\n  public get z(): number {\r\n    return this._state.current.z;\r\n  }\r\n\r\n  public set z(value: number) {\r\n    this._state.current.z = value;\r\n  }\r\n\r\n  public get opacity(): number {\r\n    return this._state.current.opacity;\r\n  }\r\n\r\n  public set opacity(value: number) {\r\n    this._state.current.opacity = value;\r\n  }\r\n\r\n  public get width() {\r\n    return this.__gl.canvas.width;\r\n  }\r\n\r\n  public get height() {\r\n    return this.__gl.canvas.height;\r\n  }\r\n\r\n  public get ortho(): Matrix {\r\n    return this._ortho;\r\n  }\r\n\r\n  /**\r\n   * Checks the underlying webgl implementation if the requested internal resolution is supported\r\n   * @param dim\r\n   */\r\n  public checkIfResolutionSupported(dim: ScreenDimension): boolean {\r\n    // Slight hack based on this thread https://groups.google.com/g/webgl-dev-list/c/AHONvz3oQTo\r\n    let supported = true;\r\n    if (dim.width > 4096 || dim.height > 4096) {\r\n      supported = false;\r\n    }\r\n    return supported;\r\n  }\r\n\r\n  constructor(options: ExcaliburGraphicsContextOptions) {\r\n    const { canvasElement, enableTransparency, smoothing, snapToPixel, backgroundColor, useDrawSorting } = options;\r\n    this.__gl = canvasElement.getContext('webgl2', {\r\n      antialias: smoothing ?? this.smoothing,\r\n      premultipliedAlpha: false,\r\n      alpha: enableTransparency ?? true,\r\n      depth: true,\r\n      powerPreference: 'high-performance',\r\n      failIfMajorPerformanceCaveat: true\r\n    });\r\n    if (!this.__gl) {\r\n      throw Error('Failed to retrieve webgl context from browser');\r\n    }\r\n    ExcaliburWebGLContextAccessor.register(this.__gl);\r\n    TextureLoader.register(this.__gl);\r\n    this.snapToPixel = snapToPixel ?? this.snapToPixel;\r\n    this.smoothing = smoothing ?? this.smoothing;\r\n    this.backgroundColor = backgroundColor ?? this.backgroundColor;\r\n    this.useDrawSorting = useDrawSorting ?? this.useDrawSorting;\r\n    this._drawCallPool.disableWarnings = true;\r\n    this._init();\r\n  }\r\n\r\n  private _init() {\r\n    const gl = this.__gl;\r\n    // Setup viewport and view matrix\r\n    this._ortho = Matrix.ortho(0, gl.canvas.width, gl.canvas.height, 0, 400, -400);\r\n    gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);\r\n\r\n    // Clear background\r\n    gl.clearColor(this.backgroundColor.r / 255, this.backgroundColor.g / 255, this.backgroundColor.b / 255, this.backgroundColor.a);\r\n    gl.clear(gl.COLOR_BUFFER_BIT);\r\n\r\n    // Enable alpha blending\r\n    // https://www.realtimerendering.com/blog/gpus-prefer-premultiplication/\r\n    gl.enable(gl.BLEND);\r\n    gl.blendEquation(gl.FUNC_ADD);\r\n    gl.blendFunc(gl.ONE, gl.ONE_MINUS_SRC_ALPHA);\r\n    gl.blendEquationSeparate(gl.FUNC_ADD, gl.FUNC_ADD);\r\n    gl.blendFuncSeparate(gl.ONE, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA);\r\n\r\n    // Setup builtin renderers\r\n    this.register(new ImageRenderer());\r\n    this.register(new RectangleRenderer());\r\n    this.register(new CircleRenderer());\r\n    this.register(new PointRenderer());\r\n    this.register(new LineRenderer());\r\n\r\n    this._screenRenderer = new ScreenPassPainter(gl);\r\n\r\n    this._renderTarget = new RenderTarget({\r\n      gl,\r\n      width: gl.canvas.width,\r\n      height: gl.canvas.height\r\n    });\r\n\r\n\r\n    this._postProcessTargets = [\r\n      new RenderTarget({\r\n        gl,\r\n        width: gl.canvas.width,\r\n        height: gl.canvas.height\r\n      }),\r\n      new RenderTarget({\r\n        gl,\r\n        width: gl.canvas.width,\r\n        height: gl.canvas.height\r\n      })\r\n    ];\r\n  }\r\n\r\n  public register<T extends RendererPlugin>(renderer: T) {\r\n    this._renderers.set(renderer.type, renderer);\r\n    renderer.initialize(this.__gl, this);\r\n  }\r\n\r\n  public get(rendererName: string): RendererPlugin {\r\n    return this._renderers.get(rendererName);\r\n  }\r\n\r\n  private _currentRenderer: RendererPlugin;\r\n\r\n  private _isCurrentRenderer(renderer: RendererPlugin): boolean {\r\n    if (!this._currentRenderer || this._currentRenderer === renderer) {\r\n      return true;\r\n    }\r\n    return false;\r\n  }\r\n\r\n  public beginDrawLifecycle() {\r\n    this._isDrawLifecycle = true;\r\n  }\r\n\r\n  public endDrawLifecycle() {\r\n    this._isDrawLifecycle = false;\r\n  }\r\n\r\n  private _alreadyWarnedDrawLifecycle = false;\r\n\r\n  public draw<TRenderer extends RendererPlugin>(rendererName: TRenderer['type'], ...args: Parameters<TRenderer['draw']>) {\r\n    if (!this._isDrawLifecycle && !this._alreadyWarnedDrawLifecycle) {\r\n      this._logger.warn(\r\n        `Attempting to draw outside the the drawing lifecycle (preDraw/postDraw) is not supported and is a source of bugs/errors.\\n` +\r\n        `If you want to do custom drawing, use Actor.graphics, or any onPreDraw or onPostDraw handler.`);\r\n      this._alreadyWarnedDrawLifecycle = true;\r\n    }\r\n\r\n    const renderer = this._renderers.get(rendererName);\r\n    if (renderer) {\r\n      if (this.useDrawSorting) {\r\n        const drawCall = this._drawCallPool.get();\r\n        drawCall.z = this._state.current.z;\r\n        drawCall.priority = renderer.priority;\r\n        drawCall.renderer = rendererName;\r\n        this.getTransform().clone(drawCall.transform);\r\n        drawCall.state.z = this._state.current.z;\r\n        drawCall.state.opacity = this._state.current.opacity;\r\n        drawCall.args = args;\r\n        this._drawCalls.push(drawCall);\r\n      } else {\r\n        // Set the current renderer if not defined\r\n        if (!this._currentRenderer) {\r\n          this._currentRenderer = renderer;\r\n        }\r\n\r\n        if (!this._isCurrentRenderer(renderer)) {\r\n          // switching graphics means we must flush the previous\r\n          this._currentRenderer.flush();\r\n        }\r\n\r\n        // If we are still using the same renderer we can add to the current batch\r\n        renderer.draw(...args);\r\n\r\n        this._currentRenderer = renderer;\r\n      }\r\n    } else {\r\n      throw Error(`No renderer with name ${rendererName} has been registered`);\r\n    }\r\n  }\r\n\r\n  public resetTransform(): void {\r\n    this._transform.current = Matrix.identity();\r\n  }\r\n\r\n  public updateViewport(resolution: ScreenDimension): void {\r\n    const gl = this.__gl;\r\n    this._ortho = this._ortho = Matrix.ortho(0, resolution.width, resolution.height, 0, 400, -400);\r\n\r\n    this._renderTarget.setResolution(gl.canvas.width, gl.canvas.height);\r\n    this._postProcessTargets[0].setResolution(gl.canvas.width, gl.canvas.height);\r\n    this._postProcessTargets[1].setResolution(gl.canvas.width, gl.canvas.height);\r\n  }\r\n\r\n  drawImage(image: HTMLImageSource, x: number, y: number): void;\r\n  drawImage(image: HTMLImageSource, x: number, y: number, width: number, height: number): void;\r\n  drawImage(\r\n    image: HTMLImageSource,\r\n    sx: number,\r\n    sy: number,\r\n    swidth?: number,\r\n    sheight?: number,\r\n    dx?: number,\r\n    dy?: number,\r\n    dwidth?: number,\r\n    dheight?: number\r\n  ): void;\r\n  drawImage(\r\n    image: HTMLImageSource,\r\n    sx: number,\r\n    sy: number,\r\n    swidth?: number,\r\n    sheight?: number,\r\n    dx?: number,\r\n    dy?: number,\r\n    dwidth?: number,\r\n    dheight?: number\r\n  ): void {\r\n    if (swidth === 0 || sheight === 0) {\r\n      return; // zero dimension dest exit early\r\n    } else if (dwidth === 0 || dheight === 0) {\r\n      return; // zero dimension dest exit early\r\n    } else if (image.width === 0 || image.height === 0) {\r\n      return; // zero dimension source exit early\r\n    }\r\n\r\n    if (!image) {\r\n      Logger.getInstance().warn('Cannot draw a null or undefined image');\r\n      // tslint:disable-next-line: no-console\r\n      if (console.trace) {\r\n        // tslint:disable-next-line: no-console\r\n        console.trace();\r\n      }\r\n      return;\r\n    }\r\n    this.draw<ImageRenderer>('ex.image', image, sx, sy, swidth, sheight, dx, dy, dwidth, dheight);\r\n  }\r\n\r\n  public drawLine(start: Vector, end: Vector, color: Color, thickness = 1) {\r\n    this.draw<RectangleRenderer>('ex.rectangle', start, end, color, thickness);\r\n  }\r\n\r\n  public drawRectangle(pos: Vector, width: number, height: number, color: Color, stroke?: Color, strokeThickness?: number) {\r\n    this.draw<RectangleRenderer>('ex.rectangle', pos, width, height, color, stroke, strokeThickness);\r\n  }\r\n\r\n  public drawCircle(pos: Vector, radius: number, color: Color, stroke?: Color, thickness?: number) {\r\n    this.draw<CircleRenderer>('ex.circle', pos, radius, color, stroke, thickness);\r\n  }\r\n\r\n  debug = new ExcaliburGraphicsContextWebGLDebug(this);\r\n\r\n  public save(): void {\r\n    this._transform.save();\r\n    this._state.save();\r\n  }\r\n\r\n  public restore(): void {\r\n    this._transform.restore();\r\n    this._state.restore();\r\n  }\r\n\r\n  public translate(x: number, y: number): void {\r\n    this._transform.translate(this.snapToPixel ? ~~x : x, this.snapToPixel ? ~~y : y);\r\n  }\r\n\r\n  public rotate(angle: number): void {\r\n    this._transform.rotate(angle);\r\n  }\r\n\r\n  public scale(x: number, y: number): void {\r\n    this._transform.scale(x, y);\r\n  }\r\n\r\n  public transform(matrix: Matrix) {\r\n    this._transform.current = matrix;\r\n  }\r\n\r\n  public getTransform(): Matrix {\r\n    return this._transform.current;\r\n  }\r\n\r\n  public multiply(m: Matrix) {\r\n    this._transform.current = this._transform.current.multiply(m);\r\n  }\r\n\r\n  public addPostProcessor(postprocessor: PostProcessor) {\r\n    this._postprocessors.push(postprocessor);\r\n    postprocessor.initialize(this.__gl);\r\n  }\r\n\r\n  public removePostProcessor(postprocessor: PostProcessor) {\r\n    const index = this._postprocessors.indexOf(postprocessor);\r\n    if (index !== -1) {\r\n      this._postprocessors.splice(index, 1);\r\n    }\r\n  }\r\n\r\n  public clearPostProcessors() {\r\n    this._postprocessors.length = 0;\r\n  }\r\n\r\n  clear() {\r\n    const gl = this.__gl;\r\n    this._renderTarget.use();\r\n    gl.clearColor(this.backgroundColor.r / 255, this.backgroundColor.g / 255, this.backgroundColor.b / 255, this.backgroundColor.a);\r\n    // Clear the context with the newly set color. This is\r\n    // the function call that actually does the drawing.\r\n    gl.clear(gl.COLOR_BUFFER_BIT);\r\n  }\r\n\r\n  /**\r\n   * Flushes all batched rendering to the screen\r\n   */\r\n  flush() {\r\n    const gl = this.__gl;\r\n\r\n    // render target captures all draws and redirects to the render target\r\n    this._renderTarget.use();\r\n\r\n    if (this.useDrawSorting) {\r\n      // sort draw calls\r\n      // Find the original order of the first instance of the draw call\r\n      const originalSort = new Map<string, number>();\r\n      for (const [name] of this._renderers) {\r\n        const firstIndex = this._drawCalls.findIndex(dc => dc.renderer === name);\r\n        originalSort.set(name, firstIndex);\r\n      }\r\n\r\n      this._drawCalls.sort((a, b) => {\r\n        const zIndex = a.z - b.z;\r\n        const originalSortOrder = originalSort.get(a.renderer) - originalSort.get(b.renderer);\r\n        const priority = a.priority - b.priority;\r\n        if (zIndex === 0) { // sort by z first\r\n          if (priority === 0) { // sort by priority\r\n            return originalSortOrder; // use the original order to inform draw call packing to maximally preserve painter order\r\n          }\r\n          return priority;\r\n        }\r\n        return zIndex;\r\n      });\r\n\r\n      const oldTransform = this._transform.current;\r\n      const oldState = this._state.current;\r\n\r\n      if (this._drawCalls.length) {\r\n        let currentRendererName = this._drawCalls[0].renderer;\r\n        let currentRenderer = this._renderers.get(currentRendererName);\r\n        for (let i = 0; i < this._drawCalls.length; i++) {\r\n          // hydrate the state for renderers\r\n          this._transform.current = this._drawCalls[i].transform;\r\n          this._state.current = this._drawCalls[i].state;\r\n\r\n          if (this._drawCalls[i].renderer !== currentRendererName) {\r\n            // switching graphics renderer means we must flush the previous\r\n            currentRenderer.flush();\r\n            currentRendererName = this._drawCalls[i].renderer;\r\n            currentRenderer = this._renderers.get(currentRendererName);\r\n          }\r\n\r\n          // If we are still using the same renderer we can add to the current batch\r\n          currentRenderer.draw(...this._drawCalls[i].args);\r\n        }\r\n        if (currentRenderer.hasPendingDraws()) {\r\n          currentRenderer.flush();\r\n        }\r\n      }\r\n\r\n      // reset state\r\n      this._transform.current = oldTransform;\r\n      this._state.current = oldState;\r\n\r\n      // reclaim draw calls\r\n      this._drawCallPool.done();\r\n      this._drawCalls.length = 0;\r\n    } else {\r\n      // This is the final flush at the moment to draw any leftover pending draw\r\n      for (const renderer of this._renderers.values()) {\r\n        if (renderer.hasPendingDraws()) {\r\n          renderer.flush();\r\n        }\r\n      }\r\n    }\r\n\r\n    this._renderTarget.disable();\r\n\r\n    // post process step\r\n    const source = this._renderTarget.toRenderSource();\r\n    source.use();\r\n\r\n    // flip flop render targets\r\n    for (let i = 0; i < this._postprocessors.length; i++) {\r\n      this._postProcessTargets[i % 2].use();\r\n      this._screenRenderer.renderWithPostProcessor(this._postprocessors[i]);\r\n      this._postProcessTargets[i % 2].toRenderSource().use();\r\n    }\r\n\r\n    // passing null switches rendering back to the canvas\r\n    gl.bindFramebuffer(gl.FRAMEBUFFER, null);\r\n    this._screenRenderer.renderToScreen();\r\n  }\r\n}\r\n","import {\r\n  ExcaliburGraphicsContext,\r\n  LineGraphicsOptions,\r\n  PointGraphicsOptions,\r\n  ExcaliburGraphicsContextOptions,\r\n  DebugDraw,\r\n  HTMLImageSource\r\n} from './ExcaliburGraphicsContext';\r\nimport { Vector } from '../../Math/vector';\r\nimport { Color } from '../../Color';\r\nimport { StateStack } from './state-stack';\r\nimport { GraphicsDiagnostics } from '../GraphicsDiagnostics';\r\nimport { DebugText } from './debug-text';\r\nimport { Matrix } from '../../Math/matrix';\r\nimport { ScreenDimension } from '../../Screen';\r\nimport { PostProcessor } from '../PostProcessor/PostProcessor';\r\n\r\nclass ExcaliburGraphicsContext2DCanvasDebug implements DebugDraw {\r\n  private _debugText = new DebugText();\r\n  constructor(private _ex: ExcaliburGraphicsContext2DCanvas) {}\r\n  /**\r\n   * Draw a debug rectangle to the context\r\n   * @param x\r\n   * @param y\r\n   * @param width\r\n   * @param height\r\n   */\r\n  drawRect(x: number, y: number, width: number, height: number): void {\r\n    this._ex.__ctx.save();\r\n    this._ex.__ctx.strokeStyle = 'red';\r\n    this._ex.__ctx.strokeRect(\r\n      this._ex.snapToPixel ? ~~x : x,\r\n      this._ex.snapToPixel ? ~~y : y,\r\n      this._ex.snapToPixel ? ~~width : width,\r\n      this._ex.snapToPixel ? ~~height : height\r\n    );\r\n    this._ex.__ctx.restore();\r\n  }\r\n\r\n  drawLine(start: Vector, end: Vector, lineOptions: LineGraphicsOptions = { color: Color.Black }): void {\r\n    this._ex.__ctx.save();\r\n    this._ex.__ctx.beginPath();\r\n    this._ex.__ctx.strokeStyle = lineOptions.color.toString();\r\n    this._ex.__ctx.moveTo(this._ex.snapToPixel ? ~~start.x : start.x, this._ex.snapToPixel ? ~~start.y : start.y);\r\n    this._ex.__ctx.lineTo(this._ex.snapToPixel ? ~~end.x : end.x, this._ex.snapToPixel ? ~~end.y : end.y);\r\n    this._ex.__ctx.lineWidth = 2;\r\n    this._ex.__ctx.stroke();\r\n    this._ex.__ctx.closePath();\r\n    this._ex.__ctx.restore();\r\n  }\r\n\r\n  drawPoint(point: Vector, pointOptions: PointGraphicsOptions = { color: Color.Black, size: 5 }): void {\r\n    this._ex.__ctx.save();\r\n    this._ex.__ctx.beginPath();\r\n    this._ex.__ctx.fillStyle = pointOptions.color.toString();\r\n    this._ex.__ctx.arc(\r\n      this._ex.snapToPixel ? ~~point.x : point.x,\r\n      this._ex.snapToPixel ? ~~point.y : point.y,\r\n      pointOptions.size,\r\n      0,\r\n      Math.PI * 2\r\n    );\r\n    this._ex.__ctx.fill();\r\n    this._ex.__ctx.closePath();\r\n    this._ex.__ctx.restore();\r\n  }\r\n\r\n  drawText(text: string, pos: Vector) {\r\n    this._debugText.write(this._ex, text, pos);\r\n  }\r\n}\r\n\r\nexport class ExcaliburGraphicsContext2DCanvas implements ExcaliburGraphicsContext {\r\n  /**\r\n   * Meant for internal use only. Access the internal context at your own risk and no guarantees this will exist in the future.\r\n   * @internal\r\n   */\r\n  public __ctx: CanvasRenderingContext2D;\r\n  public get width() {\r\n    return this.__ctx.canvas.width;\r\n  }\r\n\r\n  public get height() {\r\n    return this.__ctx.canvas.height;\r\n  }\r\n\r\n  /**\r\n   * Unused in Canvas implementation\r\n   */\r\n  public readonly useDrawSorting: boolean = false;\r\n\r\n  /**\r\n   * Unused in Canvas implementation\r\n   */\r\n  public z: number = 0;\r\n\r\n  public backgroundColor: Color = Color.ExcaliburBlue;\r\n\r\n  private _state = new StateStack();\r\n\r\n  public get opacity(): number {\r\n    return this._state.current.opacity;\r\n  }\r\n\r\n  public set opacity(value: number) {\r\n    this._state.current.opacity = value;\r\n  }\r\n\r\n  public snapToPixel: boolean = true;\r\n\r\n  public get smoothing(): boolean {\r\n    return this.__ctx.imageSmoothingEnabled;\r\n  }\r\n\r\n  public set smoothing(value: boolean) {\r\n    this.__ctx.imageSmoothingEnabled = value;\r\n  }\r\n\r\n  constructor(options: ExcaliburGraphicsContextOptions) {\r\n    const { canvasElement, enableTransparency, snapToPixel, smoothing, backgroundColor } = options;\r\n    this.__ctx = canvasElement.getContext('2d', {\r\n      alpha: enableTransparency ?? true\r\n    });\r\n    this.backgroundColor = backgroundColor ?? this.backgroundColor;\r\n    this.snapToPixel = snapToPixel ?? this.snapToPixel;\r\n    this.smoothing = smoothing ?? this.smoothing;\r\n  }\r\n\r\n  public resetTransform(): void {\r\n    this.__ctx.resetTransform();\r\n  }\r\n\r\n  public updateViewport(_resolution: ScreenDimension): void {\r\n    // pass\r\n  }\r\n\r\n  /**\r\n   * Draw an image to the Excalibur Graphics context at an x and y coordinate using the images width and height\r\n   */\r\n  drawImage(image: HTMLImageSource, x: number, y: number): void;\r\n  /**\r\n   *\r\n   * Draw an image to the Excalibur Graphics context at an x and y coordinate with a specific width and height\r\n   */\r\n  drawImage(image: HTMLImageSource, x: number, y: number, width: number, height: number): void;\r\n  /**\r\n   *\r\n   * Draw an image to the Excalibur Graphics context specifying the source image coordinates (sx, sy, swidth, sheight)\r\n   * and to a specific destination on the context (dx, dy, dwidth, dheight)\r\n   */\r\n  drawImage(\r\n    image: HTMLImageSource,\r\n    sx: number,\r\n    sy: number,\r\n    swidth?: number,\r\n    sheight?: number,\r\n    dx?: number,\r\n    dy?: number,\r\n    dwidth?: number,\r\n    dheight?: number\r\n  ): void;\r\n\r\n  drawImage(\r\n    image: HTMLImageSource,\r\n    sx: number,\r\n    sy: number,\r\n    swidth?: number,\r\n    sheight?: number,\r\n    dx?: number,\r\n    dy?: number,\r\n    dwidth?: number,\r\n    dheight?: number\r\n  ): void {\r\n    if (swidth === 0 || sheight === 0) {\r\n      return; // zero dimension dest exit early\r\n    } else if (dwidth === 0 || dheight === 0) {\r\n      return; // zero dimension dest exit early\r\n    } else if (image.width === 0 || image.height === 0) {\r\n      return; // zero dimension source exit early\r\n    }\r\n\r\n    this.__ctx.globalAlpha = this.opacity;\r\n    const args = [image, sx, sy, swidth, sheight, dx, dy, dwidth, dheight]\r\n      .filter((a) => a !== undefined)\r\n      .map((a) => (typeof a === 'number' && this.snapToPixel ? ~~a : a));\r\n    this.__ctx.drawImage.apply(this.__ctx, args);\r\n    GraphicsDiagnostics.DrawCallCount++;\r\n    GraphicsDiagnostics.DrawnImagesCount = 1;\r\n  }\r\n\r\n  public drawLine(start: Vector, end: Vector, color: Color, thickness = 1) {\r\n    this.__ctx.save();\r\n    this.__ctx.beginPath();\r\n    this.__ctx.strokeStyle = color.toString();\r\n    this.__ctx.moveTo(this.snapToPixel ? ~~start.x : start.x, this.snapToPixel ? ~~start.y : start.y);\r\n    this.__ctx.lineTo(this.snapToPixel ? ~~end.x : end.x, this.snapToPixel ? ~~end.y : end.y);\r\n    this.__ctx.lineWidth = thickness;\r\n    this.__ctx.stroke();\r\n    this.__ctx.closePath();\r\n    this.__ctx.restore();\r\n  }\r\n\r\n  public drawRectangle(pos: Vector, width: number, height: number, color: Color) {\r\n    this.__ctx.save();\r\n    this.__ctx.fillStyle = color.toString();\r\n    this.__ctx.fillRect(\r\n      this.snapToPixel ? ~~pos.x : pos.x,\r\n      this.snapToPixel ? ~~pos.y : pos.y,\r\n      this.snapToPixel ? ~~width : width,\r\n      this.snapToPixel ? ~~height : height\r\n    );\r\n    this.__ctx.restore();\r\n  }\r\n\r\n  public drawCircle(pos: Vector, radius: number, color: Color, stroke?: Color, thickness?: number) {\r\n    this.__ctx.save();\r\n    this.__ctx.beginPath();\r\n    if (stroke) {\r\n      this.__ctx.strokeStyle = stroke.toString();\r\n    }\r\n    if (thickness) {\r\n      this.__ctx.lineWidth = thickness;\r\n    }\r\n    this.__ctx.fillStyle = color.toString();\r\n    this.__ctx.arc(this.snapToPixel ? ~~pos.x : pos.x, this.snapToPixel ? ~~pos.y : pos.y, radius, 0, Math.PI * 2);\r\n    this.__ctx.fill();\r\n    if (stroke) {\r\n      this.__ctx.stroke();\r\n    }\r\n    this.__ctx.closePath();\r\n    this.__ctx.restore();\r\n  }\r\n\r\n  debug = new ExcaliburGraphicsContext2DCanvasDebug(this);\r\n\r\n  /**\r\n   * Save the current state of the canvas to the stack (transforms and opacity)\r\n   */\r\n  save(): void {\r\n    this.__ctx.save();\r\n  }\r\n\r\n  /**\r\n   * Restore the state of the canvas from the stack\r\n   */\r\n  restore(): void {\r\n    this.__ctx.restore();\r\n  }\r\n\r\n  /**\r\n   * Translate the origin of the context by an x and y\r\n   * @param x\r\n   * @param y\r\n   */\r\n  translate(x: number, y: number): void {\r\n    this.__ctx.translate(this.snapToPixel ? ~~x : x, this.snapToPixel ? ~~y : y);\r\n  }\r\n\r\n  /**\r\n   * Rotate the context about the current origin\r\n   */\r\n  rotate(angle: number): void {\r\n    this.__ctx.rotate(angle);\r\n  }\r\n\r\n  /**\r\n   * Scale the context by an x and y factor\r\n   * @param x\r\n   * @param y\r\n   */\r\n  scale(x: number, y: number): void {\r\n    this.__ctx.scale(x, y);\r\n  }\r\n\r\n  public getTransform(): Matrix {\r\n    throw new Error('Not implemented');\r\n  }\r\n\r\n  public multiply(_m: Matrix): void {\r\n    this.__ctx.setTransform(this.__ctx.getTransform().multiply(_m.toDOMMatrix()));\r\n  }\r\n\r\n  public addPostProcessor(_postprocessor: PostProcessor) {\r\n    // pass\r\n  }\r\n\r\n  public removePostProcessor(_postprocessor: PostProcessor) {\r\n    // pass\r\n  }\r\n\r\n  public clearPostProcessors() {\r\n    // pass\r\n  }\r\n\r\n  public beginDrawLifecycle() {\r\n    // pass\r\n  }\r\n\r\n  public endDrawLifecycle() {\r\n    // pass\r\n  }\r\n\r\n  clear(): void {\r\n    // Clear frame\r\n    this.__ctx.clearRect(0, 0, this.width, this.height);\r\n    this.__ctx.fillStyle = this.backgroundColor.toString();\r\n    this.__ctx.fillRect(0, 0, this.width, this.height);\r\n    GraphicsDiagnostics.clear();\r\n  }\r\n\r\n  /**\r\n   * Flushes the batched draw calls to the screen\r\n   */\r\n  flush(): void {\r\n    // pass\r\n  }\r\n}\r\n","import { vec, Vector } from './Math/vector';\r\nimport { Logger } from './Util/Log';\r\nimport { Camera } from './Camera';\r\nimport { BrowserEvents } from './Util/Browser';\r\nimport { BoundingBox } from './Collision/Index';\r\nimport { ExcaliburGraphicsContext } from './Graphics/Context/ExcaliburGraphicsContext';\r\nimport { getPosition } from './Util/Util';\r\nimport { ExcaliburGraphicsContextWebGL } from './Graphics/Context/ExcaliburGraphicsContextWebGL';\r\nimport { ExcaliburGraphicsContext2DCanvas } from './Graphics/Context/ExcaliburGraphicsContext2DCanvas';\r\n\r\n/**\r\n * Enum representing the different display modes available to Excalibur.\r\n */\r\nexport enum DisplayMode {\r\n  /**\r\n   * Default, use a specified resolution for the game. Like 800x600 pixels for example.\r\n   */\r\n  Fixed = 'Fixed',\r\n\r\n  /**\r\n   * Fit the aspect ratio given by the game resolution within the container at all times will fill any gaps with canvas.\r\n   * The displayed area outside the aspect ratio is not guaranteed to be on the screen, only the [[Screen.contentArea]]\r\n   * is guaranteed to be on screen.\r\n   */\r\n  FitContainerAndFill = 'FitContainerAndFill',\r\n\r\n  /**\r\n   * Fit the aspect ratio given by the game resolution the screen at all times will fill the screen.\r\n   * This displayed area outside the aspect ratio is not guaranteed to be on the screen, only the [[Screen.contentArea]]\r\n   * is guaranteed to be on screen.\r\n   */\r\n  FitScreenAndFill = 'FitScreenAndFill',\r\n\r\n  /**\r\n   * Fit the viewport to the parent element maintaining aspect ratio given by the game resolution, but zooms in to avoid the black bars\r\n   * (letterbox) that would otherwise be present in [[FitContainer]].\r\n   *\r\n   * **warning** This will clip some drawable area from the user because of the zoom,\r\n   * use [[Screen.contentArea]] to know the safe to draw area.\r\n   */\r\n  FitContainerAndZoom = 'FitContainerAndZoom',\r\n\r\n  /**\r\n   * Fit the viewport to the device screen maintaining aspect ratio given by the game resolution, but zooms in to avoid the black bars\r\n   * (letterbox) that would otherwise be present in [[FitScreen]].\r\n   *\r\n   * **warning** This will clip some drawable area from the user because of the zoom,\r\n   * use [[Screen.contentArea]] to know the safe to draw area.\r\n   */\r\n  FitScreenAndZoom = 'FitScreenAndZoom',\r\n\r\n  /**\r\n   * Fit to screen using as much space as possible while maintaining aspect ratio and resolution.\r\n   * This is not the same as [[Screen.goFullScreen]] but behaves in a similar way maintaining aspect ratio.\r\n   *\r\n   * You may want to center your game here is an example\r\n   * ```html\r\n   * <!-- html -->\r\n   * <body>\r\n   * <main>\r\n   *   <canvas id=\"game\"></canvas>\r\n   * </main>\r\n   * </body>\r\n   * ```\r\n   *\r\n   * ```css\r\n   * // css\r\n   * main {\r\n   *   display: flex;\r\n   *   align-items: center;\r\n   *   justify-content: center;\r\n   *   height: 100%;\r\n   *   width: 100%;\r\n   * }\r\n   * ```\r\n   */\r\n  FitScreen = 'FitScreen',\r\n\r\n  /**\r\n   * Fill the entire screen's css width/height for the game resolution dynamically. This means the resolution of the game will\r\n   * change dynamically as the window is resized. This is not the same as [[Screen.goFullScreen]]\r\n   */\r\n  FillScreen = 'FillScreen',\r\n\r\n  /**\r\n   * Fit to parent element width/height using as much space as possible while maintaining aspect ratio and resolution.\r\n   */\r\n  FitContainer = 'FitContainer',\r\n\r\n  /**\r\n   * Use the parent DOM container's css width/height for the game resolution dynamically\r\n   */\r\n  FillContainer = 'FillContainer'\r\n}\r\n\r\n/**\r\n * Convenience class for quick resolutions\r\n * Mostly sourced from https://emulation.gametechwiki.com/index.php/Resolution\r\n */\r\nexport class Resolution {\r\n  /* istanbul ignore next */\r\n  public static get SVGA(): ScreenDimension {\r\n    return { width: 800, height: 600 };\r\n  }\r\n\r\n  /* istanbul ignore next */\r\n  public static get Standard(): ScreenDimension {\r\n    return { width: 1920, height: 1080 };\r\n  }\r\n\r\n  /* istanbul ignore next */\r\n  public static get Atari2600(): ScreenDimension {\r\n    return { width: 160, height: 192 };\r\n  }\r\n\r\n  /* istanbul ignore next */\r\n  public static get GameBoy(): ScreenDimension {\r\n    return { width: 160, height: 144 };\r\n  }\r\n\r\n  /* istanbul ignore next */\r\n  public static get GameBoyAdvance(): ScreenDimension {\r\n    return { width: 240, height: 160 };\r\n  }\r\n\r\n  /* istanbul ignore next */\r\n  public static get NintendoDS(): ScreenDimension {\r\n    return { width: 256, height: 192 };\r\n  }\r\n\r\n  /* istanbul ignore next */\r\n  public static get NES(): ScreenDimension {\r\n    return { width: 256, height: 224 };\r\n  }\r\n\r\n  /* istanbul ignore next */\r\n  public static get SNES(): ScreenDimension {\r\n    return { width: 256, height: 244 };\r\n  }\r\n}\r\n\r\nexport interface ScreenDimension {\r\n  width: number;\r\n  height: number;\r\n}\r\n\r\nexport interface ScreenOptions {\r\n  /**\r\n   * Canvas element to build a screen on\r\n   */\r\n  canvas: HTMLCanvasElement;\r\n\r\n  /**\r\n   * Graphics context for the screen\r\n   */\r\n  context: ExcaliburGraphicsContext;\r\n\r\n  /**\r\n   * Browser abstraction\r\n   */\r\n  browser: BrowserEvents;\r\n  /**\r\n   * Optionally set antialiasing, defaults to true. If set to true, images will be smoothed\r\n   */\r\n  antialiasing?: boolean;\r\n  /**\r\n   * Optionally override the pixel ratio to use for the screen, otherwise calculated automatically from the browser\r\n   */\r\n  pixelRatio?: number;\r\n  /**\r\n   * Optionally specify the actual pixel resolution in width/height pixels (also known as logical resolution), by default the\r\n   * resolution will be the same as the viewport. Resolution will be overridden by [[DisplayMode.FillContainer]] and\r\n   * [[DisplayMode.FillScreen]].\r\n   */\r\n  resolution?: ScreenDimension;\r\n  /**\r\n   * Visual viewport size in css pixel, if resolution is not specified it will be the same as the viewport\r\n   */\r\n  viewport: ScreenDimension;\r\n  /**\r\n   * Set the display mode of the screen, by default DisplayMode.Fixed.\r\n   */\r\n  displayMode?: DisplayMode;\r\n}\r\n\r\n/**\r\n * The Screen handles all aspects of interacting with the screen for Excalibur.\r\n */\r\nexport class Screen {\r\n  public graphicsContext: ExcaliburGraphicsContext;\r\n  private _canvas: HTMLCanvasElement;\r\n  private _antialiasing: boolean = true;\r\n  private _contentResolution: ScreenDimension;\r\n  private _browser: BrowserEvents;\r\n  private _camera: Camera;\r\n  private _resolution: ScreenDimension;\r\n  private _resolutionStack: ScreenDimension[] = [];\r\n  private _viewport: ScreenDimension;\r\n  private _viewportStack: ScreenDimension[] = [];\r\n  private _pixelRatioOverride: number | null = null;\r\n  private _displayMode: DisplayMode;\r\n  private _isFullScreen = false;\r\n  private _mediaQueryList: MediaQueryList;\r\n  private _isDisposed = false;\r\n  private _logger = Logger.getInstance();\r\n  private _resizeObserver: ResizeObserver;\r\n\r\n  constructor(options: ScreenOptions) {\r\n    this.viewport = options.viewport;\r\n    this.resolution = options.resolution ?? { ...this.viewport };\r\n    this._contentResolution = this.resolution;\r\n    this._displayMode = options.displayMode ?? DisplayMode.Fixed;\r\n    this._canvas = options.canvas;\r\n    this.graphicsContext = options.context;\r\n    this._antialiasing = options.antialiasing ?? this._antialiasing;\r\n    this._browser = options.browser;\r\n    this._pixelRatioOverride = options.pixelRatio;\r\n\r\n    this._applyDisplayMode();\r\n\r\n    this._listenForPixelRatio();\r\n\r\n    this._canvas.addEventListener('fullscreenchange', this._fullscreenChangeHandler);\r\n    this.applyResolutionAndViewport();\r\n  }\r\n\r\n  private _listenForPixelRatio() {\r\n    if (this._mediaQueryList && !this._mediaQueryList.addEventListener) {\r\n      // Safari <=13.1 workaround, remove any existing handlers\r\n      this._mediaQueryList.removeListener(this._pixelRatioChangeHandler);\r\n    }\r\n    this._mediaQueryList = this._browser.window.nativeComponent.matchMedia(`(resolution: ${window.devicePixelRatio}dppx)`);\r\n\r\n    // Safari <=13.1 workaround\r\n    if (this._mediaQueryList.addEventListener) {\r\n      this._mediaQueryList.addEventListener('change', this._pixelRatioChangeHandler, { once: true });\r\n    } else {\r\n      this._mediaQueryList.addListener(this._pixelRatioChangeHandler);\r\n    }\r\n  }\r\n\r\n  public dispose(): void {\r\n    if (!this._isDisposed) {\r\n      // Clean up handlers\r\n      this._isDisposed = true;\r\n      this._browser.window.off('resize', this._resizeHandler);\r\n      if (this._resizeObserver) {\r\n        this._resizeObserver.disconnect();\r\n      }\r\n      this.parent.removeEventListener('resize', this._resizeHandler);\r\n      // Safari <=13.1 workaround\r\n      if (this._mediaQueryList.removeEventListener) {\r\n        this._mediaQueryList.removeEventListener('change', this._pixelRatioChangeHandler);\r\n      } else {\r\n        this._mediaQueryList.removeListener(this._pixelRatioChangeHandler);\r\n      }\r\n      this._canvas.removeEventListener('fullscreenchange', this._fullscreenChangeHandler);\r\n    }\r\n  }\r\n\r\n  private _fullscreenChangeHandler = () => {\r\n    this._isFullScreen = !this._isFullScreen;\r\n    this._logger.debug('Fullscreen Change', this._isFullScreen);\r\n  };\r\n\r\n  private _pixelRatioChangeHandler = () => {\r\n    this._logger.debug('Pixel Ratio Change', window.devicePixelRatio);\r\n    this._listenForPixelRatio();\r\n    this._devicePixelRatio = this._calculateDevicePixelRatio();\r\n    this.applyResolutionAndViewport();\r\n  };\r\n\r\n  private _resizeHandler = () => {\r\n    const parent = this.parent;\r\n    this._logger.debug('View port resized');\r\n    this._setResolutionAndViewportByDisplayMode(parent);\r\n    this.applyResolutionAndViewport();\r\n  };\r\n\r\n  private _calculateDevicePixelRatio() {\r\n    if (window.devicePixelRatio < 1) {\r\n      return 1;\r\n    }\r\n\r\n    const devicePixelRatio = window.devicePixelRatio || 1;\r\n\r\n    return devicePixelRatio;\r\n  }\r\n\r\n  // Asking the window.devicePixelRatio is expensive we do it once\r\n  private _devicePixelRatio = this._calculateDevicePixelRatio();\r\n\r\n  public get pixelRatio(): number {\r\n    if (this._pixelRatioOverride) {\r\n      return this._pixelRatioOverride;\r\n    }\r\n\r\n    return this._devicePixelRatio;\r\n  }\r\n\r\n  public get isHiDpi() {\r\n    return this.pixelRatio !== 1;\r\n  }\r\n\r\n  public get displayMode(): DisplayMode {\r\n    return this._displayMode;\r\n  }\r\n\r\n  public get canvas(): HTMLCanvasElement {\r\n    return this._canvas;\r\n  }\r\n\r\n  public get parent(): HTMLElement | Window {\r\n    switch (this.displayMode) {\r\n      case DisplayMode.FillContainer:\r\n      case DisplayMode.FitContainer:\r\n      case DisplayMode.FitContainerAndFill:\r\n      case DisplayMode.FitContainerAndZoom:\r\n        return this.canvas.parentElement || document.body;\r\n      default:\r\n        return window;\r\n    }\r\n  }\r\n\r\n  public get resolution(): ScreenDimension {\r\n    return this._resolution;\r\n  }\r\n\r\n  public set resolution(resolution: ScreenDimension) {\r\n    this._resolution = resolution;\r\n  }\r\n\r\n  public get viewport(): ScreenDimension {\r\n    if (this._viewport) {\r\n      return this._viewport;\r\n    }\r\n    return this._resolution;\r\n  }\r\n\r\n  public set viewport(viewport: ScreenDimension) {\r\n    this._viewport = viewport;\r\n  }\r\n\r\n  public get aspectRatio() {\r\n    return this._resolution.width / this._resolution.height;\r\n  }\r\n\r\n  public get scaledWidth() {\r\n    return this._resolution.width * this.pixelRatio;\r\n  }\r\n\r\n  public get scaledHeight() {\r\n    return this._resolution.height * this.pixelRatio;\r\n  }\r\n\r\n  public setCurrentCamera(camera: Camera) {\r\n    this._camera = camera;\r\n  }\r\n\r\n  public pushResolutionAndViewport() {\r\n    this._resolutionStack.push(this.resolution);\r\n    this._viewportStack.push(this.viewport);\r\n\r\n    this.resolution = { ...this.resolution };\r\n    this.viewport = { ...this.viewport };\r\n  }\r\n\r\n  public peekViewport(): ScreenDimension {\r\n    return this._viewportStack[this._viewportStack.length - 1];\r\n  }\r\n\r\n  public peekResolution(): ScreenDimension {\r\n    return this._resolutionStack[this._resolutionStack.length - 1];\r\n  }\r\n\r\n  public popResolutionAndViewport() {\r\n    this.resolution = this._resolutionStack.pop();\r\n    this.viewport = this._viewportStack.pop();\r\n  }\r\n\r\n  private _alreadyWarned = false;\r\n  public applyResolutionAndViewport() {\r\n    this._canvas.width = this.scaledWidth;\r\n    this._canvas.height = this.scaledHeight;\r\n\r\n    if (this.graphicsContext instanceof ExcaliburGraphicsContextWebGL) {\r\n      const supported = this.graphicsContext.checkIfResolutionSupported({\r\n        width: this.scaledWidth,\r\n        height: this.scaledHeight\r\n      });\r\n      if (!supported && !this._alreadyWarned) {\r\n        this._alreadyWarned = true; // warn once\r\n        this._logger.warn(\r\n          `The currently configured resolution (${this.resolution.width}x${this.resolution.height}) and pixel ratio (${this.pixelRatio})` +\r\n          ' are too large for the platform WebGL implementation, this may work but cause WebGL rendering to behave oddly.' +\r\n          ' Try reducing the resolution or disabling Hi DPI scaling to avoid this' +\r\n          ' (read more here https://excaliburjs.com/docs/screens#understanding-viewport--resolution).');\r\n      }\r\n    }\r\n\r\n    if (this._antialiasing) {\r\n      this._canvas.style.imageRendering = 'auto';\r\n    } else {\r\n      this._canvas.style.imageRendering = 'pixelated';\r\n      // Fall back to 'crisp-edges' if 'pixelated' is not supported\r\n      // Currently for firefox https://developer.mozilla.org/en-US/docs/Web/CSS/image-rendering\r\n      if (this._canvas.style.imageRendering === '') {\r\n        this._canvas.style.imageRendering = 'crisp-edges';\r\n      }\r\n    }\r\n    this._canvas.style.width = this.viewport.width + 'px';\r\n    this._canvas.style.height = this.viewport.height + 'px';\r\n\r\n    // After messing with the canvas width/height the graphics context is invalidated and needs to have some properties reset\r\n    this.graphicsContext.updateViewport(this.resolution);\r\n    this.graphicsContext.resetTransform();\r\n    this.graphicsContext.smoothing = this._antialiasing;\r\n    if (this.graphicsContext instanceof ExcaliburGraphicsContext2DCanvas) {\r\n      this.graphicsContext.scale(this.pixelRatio, this.pixelRatio);\r\n    }\r\n  }\r\n\r\n  public get antialiasing() {\r\n    return this._antialiasing;\r\n  }\r\n\r\n  public set antialiasing(isSmooth: boolean) {\r\n    this._antialiasing = isSmooth;\r\n    this.graphicsContext.smoothing = this._antialiasing;\r\n  }\r\n\r\n  /**\r\n   * Returns true if excalibur is fullscreen using the browser fullscreen api\r\n   */\r\n  public get isFullScreen() {\r\n    return this._isFullScreen;\r\n  }\r\n\r\n  /**\r\n   * Requests to go fullscreen using the browser fullscreen api, requires user interaction to be successful.\r\n   * For example, wire this to a user click handler.\r\n   */\r\n  public goFullScreen(): Promise<void> {\r\n    return this._canvas.requestFullscreen();\r\n  }\r\n\r\n  /**\r\n   * Requests to exit fullscreen using the browser fullscreen api\r\n   */\r\n  public exitFullScreen(): Promise<void> {\r\n    return document.exitFullscreen();\r\n  }\r\n\r\n  /**\r\n   * Takes a coordinate in normal html page space, for example from a pointer move event, and translates it to\r\n   * Excalibur screen space.\r\n   *\r\n   * Excalibur screen space starts at the top left (0, 0) corner of the viewport, and extends to the\r\n   * bottom right corner (resolutionX, resolutionY)\r\n   * @param point\r\n   */\r\n  public pageToScreenCoordinates(point: Vector): Vector {\r\n    let newX = point.x;\r\n    let newY = point.y;\r\n\r\n    if (!this._isFullScreen) {\r\n      newX -= getPosition(this._canvas).x;\r\n      newY -= getPosition(this._canvas).y;\r\n    }\r\n\r\n    // if fullscreen api on it centers with black bars\r\n    // we need to adjust the screen to world coordinates in this case\r\n    if (this._isFullScreen) {\r\n      if (window.innerWidth / this.aspectRatio < window.innerHeight) {\r\n        const screenHeight = window.innerWidth / this.aspectRatio;\r\n        const screenMarginY = (window.innerHeight - screenHeight) / 2;\r\n        newY = ((newY - screenMarginY) / screenHeight) * this.viewport.height;\r\n        newX = (newX / window.innerWidth) * this.viewport.width;\r\n      } else {\r\n        const screenWidth = window.innerHeight * this.aspectRatio;\r\n        const screenMarginX = (window.innerWidth - screenWidth) / 2;\r\n        newX = ((newX - screenMarginX) / screenWidth) * this.viewport.width;\r\n        newY = (newY / window.innerHeight) * this.viewport.height;\r\n      }\r\n    }\r\n\r\n    newX = (newX / this.viewport.width) * this.resolution.width;\r\n    newY = (newY / this.viewport.height) * this.resolution.height;\r\n\r\n    return new Vector(newX, newY);\r\n  }\r\n\r\n  /**\r\n   * Takes a coordinate in Excalibur screen space, and translates it to normal html page space. For example,\r\n   * this is where html elements might live if you want to position them relative to Excalibur.\r\n   *\r\n   * Excalibur screen space starts at the top left (0, 0) corner of the viewport, and extends to the\r\n   * bottom right corner (resolutionX, resolutionY)\r\n   * @param point\r\n   */\r\n  public screenToPageCoordinates(point: Vector): Vector {\r\n    let newX = point.x;\r\n    let newY = point.y;\r\n\r\n    newX = (newX / this.resolution.width) * this.viewport.width;\r\n    newY = (newY / this.resolution.height) * this.viewport.height;\r\n\r\n    if (this._isFullScreen) {\r\n      if (window.innerWidth / this.aspectRatio < window.innerHeight) {\r\n        const screenHeight = window.innerWidth / this.aspectRatio;\r\n        const screenMarginY = (window.innerHeight - screenHeight) / 2;\r\n        newY = (newY / this.viewport.height) * screenHeight + screenMarginY;\r\n        newX = (newX / this.viewport.width) * window.innerWidth;\r\n      } else {\r\n        const screenWidth = window.innerHeight * this.aspectRatio;\r\n        const screenMarginX = (window.innerWidth - screenWidth) / 2;\r\n        newX = (newX / this.viewport.width) * screenWidth + screenMarginX;\r\n        newY = (newY / this.viewport.height) * window.innerHeight;\r\n      }\r\n    }\r\n\r\n    if (!this._isFullScreen) {\r\n      newX += getPosition(this._canvas).x;\r\n      newY += getPosition(this._canvas).y;\r\n    }\r\n\r\n    return new Vector(newX, newY);\r\n  }\r\n\r\n  /**\r\n   * Takes a coordinate in Excalibur screen space, and translates it to Excalibur world space.\r\n   *\r\n   * World space is where [[Entity|entities]] in Excalibur live by default [[CoordPlane.World]]\r\n   * and extends infinitely out relative from the [[Camera]].\r\n   * @param point  Screen coordinate to convert\r\n   */\r\n  public screenToWorldCoordinates(point: Vector): Vector {\r\n    // the only difference between screen & world is the camera transform\r\n    if (this._camera) {\r\n      return this._camera.inverse.multiply(point);\r\n    }\r\n    return point.sub(vec(this.resolution.width / 2, this.resolution.height / 2));\r\n  }\r\n\r\n  /**\r\n   * Takes a coordinate in Excalibur world space, and translates it to Excalibur screen space.\r\n   *\r\n   * Screen space is where [[ScreenElement|screen elements]] and [[Entity|entities]] with [[CoordPlane.Screen]] live.\r\n   * @param point  World coordinate to convert\r\n   */\r\n  public worldToScreenCoordinates(point: Vector): Vector {\r\n    if (this._camera) {\r\n      return this._camera.transform.multiply(point);\r\n    }\r\n    return point.add(vec(this.resolution.width / 2, this.resolution.height / 2));\r\n  }\r\n\r\n  public pageToWorldCoordinates(point: Vector): Vector {\r\n    const screen = this.pageToScreenCoordinates(point);\r\n    return this.screenToWorldCoordinates(screen);\r\n  }\r\n\r\n  public worldToPageCoordinates(point: Vector): Vector {\r\n    const screen = this.worldToScreenCoordinates(point);\r\n    return this.screenToPageCoordinates(screen);\r\n  }\r\n\r\n  /**\r\n   * Returns a BoundingBox of the top left corner of the screen\r\n   * and the bottom right corner of the screen.\r\n   *\r\n   * World bounds are in world coordinates, useful for culling objects offscreen\r\n   */\r\n  public getWorldBounds(): BoundingBox {\r\n    const topLeft = this.screenToWorldCoordinates(Vector.Zero);\r\n    const right = topLeft.x + this.drawWidth;\r\n    const bottom = topLeft.y + this.drawHeight;\r\n\r\n    return new BoundingBox(topLeft.x, topLeft.y, right, bottom);\r\n  }\r\n\r\n  /**\r\n   * The width of the game canvas in pixels (physical width component of the\r\n   * resolution of the canvas element)\r\n   */\r\n  public get canvasWidth(): number {\r\n    return this.canvas.width;\r\n  }\r\n\r\n  /**\r\n   * Returns half width of the game canvas in pixels (half physical width component)\r\n   */\r\n  public get halfCanvasWidth(): number {\r\n    return this.canvas.width / 2;\r\n  }\r\n\r\n  /**\r\n   * The height of the game canvas in pixels, (physical height component of\r\n   * the resolution of the canvas element)\r\n   */\r\n  public get canvasHeight(): number {\r\n    return this.canvas.height;\r\n  }\r\n\r\n  /**\r\n   * Returns half height of the game canvas in pixels (half physical height component)\r\n   */\r\n  public get halfCanvasHeight(): number {\r\n    return this.canvas.height / 2;\r\n  }\r\n\r\n  /**\r\n   * Returns the width of the engine's visible drawing surface in pixels including zoom and device pixel ratio.\r\n   */\r\n  public get drawWidth(): number {\r\n    if (this._camera) {\r\n      return this.resolution.width / this._camera.zoom;\r\n    }\r\n    return this.resolution.width;\r\n  }\r\n\r\n  /**\r\n   * Returns half the width of the engine's visible drawing surface in pixels including zoom and device pixel ratio.\r\n   */\r\n  public get halfDrawWidth(): number {\r\n    return this.drawWidth / 2;\r\n  }\r\n\r\n  /**\r\n   * Returns the height of the engine's visible drawing surface in pixels including zoom and device pixel ratio.\r\n   */\r\n  public get drawHeight(): number {\r\n    if (this._camera) {\r\n      return this.resolution.height / this._camera.zoom;\r\n    }\r\n    return this.resolution.height;\r\n  }\r\n\r\n  /**\r\n   * Returns half the height of the engine's visible drawing surface in pixels including zoom and device pixel ratio.\r\n   */\r\n  public get halfDrawHeight(): number {\r\n    return this.drawHeight / 2;\r\n  }\r\n\r\n  /**\r\n   * Returns screen center coordinates including zoom and device pixel ratio.\r\n   */\r\n  public get center(): Vector {\r\n    return vec(this.halfDrawWidth, this.halfDrawHeight);\r\n  }\r\n\r\n  /**\r\n   * Returns the content area in screen space where it is safe to place content\r\n   */\r\n  public get contentArea(): BoundingBox {\r\n    return this._contentArea;\r\n  }\r\n\r\n  private _computeFit() {\r\n    document.body.style.margin = '0px';\r\n    document.body.style.overflow = 'hidden';\r\n    const aspect = this.aspectRatio;\r\n    let adjustedWidth = 0;\r\n    let adjustedHeight = 0;\r\n    if (window.innerWidth / aspect < window.innerHeight) {\r\n      adjustedWidth = window.innerWidth;\r\n      adjustedHeight = window.innerWidth / aspect;\r\n    } else {\r\n      adjustedWidth = window.innerHeight * aspect;\r\n      adjustedHeight = window.innerHeight;\r\n    }\r\n\r\n    this.viewport = {\r\n      width: adjustedWidth,\r\n      height: adjustedHeight\r\n    };\r\n    this._contentArea = BoundingBox.fromDimension(this.resolution.width, this.resolution.height, Vector.Zero);\r\n  }\r\n\r\n  private _contentArea: BoundingBox = new BoundingBox();\r\n  private _computeFitScreenAndFill() {\r\n    document.body.style.margin = '0px';\r\n    document.body.style.overflow = 'hidden';\r\n    const vw = window.innerWidth;\r\n    const vh = window.innerHeight;\r\n    this._computeFitAndFill(vw, vh);\r\n  }\r\n\r\n\r\n\r\n  private _computeFitContainerAndFill() {\r\n    document.body.style.margin = '0px';\r\n    document.body.style.overflow = 'hidden';\r\n    const parent = this.canvas.parentElement;\r\n    const vw = parent.clientWidth;\r\n    const vh = parent.clientHeight;\r\n    this._computeFitAndFill(vw, vh);\r\n  }\r\n\r\n  private _computeFitAndFill(vw: number, vh: number) {\r\n    this.viewport = {\r\n      width: vw,\r\n      height: vh\r\n    };\r\n    // if the current screen aspectRatio is less than the original aspectRatio\r\n    if (vw / vh <= this._contentResolution.width / this._contentResolution.height) {\r\n      // compute new resolution to match the original aspect ratio\r\n      this.resolution = {\r\n        width:  vw * this._contentResolution.width / vw,\r\n        height: vw * this._contentResolution.width / vw * vh / vw\r\n      };\r\n      const clip = (this.resolution.height - this._contentResolution.height) / 2;\r\n      this._contentArea = new BoundingBox({\r\n        top: clip,\r\n        left: 0,\r\n        right: this._contentResolution.width,\r\n        bottom: this.resolution.height - clip\r\n      });\r\n    } else {\r\n      this.resolution = {\r\n        width: vh *  this._contentResolution.height / vh * vw / vh,\r\n        height: vh *  this._contentResolution.height / vh\r\n      };\r\n      const clip = (this.resolution.width - this._contentResolution.width) / 2;\r\n      this._contentArea = new BoundingBox({\r\n        top: 0,\r\n        left: clip,\r\n        right: this.resolution.width - clip,\r\n        bottom: this._contentResolution.height\r\n      });\r\n    }\r\n  }\r\n\r\n  private _computeFitScreenAndZoom() {\r\n    document.body.style.margin = '0px';\r\n    document.body.style.overflow = 'hidden';\r\n    this.canvas.style.position = 'absolute';\r\n\r\n    const vw = window.innerWidth;\r\n    const vh = window.innerHeight;\r\n\r\n    this._computeFitAndZoom(vw, vh);\r\n  }\r\n\r\n  private _computeFitContainerAndZoom() {\r\n    document.body.style.margin = '0px';\r\n    document.body.style.overflow = 'hidden';\r\n    this.canvas.style.position = 'absolute';\r\n    const parent = this.canvas.parentElement;\r\n    parent.style.position = 'relative';\r\n    parent.style.overflow = 'hidden';\r\n\r\n    const vw = parent.clientWidth;\r\n    const vh = parent.clientHeight;\r\n\r\n    this._computeFitAndZoom(vw, vh);\r\n  }\r\n\r\n  private _computeFitAndZoom(vw: number, vh: number) {\r\n    const aspect = this.aspectRatio;\r\n    let adjustedWidth = 0;\r\n    let adjustedHeight = 0;\r\n    if (vw / aspect < vh) {\r\n      adjustedWidth = vw;\r\n      adjustedHeight = vw / aspect;\r\n    } else {\r\n      adjustedWidth = vh * aspect;\r\n      adjustedHeight = vh;\r\n    }\r\n\r\n    const scaleX = vw / adjustedWidth;\r\n    const scaleY = vh / adjustedHeight;\r\n\r\n    const maxScaleFactor = Math.max(scaleX, scaleY);\r\n\r\n    const zoomedWidth = adjustedWidth * maxScaleFactor;\r\n    const zoomedHeight = adjustedHeight * maxScaleFactor;\r\n\r\n    // Center zoomed dimension if bigger than the screen\r\n    if (zoomedWidth > vw) {\r\n      this.canvas.style.left = -(zoomedWidth - vw) / 2 + 'px';\r\n    } else {\r\n      this.canvas.style.left = '';\r\n    }\r\n\r\n    if (zoomedHeight > vh) {\r\n      this.canvas.style.top = -(zoomedHeight - vh) / 2 + 'px';\r\n    } else {\r\n      this.canvas.style.top = '';\r\n    }\r\n\r\n    this.viewport = {\r\n      width: zoomedWidth,\r\n      height: zoomedHeight\r\n    };\r\n\r\n    const bounds = BoundingBox.fromDimension(this.viewport.width, this.viewport.height, Vector.Zero);\r\n    // return safe area\r\n    if (this.viewport.width > vw) {\r\n      const clip = (this.viewport.width - vw)/this.viewport.width * this.resolution.width;\r\n      bounds.top = 0;\r\n      bounds.left = clip / 2;\r\n      bounds.right = this.resolution.width - clip / 2;\r\n      bounds.bottom = this.resolution.height;\r\n    }\r\n\r\n    if (this.viewport.height > vh) {\r\n      const clip = (this.viewport.height - vh)/this.viewport.height * this.resolution.height;\r\n      bounds.top = clip / 2;\r\n      bounds.left = 0;\r\n      bounds.bottom = this.resolution.height - clip / 2;\r\n      bounds.right = this.resolution.width;\r\n    }\r\n    this._contentArea = bounds;\r\n  }\r\n\r\n  private _computeFitContainer() {\r\n    const aspect = this.aspectRatio;\r\n    let adjustedWidth = 0;\r\n    let adjustedHeight = 0;\r\n    const parent = this.canvas.parentElement;\r\n    if (parent.clientWidth / aspect < parent.clientHeight) {\r\n      adjustedWidth = parent.clientWidth;\r\n      adjustedHeight = parent.clientWidth / aspect;\r\n    } else {\r\n      adjustedWidth = parent.clientHeight * aspect;\r\n      adjustedHeight = parent.clientHeight;\r\n    }\r\n\r\n    this.viewport = {\r\n      width: adjustedWidth,\r\n      height: adjustedHeight\r\n    };\r\n    this._contentArea = BoundingBox.fromDimension(this.resolution.width, this.resolution.height, Vector.Zero);\r\n  }\r\n\r\n  private _applyDisplayMode() {\r\n    this._setResolutionAndViewportByDisplayMode(this.parent);\r\n\r\n    // watch resizing\r\n    if (this.parent instanceof Window) {\r\n      this._browser.window.on('resize', this._resizeHandler);\r\n    } else {\r\n      this._resizeObserver = new ResizeObserver(() => {\r\n        this._resizeHandler();\r\n      });\r\n      this._resizeObserver.observe(this.parent);\r\n    }\r\n    this.parent.addEventListener('resize', this._resizeHandler);\r\n  }\r\n\r\n  /**\r\n   * Sets the resolution and viewport based on the selected display mode.\r\n   */\r\n  private _setResolutionAndViewportByDisplayMode(parent: HTMLElement | Window) {\r\n    if (this.displayMode === DisplayMode.FillContainer) {\r\n      this.resolution = {\r\n        width: (<HTMLElement> parent).clientWidth,\r\n        height: (<HTMLElement> parent).clientHeight\r\n      };\r\n\r\n      this.viewport = this.resolution;\r\n    }\r\n\r\n    if (this.displayMode === DisplayMode.FillScreen) {\r\n      document.body.style.margin = '0px';\r\n      document.body.style.overflow = 'hidden';\r\n      this.resolution = {\r\n        width: (<Window> parent).innerWidth,\r\n        height: (<Window> parent).innerHeight\r\n      };\r\n\r\n      this.viewport = this.resolution;\r\n    }\r\n\r\n    if (this.displayMode === DisplayMode.FitScreen) {\r\n      this._computeFit();\r\n    }\r\n\r\n    if (this.displayMode === DisplayMode.FitContainer) {\r\n      this._computeFitContainer();\r\n    }\r\n\r\n    if (this.displayMode === DisplayMode.FitScreenAndFill) {\r\n      this._computeFitScreenAndFill();\r\n    }\r\n\r\n    if (this.displayMode === DisplayMode.FitContainerAndFill){\r\n      this._computeFitContainerAndFill();\r\n    }\r\n\r\n    if (this.displayMode === DisplayMode.FitScreenAndZoom) {\r\n      this._computeFitScreenAndZoom();\r\n    }\r\n\r\n    if (this.displayMode === DisplayMode.FitContainerAndZoom){\r\n      this._computeFitContainerAndZoom();\r\n    }\r\n  }\r\n}\r\n","/**\r\n * Internal class used to build instances of AudioContext\r\n */\r\n/* istanbul ignore next */\r\nexport class AudioContextFactory {\r\n  private static _INSTANCE: AudioContext = null;\r\n\r\n  public static create(): AudioContext {\r\n    if (!this._INSTANCE) {\r\n      if ((<any>window).AudioContext || (<any>window).webkitAudioContext) {\r\n        this._INSTANCE = new AudioContext();\r\n      }\r\n    }\r\n\r\n    return this._INSTANCE;\r\n  }\r\n}\r\n","import { AudioContextFactory } from '../Resources/Sound/AudioContext';\r\nimport { Logger } from './Log';\r\n\r\nexport interface LegacyWebAudioSource {\r\n  playbackState: string;\r\n  PLAYING_STATE: 'playing';\r\n  FINISHED_STATE: 'finished';\r\n}\r\n\r\n/**\r\n * Patch for detecting legacy web audio in browsers\r\n * @internal\r\n * @param source\r\n */\r\nfunction isLegacyWebAudioSource(source: any): source is LegacyWebAudioSource {\r\n  return !!source.playbackState;\r\n}\r\n\r\nexport class WebAudio {\r\n  private static _UNLOCKED: boolean = false;\r\n\r\n  /**\r\n   * Play an empty sound to unlock Safari WebAudio context. Call this function\r\n   * right after a user interaction event.\r\n   * @source https://paulbakaus.com/tutorials/html5/web-audio-on-ios/\r\n   */\r\n  static unlock(): Promise<boolean> {\r\n    const promise = new Promise<boolean>((resolve, reject) => {\r\n      if (WebAudio._UNLOCKED || !AudioContextFactory.create()) {\r\n        return resolve(true);\r\n      }\r\n      const unlockTimeoutTimer = setTimeout(() => {\r\n        Logger.getInstance().warn('Excalibur was unable to unlock the audio context, audio probably will not play in this browser.');\r\n        resolve(false);\r\n      }, 200);\r\n\r\n      const audioContext = AudioContextFactory.create();\r\n      audioContext.resume().then(\r\n        () => {\r\n          // create empty buffer and play it\r\n          const buffer = audioContext.createBuffer(1, 1, 22050);\r\n          const source = audioContext.createBufferSource();\r\n          let ended = false;\r\n\r\n          source.buffer = buffer;\r\n          source.connect(audioContext.destination);\r\n          source.onended = () => (ended = true);\r\n\r\n          source.start(0);\r\n\r\n          // by checking the play state after some time, we know if we're really unlocked\r\n          setTimeout(() => {\r\n            if (isLegacyWebAudioSource(source)) {\r\n              if (source.playbackState === source.PLAYING_STATE || source.playbackState === source.FINISHED_STATE) {\r\n                WebAudio._UNLOCKED = true;\r\n              }\r\n            } else {\r\n              if (audioContext.currentTime > 0 || ended) {\r\n                WebAudio._UNLOCKED = true;\r\n              }\r\n            }\r\n          }, 0);\r\n\r\n          clearTimeout(unlockTimeoutTimer);\r\n          resolve(true);\r\n        },\r\n        () => {\r\n          reject();\r\n        }\r\n      );\r\n    });\r\n\r\n    return promise;\r\n  }\r\n\r\n  static isUnlocked() {\r\n    return this._UNLOCKED;\r\n  }\r\n}\r\n","import { EventDispatcher } from './EventDispatcher';\r\nimport { Eventable } from './Interfaces/Evented';\r\n\r\n/**\r\n * Excalibur base class that provides basic functionality such as [[EventDispatcher]]\r\n * and extending abilities for vanilla Javascript projects\r\n */\r\nexport class Class implements Eventable {\r\n  /**\r\n   * Direct access to the game object event dispatcher.\r\n   */\r\n  public eventDispatcher: EventDispatcher;\r\n\r\n  constructor() {\r\n    this.eventDispatcher = new EventDispatcher();\r\n  }\r\n\r\n  /**\r\n   * Alias for `addEventListener`. You can listen for a variety of\r\n   * events off of the engine; see the events section below for a complete list.\r\n   * @param eventName  Name of the event to listen for\r\n   * @param handler    Event handler for the thrown event\r\n   */\r\n  public on(eventName: string, handler: (event: any) => void) {\r\n    this.eventDispatcher.on(eventName, handler);\r\n  }\r\n\r\n  /**\r\n   * Alias for `removeEventListener`. If only the eventName is specified\r\n   * it will remove all handlers registered for that specific event. If the eventName\r\n   * and the handler instance are specified only that handler will be removed.\r\n   *\r\n   * @param eventName  Name of the event to listen for\r\n   * @param handler    Event handler for the thrown event\r\n   */\r\n  public off(eventName: string, handler?: (event: any) => void) {\r\n    this.eventDispatcher.off(eventName, handler);\r\n  }\r\n\r\n  /**\r\n   * Emits a new event\r\n   * @param eventName   Name of the event to emit\r\n   * @param eventObject Data associated with this event\r\n   */\r\n  public emit(eventName: string, eventObject: any) {\r\n    this.eventDispatcher.emit(eventName, eventObject);\r\n  }\r\n\r\n  /**\r\n   * Once listens to an event one time, then unsubscribes from that event\r\n   *\r\n   * @param eventName The name of the event to subscribe to once\r\n   * @param handler   The handler of the event that will be auto unsubscribed\r\n   */\r\n  public once(eventName: string, handler: (event: any) => void) {\r\n    this.eventDispatcher.once(eventName, handler);\r\n  }\r\n}\r\n","import { Color } from '../Color';\r\nimport { Vector } from '../Math/vector';\r\n\r\n/**\r\n * A canvas linecap style. \"butt\" is the default flush style, \"round\" is a semi-circle cap with a radius half the width of\r\n * the line, and \"square\" is a rectangle that is an equal width and half height cap.\r\n */\r\nexport type LineCapStyle = 'butt' | 'round' | 'square';\r\n\r\n/* istanbul ignore next */\r\n/**\r\n * Draw a line on canvas context\r\n *\r\n * @param ctx The canvas context\r\n * @param color The color of the line\r\n * @param x1 The start x coordinate\r\n * @param y1 The start y coordinate\r\n * @param x2 The ending x coordinate\r\n * @param y2 The ending y coordinate\r\n * @param thickness The line thickness\r\n * @param cap The [[LineCapStyle]] (butt, round, or square)\r\n */\r\nexport function line(\r\n  ctx: CanvasRenderingContext2D,\r\n  color: Color = Color.Red,\r\n  x1: number,\r\n  y1: number,\r\n  x2: number,\r\n  y2: number,\r\n  thickness: number = 1,\r\n  cap: LineCapStyle = 'butt'\r\n) {\r\n  ctx.save();\r\n  ctx.beginPath();\r\n  ctx.lineWidth = thickness;\r\n  ctx.lineCap = cap;\r\n  ctx.strokeStyle = color.toString();\r\n  ctx.moveTo(x1, y1);\r\n  ctx.lineTo(x2, y2);\r\n  ctx.closePath();\r\n  ctx.stroke();\r\n  ctx.restore();\r\n}\r\n\r\n/* istanbul ignore next */\r\n/**\r\n * Draw the vector as a point onto the canvas.\r\n */\r\nexport function point(ctx: CanvasRenderingContext2D, color: Color = Color.Red, point: Vector): void {\r\n  ctx.beginPath();\r\n  ctx.strokeStyle = color.toString();\r\n  ctx.arc(point.x, point.y, 5, 0, Math.PI * 2);\r\n  ctx.closePath();\r\n  ctx.stroke();\r\n}\r\n\r\n/**\r\n * Draw the vector as a line onto the canvas starting a origin point.\r\n */\r\n/* istanbul ignore next */\r\n/**\r\n *\r\n */\r\nexport function vector(ctx: CanvasRenderingContext2D, color: Color, origin: Vector, vector: Vector, scale: number = 1.0): void {\r\n  const c = color ? color.toString() : 'blue';\r\n  const v = vector.scale(scale);\r\n  ctx.beginPath();\r\n  ctx.strokeStyle = c;\r\n  ctx.moveTo(origin.x, origin.y);\r\n  ctx.lineTo(origin.x + v.x, origin.y + v.y);\r\n  ctx.closePath();\r\n  ctx.stroke();\r\n}\r\n\r\n/**\r\n * Represents border radius values\r\n */\r\nexport interface BorderRadius {\r\n  /**\r\n   * Top-left\r\n   */\r\n  tl: number;\r\n  /**\r\n   * Top-right\r\n   */\r\n  tr: number;\r\n  /**\r\n   * Bottom-right\r\n   */\r\n  br: number;\r\n  /**\r\n   * Bottom-left\r\n   */\r\n  bl: number;\r\n}\r\n\r\n/**\r\n * Draw a round rectangle on a canvas context\r\n *\r\n * @param ctx The canvas context\r\n * @param x The top-left x coordinate\r\n * @param y The top-left y coordinate\r\n * @param width The width of the rectangle\r\n * @param height The height of the rectangle\r\n * @param radius The border radius of the rectangle\r\n * @param stroke The [[Color]] to stroke rectangle with\r\n * @param fill The [[Color]] to fill rectangle with\r\n */\r\nexport function roundRect(\r\n  ctx: CanvasRenderingContext2D,\r\n  x: number,\r\n  y: number,\r\n  width: number,\r\n  height: number,\r\n  radius: number | BorderRadius = 5,\r\n  stroke: Color = Color.White,\r\n  fill: Color = null\r\n) {\r\n  let br: BorderRadius;\r\n\r\n  if (typeof radius === 'number') {\r\n    br = { tl: radius, tr: radius, br: radius, bl: radius };\r\n  } else {\r\n    const defaultRadius: BorderRadius = { tl: 0, tr: 0, br: 0, bl: 0 };\r\n\r\n    for (const prop in defaultRadius) {\r\n      if (defaultRadius.hasOwnProperty(prop)) {\r\n        const side = <keyof BorderRadius>prop;\r\n        br[side] = radius[side] || defaultRadius[side];\r\n      }\r\n    }\r\n  }\r\n\r\n  ctx.beginPath();\r\n  ctx.moveTo(x + br.tl, y);\r\n  ctx.lineTo(x + width - br.tr, y);\r\n  ctx.quadraticCurveTo(x + width, y, x + width, y + br.tr);\r\n  ctx.lineTo(x + width, y + height - br.br);\r\n  ctx.quadraticCurveTo(x + width, y + height, x + width - br.br, y + height);\r\n  ctx.lineTo(x + br.bl, y + height);\r\n  ctx.quadraticCurveTo(x, y + height, x, y + height - br.bl);\r\n  ctx.lineTo(x, y + br.tl);\r\n  ctx.quadraticCurveTo(x, y, x + br.tl, y);\r\n  ctx.closePath();\r\n\r\n  if (fill) {\r\n    ctx.fillStyle = fill.toString();\r\n    ctx.fill();\r\n  }\r\n\r\n  if (stroke) {\r\n    ctx.strokeStyle = stroke.toString();\r\n    ctx.stroke();\r\n  }\r\n}\r\n\r\n/**\r\n *\r\n */\r\nexport function circle(\r\n  ctx: CanvasRenderingContext2D,\r\n  x: number,\r\n  y: number,\r\n  radius: number,\r\n  stroke: Color = Color.White,\r\n  fill: Color = null\r\n) {\r\n  ctx.beginPath();\r\n  ctx.arc(x, y, radius, 0, Math.PI * 2);\r\n  ctx.closePath();\r\n\r\n  if (fill) {\r\n    ctx.fillStyle = fill.toString();\r\n    ctx.fill();\r\n  }\r\n\r\n  if (stroke) {\r\n    ctx.strokeStyle = stroke.toString();\r\n    ctx.stroke();\r\n  }\r\n}\r\n","import { Graphic, GraphicOptions } from './Graphic';\r\nimport { ExcaliburGraphicsContext } from './Context/ExcaliburGraphicsContext';\r\nimport { Color } from '../Color';\r\nimport { ensurePowerOfTwo } from './Context/webgl-util';\r\nimport { Vector } from '../Math/vector';\r\nimport { BoundingBox } from '../Collision/BoundingBox';\r\nimport { watch } from '../Util/Watch';\r\nimport { TextureLoader } from './Context/texture-loader';\r\nimport { ImageFiltering } from './Filtering';\r\n\r\n\r\nexport interface RasterOptions {\r\n  /**\r\n   * Optionally specify a quality number, which is how much to scale the internal Raster. Default is 1.\r\n   *\r\n   * For example if the quality is set to 2, it doubles the internal raster bitmap in memory.\r\n   *\r\n   * Adjusting this value can be useful if you are working with small rasters.\r\n   */\r\n  quality?: number;\r\n  /**\r\n   * Optionally specify \"smoothing\" if you want antialiasing to apply to the raster's bitmap context, by default `false`\r\n   */\r\n  smoothing?: boolean;\r\n\r\n  /**\r\n   * Optionally specify the color of the raster's bitmap context, by default [[Color.Black]]\r\n   */\r\n  color?: Color;\r\n\r\n  /**\r\n   * Optionally specify the stroke color of the raster's bitmap context, by default undefined\r\n   */\r\n  strokeColor?: Color;\r\n\r\n  /**\r\n   * Optionally specify the line width of the raster's bitmap, by default 1 pixel\r\n   */\r\n  lineWidth?: number;\r\n\r\n  /**\r\n   * Optionally specify the line dash of the raster's bitmap, by default `[]` which means none\r\n   */\r\n  lineDash?: number[];\r\n\r\n  /**\r\n   * Optionally specify the line end style, default is \"butt\".\r\n   */\r\n  lineCap?: 'butt' | 'round' | 'square';\r\n\r\n  /**\r\n   * Optionally specify the padding to apply to the bitmap\r\n   */\r\n  padding?: number;\r\n\r\n  /**\r\n   * Optionally specify what image filtering mode should be used, [[ImageFiltering.Pixel]] for pixel art,\r\n   * [[ImageFiltering.Blended]] for hi-res art\r\n   *\r\n   * By default unset, rasters defer to the engine antialiasing setting\r\n   */\r\n  filtering?: ImageFiltering;\r\n}\r\n\r\n/**\r\n * A Raster is a Graphic that needs to be first painted to a HTMLCanvasElement before it can be drawn to the\r\n * [[ExcaliburGraphicsContext]]. This is useful for generating custom images using the 2D canvas api.\r\n *\r\n * Implementors must implement the [[Raster.execute]] method to rasterize their drawing.\r\n */\r\nexport abstract class Raster extends Graphic {\r\n  public filtering: ImageFiltering = null;\r\n  public lineCap: 'butt' | 'round' | 'square' = 'butt';\r\n  public quality: number = 1;\r\n\r\n  public _bitmap: HTMLCanvasElement;\r\n  protected _ctx: CanvasRenderingContext2D;\r\n  private _dirty: boolean = true;\r\n\r\n  constructor(options?: GraphicOptions & RasterOptions) {\r\n    super(options);\r\n    if (options) {\r\n      this.quality = options.quality ?? this.quality;\r\n      this.color = options.color ?? Color.Black;\r\n      this.strokeColor = options?.strokeColor;\r\n      this.smoothing = options.smoothing ?? this.smoothing;\r\n      this.lineWidth = options.lineWidth ?? this.lineWidth;\r\n      this.lineDash = options.lineDash ?? this.lineDash;\r\n      this.lineCap = options.lineCap ?? this.lineCap;\r\n      this.padding = options.padding ?? this.padding;\r\n      this.filtering = options.filtering ?? this.filtering;\r\n    }\r\n    this._bitmap = document.createElement('canvas');\r\n    // get the default canvas width/height as a fallback\r\n    const bitmapWidth = options?.width ?? this._bitmap.width;\r\n    const bitmapHeight = options?.height ?? this._bitmap.height;\r\n    // Rasters use power of two images as an optimization for webgl\r\n    this.width = ensurePowerOfTwo(bitmapWidth);\r\n    this.height = ensurePowerOfTwo(bitmapHeight);\r\n    const maybeCtx = this._bitmap.getContext('2d');\r\n    if (!maybeCtx) {\r\n      /* istanbul ignore next */\r\n      throw new Error('Browser does not support 2d canvas drawing, cannot create Raster graphic');\r\n    } else {\r\n      this._ctx = maybeCtx;\r\n    }\r\n  }\r\n\r\n  public cloneRasterOptions(): RasterOptions {\r\n    return {\r\n      color: this.color ? this.color.clone() : null,\r\n      strokeColor: this.strokeColor ? this.strokeColor.clone() : null,\r\n      smoothing: this.smoothing,\r\n      lineWidth: this.lineWidth,\r\n      lineDash: this.lineDash,\r\n      lineCap: this.lineCap,\r\n      quality: this.quality,\r\n      padding: this.padding\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Gets whether the graphic is dirty, this means there are changes that haven't been re-rasterized\r\n   */\r\n  public get dirty() {\r\n    return this._dirty;\r\n  }\r\n\r\n  /**\r\n   * Flags the graphic as dirty, meaning it must be re-rasterized before draw.\r\n   * This should be called any time the graphics state changes such that it affects the outputted drawing\r\n   */\r\n  public flagDirty() {\r\n    this._dirty = true;\r\n  }\r\n\r\n  private _originalWidth: number;\r\n  /**\r\n   * Gets or sets the current width of the Raster graphic. Setting the width will cause the raster\r\n   * to be flagged dirty causing a re-raster on the next draw.\r\n   *\r\n   * Any `padding`s or `quality` set will be factored into the width\r\n   */\r\n  public get width() {\r\n    return Math.abs(this._getTotalWidth() * this.scale.x);\r\n  }\r\n  public set width(value: number) {\r\n    value /= Math.abs(this.scale.x);\r\n    this._bitmap.width = value;\r\n    this._originalWidth = value;\r\n    this.flagDirty();\r\n  }\r\n\r\n  private _originalHeight: number;\r\n  /**\r\n   * Gets or sets the current height of the Raster graphic. Setting the height will cause the raster\r\n   * to be flagged dirty causing a re-raster on the next draw.\r\n   *\r\n   * Any `padding` or `quality` set will be factored into the height\r\n   */\r\n  public get height() {\r\n    return Math.abs(this._getTotalHeight() * this.scale.y);\r\n  }\r\n\r\n  public set height(value: number) {\r\n    value /= Math.abs(this.scale.y);\r\n    this._bitmap.height = value;\r\n    this._originalHeight = value;\r\n    this.flagDirty();\r\n  }\r\n\r\n  private _getTotalWidth() {\r\n    return ((this._originalWidth ?? this._bitmap.width) + this.padding * 2) * 1;\r\n  }\r\n\r\n  private _getTotalHeight() {\r\n    return ((this._originalHeight ?? this._bitmap.height) + this.padding * 2) * 1;\r\n  }\r\n\r\n  /**\r\n   * Returns the local bounds of the Raster including the padding\r\n   */\r\n  public get localBounds() {\r\n    return BoundingBox.fromDimension(this._getTotalWidth() * this.scale.x, this._getTotalHeight() * this.scale.y, Vector.Zero);\r\n  }\r\n\r\n  private _smoothing: boolean = false;\r\n  /**\r\n   * Gets or sets the smoothing (anti-aliasing of the graphic). Setting the height will cause the raster\r\n   * to be flagged dirty causing a re-raster on the next draw.\r\n   */\r\n  public get smoothing() {\r\n    return this._smoothing;\r\n  }\r\n  public set smoothing(value: boolean) {\r\n    this._smoothing = value;\r\n    this.flagDirty();\r\n  }\r\n\r\n  private _color: Color = watch(Color.Black, () => this.flagDirty());\r\n  /**\r\n   * Gets or sets the fillStyle of the Raster graphic. Setting the fillStyle will cause the raster to be\r\n   * flagged dirty causing a re-raster on the next draw.\r\n   */\r\n  public get color() {\r\n    return this._color;\r\n  }\r\n  public set color(value) {\r\n    this.flagDirty();\r\n    this._color = watch(value, () => this.flagDirty());\r\n  }\r\n\r\n  private _strokeColor: Color;\r\n  /**\r\n   * Gets or sets the strokeStyle of the Raster graphic. Setting the strokeStyle will cause the raster to be\r\n   * flagged dirty causing a re-raster on the next draw.\r\n   */\r\n  public get strokeColor() {\r\n    return this._strokeColor;\r\n  }\r\n  public set strokeColor(value) {\r\n    this.flagDirty();\r\n    this._strokeColor = watch(value, () => this.flagDirty());\r\n  }\r\n\r\n  private _lineWidth: number = 1;\r\n  /**\r\n   * Gets or sets the line width of the Raster graphic. Setting the lineWidth will cause the raster to be\r\n   * flagged dirty causing a re-raster on the next draw.\r\n   */\r\n  public get lineWidth() {\r\n    return this._lineWidth;\r\n  }\r\n  public set lineWidth(value) {\r\n    this._lineWidth = value;\r\n    this.flagDirty();\r\n  }\r\n\r\n  private _lineDash: number[] = [];\r\n  public get lineDash() {\r\n    return this._lineDash;\r\n  }\r\n\r\n  public set lineDash(value) {\r\n    this._lineDash = value;\r\n    this.flagDirty();\r\n  }\r\n\r\n  private _padding: number = 0;\r\n  public get padding() {\r\n    return this._padding;\r\n  }\r\n\r\n  public set padding(value: number) {\r\n    this._padding = value;\r\n    this.flagDirty();\r\n  }\r\n\r\n  /**\r\n   * Rasterize the graphic to a bitmap making it usable as in excalibur. Rasterize is called automatically if\r\n   * the graphic is [[Raster.dirty]] on the next [[Graphic.draw]] call\r\n   */\r\n  public rasterize(): void {\r\n    this._dirty = false;\r\n    this._ctx.clearRect(0, 0, this._getTotalWidth(), this._getTotalHeight());\r\n    this._ctx.save();\r\n    this._applyRasterProperties(this._ctx);\r\n    this.execute(this._ctx);\r\n    this._ctx.restore();\r\n    // The webgl texture needs to be updated if it exists after a raster cycle\r\n    TextureLoader.load(this._bitmap, this.filtering, true);\r\n  }\r\n\r\n  protected _applyRasterProperties(ctx: CanvasRenderingContext2D) {\r\n    this._bitmap.width = this._getTotalWidth() * this.quality;\r\n    this._bitmap.height = this._getTotalHeight() * this.quality;\r\n    ctx.scale(this.quality, this.quality);\r\n    ctx.translate(this.padding, this.padding);\r\n    ctx.imageSmoothingEnabled = this.smoothing;\r\n    ctx.lineWidth = this.lineWidth;\r\n    ctx.setLineDash(this.lineDash ?? ctx.getLineDash());\r\n    ctx.lineCap = this.lineCap;\r\n    ctx.strokeStyle = this.strokeColor?.toString();\r\n    ctx.fillStyle = this.color?.toString();\r\n  }\r\n\r\n  protected _drawImage(ex: ExcaliburGraphicsContext, x: number, y: number) {\r\n    if (this._dirty) {\r\n      this.rasterize();\r\n    }\r\n    ex.scale(1 / this.quality, 1 / this.quality);\r\n    ex.drawImage(this._bitmap, x, y);\r\n  }\r\n\r\n  /**\r\n   * Executes drawing implementation of the graphic, this is where the specific drawing code for the graphic\r\n   * should be implemented. Once `rasterize()` the graphic can be drawn to the [[ExcaliburGraphicsContext]] via `draw(...)`\r\n   * @param ctx Canvas to draw the graphic to\r\n   */\r\n  abstract execute(ctx: CanvasRenderingContext2D): void;\r\n}\r\n","export default \"data:image/png;base64,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\"","import { GraphicOptions } from './Graphic';\r\nimport { Raster, RasterOptions } from './Raster';\r\n\r\nexport interface CanvasOptions {\r\n  draw?: (ctx: CanvasRenderingContext2D) => void;\r\n  cache?: boolean;\r\n}\r\n\r\n/**\r\n * A canvas [[Graphic]] to provide an adapter between the 2D Canvas API and the [[ExcaliburGraphicsContext]].\r\n *\r\n * The [[Canvas]] works by re-rastering a draw handler to a HTMLCanvasElement for every draw which is then passed\r\n * to the [[ExcaliburGraphicsContext]] implementation as a rendered image.\r\n *\r\n * **Low performance API**\r\n */\r\nexport class Canvas extends Raster {\r\n  /**\r\n   * Return the 2D graphics context of this canvas\r\n   */\r\n  public get ctx() {\r\n    return this._ctx;\r\n  }\r\n\r\n  constructor(private _options: GraphicOptions & RasterOptions & CanvasOptions) {\r\n    super(_options);\r\n  }\r\n\r\n  public clone(): Canvas {\r\n    return new Canvas({\r\n      ...this._options,\r\n      ...this.cloneGraphicOptions(),\r\n      ...this.cloneRasterOptions()\r\n    });\r\n  }\r\n\r\n  execute(ctx: CanvasRenderingContext2D): void {\r\n    if (this._options?.draw) {\r\n      this._options?.draw(ctx);\r\n    }\r\n    if (!this._options.cache) {\r\n      this.flagDirty();\r\n    }\r\n  }\r\n}\r\n","import { Color } from './Color';\r\nimport { WebAudio } from './Util/WebAudio';\r\nimport { Engine } from './Engine';\r\nimport { Loadable } from './Interfaces/Loadable';\r\nimport { Class } from './Class';\r\nimport * as DrawUtil from './Util/DrawUtil';\r\n\r\nimport logoImg from './Loader.logo.png';\r\nimport loaderCss from './Loader.css';\r\nimport { Canvas } from './Graphics/Canvas';\r\nimport { Vector } from './Math/vector';\r\nimport { delay } from './Util/Util';\r\nimport { ImageFiltering } from './Graphics/Filtering';\r\nimport { clamp } from './Math/util';\r\n\r\n/**\r\n * Pre-loading assets\r\n *\r\n * The loader provides a mechanism to preload multiple resources at\r\n * one time. The loader must be passed to the engine in order to\r\n * trigger the loading progress bar.\r\n *\r\n * The [[Loader]] itself implements [[Loadable]] so you can load loaders.\r\n *\r\n * ## Example: Pre-loading resources for a game\r\n *\r\n * ```js\r\n * // create a loader\r\n * var loader = new ex.Loader();\r\n *\r\n * // create a resource dictionary (best practice is to keep a separate file)\r\n * var resources = {\r\n *   TextureGround: new ex.Texture(\"/images/textures/ground.png\"),\r\n *   SoundDeath: new ex.Sound(\"/sound/death.wav\", \"/sound/death.mp3\")\r\n * };\r\n *\r\n * // loop through dictionary and add to loader\r\n * for (var loadable in resources) {\r\n *   if (resources.hasOwnProperty(loadable)) {\r\n *     loader.addResource(resources[loadable]);\r\n *   }\r\n * }\r\n *\r\n * // start game\r\n * game.start(loader).then(function () {\r\n *   console.log(\"Game started!\");\r\n * });\r\n * ```\r\n *\r\n * ## Customize the Loader\r\n *\r\n * The loader can be customized to show different, text, logo, background color, and button.\r\n *\r\n * ```typescript\r\n * const loader = new ex.Loader([playerTexture]);\r\n *\r\n * // The loaders button text can simply modified using this\r\n * loader.playButtonText = 'Start the best game ever';\r\n *\r\n * // The logo can be changed by inserting a base64 image string here\r\n *\r\n * loader.logo = 'data:image/png;base64,iVBORw...';\r\n * loader.logoWidth = 15;\r\n * loader.logoHeight = 14;\r\n *\r\n * // The background color can be changed like so by supplying a valid CSS color string\r\n *\r\n * loader.backgroundColor = 'red'\r\n * loader.backgroundColor = '#176BAA'\r\n *\r\n * // To build a completely new button\r\n * loader.startButtonFactory = () => {\r\n *     let myButton = document.createElement('button');\r\n *     myButton.textContent = 'The best button';\r\n *     return myButton;\r\n * };\r\n *\r\n * engine.start(loader).then(() => {});\r\n * ```\r\n */\r\nexport class Loader extends Class implements Loadable<Loadable<any>[]> {\r\n  public canvas: Canvas = new Canvas({\r\n    filtering: ImageFiltering.Blended,\r\n    smoothing: true,\r\n    cache: true,\r\n    draw: this.draw.bind(this)\r\n  });\r\n  private _resourceList: Loadable<any>[] = [];\r\n  private _index = 0;\r\n\r\n  private _playButtonShown: boolean = false;\r\n  private _resourceCount: number = 0;\r\n  private _numLoaded: number = 0;\r\n  private _progressCounts: { [key: string]: number } = {};\r\n  private _totalCounts: { [key: string]: number } = {};\r\n  private _engine: Engine;\r\n\r\n  // logo drawing stuff\r\n\r\n  // base64 string encoding of the excalibur logo (logo-white.png)\r\n  public logo = logoImg;\r\n  public logoWidth = 468;\r\n  public logoHeight = 118;\r\n  /**\r\n   * Positions the top left corner of the logo image\r\n   * If not set, the loader automatically positions the logo\r\n   */\r\n  public logoPosition: Vector | null;\r\n  /**\r\n   * Positions the top left corner of the play button.\r\n   * If not set, the loader automatically positions the play button\r\n   */\r\n  public playButtonPosition: Vector | null;\r\n  /**\r\n   * Positions the top left corner of the loading bar\r\n   * If not set, the loader automatically positions the loading bar\r\n   */\r\n  public loadingBarPosition: Vector | null;\r\n\r\n  /**\r\n   * Gets or sets the color of the loading bar, default is [[Color.White]]\r\n   */\r\n  public loadingBarColor: Color = Color.White;\r\n\r\n  /**\r\n   * Gets or sets the background color of the loader as a hex string\r\n   */\r\n  public backgroundColor: string = '#176BAA';\r\n\r\n  protected _imageElement: HTMLImageElement;\r\n  protected get _image() {\r\n    if (!this._imageElement) {\r\n      this._imageElement = new Image();\r\n      this._imageElement.src = this.logo;\r\n    }\r\n\r\n    return this._imageElement;\r\n  }\r\n\r\n  public suppressPlayButton: boolean = false;\r\n  public get playButtonRootElement(): HTMLElement | null {\r\n    return this._playButtonRootElement;\r\n  }\r\n  public get playButtonElement(): HTMLButtonElement | null {\r\n    return this._playButtonElement;\r\n  }\r\n  protected _playButtonRootElement: HTMLElement;\r\n  protected _playButtonElement: HTMLButtonElement;\r\n  protected _styleBlock: HTMLStyleElement;\r\n  /** Loads the css from Loader.css */\r\n  protected _playButtonStyles: string = loaderCss.toString();\r\n  protected get _playButton() {\r\n    const existingRoot = document.getElementById('excalibur-play-root');\r\n    if (existingRoot) {\r\n      this._playButtonRootElement = existingRoot;\r\n    }\r\n    if (!this._playButtonRootElement) {\r\n      this._playButtonRootElement = document.createElement('div');\r\n      this._playButtonRootElement.id = 'excalibur-play-root';\r\n      this._playButtonRootElement.style.position = 'absolute';\r\n      document.body.appendChild(this._playButtonRootElement);\r\n    }\r\n    if (!this._styleBlock) {\r\n      this._styleBlock = document.createElement('style');\r\n      this._styleBlock.textContent = this._playButtonStyles;\r\n      document.head.appendChild(this._styleBlock);\r\n    }\r\n    if (!this._playButtonElement) {\r\n      this._playButtonElement = this.startButtonFactory();\r\n      this._playButtonRootElement.appendChild(this._playButtonElement);\r\n    }\r\n    return this._playButtonElement;\r\n  }\r\n\r\n  /**\r\n   * Get/set play button text\r\n   */\r\n  public playButtonText: string = 'Play game';\r\n\r\n  /**\r\n   * Return a html button element for excalibur to use as a play button\r\n   */\r\n  public startButtonFactory = () => {\r\n    let buttonElement: HTMLButtonElement = document.getElementById('excalibur-play') as HTMLButtonElement;\r\n    if (!buttonElement) {\r\n      buttonElement = document.createElement('button');\r\n    }\r\n\r\n    buttonElement.id = 'excalibur-play';\r\n    buttonElement.textContent = this.playButtonText;\r\n    buttonElement.style.display = 'none';\r\n    return buttonElement;\r\n  };\r\n\r\n  /**\r\n   * @param loadables  Optionally provide the list of resources you want to load at constructor time\r\n   */\r\n  constructor(loadables?: Loadable<any>[]) {\r\n    super();\r\n\r\n    if (loadables) {\r\n      this.addResources(loadables);\r\n    }\r\n  }\r\n\r\n  public wireEngine(engine: Engine) {\r\n    this._engine = engine;\r\n    this.canvas.width = this._engine.canvas.width;\r\n    this.canvas.height = this._engine.canvas.height;\r\n  }\r\n\r\n  /**\r\n   * Add a resource to the loader to load\r\n   * @param loadable  Resource to add\r\n   */\r\n  public addResource(loadable: Loadable<any>) {\r\n    const key = this._index++;\r\n    this._resourceList.push(loadable);\r\n    this._progressCounts[key] = 0;\r\n    this._totalCounts[key] = 1;\r\n    this._resourceCount++;\r\n  }\r\n\r\n  /**\r\n   * Add a list of resources to the loader to load\r\n   * @param loadables  The list of resources to load\r\n   */\r\n  public addResources(loadables: Loadable<any>[]) {\r\n    let i = 0;\r\n    const len = loadables.length;\r\n\r\n    for (i; i < len; i++) {\r\n      this.addResource(loadables[i]);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Returns true if the loader has completely loaded all resources\r\n   */\r\n  public isLoaded() {\r\n    return this._numLoaded === this._resourceCount;\r\n  }\r\n\r\n  /**\r\n   * Shows the play button and returns a promise that resolves when clicked\r\n   */\r\n  public async showPlayButton(): Promise<void> {\r\n    if (this.suppressPlayButton) {\r\n      this.hidePlayButton();\r\n      // Delay is to give the logo a chance to show, otherwise don't delay\r\n      await delay(500, this._engine?.clock);\r\n    } else {\r\n      const resizeHandler = () => {\r\n        this._positionPlayButton();\r\n      };\r\n      if (this._engine?.browser) {\r\n        this._engine.browser.window.on('resize', resizeHandler);\r\n      }\r\n      this._playButtonShown = true;\r\n      this._playButton.style.display = 'block';\r\n      document.body.addEventListener('keyup', (evt: KeyboardEvent) => {\r\n        if (evt.key === 'Enter') {\r\n          this._playButton.click();\r\n        }\r\n      });\r\n      this._positionPlayButton();\r\n      const playButtonClicked = new Promise<void>((resolve) => {\r\n        const startButtonHandler = (e: Event) => {\r\n          // We want to stop propagation to keep bubbling to the engine pointer handlers\r\n          e.stopPropagation();\r\n          // Hide Button after click\r\n          this.hidePlayButton();\r\n          if (this._engine?.browser) {\r\n            this._engine.browser.window.off('resize', resizeHandler);\r\n          }\r\n          resolve();\r\n        };\r\n        this._playButton.addEventListener('click', startButtonHandler);\r\n        this._playButton.addEventListener('touchend', startButtonHandler);\r\n        this._playButton.addEventListener('pointerup', startButtonHandler);\r\n      });\r\n\r\n      return await playButtonClicked;\r\n    }\r\n  }\r\n\r\n  public hidePlayButton() {\r\n    this._playButtonShown = false;\r\n    this._playButton.style.display = 'none';\r\n  }\r\n\r\n  /**\r\n   * Clean up generated elements for the loader\r\n   */\r\n  public dispose() {\r\n    if (this._playButtonRootElement.parentElement) {\r\n      this._playButtonRootElement.removeChild(this._playButtonElement);\r\n      document.body.removeChild(this._playButtonRootElement);\r\n      document.head.removeChild(this._styleBlock);\r\n      this._playButtonRootElement = null;\r\n      this._playButtonElement = null;\r\n      this._styleBlock = null;\r\n    }\r\n  }\r\n\r\n  update(_engine: Engine, _delta: number): void {\r\n    // override me\r\n  }\r\n\r\n  data: Loadable<any>[];\r\n\r\n  private _isLoadedResolve: () => any;\r\n  private _isLoadedPromise = new Promise<void>(resolve => {\r\n    this._isLoadedResolve = resolve;\r\n  });\r\n  public areResourcesLoaded() {\r\n    return this._isLoadedPromise;\r\n  }\r\n\r\n  /**\r\n   * Begin loading all of the supplied resources, returning a promise\r\n   * that resolves when loading of all is complete AND the user has clicked the \"Play button\"\r\n   */\r\n  public async load(): Promise<Loadable<any>[]> {\r\n    await this._image?.decode(); // decode logo if it exists\r\n\r\n    await Promise.all(\r\n      this._resourceList.map((r) =>\r\n        r.load().finally(() => {\r\n          // capture progress\r\n          this._numLoaded++;\r\n          this.canvas.flagDirty();\r\n        })\r\n      )\r\n    );\r\n    this._isLoadedResolve();\r\n\r\n    // short delay in showing the button for aesthetics\r\n    await delay(200, this._engine?.clock);\r\n    this.canvas.flagDirty();\r\n\r\n    await this.showPlayButton();\r\n    // Unlock browser AudioContext in after user gesture\r\n    // See: https://github.com/excaliburjs/Excalibur/issues/262\r\n    // See: https://github.com/excaliburjs/Excalibur/issues/1031\r\n    await WebAudio.unlock();\r\n\r\n    return (this.data = this._resourceList);\r\n  }\r\n\r\n  public markResourceComplete(): void {\r\n    this._numLoaded++;\r\n  }\r\n\r\n  /**\r\n   * Returns the progress of the loader as a number between [0, 1] inclusive.\r\n   */\r\n  public get progress(): number {\r\n    return this._resourceCount > 0 ? clamp(this._numLoaded, 0, this._resourceCount) / this._resourceCount : 1;\r\n  }\r\n\r\n  private _positionPlayButton() {\r\n    if (this._engine) {\r\n      const screenHeight = this._engine.screen.viewport.height;\r\n      const screenWidth = this._engine.screen.viewport.width;\r\n      if (this._playButtonRootElement) {\r\n        const left = this._engine.canvas.offsetLeft;\r\n        const top = this._engine.canvas.offsetTop;\r\n        const buttonWidth = this._playButton.clientWidth;\r\n        const buttonHeight = this._playButton.clientHeight;\r\n        if (this.playButtonPosition) {\r\n          this._playButtonRootElement.style.left = `${this.playButtonPosition.x}px`;\r\n          this._playButtonRootElement.style.top = `${this.playButtonPosition.y}px`;\r\n        } else {\r\n          this._playButtonRootElement.style.left = `${left + screenWidth / 2 - buttonWidth / 2}px`;\r\n          this._playButtonRootElement.style.top = `${top + screenHeight / 2 - buttonHeight / 2 + 100}px`;\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Loader draw function. Draws the default Excalibur loading screen.\r\n   * Override `logo`, `logoWidth`, `logoHeight` and `backgroundColor` properties\r\n   * to customize the drawing, or just override entire method.\r\n   */\r\n  public draw(ctx: CanvasRenderingContext2D) {\r\n    const canvasHeight = this._engine.canvasHeight / this._engine.pixelRatio;\r\n    const canvasWidth = this._engine.canvasWidth / this._engine.pixelRatio;\r\n\r\n    this._positionPlayButton();\r\n\r\n    ctx.fillStyle = this.backgroundColor;\r\n    ctx.fillRect(0, 0, canvasWidth, canvasHeight);\r\n\r\n    let logoY = canvasHeight / 2;\r\n    const width = Math.min(this.logoWidth, canvasWidth * 0.75);\r\n    let logoX = canvasWidth / 2 - width / 2;\r\n\r\n    if (this.logoPosition) {\r\n      logoX = this.logoPosition.x;\r\n      logoY = this.logoPosition.y;\r\n    }\r\n\r\n    const imageHeight = Math.floor(width * (this.logoHeight / this.logoWidth)); // OG height/width factor\r\n    const oldAntialias = this._engine.getAntialiasing();\r\n    this._engine.setAntialiasing(true);\r\n    if (!this.logoPosition) {\r\n      ctx.drawImage(this._image, 0, 0, this.logoWidth, this.logoHeight, logoX, logoY - imageHeight - 20, width, imageHeight);\r\n    } else {\r\n      ctx.drawImage(this._image, 0, 0, this.logoWidth, this.logoHeight, logoX, logoY, width, imageHeight);\r\n    }\r\n\r\n    // loading box\r\n    if (!this.suppressPlayButton && this._playButtonShown) {\r\n      this._engine.setAntialiasing(oldAntialias);\r\n      return;\r\n    }\r\n\r\n    let loadingX = logoX;\r\n    let loadingY = logoY;\r\n    if (this.loadingBarPosition) {\r\n      loadingX = this.loadingBarPosition.x;\r\n      loadingY = this.loadingBarPosition.y;\r\n    }\r\n\r\n    ctx.lineWidth = 2;\r\n    DrawUtil.roundRect(ctx, loadingX, loadingY, width, 20, 10, this.loadingBarColor);\r\n    const progress = width * this.progress;\r\n    const margin = 5;\r\n    const progressWidth = progress - margin * 2;\r\n    const height = 20 - margin * 2;\r\n    DrawUtil.roundRect(\r\n      ctx,\r\n      loadingX + margin,\r\n      loadingY + margin,\r\n      progressWidth > 10 ? progressWidth : 10,\r\n      height,\r\n      5,\r\n      null,\r\n      this.loadingBarColor\r\n    );\r\n    this._engine.setAntialiasing(oldAntialias);\r\n  }\r\n}\r\n","import { Logger } from './Log';\r\n/**\r\n * This is the list of features that will be used to log the supported\r\n * features to the console when Detector.logBrowserFeatures() is called.\r\n */\r\n\r\nconst REPORTED_FEATURES: { [key: string]: string } = {\r\n  webgl: 'WebGL',\r\n  webaudio: 'WebAudio',\r\n  gamepadapi: 'Gamepad API'\r\n};\r\n\r\n/**\r\n * Interface for detected browser features matrix\r\n */\r\nexport interface DetectedFeatures {\r\n  readonly canvas: boolean;\r\n  readonly arraybuffer: boolean;\r\n  readonly dataurl: boolean;\r\n  readonly objecturl: boolean;\r\n  readonly rgba: boolean;\r\n  readonly webaudio: boolean;\r\n  readonly webgl: boolean;\r\n  readonly gamepadapi: boolean;\r\n}\r\n\r\ninterface CriticalTests {\r\n  canvasSupport(): boolean;\r\n  arrayBufferSupport(): boolean;\r\n  dataUrlSupport(): boolean;\r\n  objectUrlSupport(): boolean;\r\n  rgbaSupport(): boolean;\r\n}\r\n\r\ninterface WarningTests {\r\n  webAudioSupport(): boolean;\r\n  webglSupport(): boolean;\r\n}\r\n\r\n/**\r\n * Excalibur internal feature detection helper class\r\n */\r\nexport class Detector {\r\n  private _features: DetectedFeatures = null;\r\n\r\n  public failedTests: string[] = [];\r\n\r\n  public constructor() {\r\n    this._features = this._loadBrowserFeatures();\r\n  }\r\n\r\n  /**\r\n   * Returns a map of currently supported browser features. This method\r\n   * treats the features as a singleton and will only calculate feature\r\n   * support if it has not previously been done.\r\n   */\r\n  public getBrowserFeatures(): DetectedFeatures {\r\n    if (this._features === null) {\r\n      this._features = this._loadBrowserFeatures();\r\n    }\r\n    return this._features;\r\n  }\r\n\r\n  /**\r\n   * Report on non-critical browser support for debugging purposes.\r\n   * Use native browser console colors for visibility.\r\n   */\r\n  public logBrowserFeatures(): void {\r\n    let msg = '%cSUPPORTED BROWSER FEATURES\\n==========================%c\\n';\r\n    const args = ['font-weight: bold; color: navy', 'font-weight: normal; color: inherit'];\r\n\r\n    const supported: any = this.getBrowserFeatures();\r\n    for (const feature of Object.keys(REPORTED_FEATURES)) {\r\n      if (supported[feature]) {\r\n        msg += '(%c\\u2713%c)'; // (✓)\r\n        args.push('font-weight: bold; color: green');\r\n        args.push('font-weight: normal; color: inherit');\r\n      } else {\r\n        msg += '(%c\\u2717%c)'; // (✗)\r\n        args.push('font-weight: bold; color: red');\r\n        args.push('font-weight: normal; color: inherit');\r\n      }\r\n\r\n      msg += ' ' + REPORTED_FEATURES[feature] + '\\n';\r\n    }\r\n\r\n    args.unshift(msg);\r\n    // eslint-disable-next-line no-console\r\n    console.log.apply(console, args);\r\n  }\r\n\r\n  /**\r\n   * Executes several IIFE's to get a constant reference to supported\r\n   * features within the current execution context.\r\n   */\r\n  private _loadBrowserFeatures(): DetectedFeatures {\r\n    return {\r\n      // IIFE to check canvas support\r\n      canvas: (() => {\r\n        return this._criticalTests.canvasSupport();\r\n      })(),\r\n\r\n      // IIFE to check arraybuffer support\r\n      arraybuffer: (() => {\r\n        return this._criticalTests.arrayBufferSupport();\r\n      })(),\r\n\r\n      // IIFE to check dataurl support\r\n      dataurl: (() => {\r\n        return this._criticalTests.dataUrlSupport();\r\n      })(),\r\n\r\n      // IIFE to check objecturl support\r\n      objecturl: (() => {\r\n        return this._criticalTests.objectUrlSupport();\r\n      })(),\r\n\r\n      // IIFE to check rgba support\r\n      rgba: (() => {\r\n        return this._criticalTests.rgbaSupport();\r\n      })(),\r\n\r\n      // IIFE to check webaudio support\r\n      webaudio: (() => {\r\n        return this._warningTest.webAudioSupport();\r\n      })(),\r\n\r\n      // IIFE to check webgl support\r\n      webgl: (() => {\r\n        return this._warningTest.webglSupport();\r\n      })(),\r\n\r\n      // IIFE to check gamepadapi support\r\n      gamepadapi: (() => {\r\n        return !!(<any>navigator).getGamepads;\r\n      })()\r\n    };\r\n  }\r\n\r\n  // critical browser features required for ex to run\r\n  private _criticalTests: CriticalTests = {\r\n    // Test canvas/2d context support\r\n    canvasSupport: function() {\r\n      const elem = document.createElement('canvas');\r\n      return !!(elem.getContext && elem.getContext('2d'));\r\n    },\r\n\r\n    // Test array buffer support ex uses for downloading binary data\r\n    arrayBufferSupport: function() {\r\n      const xhr = new XMLHttpRequest();\r\n      xhr.open('GET', '/');\r\n      try {\r\n        xhr.responseType = 'arraybuffer';\r\n      } catch (e) {\r\n        return false;\r\n      }\r\n      return xhr.responseType === 'arraybuffer';\r\n    },\r\n\r\n    // Test data urls ex uses for sprites\r\n    dataUrlSupport: function() {\r\n      const canvas = document.createElement('canvas');\r\n      return canvas.toDataURL('image/png').indexOf('data:image/png') === 0;\r\n    },\r\n\r\n    // Test object url support for loading\r\n    objectUrlSupport: function() {\r\n      return 'URL' in window && 'revokeObjectURL' in URL && 'createObjectURL' in URL;\r\n    },\r\n\r\n    // RGBA support for colors\r\n    rgbaSupport: function() {\r\n      const style = document.createElement('a').style;\r\n      style.cssText = 'background-color:rgba(150,255,150,.5)';\r\n      return ('' + style.backgroundColor).indexOf('rgba') > -1;\r\n    }\r\n  };\r\n\r\n  // warnings excalibur performance will be degraded\r\n  private _warningTest: WarningTests = {\r\n    webAudioSupport: function() {\r\n      return !!(\r\n        (<any>window).AudioContext ||\r\n        (<any>window).webkitAudioContext ||\r\n        (<any>window).mozAudioContext ||\r\n        (<any>window).msAudioContext ||\r\n        (<any>window).oAudioContext\r\n      );\r\n    },\r\n    webglSupport: function() {\r\n      const elem = document.createElement('canvas');\r\n      return !!(elem.getContext && elem.getContext('webgl'));\r\n    }\r\n  };\r\n\r\n  public test(): boolean {\r\n    // Critical test will for ex not to run\r\n    let failedCritical = false;\r\n    for (const test in this._criticalTests) {\r\n      if (!this._criticalTests[<keyof CriticalTests>test].call(this)) {\r\n        this.failedTests.push(test);\r\n        Logger.getInstance().error('Critical browser feature missing, Excalibur requires:', test);\r\n        failedCritical = true;\r\n      }\r\n    }\r\n    if (failedCritical) {\r\n      return false;\r\n    }\r\n\r\n    // Warning tests do not for ex to return false to compatibility\r\n    for (const warning in this._warningTest) {\r\n      if (!this._warningTest[<keyof WarningTests>warning]()) {\r\n        Logger.getInstance().warn('Warning browser feature missing, Excalibur will have reduced performance:', warning);\r\n      }\r\n    }\r\n\r\n    return true;\r\n  }\r\n}\r\n","/**\r\n * An enum that describes the types of collisions bodies can participate in\r\n */\r\nexport enum CollisionType {\r\n  /**\r\n   * Bodies with the `PreventCollision` setting do not participate in any\r\n   * collisions and do not raise collision events.\r\n   */\r\n  PreventCollision = 'PreventCollision',\r\n  /**\r\n   * Bodies with the `Passive` setting only raise collision events, but are not\r\n   * influenced or moved by other bodies and do not influence or move other bodies.\r\n   * This is useful for use in trigger type behavior.\r\n   */\r\n  Passive = 'Passive',\r\n  /**\r\n   * Bodies with the `Active` setting raise collision events and participate\r\n   * in collisions with other bodies and will be push or moved by bodies sharing\r\n   * the `Active` or `Fixed` setting.\r\n   */\r\n  Active = 'Active',\r\n  /**\r\n   * Bodies with the `Fixed` setting raise collision events and participate in\r\n   * collisions with other bodies. Actors with the `Fixed` setting will not be\r\n   * pushed or moved by other bodies sharing the `Fixed`. Think of Fixed\r\n   * bodies as \"immovable/unstoppable\" objects. If two `Fixed` bodies meet they will\r\n   * not be pushed or moved by each other, they will not interact except to throw\r\n   * collision events.\r\n   */\r\n  Fixed = 'Fixed'\r\n}\r\n","import { Flags } from '../Flags';\r\nimport { Logger } from './Log';\r\n\r\n/**\r\n * Obsolete decorator options\r\n */\r\nexport interface ObsoleteOptions {\r\n  // Optionally specify a custom message\r\n  message?: string;\r\n  // Optionally indicate that an alternate method to the obsolete one exists\r\n  alternateMethod?: string;\r\n  // Optional show stack trace, by default off\r\n  showStackTrace?: boolean;\r\n}\r\n\r\nexport const maxMessages = 5;\r\nconst obsoleteMessage: { [messageCount: string]: number } = {};\r\nexport const resetObsoleteCounter = () => {\r\n  for (const message in obsoleteMessage) {\r\n    obsoleteMessage[message] = 0;\r\n  }\r\n};\r\n\r\nconst logMessage = (message: string, options: ObsoleteOptions) => {\r\n  const suppressObsoleteMessages = Flags.isEnabled('suppress-obsolete-message');\r\n  if (obsoleteMessage[message] < maxMessages && !suppressObsoleteMessages) {\r\n    Logger.getInstance().warn(message);\r\n\r\n    // tslint:disable-next-line: no-console\r\n    if (console.trace && options.showStackTrace) {\r\n      // tslint:disable-next-line: no-console\r\n      console.trace();\r\n    }\r\n  }\r\n  obsoleteMessage[message]++;\r\n};\r\n\r\n/**\r\n * Obsolete decorator for marking Excalibur methods obsolete, you can optionally specify a custom message and/or alternate replacement\r\n * method do the deprecated one. Inspired by https://github.com/jayphelps/core-decorators.js\r\n */\r\nexport function obsolete(options?: ObsoleteOptions): any {\r\n  options = {\r\n    message: 'This feature will be removed in future versions of Excalibur.',\r\n    alternateMethod: null,\r\n    showStackTrace: false,\r\n    ...options\r\n  };\r\n\r\n  return function (target: any, property: string, descriptor: PropertyDescriptor): any {\r\n    if (\r\n      descriptor &&\r\n      !(typeof descriptor.value === 'function' || typeof descriptor.get === 'function' || typeof descriptor.set === 'function')\r\n    ) {\r\n      throw new SyntaxError('Only classes/functions/getters/setters can be marked as obsolete');\r\n    }\r\n    const methodSignature = `${target.name || ''}${target.name && property ? '.' : ''}${property ? property : ''}`;\r\n\r\n    const message =\r\n      `${methodSignature} is marked obsolete: ${options.message}` +\r\n      (options.alternateMethod ? ` Use ${options.alternateMethod} instead` : '');\r\n\r\n    if (!obsoleteMessage[message]) {\r\n      obsoleteMessage[message] = 0;\r\n    }\r\n\r\n    // If descriptor is null it is a class\r\n    const method = descriptor ? { ...descriptor } : target;\r\n    if (!descriptor) {\r\n      // with es2015 classes we need to change our decoration tactic\r\n      class DecoratedClass extends method {\r\n        constructor(...args: any) {\r\n          logMessage(message, options);\r\n          super(...args);\r\n        }\r\n      }\r\n      return DecoratedClass;\r\n    }\r\n\r\n    if (descriptor && descriptor.value) {\r\n      method.value = function (this: any) {\r\n        logMessage(message, options);\r\n        return descriptor.value.apply(this, arguments);\r\n      };\r\n      return method;\r\n    }\r\n\r\n    if (descriptor && descriptor.get) {\r\n      method.get = function (this: any) {\r\n        logMessage(message, options);\r\n        return descriptor.get.apply(this, arguments);\r\n      };\r\n    }\r\n\r\n    if (descriptor && descriptor.set) {\r\n      method.set = function (this: any) {\r\n        logMessage(message, options);\r\n        return descriptor.set.apply(this, arguments);\r\n      };\r\n    }\r\n    return method;\r\n  };\r\n}\r\n","import { Vector } from '../Math/vector';\r\nimport { obsolete } from '../Util/Decorators';\r\n\r\n\r\n/**\r\n * Possible collision resolution strategies\r\n *\r\n * The default is [[CollisionResolutionStrategy.Arcade]] which performs simple axis aligned arcade style physics. This is useful for things\r\n * like platformers or top down games.\r\n *\r\n * More advanced rigid body physics are enabled by setting [[CollisionResolutionStrategy.Realistic]] which allows for complicated\r\n * simulated physical interactions.\r\n */\r\nexport enum CollisionResolutionStrategy {\r\n  Arcade = 'arcade',\r\n  Realistic = 'realistic'\r\n}\r\n\r\n/**\r\n * Possible broadphase collision pair identification strategies\r\n *\r\n * The default strategy is [[BroadphaseStrategy.DynamicAABBTree]] which uses a binary tree of axis-aligned bounding boxes to identify\r\n * potential collision pairs which is O(nlog(n)) faster.\r\n */\r\nexport enum BroadphaseStrategy {\r\n  DynamicAABBTree\r\n}\r\n\r\n/**\r\n * Possible numerical integrators for position and velocity\r\n */\r\nexport enum Integrator {\r\n  Euler\r\n}\r\n\r\n/**\r\n * The [[Physics]] object is the global configuration object for all Excalibur physics.\r\n */\r\n/* istanbul ignore next */\r\nexport class Physics {\r\n  /**\r\n   * Global acceleration that is applied to all vanilla actors that have a [[CollisionType.Active|active]] collision type.\r\n   * Global acceleration won't effect [[Label|labels]], [[ScreenElement|ui actors]], or [[Trigger|triggers]] in Excalibur.\r\n   *\r\n   * This is a great way to globally simulate effects like gravity.\r\n   */\r\n  public static acc = new Vector(0, 0);\r\n  public static get gravity() {\r\n    return Physics.acc;\r\n  }\r\n  public static set gravity(v: Vector) {\r\n    Physics.acc = v;\r\n  }\r\n\r\n  /**\r\n   * Globally switches all Excalibur physics behavior on or off.\r\n   */\r\n  public static enabled = true;\r\n\r\n  /**\r\n   * Gets or sets the broadphase pair identification strategy.\r\n   *\r\n   * The default strategy is [[BroadphaseStrategy.DynamicAABBTree]] which uses a binary tree of axis-aligned bounding boxes to identify\r\n   * potential collision pairs which is O(nlog(n)) faster.\r\n   */\r\n  public static broadphaseStrategy: BroadphaseStrategy = BroadphaseStrategy.DynamicAABBTree;\r\n\r\n  /**\r\n   * Gets or sets the global collision resolution strategy (narrowphase).\r\n   *\r\n   * The default is [[CollisionResolutionStrategy.Arcade]] which performs simple axis aligned arcade style physics.\r\n   *\r\n   * More advanced rigid body physics are enabled by setting [[CollisionResolutionStrategy.Realistic]] which allows for complicated\r\n   * simulated physical interactions.\r\n   */\r\n  public static collisionResolutionStrategy: CollisionResolutionStrategy = CollisionResolutionStrategy.Arcade;\r\n  /**\r\n   * The default mass to use if none is specified\r\n   */\r\n  public static defaultMass: number = 10;\r\n  /**\r\n   * Gets or sets the position and velocity positional integrator, currently only Euler is supported.\r\n   */\r\n  public static integrator: Integrator = Integrator.Euler;\r\n\r\n  /**\r\n   * Configures Excalibur to use \"arcade\" physics. Arcade physics which performs simple axis aligned arcade style physics.\r\n   */\r\n  public static useArcadePhysics(): void {\r\n    Physics.collisionResolutionStrategy = CollisionResolutionStrategy.Arcade;\r\n  }\r\n\r\n  /**\r\n   * Configures Excalibur to use rigid body physics. Rigid body physics allows for complicated\r\n   * simulated physical interactions.\r\n   */\r\n  public static useRealisticPhysics(): void {\r\n    Physics.collisionResolutionStrategy = CollisionResolutionStrategy.Realistic;\r\n  }\r\n\r\n  /**\r\n   * Factor to add to the RigidBody BoundingBox, bounding box (dimensions += vel * dynamicTreeVelocityMultiplier);\r\n   */\r\n  public static dynamicTreeVelocityMultiplier = 2;\r\n\r\n  @obsolete({\r\n    message: 'Alias for incorrect spelling used in older versions, will be removed in v0.25.0',\r\n    alternateMethod: 'dynamicTreeVelocityMultiplier'\r\n  })\r\n  public static get dynamicTreeVelocityMultiplyer() {\r\n    return Physics.dynamicTreeVelocityMultiplier;\r\n  }\r\n\r\n  public static set dynamicTreeVelocityMultiplyer(value: number) {\r\n    Physics.dynamicTreeVelocityMultiplier = value;\r\n  }\r\n\r\n  /**\r\n   * Pad RigidBody BoundingBox by a constant amount\r\n   */\r\n  public static boundsPadding = 5;\r\n\r\n  /**\r\n   * Number of position iterations (overlap) to run in the solver\r\n   */\r\n  public static positionIterations = 3;\r\n\r\n  /**\r\n   * Number of velocity iteration (response) to run in the solver\r\n   */\r\n  public static velocityIterations = 8;\r\n\r\n  /**\r\n   * Amount of overlap to tolerate in pixels\r\n   */\r\n  public static slop = 1;\r\n\r\n  /**\r\n   * Amount of positional overlap correction to apply each position iteration of the solver\r\n   * O - meaning no correction, 1 - meaning correct all overlap\r\n   */\r\n  public static steeringFactor = 0.2;\r\n\r\n  /**\r\n   * Warm start set to true re-uses impulses from previous frames back in the solver\r\n   */\r\n  public static warmStart = true;\r\n\r\n  /**\r\n   * By default bodies do not sleep\r\n   */\r\n  public static bodiesCanSleepByDefault = false;\r\n\r\n  /**\r\n   * Surface epsilon is used to help deal with surface penetration\r\n   */\r\n  public static surfaceEpsilon = 0.1;\r\n\r\n  public static sleepEpsilon = 0.07;\r\n\r\n  public static wakeThreshold = Physics.sleepEpsilon * 3;\r\n\r\n  public static sleepBias = 0.9;\r\n\r\n  /**\r\n   * Enable fast moving body checking, this enables checking for collision pairs via raycast for fast moving objects to prevent\r\n   * bodies from tunneling through one another.\r\n   */\r\n  public static checkForFastBodies = true;\r\n\r\n  /**\r\n   * Disable minimum fast moving body raycast, by default if ex.Physics.checkForFastBodies = true Excalibur will only check if the\r\n   * body is moving at least half of its minimum dimension in an update. If ex.Physics.disableMinimumSpeedForFastBody is set to true,\r\n   * Excalibur will always perform the fast body raycast regardless of speed.\r\n   */\r\n  public static disableMinimumSpeedForFastBody = false;\r\n}\r\n","import { Vector } from './vector';\r\n\r\nexport interface VectorViewOptions {\r\n  getX: () => number;\r\n  getY: () => number;\r\n  setX: (x: number) => void;\r\n  setY: (y: number) => void;\r\n}\r\nexport class VectorView extends Vector {\r\n  private _getX: () => number;\r\n  private _getY: () => number;\r\n  private _setX: (x: number) => void;\r\n  private _setY: (y: number) => void;\r\n  constructor(options: VectorViewOptions) {\r\n    super(0, 0);\r\n    this._getX = options.getX;\r\n    this._getY = options.getY;\r\n    this._setX = options.setX;\r\n    this._setY = options.setY;\r\n  }\r\n  public get x() {\r\n    return (this._x = this._getX());\r\n  }\r\n\r\n  public set x(val) {\r\n    this._setX(val);\r\n    this._x = val;\r\n  }\r\n\r\n  public get y() {\r\n    return (this._y = this._getY());\r\n  }\r\n  public set y(val) {\r\n    this._setY(val);\r\n    this._y = val;\r\n  }\r\n}\r\n","import { Entity } from './Entity';\r\n\r\n/**\r\n * Component Contructor Types\r\n */\r\nexport declare type ComponentCtor<T extends Component = Component> = new (...args:any[]) => T;\r\n\r\n/**\r\n * Type guard to check if a component implements clone\r\n * @param x\r\n */\r\nfunction hasClone(x: any): x is { clone(): any } {\r\n  return !!x?.clone;\r\n}\r\n\r\nexport type ComponentType<ComponentToParse> = ComponentToParse extends Component<infer TypeName> ? TypeName : never;\r\n\r\n/**\r\n * Plucks the string type out of a component type\r\n */\r\nexport type ComponentStringType<T> = T extends Component<infer R> ? R : string;\r\n\r\n/**\r\n * Components are containers for state in Excalibur, the are meant to convey capabilities that an Entity possesses\r\n *\r\n * Implementations of Component must have a zero-arg constructor to support dependencies\r\n *\r\n * ```typescript\r\n * class MyComponent extends ex.Component<'my'> {\r\n *   public readonly type = 'my';\r\n *   // zero arg support required if you want to use component dependencies\r\n *   constructor(public optionalPos?: ex.Vector) {}\r\n * }\r\n * ```\r\n */\r\nexport abstract class Component<TypeName extends string = string> {\r\n  /**\r\n   * Optionally list any component types this component depends on\r\n   * If the owner entity does not have these components, new components will be added to the entity\r\n   *\r\n   * Only components with zero-arg constructors are supported as automatic component dependencies\r\n   */\r\n  readonly dependencies?: ComponentCtor[];\r\n\r\n  // todo implement optional\r\n  readonly optional?: ComponentCtor[];\r\n\r\n  /**\r\n   * Type of this component, must be a unique type among component types in you game.\r\n   */\r\n  abstract readonly type: TypeName;\r\n\r\n  /**\r\n   * Current owning [[Entity]], if any, of this component. Null if not added to any [[Entity]]\r\n   */\r\n  owner?: Entity = null;\r\n\r\n  /**\r\n   * Clones any properties on this component, if that property value has a `clone()` method it will be called\r\n   */\r\n  clone(): this {\r\n    const newComponent = new (this.constructor as any)();\r\n    for (const prop in this) {\r\n      if (this.hasOwnProperty(prop)) {\r\n        const val = this[prop];\r\n        if (hasClone(val) && prop !== 'owner' && prop !== 'clone') {\r\n          newComponent[prop] = val.clone();\r\n        } else {\r\n          newComponent[prop] = val;\r\n        }\r\n      }\r\n    }\r\n    return newComponent;\r\n  }\r\n\r\n  /**\r\n   * Optional callback called when a component is added to an entity\r\n   */\r\n  onAdd?(owner: Entity): void;\r\n\r\n  /**\r\n   * Optional callback called when a component is added to an entity\r\n   */\r\n  onRemove?(previousOwner: Entity): void;\r\n}\r\n\r\n/**\r\n * Tag components are a way of tagging a component with label and a simple value\r\n *\r\n * For example:\r\n *\r\n * ```typescript\r\n * const isOffscreen = new TagComponent('offscreen');\r\n * entity.addComponent(isOffscreen);\r\n * entity.tags.includes\r\n * ```\r\n */\r\nexport class TagComponent<TypeName extends string, MaybeValueType extends string | symbol | number | boolean = never> extends Component<\r\nTypeName\r\n> {\r\n  constructor(public readonly type: TypeName, public readonly value?: MaybeValueType) {\r\n    super();\r\n  }\r\n}\r\n","/**\r\n * Defines a generic message that can contain any data\r\n * @template T is the typescript Type of the data\r\n */\r\nexport interface Message<T> {\r\n  type: string;\r\n  data: T;\r\n}\r\n\r\n/**\r\n * Defines an interface for an observer to receive a message via a notify() method\r\n */\r\nexport interface Observer<T> {\r\n  notify(message: T): void;\r\n}\r\n\r\n/**\r\n * Defines an interface for something that might be an observer if a notify() is present\r\n */\r\nexport type MaybeObserver<T> = Partial<Observer<T>>;\r\n\r\n/**\r\n * Simple Observable implementation\r\n * @template T is the typescript Type that defines the data being observed\r\n */\r\nexport class Observable<T> {\r\n  public observers: Observer<T>[] = [];\r\n  public subscriptions: ((val: T) => any)[] = [];\r\n\r\n  /**\r\n   * Register an observer to listen to this observable\r\n   * @param observer\r\n   */\r\n  register(observer: Observer<T>) {\r\n    this.observers.push(observer);\r\n  }\r\n\r\n  /**\r\n   * Register a callback to listen to this observable\r\n   * @param func\r\n   */\r\n  subscribe(func: (val: T) => any) {\r\n    this.subscriptions.push(func);\r\n  }\r\n\r\n  /**\r\n   * Remove an observer from the observable\r\n   * @param observer\r\n   */\r\n  unregister(observer: Observer<T>) {\r\n    const i = this.observers.indexOf(observer);\r\n    if (i !== -1) {\r\n      this.observers.splice(i, 1);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Remove a callback that is listening to this observable\r\n   * @param func\r\n   */\r\n  unsubscribe(func: (val: T) => any) {\r\n    const i = this.subscriptions.indexOf(func);\r\n    if (i !== -1) {\r\n      this.subscriptions.splice(i, 1);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Broadcasts a message to all observers and callbacks\r\n   * @param message\r\n   */\r\n  notifyAll(message: T) {\r\n    const observersLength = this.observers.length;\r\n    for (let i = 0; i < observersLength; i++) {\r\n      this.observers[i].notify(message);\r\n    }\r\n    const subscriptionsLength = this.subscriptions.length;\r\n    for (let i = 0; i < subscriptionsLength; i++) {\r\n      this.subscriptions[i](message);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Removes all observers and callbacks\r\n   */\r\n  clear() {\r\n    this.observers.length = 0;\r\n    this.subscriptions.length = 0;\r\n  }\r\n}\r\n","import { Matrix, MatrixLocations } from '../../Math/matrix';\r\nimport { VectorView } from '../../Math/vector-view';\r\nimport { Vector, vec } from '../../Math/vector';\r\nimport { Component } from '../Component';\r\nimport { Observable } from '../../Util/Observable';\r\nimport { watch } from '../../Util/Watch';\r\n\r\nexport interface Transform {\r\n  /**\r\n   * The [[CoordPlane|coordinate plane]] for this transform for the entity.\r\n   */\r\n  coordPlane: CoordPlane;\r\n\r\n  /**\r\n   * The current position of the entity in world space or in screen space depending on the the [[CoordPlane|coordinate plane]].\r\n   *\r\n   * If the entity has a parent this position is relative to the parent entity.\r\n   */\r\n  pos: Vector;\r\n\r\n  /**\r\n   * The z-index ordering of the entity, a higher values are drawn on top of lower values.\r\n   * For example z=99 would be drawn on top of z=0.\r\n   */\r\n  z: number;\r\n\r\n  /**\r\n   * The rotation of the entity in radians. For example `Math.PI` radians is the same as 180 degrees.\r\n   *\r\n   * If the entity has a parent this rotation is relative to the parent.\r\n   */\r\n  rotation: number;\r\n\r\n  /**\r\n   * The scale of the entity. If the entity has a parent this scale is relative to the parent.\r\n   */\r\n  scale: Vector;\r\n}\r\n\r\nconst createPosView = (matrix: Matrix) => {\r\n  const source = matrix;\r\n  return new VectorView({\r\n    setX: (x) => {\r\n      source.data[MatrixLocations.X] = x;\r\n    },\r\n    setY: (y) => {\r\n      source.data[MatrixLocations.Y] = y;\r\n    },\r\n    getX: () => {\r\n      return source.data[MatrixLocations.X];\r\n    },\r\n    getY: () => {\r\n      return source.data[MatrixLocations.Y];\r\n    }\r\n  });\r\n};\r\n\r\nconst createScaleView = (matrix: Matrix) => {\r\n  const source = matrix;\r\n  return new VectorView({\r\n    setX: (x) => {\r\n      source.setScaleX(x);\r\n    },\r\n    setY: (y) => {\r\n      source.setScaleY(y);\r\n    },\r\n    getX: () => {\r\n      return source.getScaleX();\r\n    },\r\n    getY: () => {\r\n      return source.getScaleY();\r\n    }\r\n  });\r\n};\r\n\r\n/**\r\n * Enum representing the coordinate plane for the position 2D vector in the [[TransformComponent]]\r\n */\r\nexport enum CoordPlane {\r\n  /**\r\n   * The world coordinate plane (default) represents world space, any entities drawn with world\r\n   * space move when the camera moves.\r\n   */\r\n  World = 'world',\r\n  /**\r\n   * The screen coordinate plane represents screen space, entities drawn in screen space are pinned\r\n   * to screen coordinates ignoring the camera.\r\n   */\r\n  Screen = 'screen'\r\n}\r\n\r\nexport class TransformComponent extends Component<'ex.transform'> implements Transform {\r\n  public readonly type = 'ex.transform';\r\n\r\n  private _dirty = false;\r\n\r\n  public readonly matrix = Matrix.identity().translate(0, 0).rotate(0).scale(1, 1);\r\n  private _position = watch(createPosView(this.matrix), (v) => {\r\n    this.posChanged$.notifyAll(v);\r\n  });\r\n  private _rotation = 0;\r\n  private _scale = createScaleView(this.matrix);\r\n\r\n  private _recalculate() {\r\n    this._rotation = this.matrix.getRotation();\r\n    this._dirty = false;\r\n  }\r\n\r\n  public getGlobalMatrix(): Matrix {\r\n    if (!this.parent) {\r\n      return this.matrix;\r\n    } else {\r\n      return this.parent.getGlobalMatrix().multiply(this.matrix);\r\n    }\r\n  }\r\n\r\n  public getGlobalTransform(): Transform {\r\n    return {\r\n      pos: this.globalPos,\r\n      scale: this.globalScale,\r\n      rotation: this.globalRotation,\r\n      z: this.z,\r\n      coordPlane: this.coordPlane\r\n    };\r\n  }\r\n\r\n  public get parent(): TransformComponent | null {\r\n    return this?.owner?.parent?.get(TransformComponent);\r\n  }\r\n\r\n  /**\r\n   * The [[CoordPlane|coordinate plane|]] for this transform for the entity.\r\n   */\r\n  public coordPlane = CoordPlane.World;\r\n\r\n  /**\r\n   * Observable that notifies when the position changes\r\n   */\r\n  public posChanged$ = new Observable<Vector>();\r\n  /**\r\n   * The current position of the entity in world space or in screen space depending on the the [[CoordPlane|coordinate plane]].\r\n   *\r\n   * If a parent entity exists coordinates are local to the parent.\r\n   */\r\n  public get pos(): Vector {\r\n    if (this._dirty) {\r\n      this._recalculate();\r\n    }\r\n    return this._position;\r\n  }\r\n\r\n  public set pos(val: Vector) {\r\n    const oldPos = this.matrix.getPosition();\r\n    this.matrix.setPosition(val.x, val.y);\r\n    this._dirty = true;\r\n    if (!oldPos.equals(val)) {\r\n      this.posChanged$.notifyAll(this._position);\r\n    }\r\n  }\r\n\r\n  // Dirty flag check up the chain\r\n  public get dirty(): boolean {\r\n    if (this?.owner?.parent) {\r\n      const parent = this.parent;\r\n      return parent.dirty || this._dirty;\r\n    }\r\n    return this._dirty;\r\n  }\r\n\r\n  /**\r\n   * The current world position calculated\r\n   */\r\n  public get globalPos(): Vector {\r\n    const source = this.getGlobalMatrix();\r\n    return new VectorView({\r\n      getX: () => source.data[MatrixLocations.X],\r\n      getY: () => source.data[MatrixLocations.Y],\r\n      setX: (x) => {\r\n        const oldX = this.matrix.data[MatrixLocations.X];\r\n        if (this.parent) {\r\n          const { x: newX } = this.parent?.getGlobalMatrix().getAffineInverse().multiply(vec(x, source.data[MatrixLocations.Y]));\r\n          this.matrix.data[MatrixLocations.X] = newX;\r\n        } else {\r\n          this.matrix.data[MatrixLocations.X] = x;\r\n        }\r\n        if (oldX !== this.matrix.data[MatrixLocations.X]) {\r\n          this.posChanged$.notifyAll(this._position);\r\n        }\r\n      },\r\n      setY: (y) => {\r\n        const oldY = this.matrix.data[MatrixLocations.Y];\r\n        if (this.parent) {\r\n          const { y: newY } = this.parent?.getGlobalMatrix().getAffineInverse().multiply(vec(source.data[MatrixLocations.X], y));\r\n          this.matrix.data[MatrixLocations.Y] = newY;\r\n        } else {\r\n          this.matrix.data[MatrixLocations.Y] = y;\r\n        }\r\n        if (oldY !== this.matrix.data[MatrixLocations.Y]) {\r\n          this.posChanged$.notifyAll(this._position);\r\n        }\r\n      }\r\n    });\r\n  }\r\n\r\n  public set globalPos(val: Vector) {\r\n    const oldPos = this.pos;\r\n    const parentTransform = this.parent;\r\n    if (!parentTransform) {\r\n      this.pos = val;\r\n    } else {\r\n      this.pos = parentTransform.getGlobalMatrix().getAffineInverse().multiply(val);\r\n    }\r\n    if (!oldPos.equals(val)) {\r\n      this.posChanged$.notifyAll(this.pos);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Observable that emits when the z index changes on this component\r\n   */\r\n  public zIndexChanged$ = new Observable<number>();\r\n  private _z = 0;\r\n\r\n  /**\r\n   * The z-index ordering of the entity, a higher values are drawn on top of lower values.\r\n   * For example z=99 would be drawn on top of z=0.\r\n   */\r\n  public get z(): number {\r\n    return this._z;\r\n  }\r\n\r\n  public set z(val: number) {\r\n    const oldz = this._z;\r\n    this._z = val;\r\n    if (oldz !== val) {\r\n      this.zIndexChanged$.notifyAll(val);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * The rotation of the entity in radians. For example `Math.PI` radians is the same as 180 degrees.\r\n   */\r\n  public get rotation(): number {\r\n    if (this._dirty) {\r\n      this._recalculate();\r\n    }\r\n    return this._rotation;\r\n  }\r\n\r\n  public set rotation(val: number) {\r\n    this.matrix.setRotation(val);\r\n    this._dirty = true;\r\n  }\r\n\r\n  public get globalRotation(): number {\r\n    return this.getGlobalMatrix().getRotation();\r\n  }\r\n\r\n  public set globalRotation(val: number) {\r\n    const parentTransform = this.parent;\r\n    if (!parentTransform) {\r\n      this.rotation = val;\r\n    } else {\r\n      this.rotation = val - parentTransform.globalRotation;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * The scale of the entity.\r\n   */\r\n  public get scale(): Vector {\r\n    if (this._dirty) {\r\n      this._recalculate();\r\n    }\r\n    return this._scale;\r\n  }\r\n\r\n  public set scale(val: Vector) {\r\n    this.matrix.setScale(val);\r\n    this._dirty = true;\r\n  }\r\n\r\n  public get globalScale(): Vector {\r\n    const source = this.getGlobalMatrix();\r\n    return new VectorView({\r\n      getX: () => source.getScaleX(),\r\n      getY: () => source.getScaleY(),\r\n      setX: (x) => {\r\n        if (this.parent) {\r\n          const globalScaleX = this.parent.globalScale.x;\r\n          this.matrix.setScaleX(x / globalScaleX);\r\n        } else {\r\n          this.matrix.setScaleX(x);\r\n        }\r\n      },\r\n      setY: (y) => {\r\n        if (this.parent) {\r\n          const globalScaleY = this.parent.globalScale.y;\r\n          this.matrix.setScaleY(y / globalScaleY);\r\n        } else {\r\n          this.matrix.setScaleY(y);\r\n        }\r\n      }\r\n    });\r\n  }\r\n\r\n  public set globalScale(val: Vector) {\r\n    const parentTransform = this.parent;\r\n    if (!parentTransform) {\r\n      this.scale = val;\r\n    } else {\r\n      this.scale = vec(val.x / parentTransform.globalScale.x, val.y / parentTransform.globalScale.y);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Apply the transform to a point\r\n   * @param point\r\n   */\r\n  public apply(point: Vector): Vector {\r\n    return this.matrix.multiply(point);\r\n  }\r\n\r\n  /**\r\n   * Apply the inverse transform to a point\r\n   * @param point\r\n   */\r\n  public applyInverse(point: Vector): Vector {\r\n    return this.matrix.getAffineInverse().multiply(point);\r\n  }\r\n}\r\n","import { Vector } from '../../Math/vector';\r\nimport { Component } from '../Component';\r\n\r\nexport interface Motion {\r\n  /**\r\n   * The velocity of an entity in pixels per second\r\n   */\r\n  vel: Vector;\r\n\r\n  /**\r\n   * The acceleration of entity in pixels per second^2\r\n   */\r\n  acc: Vector;\r\n\r\n  /**\r\n   * The scale rate of change in scale units per second\r\n   */\r\n  scaleFactor: Vector;\r\n\r\n  /**\r\n   * The angular velocity which is how quickly the entity is rotating in radians per second\r\n   */\r\n  angularVelocity: number;\r\n\r\n  /**\r\n   * The amount of torque applied to the entity, angular acceleration is torque * inertia\r\n   */\r\n  torque: number;\r\n\r\n  /**\r\n   * Inertia can be thought of as the resistance to motion\r\n   */\r\n  inertia: number;\r\n}\r\n\r\nexport class MotionComponent extends Component<'ex.motion'> {\r\n  public readonly type = 'ex.motion';\r\n\r\n  /**\r\n   * The velocity of an entity in pixels per second\r\n   */\r\n  public vel: Vector = Vector.Zero;\r\n\r\n  /**\r\n   * The acceleration of entity in pixels per second^2\r\n   */\r\n  public acc: Vector = Vector.Zero;\r\n\r\n  /**\r\n   * The scale rate of change in scale units per second\r\n   */\r\n  public scaleFactor: Vector = Vector.Zero;\r\n\r\n  /**\r\n   * The angular velocity which is how quickly the entity is rotating in radians per second\r\n   */\r\n  public angularVelocity = 0;\r\n\r\n  /**\r\n   * The amount of torque applied to the entity, angular acceleration is torque * inertia\r\n   */\r\n  public torque: number = 0;\r\n\r\n  /**\r\n   * Inertia can be thought of as the resistance to motion\r\n   */\r\n  public inertia: number = 1;\r\n}\r\n","/**\r\n * CollisionGroups indicate like members that do not collide with each other. Use [[CollisionGroupManager]] to create [[CollisionGroup]]s\r\n *\r\n * For example:\r\n *\r\n * Players have collision group \"player\"\r\n *\r\n * ![Player Collision Group](/assets/images/docs/CollisionGroupsPlayer.png)\r\n *\r\n * Enemies have collision group \"enemy\"\r\n *\r\n * ![Enemy Collision Group](/assets/images/docs/CollisionGroupsEnemy.png)\r\n *\r\n * Blocks have collision group \"ground\"\r\n *\r\n * ![Ground collision group](/assets/images/docs/CollisionGroupsGround.png)\r\n *\r\n * Players don't collide with each other, but enemies and blocks. Likewise, enemies don't collide with each other but collide\r\n * with players and blocks.\r\n *\r\n * This is done with bitmasking, see the following pseudo-code\r\n *\r\n * PlayerGroup = `0b001`\r\n * PlayerGroupMask = `0b110`\r\n *\r\n * EnemyGroup = `0b010`\r\n * EnemyGroupMask = `0b101`\r\n *\r\n * BlockGroup = `0b100`\r\n * BlockGroupMask = `0b011`\r\n *\r\n * Should Players collide? No because the bitwise mask evaluates to 0\r\n * `(player1.group & player2.mask) === 0`\r\n * `(0b001 & 0b110) === 0`\r\n *\r\n * Should Players and Enemies collide? Yes because the bitwise mask is non-zero\r\n * `(player1.group & enemy1.mask) === 1`\r\n * `(0b001 & 0b101) === 1`\r\n *\r\n * Should Players and Blocks collide? Yes because the bitwise mask is non-zero\r\n * `(player1.group & blocks1.mask) === 1`\r\n * `(0b001 & 0b011) === 1`\r\n */\r\nexport class CollisionGroup {\r\n  /**\r\n   * The `All` [[CollisionGroup]] is a special group that collides with all other groups including itself,\r\n   * it is the default collision group on colliders.\r\n   */\r\n  public static All = new CollisionGroup('Collide with all groups', -1, -1);\r\n\r\n  private _name: string;\r\n  private _category: number;\r\n  private _mask: number;\r\n\r\n  /**\r\n   * STOP!!** It is preferred that [[CollisionGroupManager.create]] is used to create collision groups\r\n   *  unless you know how to construct the proper bitmasks. See https://github.com/excaliburjs/Excalibur/issues/1091 for more info.\r\n   * @param name Name of the collision group\r\n   * @param category 32 bit category for the group, should be a unique power of 2. For example `0b001` or `0b010`\r\n   * @param mask 32 bit mask of category, or `~category` generally. For a category of `0b001`, the mask would be `0b110`\r\n   */\r\n  constructor(name: string, category: number, mask: number) {\r\n    this._name = name;\r\n    this._category = category;\r\n    this._mask = mask;\r\n  }\r\n\r\n  /**\r\n   * Get the name of the collision group\r\n   */\r\n  public get name() {\r\n    return this._name;\r\n  }\r\n\r\n  /**\r\n   * Get the category of the collision group, a 32 bit number which should be a unique power of 2\r\n   */\r\n  public get category() {\r\n    return this._category;\r\n  }\r\n\r\n  /**\r\n   * Get the mask for this collision group\r\n   */\r\n  public get mask() {\r\n    return this._mask;\r\n  }\r\n\r\n  /**\r\n   * Evaluates whether 2 collision groups can collide\r\n   * @param other  CollisionGroup\r\n   */\r\n  public canCollide(other: CollisionGroup): boolean {\r\n    return (this.category & other.mask) !== 0 && (other.category & this.mask) !== 0;\r\n  }\r\n\r\n  /**\r\n   * Inverts the collision group. For example, if before the group specified \"players\",\r\n   * inverting would specify all groups except players\r\n   * @returns CollisionGroup\r\n   */\r\n  public invert(): CollisionGroup {\r\n    return new CollisionGroup('~(' + this.name + ')', ~this.category, ~this.mask);\r\n  }\r\n\r\n  /**\r\n   * Combine collision groups with each other. The new group includes all of the previous groups.\r\n   *\r\n   * @param collisionGroups\r\n   */\r\n  public static combine(collisionGroups: CollisionGroup[]) {\r\n    const combinedName = collisionGroups.map((c) => c.name).join('+');\r\n    const combinedCategory = collisionGroups.reduce((current, g) => g.category | current, 0b0);\r\n    const combinedMask = ~combinedCategory;\r\n\r\n    return new CollisionGroup(combinedName, combinedCategory, combinedMask);\r\n  }\r\n\r\n  /**\r\n   * Creates a collision group that collides with the listed groups\r\n   * @param collisionGroups\r\n   */\r\n  public static collidesWith(collisionGroups: CollisionGroup[]) {\r\n    return CollisionGroup.combine(collisionGroups).invert();\r\n  }\r\n}\r\n","import { CollisionContact } from './CollisionContact';\r\nimport { CollisionType } from '../CollisionType';\r\nimport { BodyComponent } from '../BodyComponent';\r\nimport { Id } from '../../Id';\r\nimport { Collider } from '../Colliders/Collider';\r\n\r\n/**\r\n * Models a potential collision between 2 colliders\r\n */\r\nexport class Pair {\r\n  public id: string = null;\r\n  constructor(public colliderA: Collider, public colliderB: Collider) {\r\n    this.id = Pair.calculatePairHash(colliderA.id, colliderB.id);\r\n  }\r\n\r\n  /**\r\n   * Returns whether a it is allowed for 2 colliders in a Pair to collide\r\n   * @param colliderA\r\n   * @param colliderB\r\n   */\r\n  public static canCollide(colliderA: Collider, colliderB: Collider) {\r\n    const bodyA = colliderA?.owner?.get(BodyComponent);\r\n    const bodyB = colliderB?.owner?.get(BodyComponent);\r\n\r\n    // Prevent self collision\r\n    if (colliderA.id === colliderB.id) {\r\n      return false;\r\n    }\r\n\r\n    // Colliders with the same owner do not collide (composite colliders)\r\n    if (colliderA.owner &&\r\n        colliderB.owner &&\r\n        colliderA.owner.id === colliderB.owner.id) {\r\n      return false;\r\n    }\r\n\r\n    // if the pair has a member with zero dimension don't collide\r\n    if (colliderA.localBounds.hasZeroDimensions() || colliderB.localBounds.hasZeroDimensions()) {\r\n      return false;\r\n    }\r\n\r\n    // Body's needed for collision in the current state\r\n    // TODO can we collide without a body?\r\n    if (!bodyA || !bodyB) {\r\n      return false;\r\n    }\r\n\r\n    // If both are in the same collision group short circuit\r\n    if (!bodyA.group.canCollide(bodyB.group)) {\r\n      return false;\r\n    }\r\n\r\n    // if both are fixed short circuit\r\n    if (bodyA.collisionType === CollisionType.Fixed && bodyB.collisionType === CollisionType.Fixed) {\r\n      return false;\r\n    }\r\n\r\n    // if the either is prevent collision short circuit\r\n    if (bodyB.collisionType === CollisionType.PreventCollision || bodyA.collisionType === CollisionType.PreventCollision) {\r\n      return false;\r\n    }\r\n\r\n    // if either is dead short circuit\r\n    if (!bodyA.active || !bodyB.active) {\r\n      return false;\r\n    }\r\n\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * Returns whether or not it is possible for the pairs to collide\r\n   */\r\n  public get canCollide(): boolean {\r\n    const colliderA = this.colliderA;\r\n    const colliderB = this.colliderB;\r\n    return Pair.canCollide(colliderA, colliderB);\r\n  }\r\n\r\n  /**\r\n   * Runs the collision intersection logic on the members of this pair\r\n   */\r\n  public collide(): CollisionContact[] {\r\n    return this.colliderA.collide(this.colliderB);\r\n  }\r\n\r\n  /**\r\n   * Check if the collider is part of the pair\r\n   * @param collider\r\n   */\r\n  public hasCollider(collider: Collider) {\r\n    return collider === this.colliderA || collider === this.colliderB;\r\n  }\r\n\r\n  /**\r\n   * Calculates the unique pair hash id for this collision pair (owning id)\r\n   */\r\n  public static calculatePairHash(idA: Id<'collider'>, idB: Id<'collider'>): string {\r\n    if (idA.value < idB.value) {\r\n      return `#${idA.value}+${idB.value}`;\r\n    } else {\r\n      return `#${idB.value}+${idA.value}`;\r\n    }\r\n  }\r\n}\r\n","/**\r\n * A 1 dimensional projection on an axis, used to test overlaps\r\n */\r\n\r\nexport class Projection {\r\n  constructor(public min: number, public max: number) {}\r\n  public overlaps(projection: Projection): boolean {\r\n    return this.max > projection.min && projection.max > this.min;\r\n  }\r\n\r\n  public getOverlap(projection: Projection): number {\r\n    if (this.overlaps(projection)) {\r\n      if (this.max > projection.max) {\r\n        return projection.max - this.min;\r\n      } else {\r\n        return this.max - projection.min;\r\n      }\r\n    }\r\n    return 0;\r\n  }\r\n}\r\n","import { Physics } from '../Physics';\r\nimport { BoundingBox } from '../BoundingBox';\r\n\r\nimport { Ray } from '../../Math/ray';\r\nimport { Logger } from '../../Util/Log';\r\nimport { Id } from '../../Id';\r\nimport { Entity } from '../../EntityComponentSystem/Entity';\r\nimport { BodyComponent } from '../BodyComponent';\r\nimport { Color, ExcaliburGraphicsContext } from '../..';\r\n\r\n/**\r\n * Dynamic Tree Node used for tracking bounds within the tree\r\n */\r\nexport class TreeNode<T> {\r\n  public left: TreeNode<T>;\r\n  public right: TreeNode<T>;\r\n  public bounds: BoundingBox;\r\n  public height: number;\r\n  public data: T;\r\n  constructor(public parent?: TreeNode<T>) {\r\n    this.parent = parent || null;\r\n    this.data = null;\r\n    this.bounds = new BoundingBox();\r\n    this.left = null;\r\n    this.right = null;\r\n    this.height = 0;\r\n  }\r\n\r\n  public isLeaf(): boolean {\r\n    return !this.left && !this.right;\r\n  }\r\n}\r\n\r\nexport interface ColliderProxy<T> {\r\n  id: Id<'collider'>;\r\n  owner: T;\r\n  bounds: BoundingBox;\r\n}\r\n\r\n/**\r\n * The DynamicTrees provides a spatial partitioning data structure for quickly querying for overlapping bounding boxes for\r\n * all tracked bodies. The worst case performance of this is O(n*log(n)) where n is the number of bodies in the tree.\r\n *\r\n * Internally the bounding boxes are organized as a balanced binary tree of bounding boxes, where the leaf nodes are tracked bodies.\r\n * Every non-leaf node is a bounding box that contains child bounding boxes.\r\n */\r\nexport class DynamicTree<T extends ColliderProxy<Entity>> {\r\n  public root: TreeNode<T>;\r\n  public nodes: { [key: number]: TreeNode<T> };\r\n  constructor(public worldBounds: BoundingBox = new BoundingBox(-Number.MAX_VALUE, -Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE)) {\r\n    this.root = null;\r\n    this.nodes = {};\r\n  }\r\n\r\n  /**\r\n   * Inserts a node into the dynamic tree\r\n   */\r\n  private _insert(leaf: TreeNode<T>): void {\r\n    // If there are no nodes in the tree, make this the root leaf\r\n    if (this.root === null) {\r\n      this.root = leaf;\r\n      this.root.parent = null;\r\n      return;\r\n    }\r\n\r\n    // Search the tree for a node that is not a leaf and find the best place to insert\r\n    const leafAABB = leaf.bounds;\r\n    let currentRoot = this.root;\r\n    while (!currentRoot.isLeaf()) {\r\n      const left = currentRoot.left;\r\n      const right = currentRoot.right;\r\n\r\n      const area = currentRoot.bounds.getPerimeter();\r\n      const combinedAABB = currentRoot.bounds.combine(leafAABB);\r\n      const combinedArea = combinedAABB.getPerimeter();\r\n\r\n      // Calculate cost heuristic for creating a new parent and leaf\r\n      const cost = 2 * combinedArea;\r\n\r\n      // Minimum cost of pushing the leaf down the tree\r\n      const inheritanceCost = 2 * (combinedArea - area);\r\n\r\n      // Cost of descending\r\n      let leftCost = 0;\r\n      const leftCombined = leafAABB.combine(left.bounds);\r\n      let newArea;\r\n      let oldArea;\r\n      if (left.isLeaf()) {\r\n        leftCost = leftCombined.getPerimeter() + inheritanceCost;\r\n      } else {\r\n        oldArea = left.bounds.getPerimeter();\r\n        newArea = leftCombined.getPerimeter();\r\n        leftCost = newArea - oldArea + inheritanceCost;\r\n      }\r\n\r\n      let rightCost = 0;\r\n      const rightCombined = leafAABB.combine(right.bounds);\r\n      if (right.isLeaf()) {\r\n        rightCost = rightCombined.getPerimeter() + inheritanceCost;\r\n      } else {\r\n        oldArea = right.bounds.getPerimeter();\r\n        newArea = rightCombined.getPerimeter();\r\n        rightCost = newArea - oldArea + inheritanceCost;\r\n      }\r\n\r\n      // cost is acceptable\r\n      if (cost < leftCost && cost < rightCost) {\r\n        break;\r\n      }\r\n\r\n      // Descend to the depths\r\n      if (leftCost < rightCost) {\r\n        currentRoot = left;\r\n      } else {\r\n        currentRoot = right;\r\n      }\r\n    }\r\n\r\n    // Create the new parent node and insert into the tree\r\n    const oldParent = currentRoot.parent;\r\n    const newParent = new TreeNode(oldParent);\r\n    newParent.bounds = leafAABB.combine(currentRoot.bounds);\r\n    newParent.height = currentRoot.height + 1;\r\n\r\n    if (oldParent !== null) {\r\n      // The sibling node was not the root\r\n      if (oldParent.left === currentRoot) {\r\n        oldParent.left = newParent;\r\n      } else {\r\n        oldParent.right = newParent;\r\n      }\r\n\r\n      newParent.left = currentRoot;\r\n      newParent.right = leaf;\r\n\r\n      currentRoot.parent = newParent;\r\n      leaf.parent = newParent;\r\n    } else {\r\n      // The sibling node was the root\r\n      newParent.left = currentRoot;\r\n      newParent.right = leaf;\r\n\r\n      currentRoot.parent = newParent;\r\n      leaf.parent = newParent;\r\n      this.root = newParent;\r\n    }\r\n\r\n    // Walk up the tree fixing heights and AABBs\r\n    let currentNode = leaf.parent;\r\n    while (currentNode) {\r\n      currentNode = this._balance(currentNode);\r\n\r\n      if (!currentNode.left) {\r\n        throw new Error('Parent of current leaf cannot have a null left child' + currentNode);\r\n      }\r\n      if (!currentNode.right) {\r\n        throw new Error('Parent of current leaf cannot have a null right child' + currentNode);\r\n      }\r\n\r\n      currentNode.height = 1 + Math.max(currentNode.left.height, currentNode.right.height);\r\n      currentNode.bounds = currentNode.left.bounds.combine(currentNode.right.bounds);\r\n\r\n      currentNode = currentNode.parent;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Removes a node from the dynamic tree\r\n   */\r\n  private _remove(leaf: TreeNode<T>) {\r\n    if (leaf === this.root) {\r\n      this.root = null;\r\n      return;\r\n    }\r\n\r\n    const parent = leaf.parent;\r\n    const grandParent = parent.parent;\r\n    let sibling: TreeNode<T>;\r\n    if (parent.left === leaf) {\r\n      sibling = parent.right;\r\n    } else {\r\n      sibling = parent.left;\r\n    }\r\n\r\n    if (grandParent) {\r\n      if (grandParent.left === parent) {\r\n        grandParent.left = sibling;\r\n      } else {\r\n        grandParent.right = sibling;\r\n      }\r\n      sibling.parent = grandParent;\r\n\r\n      let currentNode = grandParent;\r\n      while (currentNode) {\r\n        currentNode = this._balance(currentNode);\r\n        currentNode.bounds = currentNode.left.bounds.combine(currentNode.right.bounds);\r\n        currentNode.height = 1 + Math.max(currentNode.left.height, currentNode.right.height);\r\n\r\n        currentNode = currentNode.parent;\r\n      }\r\n    } else {\r\n      this.root = sibling;\r\n      sibling.parent = null;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Tracks a body in the dynamic tree\r\n   */\r\n  public trackCollider(collider: T) {\r\n    const node = new TreeNode<T>();\r\n    node.data = collider;\r\n    node.bounds = collider.bounds;\r\n    node.bounds.left -= 2;\r\n    node.bounds.top -= 2;\r\n    node.bounds.right += 2;\r\n    node.bounds.bottom += 2;\r\n    this.nodes[collider.id.value] = node;\r\n    this._insert(node);\r\n  }\r\n\r\n  /**\r\n   * Updates the dynamic tree given the current bounds of each body being tracked\r\n   */\r\n  public updateCollider(collider: T) {\r\n    const node = this.nodes[collider.id.value];\r\n    if (!node) {\r\n      return false;\r\n    }\r\n    const b = collider.bounds;\r\n\r\n    // if the body is outside the world no longer update it\r\n    if (!this.worldBounds.contains(b)) {\r\n      Logger.getInstance().warn(\r\n        'Collider with id ' + collider.id.value + ' is outside the world bounds and will no longer be tracked for physics'\r\n      );\r\n      this.untrackCollider(collider);\r\n      return false;\r\n    }\r\n\r\n    if (node.bounds.contains(b)) {\r\n      return false;\r\n    }\r\n\r\n    this._remove(node);\r\n    b.left -= Physics.boundsPadding;\r\n    b.top -= Physics.boundsPadding;\r\n    b.right += Physics.boundsPadding;\r\n    b.bottom += Physics.boundsPadding;\r\n\r\n    // THIS IS CAUSING UNECESSARY CHECKS\r\n    if (collider.owner) {\r\n      const body = collider.owner?.get(BodyComponent);\r\n      if (body) {\r\n        const multdx = ((body.vel.x * 32) / 1000) * Physics.dynamicTreeVelocityMultiplier;\r\n        const multdy = ((body.vel.y * 32) / 1000) * Physics.dynamicTreeVelocityMultiplier;\r\n\r\n        if (multdx < 0) {\r\n          b.left += multdx;\r\n        } else {\r\n          b.right += multdx;\r\n        }\r\n\r\n        if (multdy < 0) {\r\n          b.top += multdy;\r\n        } else {\r\n          b.bottom += multdy;\r\n        }\r\n      }\r\n    }\r\n\r\n    node.bounds = b;\r\n    this._insert(node);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * Untracks a body from the dynamic tree\r\n   */\r\n  public untrackCollider(collider: T) {\r\n    const node = this.nodes[collider.id.value];\r\n    if (!node) {\r\n      return;\r\n    }\r\n    this._remove(node);\r\n    this.nodes[collider.id.value] = null;\r\n    delete this.nodes[collider.id.value];\r\n  }\r\n\r\n  /**\r\n   * Balances the tree about a node\r\n   */\r\n  private _balance(node: TreeNode<T>) {\r\n    if (node === null) {\r\n      throw new Error('Cannot balance at null node');\r\n    }\r\n\r\n    if (node.isLeaf() || node.height < 2) {\r\n      return node;\r\n    }\r\n\r\n    const left = node.left;\r\n    const right = node.right;\r\n\r\n    const a = node;\r\n    const b = left;\r\n    const c = right;\r\n    const d = left.left;\r\n    const e = left.right;\r\n    const f = right.left;\r\n    const g = right.right;\r\n\r\n    const balance = c.height - b.height;\r\n    // Rotate c node up\r\n    if (balance > 1) {\r\n      // Swap the right node with it's parent\r\n      c.left = a;\r\n      c.parent = a.parent;\r\n      a.parent = c;\r\n\r\n      // The original node's old parent should point to the right node\r\n      // this is mega confusing\r\n      if (c.parent) {\r\n        if (c.parent.left === a) {\r\n          c.parent.left = c;\r\n        } else {\r\n          c.parent.right = c;\r\n        }\r\n      } else {\r\n        this.root = c;\r\n      }\r\n\r\n      // Rotate\r\n      if (f.height > g.height) {\r\n        c.right = f;\r\n        a.right = g;\r\n        g.parent = a;\r\n\r\n        a.bounds = b.bounds.combine(g.bounds);\r\n        c.bounds = a.bounds.combine(f.bounds);\r\n\r\n        a.height = 1 + Math.max(b.height, g.height);\r\n        c.height = 1 + Math.max(a.height, f.height);\r\n      } else {\r\n        c.right = g;\r\n        a.right = f;\r\n        f.parent = a;\r\n\r\n        a.bounds = b.bounds.combine(f.bounds);\r\n        c.bounds = a.bounds.combine(g.bounds);\r\n\r\n        a.height = 1 + Math.max(b.height, f.height);\r\n        c.height = 1 + Math.max(a.height, g.height);\r\n      }\r\n\r\n      return c;\r\n    }\r\n    // Rotate left node up\r\n    if (balance < -1) {\r\n      // swap\r\n      b.left = a;\r\n      b.parent = a.parent;\r\n      a.parent = b;\r\n\r\n      // node's old parent should point to b\r\n      if (b.parent) {\r\n        if (b.parent.left === a) {\r\n          b.parent.left = b;\r\n        } else {\r\n          if (b.parent.right !== a) {\r\n            throw 'Error rotating Dynamic Tree';\r\n          }\r\n          b.parent.right = b;\r\n        }\r\n      } else {\r\n        this.root = b;\r\n      }\r\n\r\n      // rotate\r\n      if (d.height > e.height) {\r\n        b.right = d;\r\n        a.left = e;\r\n        e.parent = a;\r\n\r\n        a.bounds = c.bounds.combine(e.bounds);\r\n        b.bounds = a.bounds.combine(d.bounds);\r\n\r\n        a.height = 1 + Math.max(c.height, e.height);\r\n        b.height = 1 + Math.max(a.height, d.height);\r\n      } else {\r\n        b.right = e;\r\n        a.left = d;\r\n        d.parent = a;\r\n\r\n        a.bounds = c.bounds.combine(d.bounds);\r\n        b.bounds = a.bounds.combine(e.bounds);\r\n\r\n        a.height = 1 + Math.max(c.height, d.height);\r\n        b.height = 1 + Math.max(a.height, e.height);\r\n      }\r\n      return b;\r\n    }\r\n\r\n    return node;\r\n  }\r\n\r\n  /**\r\n   * Returns the internal height of the tree, shorter trees are better. Performance drops as the tree grows\r\n   */\r\n  public getHeight(): number {\r\n    if (this.root === null) {\r\n      return 0;\r\n    }\r\n    return this.root.height;\r\n  }\r\n\r\n  /**\r\n   * Queries the Dynamic Axis Aligned Tree for bodies that could be colliding with the provided body.\r\n   *\r\n   * In the query callback, it will be passed a potential collider. Returning true from this callback indicates\r\n   * that you are complete with your query and you do not want to continue. Returning false will continue searching\r\n   * the tree until all possible colliders have been returned.\r\n   */\r\n  public query(collider: T, callback: (other: T) => boolean): void {\r\n    const bounds = collider.bounds;\r\n    const helper = (currentNode: TreeNode<T>): boolean => {\r\n      if (currentNode && currentNode.bounds.overlaps(bounds)) {\r\n        if (currentNode.isLeaf() && currentNode.data !== collider) {\r\n          if (callback.call(collider, currentNode.data)) {\r\n            return true;\r\n          }\r\n        } else {\r\n          return helper(currentNode.left) || helper(currentNode.right);\r\n        }\r\n      }\r\n      return false;\r\n    };\r\n    helper(this.root);\r\n  }\r\n\r\n  /**\r\n   * Queries the Dynamic Axis Aligned Tree for bodies that could be intersecting. By default the raycast query uses an infinitely\r\n   * long ray to test the tree specified by `max`.\r\n   *\r\n   * In the query callback, it will be passed a potential body that intersects with the raycast. Returning true from this\r\n   * callback indicates that your are complete with your query and do not want to continue. Return false will continue searching\r\n   * the tree until all possible bodies that would intersect with the ray have been returned.\r\n   */\r\n  public rayCastQuery(ray: Ray, max: number = Infinity, callback: (other: T) => boolean): void {\r\n    const helper = (currentNode: TreeNode<T>): boolean => {\r\n      if (currentNode && currentNode.bounds.rayCast(ray, max)) {\r\n        if (currentNode.isLeaf()) {\r\n          if (callback.call(ray, currentNode.data)) {\r\n            // ray hit a leaf! return the body\r\n            return true;\r\n          }\r\n        } else {\r\n          // ray hit but not at a leaf, recurse deeper\r\n          return helper(currentNode.left) || helper(currentNode.right);\r\n        }\r\n      }\r\n      return false; // ray missed\r\n    };\r\n    helper(this.root);\r\n  }\r\n\r\n  public getNodes(): TreeNode<T>[] {\r\n    const helper = (currentNode: TreeNode<T>): TreeNode<T>[] => {\r\n      if (currentNode) {\r\n        return [currentNode].concat(helper(currentNode.left), helper(currentNode.right));\r\n      } else {\r\n        return [];\r\n      }\r\n    };\r\n    return helper(this.root);\r\n  }\r\n\r\n  public debug(ex: ExcaliburGraphicsContext) {\r\n    // draw all the nodes in the Dynamic Tree\r\n    const helper = (currentNode: TreeNode<T>) => {\r\n      if (currentNode) {\r\n        if (currentNode.isLeaf()) {\r\n          currentNode.bounds.draw(ex, Color.Green);\r\n        } else {\r\n          currentNode.bounds.draw(ex, Color.White);\r\n        }\r\n\r\n        if (currentNode.left) {\r\n          helper(currentNode.left);\r\n        }\r\n        if (currentNode.right) {\r\n          helper(currentNode.right);\r\n        }\r\n      }\r\n    };\r\n\r\n    helper(this.root);\r\n  }\r\n}\r\n","import { LineSegment } from './line-segment';\r\nimport { Vector } from './vector';\r\n\r\n/**\r\n * A 2D ray that can be cast into the scene to do collision detection\r\n */\r\n\r\nexport class Ray {\r\n  public pos: Vector;\r\n  public dir: Vector;\r\n\r\n  /**\r\n   * @param pos The starting position for the ray\r\n   * @param dir The vector indicating the direction of the ray\r\n   */\r\n  constructor(pos: Vector, dir: Vector) {\r\n    this.pos = pos;\r\n    this.dir = dir.normalize();\r\n  }\r\n\r\n  /**\r\n   * Tests a whether this ray intersects with a line segment. Returns a number greater than or equal to 0 on success.\r\n   * This number indicates the mathematical intersection time.\r\n   * @param line  The line to test\r\n   */\r\n  public intersect(line: LineSegment): number {\r\n    const numerator = line.begin.sub(this.pos);\r\n\r\n    // Test is line and ray are parallel and non intersecting\r\n    if (this.dir.cross(line.getSlope()) === 0 && numerator.cross(this.dir) !== 0) {\r\n      return -1;\r\n    }\r\n\r\n    // Lines are parallel\r\n    const divisor = this.dir.cross(line.getSlope());\r\n    if (divisor === 0) {\r\n      return -1;\r\n    }\r\n\r\n    const t = numerator.cross(line.getSlope()) / divisor;\r\n\r\n    if (t >= 0) {\r\n      const u = numerator.cross(this.dir) / divisor / line.getLength();\r\n      if (u >= 0 && u <= 1) {\r\n        return t;\r\n      }\r\n    }\r\n    return -1;\r\n  }\r\n\r\n  public intersectPoint(line: LineSegment): Vector {\r\n    const time = this.intersect(line);\r\n    if (time < 0) {\r\n      return null;\r\n    }\r\n    return this.getPoint(time);\r\n  }\r\n\r\n  /**\r\n   * Returns the point of intersection given the intersection time\r\n   */\r\n  public getPoint(time: number): Vector {\r\n    return this.pos.add(this.dir.scale(time));\r\n  }\r\n}\r\n","import { Physics } from '../Physics';\r\nimport { CollisionProcessor } from './CollisionProcessor';\r\nimport { DynamicTree } from './DynamicTree';\r\nimport { Pair } from './Pair';\r\n\r\nimport { Vector } from '../../Math/vector';\r\nimport { Ray } from '../../Math/ray';\r\nimport { FrameStats } from '../../Debug';\r\nimport { Logger } from '../../Util/Log';\r\nimport { CollisionType } from '../CollisionType';\r\nimport { Collider } from '../Colliders/Collider';\r\nimport { CollisionContact } from '../Detection/CollisionContact';\r\nimport { BodyComponent } from '../BodyComponent';\r\nimport { CompositeCollider } from '../Colliders/CompositeCollider';\r\nimport { ExcaliburGraphicsContext } from '../..';\r\n\r\n/**\r\n * Responsible for performing the collision broadphase (locating potential collisions) and\r\n * the narrowphase (actual collision contacts)\r\n */\r\nexport class DynamicTreeCollisionProcessor implements CollisionProcessor {\r\n  private _dynamicCollisionTree = new DynamicTree<Collider>();\r\n  private _pairs = new Set<string>();\r\n\r\n  private _collisionPairCache: Pair[] = [];\r\n  private _colliders: Collider[] = [];\r\n\r\n  public getColliders(): readonly Collider[] {\r\n    return this._colliders;\r\n  }\r\n\r\n  /**\r\n   * Tracks a physics body for collisions\r\n   */\r\n  public track(target: Collider): void {\r\n    if (!target) {\r\n      Logger.getInstance().warn('Cannot track null collider');\r\n      return;\r\n    }\r\n    if (target instanceof CompositeCollider) {\r\n      const colliders = target.getColliders();\r\n      for (const c of colliders) {\r\n        c.owner = target.owner;\r\n        this._colliders.push(c);\r\n        this._dynamicCollisionTree.trackCollider(c);\r\n      }\r\n    } else {\r\n      this._colliders.push(target);\r\n      this._dynamicCollisionTree.trackCollider(target);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Untracks a physics body\r\n   */\r\n  public untrack(target: Collider): void {\r\n    if (!target) {\r\n      Logger.getInstance().warn('Cannot untrack a null collider');\r\n      return;\r\n    }\r\n\r\n    if (target instanceof CompositeCollider) {\r\n      const colliders = target.getColliders();\r\n      for (const c of colliders) {\r\n        const index = this._colliders.indexOf(c);\r\n        if (index !== -1) {\r\n          this._colliders.splice(index, 1);\r\n        }\r\n        this._dynamicCollisionTree.untrackCollider(c);\r\n      }\r\n    } else {\r\n      const index = this._colliders.indexOf(target);\r\n      if (index !== -1) {\r\n        this._colliders.splice(index, 1);\r\n      }\r\n      this._dynamicCollisionTree.untrackCollider(target);\r\n    }\r\n  }\r\n\r\n  private _pairExists(colliderA: Collider, colliderB: Collider) {\r\n    // if the collision pair has been calculated already short circuit\r\n    const hash = Pair.calculatePairHash(colliderA.id, colliderB.id);\r\n    return this._pairs.has(hash);\r\n  }\r\n\r\n  /**\r\n   * Detects potential collision pairs in a broadphase approach with the dynamic AABB tree strategy\r\n   */\r\n  public broadphase(targets: Collider[], delta: number, stats?: FrameStats): Pair[] {\r\n    const seconds = delta / 1000;\r\n\r\n    // Retrieve the list of potential colliders, exclude killed, prevented, and self\r\n    const potentialColliders = targets.filter((other) => {\r\n      const body = other.owner?.get(BodyComponent);\r\n      return other.owner?.active && body.collisionType !== CollisionType.PreventCollision;\r\n    });\r\n\r\n    // clear old list of collision pairs\r\n    this._collisionPairCache = [];\r\n    this._pairs.clear();\r\n\r\n    // check for normal collision pairs\r\n    let collider: Collider;\r\n    for (let j = 0, l = potentialColliders.length; j < l; j++) {\r\n      collider = potentialColliders[j];\r\n      // Query the collision tree for potential colliders\r\n      this._dynamicCollisionTree.query(collider, (other: Collider) => {\r\n        if (!this._pairExists(collider, other) && Pair.canCollide(collider, other)) {\r\n          const pair = new Pair(collider, other);\r\n          this._pairs.add(pair.id);\r\n          this._collisionPairCache.push(pair);\r\n        }\r\n        // Always return false, to query whole tree. Returning true in the query method stops searching\r\n        return false;\r\n      });\r\n    }\r\n    if (stats) {\r\n      stats.physics.pairs = this._collisionPairCache.length;\r\n    }\r\n\r\n    // Check dynamic tree for fast moving objects\r\n    // Fast moving objects are those moving at least there smallest bound per frame\r\n    if (Physics.checkForFastBodies) {\r\n      for (const collider of potentialColliders) {\r\n        const body = collider.owner.get(BodyComponent);\r\n        // Skip non-active objects. Does not make sense on other collision types\r\n        if (body.collisionType !== CollisionType.Active) {\r\n          continue;\r\n        }\r\n\r\n        // Maximum travel distance next frame\r\n        const updateDistance =\r\n          body.vel.size * seconds + // velocity term\r\n          body.acc.size * 0.5 * seconds * seconds; // acc term\r\n\r\n        // Find the minimum dimension\r\n        const minDimension = Math.min(collider.bounds.height, collider.bounds.width);\r\n        if (Physics.disableMinimumSpeedForFastBody || updateDistance > minDimension / 2) {\r\n          if (stats) {\r\n            stats.physics.fastBodies++;\r\n          }\r\n\r\n          // start with the oldPos because the integration for actors has already happened\r\n          // objects resting on a surface may be slightly penetrating in the current position\r\n          const updateVec = body.pos.sub(body.oldPos);\r\n          const centerPoint = collider.center;\r\n          const furthestPoint = collider.getFurthestPoint(body.vel);\r\n          const origin: Vector = furthestPoint.sub(updateVec);\r\n\r\n          const ray: Ray = new Ray(origin, body.vel);\r\n\r\n          // back the ray up by -2x surfaceEpsilon to account for fast moving objects starting on the surface\r\n          ray.pos = ray.pos.add(ray.dir.scale(-2 * Physics.surfaceEpsilon));\r\n          let minCollider: Collider;\r\n          let minTranslate: Vector = new Vector(Infinity, Infinity);\r\n          this._dynamicCollisionTree.rayCastQuery(ray, updateDistance + Physics.surfaceEpsilon * 2, (other: Collider) => {\r\n            if (!this._pairExists(collider, other) && Pair.canCollide(collider, other)) {\r\n              const hitPoint = other.rayCast(ray, updateDistance + Physics.surfaceEpsilon * 10);\r\n              if (hitPoint) {\r\n                const translate = hitPoint.sub(origin);\r\n                if (translate.size < minTranslate.size) {\r\n                  minTranslate = translate;\r\n                  minCollider = other;\r\n                }\r\n              }\r\n            }\r\n            return false;\r\n          });\r\n\r\n          if (minCollider && Vector.isValid(minTranslate)) {\r\n            const pair = new Pair(collider, minCollider);\r\n            if (!this._pairs.has(pair.id)) {\r\n              this._pairs.add(pair.id);\r\n              this._collisionPairCache.push(pair);\r\n            }\r\n            // move the fast moving object to the other body\r\n            // need to push into the surface by ex.Physics.surfaceEpsilon\r\n            const shift = centerPoint.sub(furthestPoint);\r\n            body.pos = origin\r\n              .add(shift)\r\n              .add(minTranslate)\r\n              .add(ray.dir.scale(10 * Physics.surfaceEpsilon)); // needed to push the shape slightly into contact\r\n            collider.update(body.transform);\r\n\r\n            if (stats) {\r\n              stats.physics.fastBodyCollisions++;\r\n            }\r\n          }\r\n        }\r\n      }\r\n    }\r\n    // return cache\r\n    return this._collisionPairCache;\r\n  }\r\n\r\n  /**\r\n   * Applies narrow phase on collision pairs to find actual area intersections\r\n   * Adds actual colliding pairs to stats' Frame data\r\n   */\r\n  public narrowphase(pairs: Pair[], stats?: FrameStats): CollisionContact[] {\r\n    let contacts: CollisionContact[] = [];\r\n    for (let i = 0; i < pairs.length; i++) {\r\n      const newContacts = pairs[i].collide();\r\n      contacts = contacts.concat(newContacts);\r\n      if (stats && newContacts.length > 0) {\r\n        for (const c of newContacts) {\r\n          stats.physics.contacts.set(c.id, c);\r\n        }\r\n      }\r\n    }\r\n    if (stats) {\r\n      stats.physics.collisions += contacts.length;\r\n    }\r\n    return contacts;\r\n  }\r\n\r\n  /**\r\n   * Update the dynamic tree positions\r\n   */\r\n  public update(targets: Collider[]): number {\r\n    let updated = 0;\r\n    const len = targets.length;\r\n\r\n    for (let i = 0; i < len; i++) {\r\n      if (this._dynamicCollisionTree.updateCollider(targets[i])) {\r\n        updated++;\r\n      }\r\n    }\r\n    return updated;\r\n  }\r\n\r\n  public debug(ex: ExcaliburGraphicsContext) {\r\n    this._dynamicCollisionTree.debug(ex);\r\n  }\r\n}\r\n","import { Color } from '../../Color';\r\nimport { CollisionContact } from '../Detection/CollisionContact';\r\nimport { BoundingBox } from '../BoundingBox';\r\nimport { Projection } from '../../Math/projection';\r\nimport { LineSegment } from '../../Math/line-segment';\r\nimport { Vector } from '../../Math/vector';\r\nimport { Ray } from '../../Math/ray';\r\nimport { Clonable } from '../../Interfaces/Clonable';\r\nimport { Entity, Transform } from '../../EntityComponentSystem';\r\nimport { createId, Id } from '../../Id';\r\nimport { EventDispatcher } from '../../EventDispatcher';\r\nimport { ExcaliburGraphicsContext } from '../../Graphics/Context/ExcaliburGraphicsContext';\r\n\r\n/**\r\n * A collision collider specifies the geometry that can detect when other collision colliders intersect\r\n * for the purposes of colliding 2 objects in excalibur.\r\n */\r\nexport abstract class Collider implements Clonable<Collider> {\r\n  private static _ID = 0;\r\n  public readonly id: Id<'collider'> = createId('collider', Collider._ID++);\r\n  /**\r\n   * Excalibur uses this to signal to the [[CollisionSystem]] this is part of a composite collider\r\n   * @internal\r\n   * @hidden\r\n   */\r\n  public __compositeColliderId: Id<'collider'> | null = null;\r\n  public events: EventDispatcher<Collider> = new EventDispatcher<Collider>();\r\n\r\n  /**\r\n   * Returns a boolean indicating whether this body collided with\r\n   * or was in stationary contact with\r\n   * the body of the other [[Collider]]\r\n   */\r\n  public touching(other: Collider): boolean {\r\n    const contact = this.collide(other);\r\n\r\n    if (contact) {\r\n      return true;\r\n    }\r\n\r\n    return false;\r\n  }\r\n\r\n  public owner: Entity;\r\n\r\n  /**\r\n   * Pixel offset of the collision collider relative to the collider, by default (0, 0) meaning the collider is positioned\r\n   * on top of the collider.\r\n   */\r\n  offset: Vector;\r\n\r\n  /**\r\n   * Position of the collision collider in world coordinates\r\n   */\r\n  abstract get worldPos(): Vector;\r\n\r\n  /**\r\n   * The center point of the collision collider, for example if the collider is a circle it would be the center.\r\n   */\r\n  abstract get center(): Vector;\r\n\r\n  /**\r\n   * Return the axis-aligned bounding box of the collision collider in world coordinates\r\n   */\r\n  abstract get bounds(): BoundingBox;\r\n\r\n  /**\r\n   * Return the axis-aligned bounding box of the collision collider in local coordinates\r\n   */\r\n  abstract get localBounds(): BoundingBox;\r\n\r\n  /**\r\n   * Return the axes of this particular collider\r\n   */\r\n  abstract get axes(): Vector[];\r\n  /**\r\n   * Find the furthest point on the convex hull of this particular collider in a certain direction.\r\n   */\r\n  abstract getFurthestPoint(direction: Vector): Vector;\r\n\r\n  abstract getInertia(mass: number): number;\r\n\r\n  // All new CollisionShape need to do the following\r\n  // Create a new collision function in the CollisionJumpTable against all the primitives\r\n  // Currently there are 3 primitive collision collider 3! = 6 jump functions\r\n  abstract collide(collider: Collider): CollisionContact[];\r\n\r\n  /**\r\n   * Returns the closest line between the surfaces this collider and another\r\n   * @param collider\r\n   */\r\n  abstract getClosestLineBetween(collider: Collider): LineSegment;\r\n\r\n  /**\r\n   * Return wether the collider contains a point inclusive to it's border\r\n   */\r\n  abstract contains(point: Vector): boolean;\r\n\r\n  /**\r\n   * Return the point on the border of the collision collider that intersects with a ray (if any).\r\n   */\r\n  abstract rayCast(ray: Ray, max?: number): Vector;\r\n\r\n  /**\r\n   * Create a projection of this collider along an axis. Think of this as casting a \"shadow\" along an axis\r\n   */\r\n  abstract project(axis: Vector): Projection;\r\n\r\n  /**\r\n   * Updates collider world space geometry\r\n   */\r\n  abstract update(transform: Transform): void;\r\n\r\n\r\n  abstract debug(ex: ExcaliburGraphicsContext, color: Color): void;\r\n\r\n  abstract clone(): Collider;\r\n}\r\n","import { Util } from '../..';\r\nimport { Pair } from '../Detection/Pair';\r\nimport { Color } from '../../Color';\r\nimport { Transform } from '../../EntityComponentSystem';\r\nimport { ExcaliburGraphicsContext } from '../../Graphics/Context/ExcaliburGraphicsContext';\r\nimport { LineSegment } from '../../Math/line-segment';\r\nimport { Projection } from '../../Math/projection';\r\nimport { Ray } from '../../Math/ray';\r\nimport { Vector } from '../../Math/vector';\r\nimport { BoundingBox } from '../BoundingBox';\r\nimport { CollisionContact } from '../Detection/CollisionContact';\r\nimport { DynamicTree } from '../Detection/DynamicTree';\r\nimport { DynamicTreeCollisionProcessor } from '../Detection/DynamicTreeCollisionProcessor';\r\nimport { Collider } from './Collider';\r\n\r\nexport class CompositeCollider extends Collider {\r\n  private _transform: Transform;\r\n  private _collisionProcessor = new DynamicTreeCollisionProcessor();\r\n  private _dynamicAABBTree = new DynamicTree();\r\n  private _colliders: Collider[] = [];\r\n\r\n  constructor(colliders: Collider[]) {\r\n    super();\r\n    for (const c of colliders) {\r\n      this.addCollider(c);\r\n    }\r\n  }\r\n\r\n  clearColliders() {\r\n    this._colliders = [];\r\n  }\r\n\r\n  addCollider(collider: Collider) {\r\n    this.events.wire(collider.events);\r\n    collider.__compositeColliderId = this.id;\r\n    this._colliders.push(collider);\r\n    this._collisionProcessor.track(collider);\r\n    this._dynamicAABBTree.trackCollider(collider);\r\n  }\r\n\r\n  removeCollider(collider: Collider) {\r\n    this.events.unwire(collider.events);\r\n    collider.__compositeColliderId = null;\r\n    Util.removeItemFromArray(collider, this._colliders);\r\n    this._collisionProcessor.untrack(collider);\r\n    this._dynamicAABBTree.untrackCollider(collider);\r\n  }\r\n\r\n  getColliders(): Collider[] {\r\n    return this._colliders;\r\n  }\r\n\r\n  get worldPos(): Vector {\r\n    // TODO transform component world pos\r\n    return this._transform?.pos ?? Vector.Zero;\r\n  }\r\n\r\n  get center(): Vector {\r\n    return this._transform?.pos ?? Vector.Zero;\r\n  }\r\n\r\n  get bounds(): BoundingBox {\r\n    // TODO cache this\r\n    const colliders = this.getColliders();\r\n    const results = colliders.reduce(\r\n      (acc, collider) => acc.combine(collider.bounds),\r\n      colliders[0]?.bounds ?? new BoundingBox().translate(this.worldPos)\r\n    );\r\n\r\n    return results;\r\n  }\r\n\r\n  get localBounds(): BoundingBox {\r\n    // TODO cache this\r\n    const colliders = this.getColliders();\r\n    const results = colliders.reduce((acc, collider) => acc.combine(collider.localBounds), colliders[0]?.localBounds ?? new BoundingBox());\r\n\r\n    return results;\r\n  }\r\n\r\n  get axes(): Vector[] {\r\n    // TODO cache this\r\n    const colliders = this.getColliders();\r\n    let axes: Vector[] = [];\r\n    for (const collider of colliders) {\r\n      axes = axes.concat(collider.axes);\r\n    }\r\n    return axes;\r\n  }\r\n\r\n  getFurthestPoint(direction: Vector): Vector {\r\n    const colliders = this.getColliders();\r\n    const furthestPoints: Vector[] = [];\r\n    for (const collider of colliders) {\r\n      furthestPoints.push(collider.getFurthestPoint(direction));\r\n    }\r\n    // Pick best point from all colliders\r\n    let bestPoint = furthestPoints[0];\r\n    let maxDistance = -Number.MAX_VALUE;\r\n    for (const point of furthestPoints) {\r\n      const distance = point.dot(direction);\r\n      if (distance > maxDistance) {\r\n        bestPoint = point;\r\n        maxDistance = distance;\r\n      }\r\n    }\r\n    return bestPoint;\r\n  }\r\n\r\n  getInertia(mass: number): number {\r\n    const colliders = this.getColliders();\r\n    let totalInertia = 0;\r\n    for (const collider of colliders) {\r\n      totalInertia += collider.getInertia(mass);\r\n    }\r\n    return totalInertia;\r\n  }\r\n\r\n  collide(other: Collider): CollisionContact[] {\r\n    let otherColliders = [other];\r\n    if (other instanceof CompositeCollider) {\r\n      otherColliders = other.getColliders();\r\n    }\r\n\r\n    const pairs: Pair[] = [];\r\n    for (const c of otherColliders) {\r\n      this._dynamicAABBTree.query(c, (potentialCollider: Collider) => {\r\n        pairs.push(new Pair(c, potentialCollider));\r\n        return false;\r\n      });\r\n    }\r\n\r\n    let contacts: CollisionContact[] = [];\r\n    for (const p of pairs) {\r\n      contacts = contacts.concat(p.collide());\r\n    }\r\n    return contacts;\r\n  }\r\n\r\n  getClosestLineBetween(other: Collider): LineSegment {\r\n    const colliders = this.getColliders();\r\n    const lines: LineSegment[] = [];\r\n    if (other instanceof CompositeCollider) {\r\n      const otherColliders = other.getColliders();\r\n      for (const colliderA of colliders) {\r\n        for (const colliderB of otherColliders) {\r\n          const maybeLine = colliderA.getClosestLineBetween(colliderB);\r\n          if (maybeLine) {\r\n            lines.push(maybeLine);\r\n          }\r\n        }\r\n      }\r\n    } else {\r\n      for (const collider of colliders) {\r\n        const maybeLine = other.getClosestLineBetween(collider);\r\n        if (maybeLine) {\r\n          lines.push(maybeLine);\r\n        }\r\n      }\r\n    }\r\n\r\n    if (lines.length) {\r\n      let minLength = lines[0].getLength();\r\n      let minLine = lines[0];\r\n      for (const line of lines) {\r\n        const length = line.getLength();\r\n        if (length < minLength) {\r\n          minLength = length;\r\n          minLine = line;\r\n        }\r\n      }\r\n      return minLine;\r\n    }\r\n    return null;\r\n  }\r\n  contains(point: Vector): boolean {\r\n    const colliders = this.getColliders();\r\n    for (const collider of colliders) {\r\n      if (collider.contains(point)) {\r\n        return true;\r\n      }\r\n    }\r\n    return false;\r\n  }\r\n  rayCast(ray: Ray, max?: number): Vector {\r\n    const colliders = this.getColliders();\r\n    const points: Vector[] = [];\r\n    for (const collider of colliders) {\r\n      const vec = collider.rayCast(ray, max);\r\n      if (vec) {\r\n        points.push(vec);\r\n      }\r\n    }\r\n    if (points.length) {\r\n      let minPoint = points[0];\r\n      let minDistance = minPoint.dot(ray.dir);\r\n      for (const point of points) {\r\n        const distance = ray.dir.dot(point);\r\n        if (distance < minDistance) {\r\n          minPoint = point;\r\n          minDistance = distance;\r\n        }\r\n      }\r\n      return minPoint;\r\n    }\r\n    return null;\r\n  }\r\n  project(axis: Vector): Projection {\r\n    const colliders = this.getColliders();\r\n    const projs: Projection[] = [];\r\n    for (const collider of colliders) {\r\n      const proj = collider.project(axis);\r\n      if (proj) {\r\n        projs.push(proj);\r\n      }\r\n    }\r\n    // Merge all proj's on the same axis\r\n    if (projs.length) {\r\n      const newProjection = new Projection(projs[0].min, projs[0].max);\r\n      for (const proj of projs) {\r\n        newProjection.min = Math.min(proj.min, newProjection.min);\r\n        newProjection.max = Math.max(proj.max, newProjection.max);\r\n      }\r\n      return newProjection;\r\n    }\r\n    return null;\r\n  }\r\n\r\n  update(transform: Transform): void {\r\n    if (transform) {\r\n      const colliders = this.getColliders();\r\n      for (const collider of colliders) {\r\n        collider.owner = this.owner;\r\n        collider.update(transform);\r\n      }\r\n    }\r\n  }\r\n\r\n  public debug(ex: ExcaliburGraphicsContext, color: Color) {\r\n    const colliders = this.getColliders();\r\n    for (const collider of colliders) {\r\n      collider.debug(ex, color);\r\n    }\r\n  }\r\n\r\n  clone(): Collider {\r\n    return new CompositeCollider(this._colliders.map((c) => c.clone()));\r\n  }\r\n}\r\n","import { Vector } from './vector';\r\n\r\n/**\r\n * A 2D line segment\r\n */\r\n\r\nexport class LineSegment {\r\n  /**\r\n   * @param begin  The starting point of the line segment\r\n   * @param end  The ending point of the line segment\r\n   */\r\n  constructor(public begin: Vector, public end: Vector) {}\r\n\r\n  /**\r\n   * Gets the raw slope (m) of the line. Will return (+/-)Infinity for vertical lines.\r\n   */\r\n  public get slope() {\r\n    return (this.end.y - this.begin.y) / (this.end.x - this.begin.x);\r\n  }\r\n\r\n  /**\r\n   * Gets the Y-intercept (b) of the line. Will return (+/-)Infinity if there is no intercept.\r\n   */\r\n  public get intercept() {\r\n    return this.begin.y - this.slope * this.begin.x;\r\n  }\r\n\r\n  /**\r\n   * Gets the normal of the line\r\n   */\r\n  public normal(): Vector {\r\n    return this.end.sub(this.begin).normal();\r\n  }\r\n\r\n  public dir(): Vector {\r\n    return this.end.sub(this.begin);\r\n  }\r\n\r\n  public getPoints(): Vector[] {\r\n    return [this.begin, this.end];\r\n  }\r\n\r\n  /**\r\n   * Returns the slope of the line in the form of a vector of length 1\r\n   */\r\n  public getSlope(): Vector {\r\n    const begin = this.begin;\r\n    const end = this.end;\r\n    const distance = begin.distance(end);\r\n    return end.sub(begin).scale(1 / distance);\r\n  }\r\n\r\n  /**\r\n   * Returns the edge of the line as vector, the length of the vector is the length of the edge\r\n   */\r\n  public getEdge(): Vector {\r\n    const begin = this.begin;\r\n    const end = this.end;\r\n    return end.sub(begin);\r\n  }\r\n\r\n  /**\r\n   * Returns the length of the line segment in pixels\r\n   */\r\n  public getLength(): number {\r\n    const begin = this.begin;\r\n    const end = this.end;\r\n    const distance = begin.distance(end);\r\n    return distance;\r\n  }\r\n\r\n  /**\r\n   * Returns the midpoint of the edge\r\n   */\r\n  public get midpoint(): Vector {\r\n    return this.begin.add(this.end).scale(0.5);\r\n  }\r\n\r\n  /**\r\n   * Flips the direction of the line segment\r\n   */\r\n  public flip(): LineSegment {\r\n    return new LineSegment(this.end, this.begin);\r\n  }\r\n\r\n  /**\r\n   * Tests if a given point is below the line, points in the normal direction above the line are considered above.\r\n   * @param point\r\n   */\r\n  public below(point: Vector): boolean {\r\n    const above2 = (this.end.x - this.begin.x) * (point.y - this.begin.y) - (this.end.y - this.begin.y) * (point.x - this.begin.x);\r\n    return above2 >= 0;\r\n  }\r\n\r\n  /**\r\n   * Returns the clip point\r\n   * @param sideVector Vector that traces the line\r\n   * @param length Length to clip along side\r\n   */\r\n  public clip(sideVector: Vector, length: number): LineSegment {\r\n    let dir = sideVector;\r\n    dir = dir.normalize();\r\n\r\n    const near = dir.dot(this.begin) - length;\r\n    const far = dir.dot(this.end) - length;\r\n\r\n    const results = [];\r\n    if (near <= 0) {\r\n      results.push(this.begin);\r\n    }\r\n    if (far <= 0) {\r\n      results.push(this.end);\r\n    }\r\n\r\n    if (near * far < 0) {\r\n      const clipTime = near / (near - far);\r\n      results.push(this.begin.add(this.end.sub(this.begin).scale(clipTime)));\r\n    }\r\n    if (results.length !== 2) {\r\n      return null;\r\n    }\r\n\r\n    return new LineSegment(results[0], results[1]);\r\n  }\r\n\r\n  /**\r\n   * Find the perpendicular distance from the line to a point\r\n   * https://en.wikipedia.org/wiki/Distance_from_a_point_to_a_line\r\n   * @param point\r\n   */\r\n  public distanceToPoint(point: Vector, signed: boolean = false) {\r\n    const x0 = point.x;\r\n    const y0 = point.y;\r\n\r\n    const l = this.getLength();\r\n\r\n    const dy = this.end.y - this.begin.y;\r\n    const dx = this.end.x - this.begin.x;\r\n    const distance = (dy * x0 - dx * y0 + this.end.x * this.begin.y - this.end.y * this.begin.x) / l;\r\n    return signed ? distance : Math.abs(distance);\r\n  }\r\n\r\n  /**\r\n   * Find the perpendicular line from the line to a point\r\n   * https://en.wikipedia.org/wiki/Distance_from_a_point_to_a_line\r\n   * (a - p) - ((a - p) * n)n\r\n   * a is a point on the line\r\n   * p is the arbitrary point above the line\r\n   * n is a unit vector in direction of the line\r\n   * @param point\r\n   */\r\n  public findVectorToPoint(point: Vector): Vector {\r\n    const aMinusP = this.begin.sub(point);\r\n    const n = this.getSlope();\r\n\r\n    return aMinusP.sub(n.scale(aMinusP.dot(n)));\r\n  }\r\n\r\n  /**\r\n   * Finds a point on the line given only an X or a Y value. Given an X value, the function returns\r\n   * a new point with the calculated Y value and vice-versa.\r\n   *\r\n   * @param x The known X value of the target point\r\n   * @param y The known Y value of the target point\r\n   * @returns A new point with the other calculated axis value\r\n   */\r\n  public findPoint(x: number = null, y: number = null): Vector {\r\n    const m = this.slope;\r\n    const b = this.intercept;\r\n\r\n    if (x !== null) {\r\n      return new Vector(x, m * x + b);\r\n    } else if (y !== null) {\r\n      return new Vector((y - b) / m, y);\r\n    } else {\r\n      throw new Error('You must provide an X or a Y value');\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Whether or not the given point lies on this line. This method is precise by default\r\n   * meaning the point must lie exactly on the line. Adjust threshold to\r\n   * loosen the strictness of the check for floating-point calculations.\r\n   */\r\n  public hasPoint(x: number, y: number, threshold?: number): boolean;\r\n\r\n  /**\r\n   * Whether or not the given point lies on this line. This method is precise by default\r\n   * meaning the point must lie exactly on the line. Adjust threshold to\r\n   * loosen the strictness of the check for floating-point calculations.\r\n   */\r\n  public hasPoint(v: Vector, threshold?: number): boolean;\r\n\r\n  /**\r\n   * @see http://stackoverflow.com/a/11908158/109458\r\n   */\r\n  public hasPoint(): boolean {\r\n    let currPoint: Vector;\r\n    let threshold = 0;\r\n\r\n    if (typeof arguments[0] === 'number' && typeof arguments[1] === 'number') {\r\n      currPoint = new Vector(arguments[0], arguments[1]);\r\n      threshold = arguments[2] || 0;\r\n    } else if (arguments[0] instanceof Vector) {\r\n      currPoint = arguments[0];\r\n      threshold = arguments[1] || 0;\r\n    } else {\r\n      throw 'Could not determine the arguments for Vector.hasPoint';\r\n    }\r\n\r\n    const dxc = currPoint.x - this.begin.x;\r\n    const dyc = currPoint.y - this.begin.y;\r\n\r\n    const dx1 = this.end.x - this.begin.x;\r\n    const dy1 = this.end.y - this.begin.y;\r\n\r\n    const cross = dxc * dy1 - dyc * dx1;\r\n\r\n    // check whether point lines on the line\r\n    if (Math.abs(cross) > threshold) {\r\n      return false;\r\n    }\r\n\r\n    // check whether point lies in-between start and end\r\n    if (Math.abs(dx1) >= Math.abs(dy1)) {\r\n      return dx1 > 0 ? this.begin.x <= currPoint.x && currPoint.x <= this.end.x : this.end.x <= currPoint.x && currPoint.x <= this.begin.x;\r\n    } else {\r\n      return dy1 > 0 ? this.begin.y <= currPoint.y && currPoint.y <= this.end.y : this.end.y <= currPoint.y && currPoint.y <= this.begin.y;\r\n    }\r\n  }\r\n}\r\n","import { LineSegment } from '../../Math/line-segment';\r\nimport { Vector } from '../../Math/vector';\r\nimport { Ray } from '../../Math/ray';\r\nimport { PolygonCollider } from './PolygonCollider';\r\nimport { EdgeCollider } from './EdgeCollider';\r\nimport { CircleCollider } from './CircleCollider';\r\n\r\n/**\r\n * Finds the closes line between 2 line segments, were the magnitude of u, v are the lengths of each segment\r\n * L1 = P(s) = p0 + s * u, where s is time and p0 is the start of the line\r\n * L2 = Q(t) = q0 + t * v, where t is time and q0 is the start of the line\r\n * @param p0 Point where L1 begins\r\n * @param u Direction and length of L1\r\n * @param q0 Point were L2 begins\r\n * @param v Direction and length of L2\r\n */\r\nexport function ClosestLine(p0: Vector, u: Vector, q0: Vector, v: Vector) {\r\n  // Distance between 2 lines http://geomalgorithms.com/a07-_distance.html\r\n\r\n  // w(s, t) = P(s) - Q(t)\r\n  // The w(s, t) that has the minimum distance we will say is w(sClosest, tClosest) = wClosest\r\n  //\r\n  // wClosest is the vector that is uniquely perpendicular to the 2 line directions u & v.\r\n  // wClosest = w0 + sClosest * u - tClosest * v, where w0 is p0 - q0\r\n  //\r\n  // The closest point between 2 lines then satisfies this pair of equations\r\n  // 1: u * wClosest = 0\r\n  // 2: v * wClosest = 0\r\n  //\r\n  // Substituting wClosest into the equations we get\r\n  //\r\n  // 1: (u * u) * sClosest - (u * v) tClosest = -u * w0\r\n  // 2: (v * u) * sClosest - (v * v) tClosest = -v * w0\r\n\r\n  // simplify w0\r\n  const w0 = p0.sub(q0);\r\n\r\n  // simplify (u * u);\r\n  const a = u.dot(u);\r\n  // simplify (u * v);\r\n  const b = u.dot(v);\r\n  // simplify (v * v)\r\n  const c = v.dot(v);\r\n  // simplify (u * w0)\r\n  const d = u.dot(w0);\r\n  // simplify (v * w0)\r\n  const e = v.dot(w0);\r\n\r\n  // denominator ac - b^2\r\n  const denom = a * c - b * b;\r\n  let sDenom = denom;\r\n  let tDenom = denom;\r\n  // if denom is 0 they are parallel, use any point from either as the start in this case p0\r\n  if (denom === 0 || denom <= 0.01) {\r\n    const tClosestParallel = d / b;\r\n    return new LineSegment(p0, q0.add(v.scale(tClosestParallel)));\r\n  }\r\n\r\n  // Solve for sClosest for infinite line\r\n  let sClosest = b * e - c * d; // / denom;\r\n\r\n  // Solve for tClosest for infinite line\r\n  let tClosest = a * e - b * d; // / denom;\r\n\r\n  // Solve for segments candidate edges, if sClosest and tClosest are outside their segments\r\n  if (sClosest < 0) {\r\n    sClosest = 0;\r\n    tClosest = e;\r\n    tDenom = c;\r\n  } else if (sClosest > sDenom) {\r\n    sClosest = sDenom;\r\n    tClosest = e + b;\r\n    tDenom = c;\r\n  }\r\n\r\n  if (tClosest < 0) {\r\n    tClosest = 0;\r\n    if (-d < 0) {\r\n      sClosest = 0;\r\n    } else if (-d > a) {\r\n      sClosest = sDenom;\r\n    } else {\r\n      sClosest = -d;\r\n      sDenom = a;\r\n    }\r\n  } else if (tClosest > tDenom) {\r\n    tClosest = tDenom;\r\n    if (-d + b < 0) {\r\n      sClosest = 0;\r\n    } else if (-d + b > a) {\r\n      sClosest = sDenom;\r\n    } else {\r\n      sClosest = -d + b;\r\n      sDenom = a;\r\n    }\r\n  }\r\n  sClosest = Math.abs(sClosest) < 0.001 ? 0 : sClosest / sDenom;\r\n  tClosest = Math.abs(tClosest) < 0.001 ? 0 : tClosest / tDenom;\r\n\r\n  return new LineSegment(p0.add(u.scale(sClosest)), q0.add(v.scale(tClosest)));\r\n}\r\n\r\nexport const ClosestLineJumpTable = {\r\n  PolygonPolygonClosestLine(polygonA: PolygonCollider, polygonB: PolygonCollider) {\r\n    // Find the 2 closest faces on each polygon\r\n    const otherWorldPos = polygonB.worldPos;\r\n    const otherDirection = otherWorldPos.sub(polygonA.worldPos);\r\n    const thisDirection = otherDirection.negate();\r\n\r\n    const rayTowardsOther = new Ray(polygonA.worldPos, otherDirection);\r\n    const rayTowardsThis = new Ray(otherWorldPos, thisDirection);\r\n\r\n    const thisPoint = polygonA.rayCast(rayTowardsOther).add(rayTowardsOther.dir.scale(0.1));\r\n    const otherPoint = polygonB.rayCast(rayTowardsThis).add(rayTowardsThis.dir.scale(0.1));\r\n\r\n    const thisFace = polygonA.getClosestFace(thisPoint);\r\n    const otherFace = polygonB.getClosestFace(otherPoint);\r\n\r\n    // L1 = P(s) = p0 + s * u, where s is time and p0 is the start of the line\r\n    const p0 = thisFace.face.begin;\r\n    const u = thisFace.face.getEdge();\r\n\r\n    // L2 = Q(t) = q0 + t * v, where t is time and q0 is the start of the line\r\n    const q0 = otherFace.face.begin;\r\n    const v = otherFace.face.getEdge();\r\n\r\n    return ClosestLine(p0, u, q0, v);\r\n  },\r\n\r\n  PolygonEdgeClosestLine(polygon: PolygonCollider, edge: EdgeCollider) {\r\n    // Find the 2 closest faces on each polygon\r\n    const otherWorldPos = edge.worldPos;\r\n    const otherDirection = otherWorldPos.sub(polygon.worldPos);\r\n\r\n    const rayTowardsOther = new Ray(polygon.worldPos, otherDirection);\r\n\r\n    const thisPoint = polygon.rayCast(rayTowardsOther).add(rayTowardsOther.dir.scale(0.1));\r\n\r\n    const thisFace = polygon.getClosestFace(thisPoint);\r\n\r\n    // L1 = P(s) = p0 + s * u, where s is time and p0 is the start of the line\r\n    const p0 = thisFace.face.begin;\r\n    const u = thisFace.face.getEdge();\r\n\r\n    // L2 = Q(t) = q0 + t * v, where t is time and q0 is the start of the line\r\n    const edgeLine = edge.asLine();\r\n    const edgeStart = edgeLine.begin;\r\n    const edgeVector = edgeLine.getEdge();\r\n    const q0 = edgeStart;\r\n    const v = edgeVector;\r\n\r\n    return ClosestLine(p0, u, q0, v);\r\n  },\r\n\r\n  PolygonCircleClosestLine(polygon: PolygonCollider, circle: CircleCollider) {\r\n    // https://math.stackexchange.com/questions/1919177/how-to-find-point-on-line-closest-to-sphere\r\n    // Find the 2 closest faces on each polygon\r\n    const otherWorldPos = circle.worldPos;\r\n    const otherDirection = otherWorldPos.sub(polygon.worldPos);\r\n\r\n    const rayTowardsOther = new Ray(polygon.worldPos, otherDirection.normalize());\r\n\r\n    const thisPoint = polygon.rayCast(rayTowardsOther).add(rayTowardsOther.dir.scale(0.1));\r\n\r\n    const thisFace = polygon.getClosestFace(thisPoint);\r\n\r\n    // L1 = P(s) = p0 + s * u, where s is time and p0 is the start of the line\r\n    const p0 = thisFace.face.begin;\r\n    const u = thisFace.face.getEdge();\r\n\r\n    // Time of minimum distance\r\n    let t = (u.x * (otherWorldPos.x - p0.x) + u.y * (otherWorldPos.y - p0.y)) / (u.x * u.x + u.y * u.y);\r\n\r\n    // If time of minimum is past the edge clamp\r\n    if (t > 1) {\r\n      t = 1;\r\n    } else if (t < 0) {\r\n      t = 0;\r\n    }\r\n\r\n    // Minimum distance\r\n    const d = Math.sqrt(Math.pow(p0.x + u.x * t - otherWorldPos.x, 2) + Math.pow(p0.y + u.y * t - otherWorldPos.y, 2)) - circle.radius;\r\n\r\n    const circlex = ((p0.x + u.x * t - otherWorldPos.x) * circle.radius) / (circle.radius + d);\r\n    const circley = ((p0.y + u.y * t - otherWorldPos.y) * circle.radius) / (circle.radius + d);\r\n    return new LineSegment(u.scale(t).add(p0), new Vector(otherWorldPos.x + circlex, otherWorldPos.y + circley));\r\n  },\r\n\r\n  CircleCircleClosestLine(circleA: CircleCollider, circleB: CircleCollider) {\r\n    // Find the 2 closest faces on each polygon\r\n    const otherWorldPos = circleB.worldPos;\r\n    const otherDirection = otherWorldPos.sub(circleA.worldPos);\r\n\r\n    const thisWorldPos = circleA.worldPos;\r\n    const thisDirection = thisWorldPos.sub(circleB.worldPos);\r\n\r\n    const rayTowardsOther = new Ray(circleA.worldPos, otherDirection);\r\n    const rayTowardsThis = new Ray(circleB.worldPos, thisDirection);\r\n\r\n    const thisPoint = circleA.rayCast(rayTowardsOther);\r\n    const otherPoint = circleB.rayCast(rayTowardsThis);\r\n\r\n    return new LineSegment(thisPoint, otherPoint);\r\n  },\r\n\r\n  CircleEdgeClosestLine(circle: CircleCollider, edge: EdgeCollider) {\r\n    // https://math.stackexchange.com/questions/1919177/how-to-find-point-on-line-closest-to-sphere\r\n    const circleWorlPos = circle.worldPos;\r\n\r\n    // L1 = P(s) = p0 + s * u, where s is time and p0 is the start of the line\r\n    const edgeLine = edge.asLine();\r\n    const edgeStart = edgeLine.begin;\r\n    const edgeVector = edgeLine.getEdge();\r\n    const p0 = edgeStart;\r\n    const u = edgeVector;\r\n\r\n    // Time of minimum distance\r\n    let t = (u.x * (circleWorlPos.x - p0.x) + u.y * (circleWorlPos.y - p0.y)) / (u.x * u.x + u.y * u.y);\r\n\r\n    // If time of minimum is past the edge clamp to edge\r\n    if (t > 1) {\r\n      t = 1;\r\n    } else if (t < 0) {\r\n      t = 0;\r\n    }\r\n\r\n    // Minimum distance\r\n    const d = Math.sqrt(Math.pow(p0.x + u.x * t - circleWorlPos.x, 2) + Math.pow(p0.y + u.y * t - circleWorlPos.y, 2)) - circle.radius;\r\n\r\n    const circlex = ((p0.x + u.x * t - circleWorlPos.x) * circle.radius) / (circle.radius + d);\r\n    const circley = ((p0.y + u.y * t - circleWorlPos.y) * circle.radius) / (circle.radius + d);\r\n    return new LineSegment(u.scale(t).add(p0), new Vector(circleWorlPos.x + circlex, circleWorlPos.y + circley));\r\n  },\r\n\r\n  EdgeEdgeClosestLine(edgeA: EdgeCollider, edgeB: EdgeCollider) {\r\n    // L1 = P(s) = p0 + s * u, where s is time and p0 is the start of the line\r\n    const edgeLineA = edgeA.asLine();\r\n    const edgeStartA = edgeLineA.begin;\r\n    const edgeVectorA = edgeLineA.getEdge();\r\n    const p0 = edgeStartA;\r\n    const u = edgeVectorA;\r\n\r\n    // L2 = Q(t) = q0 + t * v, where t is time and q0 is the start of the line\r\n    const edgeLineB = edgeB.asLine();\r\n    const edgeStartB = edgeLineB.begin;\r\n    const edgeVectorB = edgeLineB.getEdge();\r\n    const q0 = edgeStartB;\r\n    const v = edgeVectorB;\r\n\r\n    return ClosestLine(p0, u, q0, v);\r\n  }\r\n};\r\n","import { BoundingBox } from '../BoundingBox';\r\nimport { CollisionJumpTable } from './CollisionJumpTable';\r\nimport { CollisionContact } from '../Detection/CollisionContact';\r\nimport { PolygonCollider } from './PolygonCollider';\r\nimport { EdgeCollider } from './EdgeCollider';\r\n\r\nimport { Projection } from '../../Math/projection';\r\nimport { LineSegment } from '../../Math/line-segment';\r\nimport { Vector } from '../../Math/vector';\r\nimport { Ray } from '../../Math/ray';\r\nimport { Color } from '../../Color';\r\nimport { Collider } from './Collider';\r\n\r\nimport { ClosestLineJumpTable } from './ClosestLineJumpTable';\r\nimport { Transform, TransformComponent } from '../../EntityComponentSystem';\r\nimport { ExcaliburGraphicsContext } from '../../Graphics/Context/ExcaliburGraphicsContext';\r\n\r\nexport interface CircleColliderOptions {\r\n  /**\r\n   * Optional pixel offset to shift the circle relative to the collider, by default (0, 0).\r\n   */\r\n  offset?: Vector;\r\n  /**\r\n   * Required radius of the circle\r\n   */\r\n  radius: number;\r\n}\r\n\r\n/**\r\n * This is a circle collider for the excalibur rigid body physics simulation\r\n */\r\nexport class CircleCollider extends Collider {\r\n  /**\r\n   * Position of the circle relative to the collider, by default (0, 0).\r\n   */\r\n  public offset: Vector = Vector.Zero;\r\n\r\n  public get worldPos(): Vector {\r\n    const tx = this._transform as TransformComponent;\r\n    const scale = tx?.globalScale ?? Vector.One;\r\n    const rotation = tx?.globalRotation ?? 0;\r\n    const pos = (tx?.globalPos ?? Vector.Zero);\r\n\r\n    return (this.offset ?? Vector.Zero).scale(scale).rotate(rotation).add(pos);\r\n  }\r\n\r\n  private _naturalRadius: number;\r\n  /**\r\n   * Get the radius of the circle\r\n   */\r\n  public get radius(): number {\r\n    const tx = this._transform as TransformComponent;\r\n    const scale = tx?.globalScale ?? Vector.One;\r\n    // This is a trade off, the alternative is retooling circles to support ellipse collisions\r\n    return this._naturalRadius * Math.min(scale.x, scale.y);\r\n  }\r\n\r\n  /**\r\n   * Set the radius of the circle\r\n   */\r\n  public set radius(val: number) {\r\n    const tx = this._transform as TransformComponent;\r\n    const scale = tx?.globalScale ?? Vector.One;\r\n    // This is a trade off, the alternative is retooling circles to support ellipse collisions\r\n    this._naturalRadius = val / Math.min(scale.x, scale.y);\r\n  }\r\n\r\n  private _transform: Transform;\r\n\r\n  constructor(options: CircleColliderOptions) {\r\n    super();\r\n    this.offset = options.offset || Vector.Zero;\r\n    this.radius = options.radius || 0;\r\n  }\r\n\r\n  /**\r\n   * Returns a clone of this shape, not associated with any collider\r\n   */\r\n  public clone(): CircleCollider {\r\n    return new CircleCollider({\r\n      offset: this.offset.clone(),\r\n      radius: this.radius\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Get the center of the collider in world coordinates\r\n   */\r\n  public get center(): Vector {\r\n    const tx = this._transform as TransformComponent;\r\n    const scale = tx?.globalScale ?? Vector.One;\r\n    const rotation = tx?.globalRotation ?? 0;\r\n    const pos = (tx?.globalPos ?? Vector.Zero);\r\n\r\n    return (this.offset ?? Vector.Zero).scale(scale).rotate(rotation).add(pos);\r\n  }\r\n\r\n  /**\r\n   * Tests if a point is contained in this collider\r\n   */\r\n  public contains(point: Vector): boolean {\r\n    const pos = this._transform?.pos ?? this.offset;\r\n    const distance = pos.distance(point);\r\n    if (distance <= this.radius) {\r\n      return true;\r\n    }\r\n    return false;\r\n  }\r\n\r\n  /**\r\n   * Casts a ray at the Circle collider and returns the nearest point of collision\r\n   * @param ray\r\n   */\r\n  public rayCast(ray: Ray, max: number = Infinity): Vector {\r\n    //https://en.wikipedia.org/wiki/Line%E2%80%93sphere_intersection\r\n    const c = this.center;\r\n    const dir = ray.dir;\r\n    const orig = ray.pos;\r\n\r\n    const discriminant = Math.sqrt(Math.pow(dir.dot(orig.sub(c)), 2) - Math.pow(orig.sub(c).distance(), 2) + Math.pow(this.radius, 2));\r\n\r\n    if (discriminant < 0) {\r\n      // no intersection\r\n      return null;\r\n    } else {\r\n      let toi = 0;\r\n      if (discriminant === 0) {\r\n        toi = -dir.dot(orig.sub(c));\r\n        if (toi > 0 && toi < max) {\r\n          return ray.getPoint(toi);\r\n        }\r\n        return null;\r\n      } else {\r\n        const toi1 = -dir.dot(orig.sub(c)) + discriminant;\r\n        const toi2 = -dir.dot(orig.sub(c)) - discriminant;\r\n\r\n        const positiveToi: number[] = [];\r\n        if (toi1 >= 0) {\r\n          positiveToi.push(toi1);\r\n        }\r\n\r\n        if (toi2 >= 0) {\r\n          positiveToi.push(toi2);\r\n        }\r\n\r\n        const mintoi = Math.min(...positiveToi);\r\n        if (mintoi <= max) {\r\n          return ray.getPoint(mintoi);\r\n        }\r\n        return null;\r\n      }\r\n    }\r\n  }\r\n\r\n  public getClosestLineBetween(shape: Collider): LineSegment {\r\n    if (shape instanceof CircleCollider) {\r\n      return ClosestLineJumpTable.CircleCircleClosestLine(this, shape);\r\n    } else if (shape instanceof PolygonCollider) {\r\n      return ClosestLineJumpTable.PolygonCircleClosestLine(shape, this).flip();\r\n    } else if (shape instanceof EdgeCollider) {\r\n      return ClosestLineJumpTable.CircleEdgeClosestLine(this, shape).flip();\r\n    } else {\r\n      throw new Error(`Polygon could not collide with unknown CollisionShape ${typeof shape}`);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @inheritdoc\r\n   */\r\n  public collide(collider: Collider): CollisionContact[] {\r\n    if (collider instanceof CircleCollider) {\r\n      return CollisionJumpTable.CollideCircleCircle(this, collider);\r\n    } else if (collider instanceof PolygonCollider) {\r\n      return CollisionJumpTable.CollideCirclePolygon(this, collider);\r\n    } else if (collider instanceof EdgeCollider) {\r\n      return CollisionJumpTable.CollideCircleEdge(this, collider);\r\n    } else {\r\n      throw new Error(`Circle could not collide with unknown CollisionShape ${typeof collider}`);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Find the point on the collider furthest in the direction specified\r\n   */\r\n  public getFurthestPoint(direction: Vector): Vector {\r\n    return this.center.add(direction.normalize().scale(this.radius));\r\n  }\r\n\r\n  /**\r\n   * Find the local point on the shape in the direction specified\r\n   * @param direction\r\n   */\r\n  public getFurthestLocalPoint(direction: Vector): Vector {\r\n    const dir = direction.normalize();\r\n    return dir.scale(this.radius);\r\n  }\r\n\r\n  /**\r\n   * Get the axis aligned bounding box for the circle collider in world coordinates\r\n   */\r\n  public get bounds(): BoundingBox {\r\n    const tx = this._transform as TransformComponent;\r\n    const scale = tx?.globalScale ?? Vector.One;\r\n    const rotation = tx?.globalRotation ?? 0;\r\n    const pos = (tx?.globalPos ?? Vector.Zero);\r\n    return new BoundingBox(\r\n      this.offset.x - this._naturalRadius,\r\n      this.offset.y - this._naturalRadius,\r\n      this.offset.x + this._naturalRadius,\r\n      this.offset.y + this._naturalRadius\r\n    ).rotate(rotation).scale(scale).translate(pos);\r\n  }\r\n\r\n  /**\r\n   * Get the axis aligned bounding box for the circle collider in local coordinates\r\n   */\r\n  public get localBounds(): BoundingBox {\r\n    return new BoundingBox(\r\n      this.offset.x - this._naturalRadius,\r\n      this.offset.y - this._naturalRadius,\r\n      this.offset.x + this._naturalRadius,\r\n      this.offset.y + this._naturalRadius\r\n    );\r\n  }\r\n\r\n  /**\r\n   * Get axis not implemented on circles, since there are infinite axis in a circle\r\n   */\r\n  public get axes(): Vector[] {\r\n    return [];\r\n  }\r\n\r\n  /**\r\n   * Returns the moment of inertia of a circle given it's mass\r\n   * https://en.wikipedia.org/wiki/List_of_moments_of_inertia\r\n   */\r\n  public getInertia(mass: number): number {\r\n    return (mass * this.radius * this.radius) / 2;\r\n  }\r\n\r\n  /* istanbul ignore next */\r\n  public update(transform: Transform): void {\r\n    this._transform = transform;\r\n  }\r\n\r\n  /**\r\n   * Project the circle along a specified axis\r\n   */\r\n  public project(axis: Vector): Projection {\r\n    const scalars = [];\r\n    const point = this.center;\r\n    const dotProduct = point.dot(axis);\r\n    scalars.push(dotProduct);\r\n    scalars.push(dotProduct + this.radius);\r\n    scalars.push(dotProduct - this.radius);\r\n    return new Projection(Math.min.apply(Math, scalars), Math.max.apply(Math, scalars));\r\n  }\r\n\r\n  public debug(ex: ExcaliburGraphicsContext, color: Color) {\r\n    const tx = this._transform as TransformComponent;\r\n    const scale = tx?.globalScale ?? Vector.One;\r\n    const rotation = tx?.globalRotation ?? 0;\r\n    const pos = (tx?.globalPos ?? Vector.Zero);\r\n    ex.save();\r\n    ex.translate(pos.x, pos.y);\r\n    ex.rotate(rotation);\r\n    ex.scale(scale.x, scale.y);\r\n    ex.drawCircle((this.offset ?? Vector.Zero), this._naturalRadius, Color.Transparent, color, 2);\r\n    ex.restore();\r\n  }\r\n}\r\n","import { Vector } from '../../Math/vector';\r\nimport { Physics } from '../Physics';\r\nimport { Collider } from '../Colliders/Collider';\r\nimport { CollisionType } from '../CollisionType';\r\nimport { Pair } from './Pair';\r\nimport { SeparationInfo } from '../Colliders/SeparatingAxis';\r\nimport { BodyComponent } from '../BodyComponent';\r\n\r\n/**\r\n * Collision contacts are used internally by Excalibur to resolve collision between colliders. This\r\n * Pair prevents collisions from being evaluated more than one time\r\n */\r\nexport class CollisionContact {\r\n  private _canceled = false;\r\n\r\n  /**\r\n   * Currently the ids between colliders\r\n   */\r\n  readonly id: string;\r\n\r\n  /**\r\n   * The first collider in the collision\r\n   */\r\n  colliderA: Collider;\r\n\r\n  /**\r\n   * The second collider in the collision\r\n   */\r\n  colliderB: Collider;\r\n\r\n  /**\r\n   * The minimum translation vector to resolve overlap, pointing away from colliderA\r\n   */\r\n  mtv: Vector;\r\n\r\n  /**\r\n   * World space contact points between colliderA and colliderB\r\n   */\r\n  points: Vector[];\r\n\r\n  /**\r\n   * Local space contact points between colliderA and colliderB\r\n   */\r\n  localPoints: Vector[];\r\n\r\n  /**\r\n   * The collision normal, pointing away from colliderA\r\n   */\r\n  normal: Vector;\r\n\r\n  /**\r\n   * The collision tangent\r\n   */\r\n  tangent: Vector;\r\n\r\n  /**\r\n   * Information about the specifics of the collision contact separation\r\n   */\r\n  info: SeparationInfo;\r\n\r\n  constructor(\r\n    colliderA: Collider,\r\n    colliderB: Collider,\r\n    mtv: Vector,\r\n    normal: Vector,\r\n    tangent: Vector,\r\n    points: Vector[],\r\n    localPoints: Vector[],\r\n    info: SeparationInfo\r\n  ) {\r\n    this.colliderA = colliderA;\r\n    this.colliderB = colliderB;\r\n    this.mtv = mtv;\r\n    this.normal = normal;\r\n    this.tangent = tangent;\r\n    this.points = points;\r\n    this.localPoints = localPoints;\r\n    this.info = info;\r\n    this.id = Pair.calculatePairHash(colliderA.id, colliderB.id);\r\n    if (colliderA.__compositeColliderId || colliderB.__compositeColliderId) {\r\n      // Add on the parent composite pair for start/end contact\r\n      this.id += '|' + Pair.calculatePairHash(\r\n        colliderA.__compositeColliderId ?? colliderA.id,\r\n        colliderB.__compositeColliderId ?? colliderB.id);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Match contact awake state, except if body's are Fixed\r\n   */\r\n  public matchAwake(): void {\r\n    const bodyA = this.colliderA.owner.get(BodyComponent);\r\n    const bodyB = this.colliderB.owner.get(BodyComponent);\r\n    if (bodyA && bodyB) {\r\n      if (bodyA.sleeping !== bodyB.sleeping) {\r\n        if (bodyA.sleeping && bodyA.collisionType !== CollisionType.Fixed && bodyB.sleepMotion >= Physics.wakeThreshold) {\r\n          bodyA.setSleeping(false);\r\n        }\r\n        if (bodyB.sleeping && bodyB.collisionType !== CollisionType.Fixed && bodyA.sleepMotion >= Physics.wakeThreshold) {\r\n          bodyB.setSleeping(false);\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  public isCanceled() {\r\n    return this._canceled;\r\n  }\r\n\r\n  public cancel(): void {\r\n    this._canceled = true;\r\n  }\r\n}\r\n","import { LineSegment } from '../../Math/line-segment';\r\nimport { Vector } from '../../Math/vector';\r\nimport { Collider } from './Collider';\r\nimport { CircleCollider } from './CircleCollider';\r\nimport { PolygonCollider } from './PolygonCollider';\r\n\r\n/**\r\n * Specific information about a contact and it's separation\r\n */\r\nexport interface SeparationInfo {\r\n  /**\r\n   * Collider A\r\n   */\r\n  collider: Collider;\r\n\r\n  /**\r\n   * Signed value (negative means overlap, positive no overlap)\r\n   */\r\n  separation: number;\r\n\r\n  /**\r\n   * Axis of separation from the collider's perspective\r\n   */\r\n  axis: Vector;\r\n\r\n  /**\r\n   * Side of separation (reference) from the collider's perspective\r\n   */\r\n\r\n  side?: LineSegment;\r\n\r\n  /**\r\n   * Local side of separation (reference) from the collider's perspective\r\n   */\r\n  localSide?: LineSegment;\r\n\r\n  /**\r\n   * Index of the separation side (reference) from the collider's perspective\r\n   */\r\n  sideId?: number;\r\n\r\n  /**\r\n   * Point on collider B (incident point)\r\n   */\r\n  point: Vector;\r\n\r\n  /**\r\n   * Local point on collider B (incident point)\r\n   */\r\n  localPoint?: Vector;\r\n}\r\n\r\nexport class SeparatingAxis {\r\n  static findPolygonPolygonSeparation(polyA: PolygonCollider, polyB: PolygonCollider): SeparationInfo {\r\n    let bestSeparation = -Number.MAX_VALUE;\r\n    let bestSide: LineSegment | null = null;\r\n    let bestAxis: Vector | null = null;\r\n    let bestSideIndex: number = -1;\r\n    let bestOtherPoint: Vector | null = null;\r\n    const sides = polyA.getSides();\r\n    const localSides = polyA.getLocalSides();\r\n    for (let i = 0; i < sides.length; i++) {\r\n      const side = sides[i];\r\n      const axis = side.normal();\r\n      const vertB = polyB.getFurthestPoint(axis.negate());\r\n      // Separation on side i's axis\r\n      // We are looking for the largest separation between poly A's sides\r\n      const vertSeparation = side.distanceToPoint(vertB, true);\r\n      if (vertSeparation > bestSeparation) {\r\n        bestSeparation = vertSeparation;\r\n        bestSide = side;\r\n        bestAxis = axis;\r\n        bestSideIndex = i;\r\n        bestOtherPoint = vertB;\r\n      }\r\n    }\r\n\r\n    return {\r\n      collider: polyA,\r\n      separation: bestAxis ? bestSeparation : 99,\r\n      axis: bestAxis as Vector,\r\n      side: bestSide,\r\n      localSide: localSides[bestSideIndex],\r\n      sideId: bestSideIndex,\r\n      point: bestOtherPoint as Vector,\r\n      localPoint: bestAxis ? polyB.getFurthestLocalPoint(bestAxis!.negate()) : null\r\n    };\r\n  }\r\n\r\n  static findCirclePolygonSeparation(circle: CircleCollider, polygon: PolygonCollider): Vector | null {\r\n    const axes = polygon.axes;\r\n    const pc = polygon.center;\r\n    // Special SAT with circles\r\n    const polyDir = pc.sub(circle.worldPos);\r\n    const closestPointOnPoly = polygon.getFurthestPoint(polyDir.negate());\r\n    axes.push(closestPointOnPoly.sub(circle.worldPos).normalize());\r\n\r\n    let minOverlap = Number.MAX_VALUE;\r\n    let minAxis = null;\r\n    let minIndex = -1;\r\n    for (let i = 0; i < axes.length; i++) {\r\n      const proj1 = polygon.project(axes[i]);\r\n      const proj2 = circle.project(axes[i]);\r\n      const overlap = proj1.getOverlap(proj2);\r\n      if (overlap <= 0) {\r\n        return null;\r\n      } else {\r\n        if (overlap < minOverlap) {\r\n          minOverlap = overlap;\r\n          minAxis = axes[i];\r\n          minIndex = i;\r\n        }\r\n      }\r\n    }\r\n    if (minIndex < 0) {\r\n      return null;\r\n    }\r\n    return minAxis.normalize().scale(minOverlap);\r\n  }\r\n}\r\n","import { CircleCollider } from './CircleCollider';\r\nimport { CollisionContact } from '../Detection/CollisionContact';\r\nimport { PolygonCollider } from './PolygonCollider';\r\nimport { EdgeCollider } from './EdgeCollider';\r\nimport { SeparatingAxis, SeparationInfo } from './SeparatingAxis';\r\nimport { LineSegment } from '../../Math/line-segment';\r\nimport { Vector } from '../../Math/vector';\r\nimport { TransformComponent } from '../../EntityComponentSystem';\r\nimport { Pair } from '../Detection/Pair';\r\n\r\nexport const CollisionJumpTable = {\r\n  CollideCircleCircle(circleA: CircleCollider, circleB: CircleCollider): CollisionContact[] {\r\n    const circleAPos = circleA.worldPos;\r\n    const circleBPos = circleB.worldPos;\r\n    const combinedRadius = circleA.radius + circleB.radius;\r\n    const distance = circleAPos.distance(circleBPos);\r\n\r\n    if (distance > combinedRadius) {\r\n      return [];\r\n    }\r\n\r\n    // negative means overlap\r\n    const separation = combinedRadius - distance;\r\n\r\n    // Normal points from A -> B\r\n    const normal = circleBPos.sub(circleAPos).normalize();\r\n    const tangent = normal.perpendicular();\r\n    const mvt = normal.scale(separation);\r\n\r\n    const point = circleA.getFurthestPoint(normal);\r\n    const local = circleA.getFurthestLocalPoint(normal);\r\n\r\n    const info: SeparationInfo = {\r\n      collider: circleA,\r\n      separation,\r\n      axis: normal,\r\n      point: point\r\n    };\r\n\r\n    return [new CollisionContact(circleA, circleB, mvt, normal, tangent, [point], [local], info)];\r\n  },\r\n\r\n  CollideCirclePolygon(circle: CircleCollider, polygon: PolygonCollider): CollisionContact[] {\r\n    let minAxis = SeparatingAxis.findCirclePolygonSeparation(circle, polygon);\r\n    if (!minAxis) {\r\n      return [];\r\n    }\r\n\r\n    // make sure that the minAxis is pointing away from circle\r\n    const samedir = minAxis.dot(polygon.center.sub(circle.center));\r\n    minAxis = samedir < 0 ? minAxis.negate() : minAxis;\r\n\r\n    const point = circle.getFurthestPoint(minAxis);\r\n    const xf = circle.owner?.get(TransformComponent) ?? new TransformComponent();\r\n    const local = xf.applyInverse(point);\r\n    const normal = minAxis.normalize();\r\n\r\n    const info: SeparationInfo = {\r\n      collider: circle,\r\n      separation: -minAxis.size,\r\n      axis: normal,\r\n      point: point,\r\n      localPoint: local,\r\n      side: polygon.findSide(normal.negate()),\r\n      localSide: polygon.findLocalSide(normal.negate())\r\n    };\r\n\r\n    return [new CollisionContact(circle, polygon, minAxis, normal, normal.perpendicular(), [point], [local], info)];\r\n  },\r\n\r\n  CollideCircleEdge(circle: CircleCollider, edge: EdgeCollider): CollisionContact[] {\r\n    // TODO not sure this actually abides by local/world collisions\r\n    // Are edge.begin and edge.end local space or world space? I think they should be local\r\n\r\n    // center of the circle in world pos\r\n    const cc = circle.center;\r\n    // vector in the direction of the edge\r\n    const edgeWorld = edge.asLine();\r\n    const e = edgeWorld.end.sub(edgeWorld.begin);\r\n\r\n    // amount of overlap with the circle's center along the edge direction\r\n    const u = e.dot(edgeWorld.end.sub(cc));\r\n    const v = e.dot(cc.sub(edgeWorld.begin));\r\n    const side = edge.asLine();\r\n    const localSide = edge.asLocalLine();\r\n\r\n    // Potential region A collision (circle is on the left side of the edge, before the beginning)\r\n    if (v <= 0) {\r\n      const da = edgeWorld.begin.sub(cc);\r\n      const dda = da.dot(da); // quick and dirty way of calc'n distance in r^2 terms saves some sqrts\r\n      // save some sqrts\r\n      if (dda > circle.radius * circle.radius) {\r\n        return []; // no collision\r\n      }\r\n\r\n      const normal = da.normalize();\r\n      const separation = circle.radius - Math.sqrt(dda);\r\n\r\n      const info: SeparationInfo = {\r\n        collider: circle,\r\n        separation: separation,\r\n        axis: normal,\r\n        point: side.begin,\r\n        side: side,\r\n        localSide: localSide\r\n      };\r\n\r\n      return [\r\n        new CollisionContact(circle, edge, normal.scale(separation), normal, normal.perpendicular(), [side.begin], [localSide.begin], info)\r\n      ];\r\n    }\r\n\r\n    // Potential region B collision (circle is on the right side of the edge, after the end)\r\n    if (u <= 0) {\r\n      const db = edgeWorld.end.sub(cc);\r\n      const ddb = db.dot(db);\r\n      if (ddb > circle.radius * circle.radius) {\r\n        return [];\r\n      }\r\n\r\n      const normal = db.normalize();\r\n      const separation = circle.radius - Math.sqrt(ddb);\r\n\r\n      const info: SeparationInfo = {\r\n        collider: circle,\r\n        separation: separation,\r\n        axis: normal,\r\n        point: side.end,\r\n        side: side,\r\n        localSide: localSide\r\n      };\r\n\r\n      return [\r\n        new CollisionContact(circle, edge, normal.scale(separation), normal, normal.perpendicular(), [side.end], [localSide.end], info)\r\n      ];\r\n    }\r\n\r\n    // Otherwise potential region AB collision (circle is in the middle of the edge between the beginning and end)\r\n    const den = e.dot(e);\r\n    const pointOnEdge = edgeWorld.begin\r\n      .scale(u)\r\n      .add(edgeWorld.end.scale(v))\r\n      .scale(1 / den);\r\n    const d = cc.sub(pointOnEdge);\r\n\r\n    const dd = d.dot(d);\r\n    if (dd > circle.radius * circle.radius) {\r\n      return []; // no collision\r\n    }\r\n\r\n    let normal = e.perpendicular();\r\n    // flip correct direction\r\n    if (normal.dot(cc.sub(edgeWorld.begin)) < 0) {\r\n      normal.x = -normal.x;\r\n      normal.y = -normal.y;\r\n    }\r\n\r\n    normal = normal.normalize();\r\n    const separation = circle.radius - Math.sqrt(dd);\r\n\r\n    const mvt = normal.scale(separation);\r\n    const info: SeparationInfo = {\r\n      collider: circle,\r\n      separation: separation,\r\n      axis: normal,\r\n      point: pointOnEdge,\r\n      side: side,\r\n      localSide: localSide\r\n    };\r\n\r\n    return [\r\n      new CollisionContact(\r\n        circle,\r\n        edge,\r\n        mvt,\r\n        normal.negate(),\r\n        normal.negate().perpendicular(),\r\n        [pointOnEdge],\r\n        [pointOnEdge.sub(edge.worldPos)],\r\n        info\r\n      )\r\n    ];\r\n  },\r\n\r\n  CollideEdgeEdge(): CollisionContact[] {\r\n    // Edge-edge collision doesn't make sense\r\n    return [];\r\n  },\r\n\r\n  CollidePolygonEdge(polygon: PolygonCollider, edge: EdgeCollider): CollisionContact[] {\r\n    const pc = polygon.center;\r\n    const ec = edge.center;\r\n    const dir = ec.sub(pc).normalize();\r\n\r\n    // build a temporary polygon from the edge to use SAT\r\n    const linePoly = new PolygonCollider({\r\n      points: [edge.begin, edge.end, edge.end.add(dir.scale(100)), edge.begin.add(dir.scale(100))],\r\n      offset: edge.offset\r\n    });\r\n    linePoly.owner = edge.owner;\r\n    const tx = edge.owner?.get(TransformComponent);\r\n    if (tx) {\r\n      linePoly.update(edge.owner.get(TransformComponent));\r\n    }\r\n    // Gross hack but poly-poly works well\r\n    const contact = this.CollidePolygonPolygon(polygon, linePoly);\r\n    if (contact.length) {\r\n      // Fudge the contact back to edge\r\n      contact[0].colliderB = edge;\r\n      (contact[0].id as any) = Pair.calculatePairHash(polygon.id, edge.id);\r\n      // contact[0].info.collider\r\n    }\r\n    return contact;\r\n  },\r\n\r\n  CollidePolygonPolygon(polyA: PolygonCollider, polyB: PolygonCollider): CollisionContact[] {\r\n    // Multi contact from SAT\r\n    // https://gamedev.stackexchange.com/questions/111390/multiple-contacts-for-sat-collision-detection\r\n    // do a SAT test to find a min axis if it exists\r\n    const separationA = SeparatingAxis.findPolygonPolygonSeparation(polyA, polyB);\r\n    // If there is no overlap from boxA's perspective we can end early\r\n    if (separationA.separation > 0) {\r\n      return [];\r\n    }\r\n\r\n    const separationB = SeparatingAxis.findPolygonPolygonSeparation(polyB, polyA);\r\n    // If there is no overlap from boxB's perspective exit now\r\n    if (separationB.separation > 0) {\r\n      return [];\r\n    }\r\n\r\n    // Separations are both negative, we want to pick the least negative (minimal movement)\r\n    const separation = separationA.separation > separationB.separation ? separationA : separationB;\r\n\r\n    // The incident side is the most opposite from the axes of collision on the other collider\r\n    const other = separation.collider === polyA ? polyB : polyA;\r\n    const incident = other.findSide(separation.axis.negate()) as LineSegment;\r\n\r\n    // Clip incident side by the perpendicular lines at each end of the reference side\r\n    // https://en.wikipedia.org/wiki/Sutherland%E2%80%93Hodgman_algorithm\r\n    const reference = separation.side;\r\n    const refDir = reference.dir().normalize();\r\n\r\n    // Find our contact points by clipping the incident by the collision side\r\n    const clipRight = incident.clip(refDir.negate(), -refDir.dot(reference.begin));\r\n    let clipLeft: LineSegment | null = null;\r\n    if (clipRight) {\r\n      clipLeft = clipRight.clip(refDir, refDir.dot(reference.end));\r\n    }\r\n\r\n    // If there is no left there is no collision\r\n    if (clipLeft) {\r\n      // We only want clip points below the reference edge, discard the others\r\n      const points = clipLeft.getPoints().filter((p) => {\r\n        return reference.below(p);\r\n      });\r\n\r\n      let normal = separation.axis;\r\n      let tangent = normal.perpendicular();\r\n      // Point Contact A -> B\r\n      if (polyB.center.sub(polyA.center).dot(normal) < 0) {\r\n        normal = normal.negate();\r\n        tangent = normal.perpendicular();\r\n      }\r\n      // Points are clipped from incident which is the other collider\r\n      // Store those as locals\r\n      let localPoints: Vector[] = [];\r\n      if (separation.collider === polyA) {\r\n        const xf = polyB.owner?.get(TransformComponent) ?? new TransformComponent();\r\n        localPoints = points.map((p) => xf.applyInverse(p));\r\n      } else {\r\n        const xf = polyA.owner?.get(TransformComponent) ?? new TransformComponent();\r\n        localPoints = points.map((p) => xf.applyInverse(p));\r\n      }\r\n      return [new CollisionContact(polyA, polyB, normal.scale(-separation.separation), normal, tangent, points, localPoints, separation)];\r\n    }\r\n    return [];\r\n  },\r\n\r\n  FindContactSeparation(contact: CollisionContact, localPoint: Vector) {\r\n    const shapeA = contact.colliderA;\r\n    const txA = contact.colliderA.owner?.get(TransformComponent) ?? new TransformComponent();\r\n    const shapeB = contact.colliderB;\r\n    const txB = contact.colliderB.owner?.get(TransformComponent) ?? new TransformComponent();\r\n\r\n    // both are circles\r\n    if (shapeA instanceof CircleCollider && shapeB instanceof CircleCollider) {\r\n      const combinedRadius = shapeA.radius + shapeB.radius;\r\n      const distance = txA.pos.distance(txB.pos);\r\n      const separation = combinedRadius - distance;\r\n      return -separation;\r\n    }\r\n\r\n    // both are polygons\r\n    if (shapeA instanceof PolygonCollider && shapeB instanceof PolygonCollider) {\r\n      if (contact.info.localSide) {\r\n        let side: LineSegment;\r\n        let worldPoint: Vector;\r\n        if (contact.info.collider === shapeA) {\r\n          side = new LineSegment(txA.apply(contact.info.localSide.begin), txA.apply(contact.info.localSide.end));\r\n          worldPoint = txB.apply(localPoint);\r\n        } else {\r\n          side = new LineSegment(txB.apply(contact.info.localSide.begin), txB.apply(contact.info.localSide.end));\r\n          worldPoint = txA.apply(localPoint);\r\n        }\r\n\r\n        return side.distanceToPoint(worldPoint, true);\r\n      }\r\n    }\r\n\r\n    // polygon v circle\r\n    if (\r\n      (shapeA instanceof PolygonCollider && shapeB instanceof CircleCollider) ||\r\n      (shapeB instanceof PolygonCollider && shapeA instanceof CircleCollider)\r\n    ) {\r\n      const worldPoint = txA.apply(localPoint);\r\n      if (contact.info.side) {\r\n        return contact.info.side.distanceToPoint(worldPoint, true);\r\n      }\r\n    }\r\n\r\n    // polygon v edge\r\n    if (\r\n      (shapeA instanceof EdgeCollider && shapeB instanceof PolygonCollider) ||\r\n      (shapeB instanceof EdgeCollider && shapeA instanceof PolygonCollider)\r\n    ) {\r\n      let worldPoint: Vector;\r\n      if (contact.info.collider === shapeA) {\r\n        worldPoint = txB.apply(localPoint);\r\n      } else {\r\n        worldPoint = txA.apply(localPoint);\r\n      }\r\n      if (contact.info.side) {\r\n        return contact.info.side.distanceToPoint(worldPoint, true);\r\n      }\r\n    }\r\n\r\n    // circle v edge\r\n    if (\r\n      (shapeA instanceof CircleCollider && shapeB instanceof EdgeCollider) ||\r\n      (shapeB instanceof CircleCollider && shapeA instanceof EdgeCollider)\r\n    ) {\r\n      // Local point is always on the edge which is always shapeB\r\n      const worldPoint = txB.apply(localPoint);\r\n\r\n      let circlePoint: Vector;\r\n      if (shapeA instanceof CircleCollider) {\r\n        circlePoint = shapeA.getFurthestPoint(contact.normal);\r\n      }\r\n\r\n      const dist = worldPoint.distance(circlePoint);\r\n\r\n      if (contact.info.side) {\r\n        return dist > 0 ? -dist : 0;\r\n      }\r\n    }\r\n\r\n    return 0;\r\n  }\r\n};\r\n","import { BoundingBox } from '../BoundingBox';\r\nimport { CollisionContact } from '../Detection/CollisionContact';\r\nimport { CollisionJumpTable } from './CollisionJumpTable';\r\nimport { CircleCollider } from './CircleCollider';\r\nimport { PolygonCollider } from './PolygonCollider';\r\n\r\nimport { Projection } from '../../Math/projection';\r\nimport { LineSegment } from '../../Math/line-segment';\r\nimport { Vector } from '../../Math/vector';\r\nimport { Ray } from '../../Math/ray';\r\nimport { Color } from '../../Color';\r\nimport { Collider } from './Collider';\r\nimport { ClosestLineJumpTable } from './ClosestLineJumpTable';\r\nimport { Transform, TransformComponent } from '../../EntityComponentSystem/Components/TransformComponent';\r\nimport { ExcaliburGraphicsContext } from '../../Graphics/Context/ExcaliburGraphicsContext';\r\n\r\nexport interface EdgeColliderOptions {\r\n  /**\r\n   * The beginning of the edge defined in local coordinates to the collider\r\n   */\r\n  begin: Vector;\r\n  /**\r\n   * The ending of the edge defined in local coordinates to the collider\r\n   */\r\n  end: Vector;\r\n  /**\r\n   * Optionally specify an offset\r\n   */\r\n  offset?: Vector;\r\n}\r\n\r\n/**\r\n * Edge is a single line collider to create collisions with a single line.\r\n */\r\nexport class EdgeCollider extends Collider {\r\n  offset: Vector;\r\n  begin: Vector;\r\n  end: Vector;\r\n\r\n  private _transform: Transform;\r\n\r\n  constructor(options: EdgeColliderOptions) {\r\n    super();\r\n    this.begin = options.begin || Vector.Zero;\r\n    this.end = options.end || Vector.Zero;\r\n    this.offset = options.offset ?? Vector.Zero;\r\n  }\r\n\r\n  /**\r\n   * Returns a clone of this Edge, not associated with any collider\r\n   */\r\n  public clone(): EdgeCollider {\r\n    return new EdgeCollider({\r\n      begin: this.begin.clone(),\r\n      end: this.end.clone()\r\n    });\r\n  }\r\n\r\n  public get worldPos(): Vector {\r\n    const tx = this._transform as TransformComponent;\r\n    return tx?.globalPos.add(this.offset) ?? this.offset;\r\n  }\r\n\r\n  /**\r\n   * Get the center of the collision area in world coordinates\r\n   */\r\n  public get center(): Vector {\r\n    const pos = this.begin.average(this.end).add(this._getBodyPos());\r\n    return pos;\r\n  }\r\n\r\n  private _getBodyPos(): Vector {\r\n    const tx = this._transform as TransformComponent;\r\n    const bodyPos = tx?.globalPos ?? Vector.Zero;\r\n    return bodyPos;\r\n  }\r\n\r\n  private _getTransformedBegin(): Vector {\r\n    const tx = this._transform as TransformComponent;\r\n    const angle = tx ? tx.globalRotation : 0;\r\n    return this.begin.rotate(angle).add(this._getBodyPos());\r\n  }\r\n\r\n  private _getTransformedEnd(): Vector {\r\n    const tx = this._transform as TransformComponent;\r\n    const angle = tx ? tx.globalRotation : 0;\r\n    return this.end.rotate(angle).add(this._getBodyPos());\r\n  }\r\n\r\n  /**\r\n   * Returns the slope of the line in the form of a vector\r\n   */\r\n  public getSlope(): Vector {\r\n    const begin = this._getTransformedBegin();\r\n    const end = this._getTransformedEnd();\r\n    const distance = begin.distance(end);\r\n    return end.sub(begin).scale(1 / distance);\r\n  }\r\n\r\n  /**\r\n   * Returns the length of the line segment in pixels\r\n   */\r\n  public getLength(): number {\r\n    const begin = this._getTransformedBegin();\r\n    const end = this._getTransformedEnd();\r\n    const distance = begin.distance(end);\r\n    return distance;\r\n  }\r\n\r\n  /**\r\n   * Tests if a point is contained in this collision area\r\n   */\r\n  public contains(): boolean {\r\n    return false;\r\n  }\r\n\r\n  /**\r\n   * @inheritdoc\r\n   */\r\n  public rayCast(ray: Ray, max: number = Infinity): Vector {\r\n    const numerator = this._getTransformedBegin().sub(ray.pos);\r\n\r\n    // Test is line and ray are parallel and non intersecting\r\n    if (ray.dir.cross(this.getSlope()) === 0 && numerator.cross(ray.dir) !== 0) {\r\n      return null;\r\n    }\r\n\r\n    // Lines are parallel\r\n    const divisor = ray.dir.cross(this.getSlope());\r\n    if (divisor === 0) {\r\n      return null;\r\n    }\r\n\r\n    const t = numerator.cross(this.getSlope()) / divisor;\r\n\r\n    if (t >= 0 && t <= max) {\r\n      const u = numerator.cross(ray.dir) / divisor / this.getLength();\r\n      if (u >= 0 && u <= 1) {\r\n        return ray.getPoint(t);\r\n      }\r\n    }\r\n\r\n    return null;\r\n  }\r\n\r\n  /**\r\n   * Returns the closes line between this and another collider, from this -> collider\r\n   * @param shape\r\n   */\r\n  public getClosestLineBetween(shape: Collider): LineSegment {\r\n    if (shape instanceof CircleCollider) {\r\n      return ClosestLineJumpTable.CircleEdgeClosestLine(shape, this);\r\n    } else if (shape instanceof PolygonCollider) {\r\n      return ClosestLineJumpTable.PolygonEdgeClosestLine(shape, this).flip();\r\n    } else if (shape instanceof EdgeCollider) {\r\n      return ClosestLineJumpTable.EdgeEdgeClosestLine(this, shape);\r\n    } else {\r\n      throw new Error(`Polygon could not collide with unknown CollisionShape ${typeof shape}`);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @inheritdoc\r\n   */\r\n  public collide(shape: Collider): CollisionContact[] {\r\n    if (shape instanceof CircleCollider) {\r\n      return CollisionJumpTable.CollideCircleEdge(shape, this);\r\n    } else if (shape instanceof PolygonCollider) {\r\n      return CollisionJumpTable.CollidePolygonEdge(shape, this);\r\n    } else if (shape instanceof EdgeCollider) {\r\n      return CollisionJumpTable.CollideEdgeEdge();\r\n    } else {\r\n      throw new Error(`Edge could not collide with unknown CollisionShape ${typeof shape}`);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Find the point on the collider furthest in the direction specified\r\n   */\r\n  public getFurthestPoint(direction: Vector): Vector {\r\n    const transformedBegin = this._getTransformedBegin();\r\n    const transformedEnd = this._getTransformedEnd();\r\n    if (direction.dot(transformedBegin) > 0) {\r\n      return transformedBegin;\r\n    } else {\r\n      return transformedEnd;\r\n    }\r\n  }\r\n\r\n  private _boundsFromBeginEnd(begin: Vector, end: Vector, padding = 10) {\r\n    // A perfectly vertical or horizontal edge would have a bounds 0 width or height\r\n    // this causes problems for the collision system so we give them some padding\r\n    return new BoundingBox(\r\n      Math.min(begin.x, end.x) - padding,\r\n      Math.min(begin.y, end.y) - padding,\r\n      Math.max(begin.x, end.x) + padding,\r\n      Math.max(begin.y, end.y) + padding\r\n    );\r\n  }\r\n\r\n  /**\r\n   * Get the axis aligned bounding box for the edge collider in world space\r\n   */\r\n  public get bounds(): BoundingBox {\r\n    const transformedBegin = this._getTransformedBegin();\r\n    const transformedEnd = this._getTransformedEnd();\r\n    return this._boundsFromBeginEnd(transformedBegin, transformedEnd);\r\n  }\r\n\r\n  /**\r\n   * Get the axis aligned bounding box for the edge collider in local space\r\n   */\r\n  public get localBounds(): BoundingBox {\r\n    return this._boundsFromBeginEnd(this.begin, this.end);\r\n  }\r\n\r\n  /**\r\n   * Returns this edge represented as a line in world coordinates\r\n   */\r\n  public asLine(): LineSegment {\r\n    return new LineSegment(this._getTransformedBegin(), this._getTransformedEnd());\r\n  }\r\n\r\n  /**\r\n   * Return this edge as a line in local line coordinates (relative to the position)\r\n   */\r\n  public asLocalLine(): LineSegment {\r\n    return new LineSegment(this.begin, this.end);\r\n  }\r\n\r\n  /**\r\n   * Get the axis associated with the edge\r\n   */\r\n  public get axes(): Vector[] {\r\n    const e = this._getTransformedEnd().sub(this._getTransformedBegin());\r\n    const edgeNormal = e.normal();\r\n\r\n    const axes = [];\r\n    axes.push(edgeNormal);\r\n    axes.push(edgeNormal.negate());\r\n    axes.push(edgeNormal.normal());\r\n    axes.push(edgeNormal.normal().negate());\r\n    return axes;\r\n  }\r\n\r\n  /**\r\n   * Get the moment of inertia for an edge\r\n   * https://en.wikipedia.org/wiki/List_of_moments_of_inertia\r\n   */\r\n  public getInertia(mass: number): number {\r\n    const length = this.end.sub(this.begin).distance() / 2;\r\n    return mass * length * length;\r\n  }\r\n\r\n  /**\r\n   * @inheritdoc\r\n   */\r\n  public update(transform: Transform): void {\r\n    this._transform = transform;\r\n  }\r\n\r\n  /**\r\n   * Project the edge along a specified axis\r\n   */\r\n  public project(axis: Vector): Projection {\r\n    const scalars = [];\r\n\r\n    const points = [this._getTransformedBegin(), this._getTransformedEnd()];\r\n    const len = points.length;\r\n    for (let i = 0; i < len; i++) {\r\n      scalars.push(points[i].dot(axis));\r\n    }\r\n\r\n    return new Projection(Math.min.apply(Math, scalars), Math.max.apply(Math, scalars));\r\n  }\r\n\r\n  public debug(ex: ExcaliburGraphicsContext, color: Color) {\r\n    const begin = this._getTransformedBegin();\r\n    const end = this._getTransformedEnd();\r\n    ex.drawLine(begin, end, color, 2);\r\n    ex.drawCircle(begin, 2, color);\r\n    ex.drawCircle(end, 2, color);\r\n  }\r\n\r\n}\r\n","import { Color } from '../../Color';\r\nimport { BoundingBox } from '../BoundingBox';\r\nimport { EdgeCollider } from './EdgeCollider';\r\nimport { CollisionJumpTable } from './CollisionJumpTable';\r\nimport { CircleCollider } from './CircleCollider';\r\nimport { CollisionContact } from '../Detection/CollisionContact';\r\nimport { Projection } from '../../Math/projection';\r\nimport { LineSegment } from '../../Math/line-segment';\r\nimport { Vector } from '../../Math/vector';\r\nimport { Matrix } from '../../Math/matrix';\r\nimport { Ray } from '../../Math/ray';\r\nimport { ClosestLineJumpTable } from './ClosestLineJumpTable';\r\nimport { Transform, TransformComponent } from '../../EntityComponentSystem';\r\nimport { Collider } from './Collider';\r\nimport { ExcaliburGraphicsContext, Logger, range } from '../..';\r\nimport { CompositeCollider } from './CompositeCollider';\r\nimport { Shape } from './Shape';\r\n\r\nexport interface PolygonColliderOptions {\r\n  /**\r\n   * Pixel offset relative to a collider's body transform position.\r\n   */\r\n  offset?: Vector;\r\n  /**\r\n   * Points in the polygon in order around the perimeter in local coordinates. These are relative from the body transform position.\r\n   */\r\n  points: Vector[];\r\n}\r\n\r\n/**\r\n * Polygon collider for detecting collisions\r\n */\r\nexport class PolygonCollider extends Collider {\r\n  private _logger = Logger.getInstance();\r\n  /**\r\n   * Pixel offset relative to a collider's body transform position.\r\n   */\r\n  public offset: Vector;\r\n\r\n  private _points: Vector[];\r\n  /**\r\n   * Points in the polygon in order around the perimeter in local coordinates. These are relative from the body transform position.\r\n   * Excalibur stores these in counter-clockwise order\r\n   */\r\n  public set points(points: Vector[]) {\r\n    this._localBoundsDirty = true;\r\n    this._points = points;\r\n  }\r\n\r\n  /**\r\n   * Points in the polygon in order around the perimeter in local coordinates. These are relative from the body transform position.\r\n   * Excalibur stores these in counter-clockwise order\r\n   */\r\n  public get points(): Vector[] {\r\n    return this._points;\r\n  }\r\n\r\n  private _transform: Transform;\r\n\r\n  private _transformedPoints: Vector[] = [];\r\n  private _axes: Vector[] = [];\r\n  private _sides: LineSegment[] = [];\r\n  private _localSides: LineSegment[] = [];\r\n\r\n  constructor(options: PolygonColliderOptions) {\r\n    super();\r\n    this.offset = options.offset ?? Vector.Zero;\r\n    this._globalMatrix.translate(this.offset.x, this.offset.y);\r\n    this.points = options.points ?? [];\r\n    const counterClockwise = this._isCounterClockwiseWinding(this.points);\r\n    if (!counterClockwise) {\r\n      this.points.reverse();\r\n    }\r\n    if (!this.isConvex()) {\r\n      this._logger.warn(\r\n        'Excalibur only supports convex polygon colliders and will not behave properly.'+\r\n        'Call PolygonCollider.triangulate() to build a new collider composed of smaller convex triangles');\r\n    }\r\n\r\n    // calculate initial transformation\r\n    this._calculateTransformation();\r\n  }\r\n\r\n  private _isCounterClockwiseWinding(points: Vector[]): boolean {\r\n    // https://stackoverflow.com/a/1165943\r\n    let sum = 0;\r\n    for (let i = 0; i < points.length; i++) {\r\n      sum += (points[(i + 1) % points.length].x - points[i].x) * (points[(i + 1) % points.length].y + points[i].y);\r\n    }\r\n    return sum < 0;\r\n  }\r\n\r\n  /**\r\n   * Returns if the polygon collider is convex, Excalibur does not handle non-convex collision shapes.\r\n   * Call [[Polygon.triangulate]] to generate a [[CompositeCollider]] from this non-convex shape\r\n   */\r\n  public isConvex(): boolean {\r\n    // From SO: https://stackoverflow.com/a/45372025\r\n    if (this.points.length < 3) {\r\n      return false;\r\n    }\r\n    let oldPoint = this.points[this.points.length - 2];\r\n    let newPoint = this.points[this.points.length - 1];\r\n    let direction = Math.atan2(newPoint.y - oldPoint.y, newPoint.x - oldPoint.x);\r\n    let oldDirection = 0;\r\n    let orientation = 0;\r\n    let angleSum = 0;\r\n    for (const [i, point] of this.points.entries()) {\r\n      oldPoint = newPoint;\r\n      oldDirection = direction;\r\n      newPoint =  point;\r\n      direction = Math.atan2(newPoint.y - oldPoint.y, newPoint.x - oldPoint.x);\r\n      if (oldPoint.equals(newPoint)) {\r\n        return false; // repeat point\r\n      }\r\n      let angle = direction - oldDirection;\r\n      if (angle <= -Math.PI){\r\n        angle += Math.PI * 2;\r\n      } else if (angle > Math.PI) {\r\n        angle -= Math.PI * 2;\r\n      }\r\n      if (i === 0) {\r\n        if (angle === 0.0) {\r\n          return false;\r\n        }\r\n        orientation = angle  > 0 ? 1 : -1;\r\n      } else {\r\n        if (orientation * angle <= 0) {\r\n          return false;\r\n        }\r\n      }\r\n      angleSum += angle;\r\n    }\r\n    return Math.abs(Math.round(angleSum / (Math.PI * 2))) === 1;\r\n  }\r\n\r\n  /**\r\n   * Tessellates the polygon into a triangle fan as a [[CompositeCollider]] of triangle polygons\r\n   */\r\n  public tessellate(): CompositeCollider {\r\n    const polygons: Vector[][] = [];\r\n    for (let i = 1; i < this.points.length - 2; i++) {\r\n      polygons.push([this.points[0], this.points[i + 1], this.points[i + 2]]);\r\n    }\r\n    polygons.push([this.points[0], this.points[1], this.points[2]]);\r\n\r\n    return new CompositeCollider(polygons.map(points => Shape.Polygon(points)));\r\n  }\r\n\r\n  /**\r\n   * Triangulate the polygon collider using the \"Ear Clipping\" algorithm.\r\n   * Returns a new [[CompositeCollider]] made up of smaller triangles.\r\n   */\r\n  public triangulate(): CompositeCollider {\r\n    // https://www.youtube.com/watch?v=hTJFcHutls8\r\n    if (this.points.length < 3) {\r\n      throw Error('Invalid polygon');\r\n    }\r\n\r\n    /**\r\n     * Helper to get a vertex in the list\r\n     */\r\n    function getItem<T>(index: number, list: T[]) {\r\n      if (index >= list.length) {\r\n        return list[index % list.length];\r\n      } else if (index < 0) {\r\n        return list[index % list.length + list.length];\r\n      } else {\r\n        return list[index];\r\n      }\r\n    }\r\n\r\n    /**\r\n     * Quick test for point in triangle\r\n     */\r\n    function isPointInTriangle(point: Vector, a: Vector, b: Vector, c: Vector) {\r\n      const ab = b.sub(a);\r\n      const bc = c.sub(b);\r\n      const ca = a.sub(c);\r\n\r\n      const ap = point.sub(a);\r\n      const bp = point.sub(b);\r\n      const cp = point.sub(c);\r\n\r\n      const cross1 = ab.cross(ap);\r\n      const cross2 = bc.cross(bp);\r\n      const cross3 = ca.cross(cp);\r\n\r\n      if (cross1 > 0 || cross2 > 0 || cross3 > 0) {\r\n        return false;\r\n      }\r\n      return true;\r\n    }\r\n\r\n    const triangles: Vector[][] = [];\r\n    const vertices = [...this.points];\r\n    const indices = range(0, this.points.length - 1);\r\n\r\n    // 1. Loop through vertices clockwise\r\n    //    if the vertex is convex (interior angle is < 180) (cross product positive)\r\n    //    if the polygon formed by it's edges doesn't contain the points\r\n    //         it's an ear add it to our list of triangles, and restart\r\n\r\n    while (indices.length > 3) {\r\n      for (let i = 0; i < indices.length; i++) {\r\n        const a = indices[i];\r\n        const b = getItem(i - 1, indices);\r\n        const c = getItem(i + 1, indices);\r\n\r\n        const va = vertices[a];\r\n        const vb = vertices[b];\r\n        const vc = vertices[c];\r\n\r\n        // Check convexity\r\n        const leftArm = vb.sub(va);\r\n        const rightArm = vc.sub(va);\r\n        const isConvex = rightArm.cross(leftArm) > 0; // positive cross means convex\r\n        if (!isConvex) {\r\n          continue;\r\n        }\r\n\r\n        let isEar = true;\r\n        // Check that if any vertices are in the triangle a, b, c\r\n        for (let j = 0; j < indices.length; j++) {\r\n          const vertIndex = indices[j];\r\n          // We can skip these\r\n          if (vertIndex === a || vertIndex === b || vertIndex === c) {\r\n            continue;\r\n          }\r\n\r\n          const point = vertices[vertIndex];\r\n          if (isPointInTriangle(point, vb, va, vc)) {\r\n            isEar = false;\r\n            break;\r\n          }\r\n        }\r\n\r\n        // Add ear to polygon list and remove from list\r\n        if (isEar) {\r\n          triangles.push([vb, va, vc]);\r\n          indices.splice(i, 1);\r\n          break;\r\n        }\r\n      }\r\n    }\r\n\r\n    triangles.push([vertices[indices[0]], vertices[indices[1]], vertices[indices[2]]]);\r\n\r\n    return new CompositeCollider(triangles.map(points => Shape.Polygon(points)));\r\n  }\r\n\r\n  /**\r\n   * Returns a clone of this ConvexPolygon, not associated with any collider\r\n   */\r\n  public clone(): PolygonCollider {\r\n    return new PolygonCollider({\r\n      offset: this.offset.clone(),\r\n      points: this.points.map((p) => p.clone())\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Returns the world position of the collider, which is the current body transform plus any defined offset\r\n   */\r\n  public get worldPos(): Vector {\r\n    if (this._transform) {\r\n      return this._transform.pos.add(this.offset);\r\n    }\r\n    return this.offset;\r\n  }\r\n\r\n  /**\r\n   * Get the center of the collider in world coordinates\r\n   */\r\n  public get center(): Vector {\r\n    return this.bounds.center;\r\n  }\r\n\r\n  private _globalMatrix: Matrix = Matrix.identity();\r\n\r\n  /**\r\n   * Calculates the underlying transformation from the body relative space to world space\r\n   */\r\n  private _calculateTransformation() {\r\n\r\n    const len = this.points.length;\r\n    this._transformedPoints.length = 0; // clear out old transform\r\n    for (let i = 0; i < len; i++) {\r\n      this._transformedPoints[i] = this._globalMatrix.multiply(this.points[i].clone());\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Gets the points that make up the polygon in world space, from actor relative space (if specified)\r\n   */\r\n  public getTransformedPoints(): Vector[] {\r\n    this._calculateTransformation();\r\n    return this._transformedPoints;\r\n  }\r\n\r\n  /**\r\n   * Gets the sides of the polygon in world space\r\n   */\r\n  public getSides(): LineSegment[] {\r\n    if (this._sides.length) {\r\n      return this._sides;\r\n    }\r\n    const lines = [];\r\n    const points = this.getTransformedPoints();\r\n    const len = points.length;\r\n    for (let i = 0; i < len; i++) {\r\n      // This winding is important\r\n      lines.push(new LineSegment(points[i], points[(i + 1) % len]));\r\n    }\r\n    this._sides = lines;\r\n    return this._sides;\r\n  }\r\n\r\n  /**\r\n   * Returns the local coordinate space sides\r\n   */\r\n  public getLocalSides(): LineSegment[] {\r\n    if (this._localSides.length) {\r\n      return this._localSides;\r\n    }\r\n    const lines = [];\r\n    const points = this.points;\r\n    const len = points.length;\r\n    for (let i = 0; i < len; i++) {\r\n      // This winding is important\r\n      lines.push(new LineSegment(points[i], points[(i + 1) % len]));\r\n    }\r\n    this._localSides = lines;\r\n    return this._localSides;\r\n  }\r\n\r\n  /**\r\n   * Given a direction vector find the world space side that is most in that direction\r\n   * @param direction\r\n   */\r\n  public findSide(direction: Vector): LineSegment {\r\n    const sides = this.getSides();\r\n    let bestSide = sides[0];\r\n    let maxDistance = -Number.MAX_VALUE;\r\n    for (let side = 0; side < sides.length; side++) {\r\n      const currentSide = sides[side];\r\n      const sideNormal = currentSide.normal();\r\n      const mostDirection = sideNormal.dot(direction);\r\n      if (mostDirection > maxDistance) {\r\n        bestSide = currentSide;\r\n        maxDistance = mostDirection;\r\n      }\r\n    }\r\n    return bestSide;\r\n  }\r\n\r\n  /**\r\n   * Given a direction vector find the local space side that is most in that direction\r\n   * @param direction\r\n   */\r\n  public findLocalSide(direction: Vector): LineSegment {\r\n    const sides = this.getLocalSides();\r\n    let bestSide = sides[0];\r\n    let maxDistance = -Number.MAX_VALUE;\r\n    for (let side = 0; side < sides.length; side++) {\r\n      const currentSide = sides[side];\r\n      const sideNormal = currentSide.normal();\r\n      const mostDirection = sideNormal.dot(direction);\r\n      if (mostDirection > maxDistance) {\r\n        bestSide = currentSide;\r\n        maxDistance = mostDirection;\r\n      }\r\n    }\r\n    return bestSide;\r\n  }\r\n\r\n  /**\r\n   * Get the axis associated with the convex polygon\r\n   */\r\n  public get axes(): Vector[] {\r\n    if (this._axes.length) {\r\n      return this._axes;\r\n    }\r\n    const axes = this.getSides().map((s) => s.normal());\r\n    this._axes = axes;\r\n    return this._axes;\r\n  }\r\n\r\n  /**\r\n   * Updates the transform for the collision geometry\r\n   *\r\n   * Collision geometry (points/bounds) will not change until this is called.\r\n   * @param transform\r\n   */\r\n  public update(transform: Transform): void {\r\n    this._transform = transform;\r\n    this._sides.length = 0;\r\n    this._localSides.length = 0;\r\n    this._axes.length = 0;\r\n    const tx = this._transform as TransformComponent;\r\n    // This change means an update must be performed in order for geometry to update\r\n    const globalMat = tx?.getGlobalMatrix() ?? this._globalMatrix;\r\n    globalMat.clone(this._globalMatrix);\r\n    this._globalMatrix.translate(this.offset.x, this.offset.y);\r\n    this.getTransformedPoints();\r\n    this.getSides();\r\n    this.getLocalSides();\r\n  }\r\n\r\n  /**\r\n   * Tests if a point is contained in this collider in world space\r\n   */\r\n  public contains(point: Vector): boolean {\r\n    // Always cast to the right, as long as we cast in a consistent fixed direction we\r\n    // will be fine\r\n    const testRay = new Ray(point, new Vector(1, 0));\r\n    const intersectCount = this.getSides().reduce(function (accum, side) {\r\n      if (testRay.intersect(side) >= 0) {\r\n        return accum + 1;\r\n      }\r\n      return accum;\r\n    }, 0);\r\n\r\n    if (intersectCount % 2 === 0) {\r\n      return false;\r\n    }\r\n    return true;\r\n  }\r\n\r\n  public getClosestLineBetween(collider: Collider): LineSegment {\r\n    if (collider instanceof CircleCollider) {\r\n      return ClosestLineJumpTable.PolygonCircleClosestLine(this, collider);\r\n    } else if (collider instanceof PolygonCollider) {\r\n      return ClosestLineJumpTable.PolygonPolygonClosestLine(this, collider);\r\n    } else if (collider instanceof EdgeCollider) {\r\n      return ClosestLineJumpTable.PolygonEdgeClosestLine(this, collider);\r\n    } else {\r\n      throw new Error(`Polygon could not collide with unknown CollisionShape ${typeof collider}`);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Returns a collision contact if the 2 colliders collide, otherwise collide will\r\n   * return null.\r\n   * @param collider\r\n   */\r\n  public collide(collider: Collider): CollisionContact[] {\r\n    if (collider instanceof CircleCollider) {\r\n      return CollisionJumpTable.CollideCirclePolygon(collider, this);\r\n    } else if (collider instanceof PolygonCollider) {\r\n      return CollisionJumpTable.CollidePolygonPolygon(this, collider);\r\n    } else if (collider instanceof EdgeCollider) {\r\n      return CollisionJumpTable.CollidePolygonEdge(this, collider);\r\n    } else {\r\n      throw new Error(`Polygon could not collide with unknown CollisionShape ${typeof collider}`);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Find the point on the collider furthest in the direction specified\r\n   */\r\n  public getFurthestPoint(direction: Vector): Vector {\r\n    const pts = this.getTransformedPoints();\r\n    let furthestPoint = null;\r\n    let maxDistance = -Number.MAX_VALUE;\r\n    for (let i = 0; i < pts.length; i++) {\r\n      const distance = direction.dot(pts[i]);\r\n      if (distance > maxDistance) {\r\n        maxDistance = distance;\r\n        furthestPoint = pts[i];\r\n      }\r\n    }\r\n    return furthestPoint;\r\n  }\r\n\r\n  /**\r\n   * Find the local point on the collider furthest in the direction specified\r\n   * @param direction\r\n   */\r\n  public getFurthestLocalPoint(direction: Vector): Vector {\r\n    const pts = this.points;\r\n    let furthestPoint = pts[0];\r\n    let maxDistance = -Number.MAX_VALUE;\r\n    for (let i = 0; i < pts.length; i++) {\r\n      const distance = direction.dot(pts[i]);\r\n      if (distance > maxDistance) {\r\n        maxDistance = distance;\r\n        furthestPoint = pts[i];\r\n      }\r\n    }\r\n    return furthestPoint;\r\n  }\r\n\r\n  /**\r\n   * Finds the closes face to the point using perpendicular distance\r\n   * @param point point to test against polygon\r\n   */\r\n  public getClosestFace(point: Vector): { distance: Vector; face: LineSegment } {\r\n    const sides = this.getSides();\r\n    let min = Number.POSITIVE_INFINITY;\r\n    let faceIndex = -1;\r\n    let distance = -1;\r\n    for (let i = 0; i < sides.length; i++) {\r\n      const dist = sides[i].distanceToPoint(point);\r\n      if (dist < min) {\r\n        min = dist;\r\n        faceIndex = i;\r\n        distance = dist;\r\n      }\r\n    }\r\n\r\n    if (faceIndex !== -1) {\r\n      return {\r\n        distance: sides[faceIndex].normal().scale(distance),\r\n        face: sides[faceIndex]\r\n      };\r\n    }\r\n\r\n    return null;\r\n  }\r\n\r\n  /**\r\n   * Get the axis aligned bounding box for the polygon collider in world coordinates\r\n   */\r\n  public get bounds(): BoundingBox {\r\n    return this.localBounds.transform(this._globalMatrix);\r\n  }\r\n\r\n  private _localBoundsDirty = true;\r\n  private _localBounds: BoundingBox;\r\n  /**\r\n   * Get the axis aligned bounding box for the polygon collider in local coordinates\r\n   */\r\n  public get localBounds(): BoundingBox {\r\n    if (this._localBoundsDirty) {\r\n      this._localBounds = BoundingBox.fromPoints(this.points);\r\n      this._localBoundsDirty = false;\r\n    }\r\n\r\n    return this._localBounds;\r\n  }\r\n\r\n  /**\r\n   * Get the moment of inertia for an arbitrary polygon\r\n   * https://en.wikipedia.org/wiki/List_of_moments_of_inertia\r\n   */\r\n  public getInertia(mass: number): number {\r\n    let numerator = 0;\r\n    let denominator = 0;\r\n    for (let i = 0; i < this.points.length; i++) {\r\n      const iplusone = (i + 1) % this.points.length;\r\n      const crossTerm = this.points[iplusone].cross(this.points[i]);\r\n      numerator +=\r\n        crossTerm *\r\n        (this.points[i].dot(this.points[i]) + this.points[i].dot(this.points[iplusone]) + this.points[iplusone].dot(this.points[iplusone]));\r\n      denominator += crossTerm;\r\n    }\r\n    return (mass / 6) * (numerator / denominator);\r\n  }\r\n\r\n  /**\r\n   * Casts a ray into the polygon and returns a vector representing the point of contact (in world space) or null if no collision.\r\n   */\r\n  public rayCast(ray: Ray, max: number = Infinity) {\r\n    // find the minimum contact time greater than 0\r\n    // contact times less than 0 are behind the ray and we don't want those\r\n    const sides = this.getSides();\r\n    const len = sides.length;\r\n    let minContactTime = Number.MAX_VALUE;\r\n    let contactIndex = -1;\r\n    for (let i = 0; i < len; i++) {\r\n      const contactTime = ray.intersect(sides[i]);\r\n      if (contactTime >= 0 && contactTime < minContactTime && contactTime <= max) {\r\n        minContactTime = contactTime;\r\n        contactIndex = i;\r\n      }\r\n    }\r\n\r\n    // contact was found\r\n    if (contactIndex >= 0) {\r\n      return ray.getPoint(minContactTime);\r\n    }\r\n\r\n    // no contact found\r\n    return null;\r\n  }\r\n\r\n  /**\r\n   * Project the edges of the polygon along a specified axis\r\n   */\r\n  public project(axis: Vector): Projection {\r\n    const points = this.getTransformedPoints();\r\n    const len = points.length;\r\n    let min = Number.MAX_VALUE;\r\n    let max = -Number.MAX_VALUE;\r\n    for (let i = 0; i < len; i++) {\r\n      const scalar = points[i].dot(axis);\r\n      min = Math.min(min, scalar);\r\n      max = Math.max(max, scalar);\r\n    }\r\n\r\n    return new Projection(min, max);\r\n  }\r\n\r\n  public debug(ex: ExcaliburGraphicsContext, color: Color) {\r\n    const firstPoint = this.getTransformedPoints()[0];\r\n    const points = [firstPoint, ...this.getTransformedPoints(), firstPoint];\r\n    for (let i = 0; i < points.length - 1; i++) {\r\n      ex.drawLine(points[i], points[i + 1], color, 2);\r\n      ex.drawCircle(points[i], 2, color);\r\n      ex.drawCircle(points[i + 1], 2, color);\r\n    }\r\n  }\r\n}\r\n","import { PolygonCollider } from './PolygonCollider';\r\nimport { CircleCollider } from './CircleCollider';\r\nimport { EdgeCollider } from './EdgeCollider';\r\nimport { BoundingBox } from '../BoundingBox';\r\nimport { vec, Vector } from '../../Math/vector';\r\nimport { CompositeCollider } from './CompositeCollider';\r\nimport { Logger } from '../..';\r\n\r\n/**\r\n * Excalibur helper for defining colliders quickly\r\n */\r\nexport class Shape {\r\n  /**\r\n   * Creates a box collider, under the hood defines a [[PolygonCollider]] collider\r\n   * @param width Width of the box\r\n   * @param height Height of the box\r\n   * @param anchor Anchor of the box (default (.5, .5)) which positions the box relative to the center of the collider's position\r\n   * @param offset Optional offset relative to the collider in local coordinates\r\n   */\r\n  static Box(width: number, height: number, anchor: Vector = Vector.Half, offset: Vector = Vector.Zero): PolygonCollider {\r\n    return new PolygonCollider({\r\n      points: new BoundingBox(-width * anchor.x, -height * anchor.y, width - width * anchor.x, height - height * anchor.y).getPoints(),\r\n      offset: offset\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Creates a new [[PolygonCollider|arbitrary polygon]] collider\r\n   *\r\n   * PolygonColliders are useful for creating convex polygon shapes\r\n   * @param points Points specified in counter clockwise\r\n   * @param offset Optional offset relative to the collider in local coordinates\r\n   */\r\n  static Polygon(points: Vector[], offset: Vector = Vector.Zero): PolygonCollider {\r\n    return new PolygonCollider({\r\n      points: points,\r\n      offset: offset\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Creates a new [[CircleCollider|circle]] collider\r\n   *\r\n   * Circle colliders are useful for balls, or to make collisions more forgiving on sharp edges\r\n   * @param radius Radius of the circle collider\r\n   * @param offset Optional offset relative to the collider in local coordinates\r\n   */\r\n  static Circle(radius: number, offset: Vector = Vector.Zero): CircleCollider {\r\n    return new CircleCollider({\r\n      radius: radius,\r\n      offset: offset\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Creates a new [[EdgeCollider|edge]] collider\r\n   *\r\n   * Edge colliders are useful for  floors, walls, and other barriers\r\n   * @param begin Beginning of the edge in local coordinates to the collider\r\n   * @param end Ending of the edge in local coordinates to the collider\r\n   */\r\n  static Edge(begin: Vector, end: Vector): EdgeCollider {\r\n    return new EdgeCollider({\r\n      begin: begin,\r\n      end: end\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Creates a new capsule shaped [[CompositeCollider]] using 2 circles and a box\r\n   *\r\n   * Capsule colliders are useful for platformers with incline or jagged floors to have a smooth\r\n   * player experience.\r\n   *\r\n   * @param width\r\n   * @param height\r\n   * @param offset Optional offset\r\n   */\r\n  static Capsule(width: number, height: number, offset = Vector.Zero): CompositeCollider {\r\n    const logger = Logger.getInstance();\r\n    if (width === height) {\r\n      logger.warn('A capsule collider with equal width and height is a circle, consider using a ex.Shape.Circle or ex.CircleCollider');\r\n    }\r\n\r\n    const vertical = height >= width;\r\n\r\n    if (vertical) {\r\n      // height > width, if equal maybe use a circle\r\n      const capsule = new CompositeCollider([\r\n        Shape.Circle(width / 2, vec(0, -height / 2 + width / 2).add(offset)),\r\n        Shape.Box(width, height - width, Vector.Half, offset),\r\n        Shape.Circle(width / 2, vec(0, height / 2 - width / 2).add(offset))\r\n      ]);\r\n      return capsule;\r\n    } else {\r\n      // width > height, if equal maybe use a circle\r\n      const capsule = new CompositeCollider([\r\n        Shape.Circle(height / 2, vec(-width / 2 + height / 2, 0).add(offset)),\r\n        Shape.Box(width - height, height, Vector.Half, offset),\r\n        Shape.Circle(height / 2, vec(width / 2 - height / 2, 0).add(offset))\r\n      ]);\r\n      return capsule;\r\n    }\r\n  }\r\n}\r\n","import { Vector } from '../Math/vector';\r\nimport { TransformComponent } from '../EntityComponentSystem';\r\nimport { Component } from '../EntityComponentSystem/Component';\r\nimport { Entity } from '../EntityComponentSystem/Entity';\r\nimport { EventDispatcher } from '../EventDispatcher';\r\nimport { CollisionEndEvent, CollisionStartEvent, PostCollisionEvent, PreCollisionEvent } from '../Events';\r\nimport { Observable } from '../Util/Observable';\r\nimport { BoundingBox } from './BoundingBox';\r\nimport { CollisionContact } from './Detection/CollisionContact';\r\nimport { CircleCollider } from './Colliders/CircleCollider';\r\nimport { Collider } from './Colliders/Collider';\r\nimport { CompositeCollider } from './Colliders/CompositeCollider';\r\nimport { PolygonCollider } from './Colliders/PolygonCollider';\r\nimport { EdgeCollider } from './Colliders/EdgeCollider';\r\nimport { Shape } from './Colliders/Shape';\r\n\r\nexport class ColliderComponent extends Component<'ex.collider'> {\r\n  public readonly type = 'ex.collider';\r\n\r\n  public events = new EventDispatcher();\r\n  /**\r\n   * Observable that notifies when a collider is added to the body\r\n   */\r\n  public $colliderAdded = new Observable<Collider>();\r\n\r\n  /**\r\n   * Observable that notifies when a collider is removed from the body\r\n   */\r\n  public $colliderRemoved = new Observable<Collider>();\r\n\r\n  constructor(collider?: Collider) {\r\n    super();\r\n    this.set(collider);\r\n  }\r\n\r\n  private _collider: Collider;\r\n  /**\r\n   * Get the current collider geometry\r\n   */\r\n  public get() {\r\n    return this._collider;\r\n  }\r\n\r\n  /**\r\n   * Set the collider geometry\r\n   * @param collider\r\n   * @returns the collider you set\r\n   */\r\n  public set<T extends Collider>(collider: T): T {\r\n    this.clear();\r\n    if (collider) {\r\n      this._collider = collider;\r\n      this._collider.owner = this.owner;\r\n      this.events.wire(collider.events);\r\n      this.$colliderAdded.notifyAll(collider);\r\n      this.update();\r\n    }\r\n    return collider;\r\n  }\r\n\r\n  /**\r\n   * Remove collider geometry from collider component\r\n   */\r\n  public clear() {\r\n    if (this._collider) {\r\n      this.events.unwire(this._collider.events);\r\n      this.$colliderRemoved.notifyAll(this._collider);\r\n      this._collider.owner = null;\r\n      this._collider = null;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Return world space bounds\r\n   */\r\n  public get bounds() {\r\n    return this._collider?.bounds ?? new BoundingBox();\r\n  }\r\n\r\n  /**\r\n   * Return local space bounds\r\n   */\r\n  public get localBounds() {\r\n    return this._collider?.localBounds ?? new BoundingBox();\r\n  }\r\n\r\n  /**\r\n   * Update the collider's transformed geometry\r\n   */\r\n  public update() {\r\n    const tx = this.owner?.get(TransformComponent);\r\n    if (this._collider) {\r\n      this._collider.owner = this.owner;\r\n      if (tx) {\r\n        this._collider.update(tx);\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Collide component with another\r\n   * @param other\r\n   */\r\n  collide(other: ColliderComponent): CollisionContact[] {\r\n    let colliderA = this._collider;\r\n    let colliderB = other._collider;\r\n    if (!colliderA || !colliderB) {\r\n      return [];\r\n    }\r\n\r\n    // If we have a composite lefthand side :(\r\n    // Might bite us, but to avoid updating all the handlers make composite always left side\r\n    let flipped = false;\r\n    if (colliderB instanceof CompositeCollider) {\r\n      colliderA = colliderB;\r\n      colliderB = this._collider;\r\n      flipped = true;\r\n    }\r\n\r\n    if (this._collider) {\r\n      const contacts = colliderA.collide(colliderB);\r\n      if (contacts) {\r\n        if (flipped) {\r\n          contacts.forEach((contact) => {\r\n            contact.mtv = contact.mtv.negate();\r\n            contact.normal = contact.normal.negate();\r\n            contact.tangent = contact.normal.perpendicular();\r\n            contact.colliderA = this._collider;\r\n            contact.colliderB = other._collider;\r\n          });\r\n        }\r\n        return contacts;\r\n      }\r\n      return [];\r\n    }\r\n    return [];\r\n  }\r\n\r\n  onAdd(entity: Entity) {\r\n    if (this._collider) {\r\n      this.update();\r\n    }\r\n    // Wire up the collider events to the owning entity\r\n    this.events.on('precollision', (evt: any) => {\r\n      const precollision = evt as PreCollisionEvent<Collider>;\r\n      entity.events.emit(\r\n        'precollision',\r\n        new PreCollisionEvent(precollision.target.owner, precollision.other.owner, precollision.side, precollision.intersection)\r\n      );\r\n    });\r\n    this.events.on('postcollision', (evt: any) => {\r\n      const postcollision = evt as PostCollisionEvent<Collider>;\r\n      entity.events.emit(\r\n        'postcollision',\r\n        new PostCollisionEvent(postcollision.target.owner, postcollision.other.owner, postcollision.side, postcollision.intersection)\r\n      );\r\n    });\r\n    this.events.on('collisionstart', (evt: any) => {\r\n      const start = evt as CollisionStartEvent<Collider>;\r\n      entity.events.emit('collisionstart', new CollisionStartEvent(start.target.owner, start.other.owner, start.contact));\r\n    });\r\n    this.events.on('collisionend', (evt: any) => {\r\n      const end = evt as CollisionEndEvent<Collider>;\r\n      entity.events.emit('collisionend', new CollisionEndEvent(end.target.owner, end.other.owner));\r\n    });\r\n  }\r\n\r\n  onRemove() {\r\n    this.events.clear();\r\n    this.$colliderRemoved.notifyAll(this._collider);\r\n  }\r\n\r\n  /**\r\n   * Sets up a box geometry based on the current bounds of the associated actor of this physics body.\r\n   *\r\n   * If no width/height are specified the body will attempt to use the associated actor's width/height.\r\n   *\r\n   * By default, the box is center is at (0, 0) which means it is centered around the actors anchor.\r\n   */\r\n  useBoxCollider(width: number, height: number, anchor: Vector = Vector.Half, center: Vector = Vector.Zero): PolygonCollider {\r\n    const collider = Shape.Box(width, height, anchor, center);\r\n    return (this.set(collider));\r\n  }\r\n\r\n  /**\r\n   * Sets up a [[PolygonCollider|polygon]] collision geometry based on a list of of points relative\r\n   *  to the anchor of the associated actor\r\n   * of this physics body.\r\n   *\r\n   * Only [convex polygon](https://en.wikipedia.org/wiki/Convex_polygon) definitions are supported.\r\n   *\r\n   * By default, the box is center is at (0, 0) which means it is centered around the actors anchor.\r\n   */\r\n  usePolygonCollider(points: Vector[], center: Vector = Vector.Zero): PolygonCollider {\r\n    const poly = Shape.Polygon(points, center);\r\n    return (this.set(poly));\r\n  }\r\n\r\n  /**\r\n   * Sets up a [[Circle|circle collision geometry]] as the only collider with a specified radius in pixels.\r\n   *\r\n   * By default, the box is center is at (0, 0) which means it is centered around the actors anchor.\r\n   */\r\n  useCircleCollider(radius: number, center: Vector = Vector.Zero): CircleCollider {\r\n    const collider = Shape.Circle(radius, center);\r\n    return (this.set(collider));\r\n  }\r\n\r\n  /**\r\n   * Sets up an [[Edge|edge collision geometry]] with a start point and an end point relative to the anchor of the associated actor\r\n   * of this physics body.\r\n   *\r\n   * By default, the box is center is at (0, 0) which means it is centered around the actors anchor.\r\n   */\r\n  useEdgeCollider(begin: Vector, end: Vector): EdgeCollider {\r\n    const collider = Shape.Edge(begin, end);\r\n    return (this.set(collider));\r\n  }\r\n\r\n  /**\r\n   * Setups up a [[CompositeCollider]] which can define any arbitrary set of excalibur colliders\r\n   * @param colliders\r\n   */\r\n  useCompositeCollider(colliders: Collider[]): CompositeCollider {\r\n    return (this.set(new CompositeCollider(colliders)));\r\n  }\r\n}\r\n","import { Vector } from '../Math/vector';\r\nimport { CollisionType } from './CollisionType';\r\nimport { Physics } from './Physics';\r\nimport { Clonable } from '../Interfaces/Clonable';\r\nimport { TransformComponent } from '../EntityComponentSystem/Components/TransformComponent';\r\nimport { MotionComponent } from '../EntityComponentSystem/Components/MotionComponent';\r\nimport { Component } from '../EntityComponentSystem/Component';\r\nimport { CollisionGroup } from './Group/CollisionGroup';\r\nimport { EventDispatcher } from '../EventDispatcher';\r\nimport { createId, Id } from '../Id';\r\nimport { clamp } from '../Math/util';\r\nimport { ColliderComponent } from './ColliderComponent';\r\nimport { Matrix } from '../Math/matrix';\r\n\r\nexport interface BodyComponentOptions {\r\n  type?: CollisionType;\r\n  group?: CollisionGroup;\r\n  useGravity?: boolean;\r\n}\r\n\r\nexport enum DegreeOfFreedom {\r\n  Rotation = 'rotation',\r\n  X = 'x',\r\n  Y = 'y'\r\n}\r\n\r\n/**\r\n * Body describes all the physical properties pos, vel, acc, rotation, angular velocity for the purpose of\r\n * of physics simulation.\r\n */\r\nexport class BodyComponent extends Component<'ex.body'> implements Clonable<BodyComponent> {\r\n  public readonly type = 'ex.body';\r\n  public dependencies = [TransformComponent, MotionComponent];\r\n  public static _ID = 0;\r\n  public readonly id: Id<'body'> = createId('body', BodyComponent._ID++);\r\n  public events = new EventDispatcher();\r\n\r\n  private _oldTransform = Matrix.identity();\r\n\r\n  constructor(options?: BodyComponentOptions) {\r\n    super();\r\n    if (options) {\r\n      this.collisionType = options.type ?? this.collisionType;\r\n      this.group = options.group ?? this.group;\r\n      this.useGravity = options.useGravity ?? this.useGravity;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Collision type for the rigidbody physics simulation, by default [[CollisionType.PreventCollision]]\r\n   */\r\n  public collisionType: CollisionType = CollisionType.PreventCollision;\r\n\r\n  /**\r\n   * The collision group for the body's colliders, by default body colliders collide with everything\r\n   */\r\n  public group: CollisionGroup = CollisionGroup.All;\r\n\r\n  /**\r\n   * The amount of mass the body has\r\n   */\r\n  public mass: number = Physics.defaultMass;\r\n\r\n  /**\r\n   * The inverse mass (1/mass) of the body. If [[CollisionType.Fixed]] this is 0, meaning \"infinite\" mass\r\n   */\r\n  public get inverseMass(): number {\r\n    return this.collisionType === CollisionType.Fixed ? 0 : 1 / this.mass;\r\n  }\r\n\r\n  /**\r\n   * Amount of \"motion\" the body has before sleeping. If below [[Physics.sleepEpsilon]] it goes to \"sleep\"\r\n   */\r\n  public sleepMotion: number = Physics.sleepEpsilon * 5;\r\n\r\n  /**\r\n   * Can this body sleep, by default bodies do not sleep\r\n   */\r\n  public canSleep: boolean = Physics.bodiesCanSleepByDefault;\r\n\r\n  private _sleeping = false;\r\n  /**\r\n   * Whether this body is sleeping or not\r\n   */\r\n  public get sleeping(): boolean {\r\n    return this._sleeping;\r\n  }\r\n\r\n  /**\r\n   * Set the sleep state of the body\r\n   * @param sleeping\r\n   */\r\n  public setSleeping(sleeping: boolean) {\r\n    this._sleeping = sleeping;\r\n    if (!sleeping) {\r\n      // Give it a kick to keep it from falling asleep immediately\r\n      this.sleepMotion = Physics.sleepEpsilon * 5;\r\n    } else {\r\n      this.vel = Vector.Zero;\r\n      this.acc = Vector.Zero;\r\n      this.angularVelocity = 0;\r\n      this.sleepMotion = 0;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Update body's [[BodyComponent.sleepMotion]] for the purpose of sleeping\r\n   */\r\n  public updateMotion() {\r\n    if (this._sleeping) {\r\n      this.setSleeping(true);\r\n    }\r\n    const currentMotion = this.vel.size * this.vel.size + Math.abs(this.angularVelocity * this.angularVelocity);\r\n    const bias = Physics.sleepBias;\r\n    this.sleepMotion = bias * this.sleepMotion + (1 - bias) * currentMotion;\r\n    this.sleepMotion = clamp(this.sleepMotion, 0, 10 * Physics.sleepEpsilon);\r\n    if (this.canSleep && this.sleepMotion < Physics.sleepEpsilon) {\r\n      this.setSleeping(true);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get the moment of inertia from the [[ColliderComponent]]\r\n   */\r\n  public get inertia() {\r\n    // Inertia is a property of the geometry, so this is a little goofy but seems to be okay?\r\n    const collider = this.owner.get(ColliderComponent);\r\n    if (collider?.get()) {\r\n      return collider.get().getInertia(this.mass);\r\n    }\r\n    return 0;\r\n  }\r\n\r\n  /**\r\n   * Get the inverse moment of inertial from the [[ColliderComponent]]. If [[CollisionType.Fixed]] this is 0, meaning \"infinite\" mass\r\n   */\r\n  public get inverseInertia() {\r\n    return this.collisionType === CollisionType.Fixed ? 0 : 1 / this.inertia;\r\n  }\r\n\r\n  /**\r\n   * The also known as coefficient of restitution of this actor, represents the amount of energy preserved after collision or the\r\n   * bounciness. If 1, it is 100% bouncy, 0 it completely absorbs.\r\n   */\r\n  public bounciness: number = 0.2;\r\n\r\n  /**\r\n   * The coefficient of friction on this actor\r\n   */\r\n  public friction: number = 0.99;\r\n\r\n  /**\r\n   * Should use global gravity [[Physics.gravity]] in it's physics simulation, default is true\r\n   */\r\n  public useGravity: boolean = true;\r\n\r\n  /**\r\n   * Degrees of freedom to limit\r\n   */\r\n  public limitDegreeOfFreedom: DegreeOfFreedom[] = [];\r\n\r\n  /**\r\n   * Returns if the owner is active\r\n   */\r\n  public get active() {\r\n    return !!this.owner?.active;\r\n  }\r\n\r\n  public get center() {\r\n    return this.pos;\r\n  }\r\n\r\n  public get transform(): TransformComponent {\r\n    return this.owner?.get(TransformComponent);\r\n  }\r\n\r\n  public get motion(): MotionComponent {\r\n    return this.owner?.get(MotionComponent);\r\n  }\r\n\r\n  /**\r\n   * The (x, y) position of the actor this will be in the middle of the actor if the\r\n   * [[Actor.anchor]] is set to (0.5, 0.5) which is default.\r\n   * If you want the (x, y) position to be the top left of the actor specify an anchor of (0, 0).\r\n   */\r\n  public get pos(): Vector {\r\n    return this.transform.globalPos;\r\n  }\r\n\r\n  public set pos(val: Vector) {\r\n    this.transform.globalPos = val;\r\n  }\r\n\r\n  /**\r\n   * The position of the actor last frame (x, y) in pixels\r\n   */\r\n  public get oldPos(): Vector {\r\n    return this._oldTransform.getPosition();\r\n  }\r\n\r\n  /**\r\n   * The current velocity vector (vx, vy) of the actor in pixels/second\r\n   */\r\n  public get vel(): Vector {\r\n    return this.motion.vel;\r\n  }\r\n\r\n  public set vel(val: Vector) {\r\n    this.motion.vel = val;\r\n  }\r\n\r\n  /**\r\n   * The velocity of the actor last frame (vx, vy) in pixels/second\r\n   */\r\n  public oldVel: Vector = new Vector(0, 0);\r\n\r\n  /**\r\n   * The current acceleration vector (ax, ay) of the actor in pixels/second/second. An acceleration pointing down such as (0, 100) may\r\n   * be useful to simulate a gravitational effect.\r\n   */\r\n  public get acc(): Vector {\r\n    return this.motion.acc;\r\n  }\r\n\r\n  public set acc(val: Vector) {\r\n    this.motion.acc = val;\r\n  }\r\n\r\n  /**\r\n   * Gets/sets the acceleration of the actor from the last frame. This does not include the global acc [[Physics.acc]].\r\n   */\r\n  public oldAcc: Vector = Vector.Zero;\r\n\r\n  /**\r\n   * The current torque applied to the actor\r\n   */\r\n  public get torque(): number {\r\n    return this.motion.torque;\r\n  }\r\n\r\n  public set torque(val: number) {\r\n    this.motion.torque = val;\r\n  }\r\n\r\n  /**\r\n   * Gets/sets the rotation of the body from the last frame.\r\n   */\r\n  public get oldRotation(): number {\r\n    return this._oldTransform.getRotation();\r\n  }\r\n\r\n  /**\r\n   * The rotation of the body in radians\r\n   */\r\n  public get rotation() {\r\n    return this.transform.globalRotation;\r\n  }\r\n\r\n  public set rotation(val: number) {\r\n    this.transform.globalRotation = val;\r\n  }\r\n\r\n  /**\r\n   * The scale vector of the actor\r\n   */\r\n  public get scale(): Vector {\r\n    return this.transform.globalScale;\r\n  }\r\n\r\n  public set scale(val: Vector) {\r\n    this.transform.globalScale = val;\r\n  }\r\n\r\n  /**\r\n   * The scale of the actor last frame\r\n   */\r\n  public get oldScale(): Vector {\r\n    return this._oldTransform.getScale();\r\n  }\r\n\r\n  /**\r\n   * The scale rate of change of the actor in scale/second\r\n   */\r\n  public get scaleFactor(): Vector {\r\n    return this.motion.scaleFactor;\r\n  }\r\n\r\n  public set scaleFactor(scaleFactor: Vector) {\r\n    this.motion.scaleFactor = scaleFactor;\r\n  }\r\n\r\n  /**\r\n   * Get the angular velocity in radians/second\r\n   */\r\n  public get angularVelocity(): number {\r\n    return this.motion.angularVelocity;\r\n  }\r\n\r\n  /**\r\n   * Set the angular velocity in radians/second\r\n   */\r\n  public set angularVelocity(value: number) {\r\n    this.motion.angularVelocity = value;\r\n  }\r\n\r\n  /**\r\n   * Apply a specific impulse to the body\r\n   * @param point\r\n   * @param impulse\r\n   */\r\n  public applyImpulse(point: Vector, impulse: Vector) {\r\n    if (this.collisionType !== CollisionType.Active) {\r\n      return; // only active objects participate in the simulation\r\n    }\r\n\r\n    const finalImpulse = impulse.scale(this.inverseMass);\r\n    if (this.limitDegreeOfFreedom.includes(DegreeOfFreedom.X)) {\r\n      finalImpulse.x = 0;\r\n    }\r\n    if (this.limitDegreeOfFreedom.includes(DegreeOfFreedom.Y)) {\r\n      finalImpulse.y = 0;\r\n    }\r\n\r\n    this.vel.addEqual(finalImpulse);\r\n\r\n    if (!this.limitDegreeOfFreedom.includes(DegreeOfFreedom.Rotation)) {\r\n      const distanceFromCenter = point.sub(this.pos);\r\n      this.angularVelocity += this.inverseInertia * distanceFromCenter.cross(impulse);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Apply only linear impulse to the body\r\n   * @param impulse\r\n   */\r\n  public applyLinearImpulse(impulse: Vector) {\r\n    if (this.collisionType !== CollisionType.Active) {\r\n      return; // only active objects participate in the simulation\r\n    }\r\n\r\n    const finalImpulse = impulse.scale(this.inverseMass);\r\n\r\n    if (this.limitDegreeOfFreedom.includes(DegreeOfFreedom.X)) {\r\n      finalImpulse.x = 0;\r\n    }\r\n    if (this.limitDegreeOfFreedom.includes(DegreeOfFreedom.Y)) {\r\n      finalImpulse.y = 0;\r\n    }\r\n\r\n    this.vel = this.vel.add(finalImpulse);\r\n  }\r\n\r\n  /**\r\n   * Apply only angular impulse to the body\r\n   * @param point\r\n   * @param impulse\r\n   */\r\n  public applyAngularImpulse(point: Vector, impulse: Vector) {\r\n    if (this.collisionType !== CollisionType.Active) {\r\n      return; // only active objects participate in the simulation\r\n    }\r\n\r\n    if (!this.limitDegreeOfFreedom.includes(DegreeOfFreedom.Rotation)) {\r\n      const distanceFromCenter = point.sub(this.pos);\r\n      this.angularVelocity += this.inverseInertia * distanceFromCenter.cross(impulse);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Sets the old versions of pos, vel, acc, and scale.\r\n   */\r\n  public captureOldTransform() {\r\n    // Capture old values before integration step updates them\r\n    this.transform.getGlobalMatrix().clone(this._oldTransform);\r\n    this.oldVel.setTo(this.vel.x, this.vel.y);\r\n    this.oldAcc.setTo(this.acc.x, this.acc.y);\r\n  }\r\n}\r\n","import { Component, ComponentCtor, TagComponent } from './Component';\r\n\r\nimport { Observable, Message } from '../Util/Observable';\r\nimport { Class } from '../Class';\r\nimport { OnInitialize, OnPreUpdate, OnPostUpdate } from '../Interfaces/LifecycleEvents';\r\nimport { Engine } from '../Engine';\r\nimport { InitializeEvent, PreUpdateEvent, PostUpdateEvent } from '../Events';\r\nimport { EventDispatcher } from '../EventDispatcher';\r\nimport { Util } from '..';\r\n\r\n/**\r\n * Interface holding an entity component pair\r\n */\r\nexport interface EntityComponent {\r\n  component: Component;\r\n  entity: Entity;\r\n}\r\n\r\n/**\r\n * AddedComponent message\r\n */\r\nexport class AddedComponent implements Message<EntityComponent> {\r\n  readonly type: 'Component Added' = 'Component Added';\r\n  constructor(public data: EntityComponent) {}\r\n}\r\n\r\n/**\r\n * Type guard to know if message is f an Added Component\r\n */\r\nexport function isAddedComponent(x: Message<EntityComponent>): x is AddedComponent {\r\n  return !!x && x.type === 'Component Added';\r\n}\r\n\r\n/**\r\n * RemovedComponent message\r\n */\r\nexport class RemovedComponent implements Message<EntityComponent> {\r\n  readonly type: 'Component Removed' = 'Component Removed';\r\n  constructor(public data: EntityComponent) {}\r\n}\r\n\r\n/**\r\n * Type guard to know if message is for a Removed Component\r\n */\r\nexport function isRemovedComponent(x: Message<EntityComponent>): x is RemovedComponent {\r\n  return !!x && x.type === 'Component Removed';\r\n}\r\n\r\n/**\r\n * An Entity is the base type of anything that can have behavior in Excalibur, they are part of the built in entity component system\r\n *\r\n * Entities can be strongly typed with the components they contain\r\n *\r\n * ```typescript\r\n * const entity = new Entity<ComponentA | ComponentB>();\r\n * entity.components.a; // Type ComponentA\r\n * entity.components.b; // Type ComponentB\r\n * ```\r\n */\r\nexport class Entity extends Class implements OnInitialize, OnPreUpdate, OnPostUpdate {\r\n  private static _ID = 0;\r\n\r\n  constructor(components?: Component[], name?: string) {\r\n    super();\r\n    this._setName(name);\r\n    if (components) {\r\n      for (const component of components) {\r\n        this.addComponent(component);\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * The unique identifier for the entity\r\n   */\r\n  public id: number = Entity._ID++;\r\n\r\n  private _name: string = 'anonymous';\r\n  protected _setName(name: string) {\r\n    if (name) {\r\n      this._name = name;\r\n    }\r\n  }\r\n  public get name(): string {\r\n    return this._name;\r\n  }\r\n\r\n  public get events(): EventDispatcher {\r\n    return this.eventDispatcher;\r\n  }\r\n\r\n  /**\r\n   * Whether this entity is active, if set to false it will be reclaimed\r\n   */\r\n  public active: boolean = true;\r\n\r\n  /**\r\n   * Kill the entity, means it will no longer be updated. Kills are deferred to the end of the update.\r\n   */\r\n  public kill() {\r\n    this.active = false;\r\n  }\r\n\r\n  public isKilled() {\r\n    return !this.active;\r\n  }\r\n\r\n  /**\r\n   * Specifically get the tags on the entity from [[TagComponent]]\r\n   */\r\n  public get tags(): readonly string[] {\r\n    return this._tagsMemo;\r\n  }\r\n\r\n  /**\r\n   * Check if a tag exists on the entity\r\n   * @param tag name to check for\r\n   */\r\n  public hasTag(tag: string): boolean {\r\n    return this.tags.includes(tag);\r\n  }\r\n\r\n  /**\r\n   * Adds a tag to an entity\r\n   * @param tag\r\n   * @returns Entity\r\n   */\r\n  public addTag(tag: string) {\r\n    return this.addComponent(new TagComponent(tag));\r\n  }\r\n\r\n  /**\r\n   * Removes a tag on the entity\r\n   *\r\n   * Removals are deferred until the end of update\r\n   * @param tag\r\n   * @param force Remove component immediately, no deferred\r\n   */\r\n  public removeTag(tag: string, force = false) {\r\n    return this.removeComponent(tag, force);\r\n  }\r\n\r\n  /**\r\n   * The types of the components on the Entity\r\n   */\r\n  public get types(): string[] {\r\n    return this._typesMemo;\r\n  }\r\n\r\n  /**\r\n   * Bucket to hold on to deferred removals\r\n   */\r\n  private _componentsToRemove: (Component | string)[] = [];\r\n  private _componentTypeToInstance = new Map<ComponentCtor, Component>();\r\n  private _componentStringToInstance = new Map<string, Component>();\r\n\r\n  private _tagsMemo: string[] = [];\r\n  private _typesMemo: string[] = [];\r\n  private _rebuildMemos() {\r\n    this._tagsMemo = Array.from(this._componentStringToInstance.values())\r\n      .filter((c) => c instanceof TagComponent)\r\n      .map((c) => c.type);\r\n    this._typesMemo = Array.from(this._componentStringToInstance.keys());\r\n  }\r\n\r\n  public getComponents(): Component[] {\r\n    return Array.from(this._componentStringToInstance.values());\r\n  }\r\n\r\n  /**\r\n   * Observable that keeps track of component add or remove changes on the entity\r\n   */\r\n  public componentAdded$ = new Observable<AddedComponent>();\r\n  private _notifyAddComponent(component: Component) {\r\n    this._rebuildMemos();\r\n    const added = new AddedComponent({\r\n      component,\r\n      entity: this\r\n    });\r\n    this.componentAdded$.notifyAll(added);\r\n  }\r\n\r\n  public componentRemoved$ = new Observable<RemovedComponent>();\r\n  private _notifyRemoveComponent(component: Component) {\r\n    const removed = new RemovedComponent({\r\n      component,\r\n      entity: this\r\n    });\r\n    this.componentRemoved$.notifyAll(removed);\r\n    this._rebuildMemos();\r\n  }\r\n\r\n  private _parent: Entity = null;\r\n  public get parent(): Entity {\r\n    return this._parent;\r\n  }\r\n\r\n  public childrenAdded$ = new Observable<Entity>();\r\n  public childrenRemoved$ = new Observable<Entity>();\r\n\r\n  private _children: Entity[] = [];\r\n  /**\r\n   * Get the direct children of this entity\r\n   */\r\n  public get children(): readonly Entity[] {\r\n    return this._children;\r\n  }\r\n\r\n  /**\r\n   * Unparents this entity, if there is a parent. Otherwise it does nothing.\r\n   */\r\n  public unparent() {\r\n    if (this._parent) {\r\n      this._parent.removeChild(this);\r\n      this._parent = null;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Adds an entity to be a child of this entity\r\n   * @param entity\r\n   */\r\n  public addChild(entity: Entity): Entity {\r\n    if (entity.parent === null) {\r\n      if (this.getAncestors().includes(entity)) {\r\n        throw new Error('Cycle detected, cannot add entity');\r\n      }\r\n      this._children.push(entity);\r\n      entity._parent = this;\r\n      this.childrenAdded$.notifyAll(entity);\r\n    } else {\r\n      throw new Error('Entity already has a parent, cannot add without unparenting');\r\n    }\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Remove an entity from children if it exists\r\n   * @param entity\r\n   */\r\n  public removeChild(entity: Entity): Entity {\r\n    if (entity.parent === this) {\r\n      Util.removeItemFromArray(entity, this._children);\r\n      entity._parent = null;\r\n      this.childrenRemoved$.notifyAll(entity);\r\n    }\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Removes all children from this entity\r\n   */\r\n  public removeAllChildren(): Entity {\r\n    this.children.forEach((c) => {\r\n      this.removeChild(c);\r\n    });\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Returns a list of parent entities starting with the topmost parent. Includes the current entity.\r\n   */\r\n  public getAncestors(): Entity[] {\r\n    const result: Entity[] = [this];\r\n    let current = this.parent;\r\n    while (current) {\r\n      result.push(current);\r\n      current = current.parent;\r\n    }\r\n    return result.reverse();\r\n  }\r\n\r\n  /**\r\n   * Returns a list of all the entities that descend from this entity. Includes the current entity.\r\n   */\r\n  public getDescendants(): Entity[] {\r\n    let result: Entity[] = [this];\r\n    let queue: Entity[] = [this];\r\n    while (queue.length > 0) {\r\n      const curr = queue.pop();\r\n      queue = queue.concat(curr.children);\r\n      result = result.concat(curr.children);\r\n    }\r\n    return result;\r\n  }\r\n\r\n  /**\r\n   * Creates a deep copy of the entity and a copy of all its components\r\n   */\r\n  public clone(): Entity {\r\n    const newEntity = new Entity();\r\n    for (const c of this.types) {\r\n      newEntity.addComponent(this.get(c).clone());\r\n    }\r\n    for (const child of this.children) {\r\n      newEntity.addChild(child.clone());\r\n    }\r\n    return newEntity;\r\n  }\r\n\r\n  /**\r\n   * Adds a copy of all the components from another template entity as a \"prefab\"\r\n   * @param templateEntity Entity to use as a template\r\n   * @param force Force component replacement if it already exists on the target entity\r\n   */\r\n  public addTemplate(templateEntity: Entity, force: boolean = false): Entity {\r\n    for (const c of templateEntity.getComponents()) {\r\n      this.addComponent(c.clone(), force);\r\n    }\r\n    for (const child of templateEntity.children) {\r\n      this.addChild(child.clone().addTemplate(child));\r\n    }\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Adds a component to the entity\r\n   * @param component Component or Entity to add copy of components from\r\n   * @param force Optionally overwrite any existing components of the same type\r\n   */\r\n  public addComponent<T extends Component>(component: T, force: boolean = false): Entity {\r\n    // if component already exists, skip if not forced\r\n    if (this.has(component.type)) {\r\n      if (force) {\r\n        // Remove existing component type if exists when forced\r\n        this.removeComponent(component);\r\n      } else {\r\n        // early exit component exits\r\n        return this;\r\n      }\r\n    }\r\n\r\n    // TODO circular dependencies will be a problem\r\n    if (component.dependencies && component.dependencies.length) {\r\n      for (const ctor of component.dependencies) {\r\n        this.addComponent(new ctor());\r\n      }\r\n    }\r\n\r\n    component.owner = this;\r\n    const constuctorType = component.constructor as ComponentCtor<T>;\r\n    this._componentTypeToInstance.set(constuctorType, component);\r\n    this._componentStringToInstance.set(component.type, component);\r\n    if (component.onAdd) {\r\n      component.onAdd(this);\r\n    }\r\n    this._notifyAddComponent(component);\r\n\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Removes a component from the entity, by default removals are deferred to the end of entity update to avoid consistency issues\r\n   *\r\n   * Components can be force removed with the `force` flag, the removal is not deferred and happens immediately\r\n   * @param componentOrType\r\n   * @param force\r\n   */\r\n  public removeComponent<ComponentOrType extends string | Component>(componentOrType: ComponentOrType, force = false): Entity {\r\n    if (force) {\r\n      if (typeof componentOrType === 'string') {\r\n        this._removeComponentByType(componentOrType);\r\n      } else if (componentOrType instanceof Component) {\r\n        this._removeComponentByType(componentOrType.type);\r\n      }\r\n    } else {\r\n      this._componentsToRemove.push(componentOrType);\r\n    }\r\n\r\n    return this as any;\r\n  }\r\n\r\n  private _removeComponentByType(type: string) {\r\n    if (this.has(type)) {\r\n      const component = this.get(type);\r\n      component.owner = null;\r\n      if (component.onRemove) {\r\n        component.onRemove(this);\r\n      }\r\n      const ctor = component.constructor as ComponentCtor;\r\n      this._componentTypeToInstance.delete(ctor);\r\n      this._componentStringToInstance.delete(component.type);\r\n      this._notifyRemoveComponent(component);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @hidden\r\n   * @internal\r\n   */\r\n  public processComponentRemoval() {\r\n    for (const componentOrType of this._componentsToRemove) {\r\n      const type = typeof componentOrType === 'string' ? componentOrType : componentOrType.type;\r\n      this._removeComponentByType(type);\r\n    }\r\n    this._componentsToRemove.length = 0;\r\n  }\r\n\r\n  /**\r\n   * Check if a component type exists\r\n   * @param type\r\n   */\r\n  public has<T extends Component>(type: ComponentCtor<T>): boolean;\r\n  public has(type: string): boolean;\r\n  public has<T extends Component>(type: ComponentCtor<T> | string): boolean {\r\n    if (typeof type === 'string') {\r\n      return this._componentStringToInstance.has(type);\r\n    } else {\r\n      return this._componentTypeToInstance.has(type);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get a component by type with typecheck\r\n   *\r\n   * (Does not work on tag components, use .hasTag(\"mytag\") instead)\r\n   * @param type\r\n   */\r\n  public get<T extends Component>(type: ComponentCtor<T>): T | null;\r\n  public get<T extends Component>(type: string): T | null;\r\n  public get<T extends Component>(type: ComponentCtor<T> | string): T | null {\r\n    if (typeof type === 'string') {\r\n      return this._componentStringToInstance.get(type) as T;\r\n    } else {\r\n      return this._componentTypeToInstance.get(type) as T;\r\n    }\r\n  }\r\n\r\n  private _isInitialized = false;\r\n\r\n  /**\r\n   * Gets whether the actor is Initialized\r\n   */\r\n  public get isInitialized(): boolean {\r\n    return this._isInitialized;\r\n  }\r\n\r\n  /**\r\n   * Initializes this entity, meant to be called by the Scene before first update not by users of Excalibur.\r\n   *\r\n   * It is not recommended that internal excalibur methods be overridden, do so at your own risk.\r\n   *\r\n   * @internal\r\n   */\r\n  public _initialize(engine: Engine) {\r\n    if (!this.isInitialized) {\r\n      this.onInitialize(engine);\r\n      super.emit('initialize', new InitializeEvent(engine, this));\r\n      this._isInitialized = true;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * It is not recommended that internal excalibur methods be overridden, do so at your own risk.\r\n   *\r\n   * Internal _preupdate handler for [[onPreUpdate]] lifecycle event\r\n   * @internal\r\n   */\r\n  public _preupdate(engine: Engine, delta: number): void {\r\n    this.emit('preupdate', new PreUpdateEvent(engine, delta, this));\r\n    this.onPreUpdate(engine, delta);\r\n  }\r\n\r\n  /**\r\n   * It is not recommended that internal excalibur methods be overridden, do so at your own risk.\r\n   *\r\n   * Internal _preupdate handler for [[onPostUpdate]] lifecycle event\r\n   * @internal\r\n   */\r\n  public _postupdate(engine: Engine, delta: number): void {\r\n    this.emit('postupdate', new PostUpdateEvent(engine, delta, this));\r\n    this.onPostUpdate(engine, delta);\r\n  }\r\n\r\n  /**\r\n   * `onInitialize` is called before the first update of the entity. This method is meant to be\r\n   * overridden.\r\n   *\r\n   * Synonymous with the event handler `.on('initialize', (evt) => {...})`\r\n   */\r\n  public onInitialize(_engine: Engine): void {\r\n    // Override me\r\n  }\r\n\r\n  /**\r\n   * Safe to override onPreUpdate lifecycle event handler. Synonymous with `.on('preupdate', (evt) =>{...})`\r\n   *\r\n   * `onPreUpdate` is called directly before an entity is updated.\r\n   */\r\n  public onPreUpdate(_engine: Engine, _delta: number): void {\r\n    // Override me\r\n  }\r\n\r\n  /**\r\n   * Safe to override onPostUpdate lifecycle event handler. Synonymous with `.on('postupdate', (evt) =>{...})`\r\n   *\r\n   * `onPostUpdate` is called directly after an entity is updated.\r\n   */\r\n  public onPostUpdate(_engine: Engine, _delta: number): void {\r\n    // Override me\r\n  }\r\n\r\n  /**\r\n   *\r\n   * Entity update lifecycle, called internally\r\n   *\r\n   * @internal\r\n   * @param engine\r\n   * @param delta\r\n   */\r\n  public update(engine: Engine, delta: number): void {\r\n    this._initialize(engine);\r\n    this._preupdate(engine, delta);\r\n    for (const child of this.children) {\r\n      child.update(engine, delta);\r\n    }\r\n    this._postupdate(engine, delta);\r\n  }\r\n}\r\n","import { Vector, vec } from '../Math/vector';\r\nimport { Graphic } from './Graphic';\r\nimport { HasTick } from './Animation';\r\nimport { ExcaliburGraphicsContext } from './Context/ExcaliburGraphicsContext';\r\nimport { Logger } from '../Util/Log';\r\nimport { BoundingBox } from '../Collision/Index';\r\nimport { Component } from '../EntityComponentSystem/Component';\r\n\r\n/**\r\n * Type guard for checking if a Graphic HasTick (used for graphics that change over time like animations)\r\n * @param graphic\r\n */\r\nexport function hasGraphicsTick(graphic: Graphic): graphic is Graphic & HasTick {\r\n  return !!(graphic as unknown as HasTick).tick;\r\n}\r\nexport interface GraphicsShowOptions {\r\n  offset?: Vector;\r\n  anchor?: Vector;\r\n}\r\n\r\nexport interface GraphicsComponentOptions {\r\n  onPostDraw?: (ex: ExcaliburGraphicsContext, elapsed: number) => void;\r\n  onPreDraw?: (ex: ExcaliburGraphicsContext, elapsed: number) => void;\r\n\r\n  /**\r\n   * Name of current graphic to use\r\n   */\r\n  current?: string;\r\n\r\n  /**\r\n   * Optionally copy instances of graphics by calling .clone(), you may set this to false to avoid sharing graphics when added to the\r\n   * component for performance reasons. By default graphics are not copied and are shared when added to the component.\r\n   */\r\n  copyGraphics?: boolean;\r\n\r\n  /**\r\n   * Optional visible flag, if the graphics component is not visible it will not be displayed\r\n   */\r\n  visible?: boolean;\r\n\r\n  /**\r\n   * Optional opacity\r\n   */\r\n  opacity?: number;\r\n\r\n  /**\r\n   * List of graphics\r\n   */\r\n  graphics?: { [graphicName: string]: Graphic };\r\n\r\n  /**\r\n   * Optional offset in absolute pixels to shift all graphics in this component from each graphic's anchor (default is top left corner)\r\n   */\r\n  offset?: Vector;\r\n\r\n  /**\r\n   * Optional anchor\r\n   */\r\n  anchor?: Vector;\r\n}\r\n\r\nexport interface GraphicsLayerOptions {\r\n  /**\r\n   * Name of the layer required, for example 'background'\r\n   */\r\n  name: string;\r\n  /**\r\n   * Order of the layer, a layer with order -1 will be below a layer with order of 1\r\n   */\r\n  order: number;\r\n  /**\r\n   * Offset to shift the entire layer\r\n   */\r\n  offset?: Vector;\r\n}\r\nexport class GraphicsLayer {\r\n  public graphics: { graphic: Graphic; options: GraphicsShowOptions }[] = [];\r\n  constructor(private _options: GraphicsLayerOptions, private _graphics: GraphicsComponent) {}\r\n  public get name(): string {\r\n    return this._options.name;\r\n  }\r\n\r\n  /**\r\n   * Remove any instance(s) of a graphic currently being shown in this layer\r\n   */\r\n  public hide(nameOrGraphic: string | Graphic): void;\r\n  /**\r\n   * Remove all currently shown graphics in this layer\r\n   */\r\n  public hide(): void;\r\n  public hide(nameOrGraphic?: string | Graphic): void {\r\n    if (!nameOrGraphic) {\r\n      this.graphics.length = 0;\r\n    } else {\r\n      let gfx: Graphic = null;\r\n      if (nameOrGraphic instanceof Graphic) {\r\n        gfx = nameOrGraphic;\r\n      } else {\r\n        gfx = this._graphics.getGraphic(nameOrGraphic);\r\n      }\r\n      this.graphics = this.graphics.filter((g) => g.graphic !== gfx);\r\n      this._graphics.recalculateBounds();\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Show a graphic by name or instance at an offset, graphics are shown in the order in which `show()` is called.\r\n   *\r\n   * If `show()` is called multiple times for the same graphic it will be shown multiple times.\r\n   * @param nameOrGraphic\r\n   * @param options\r\n   */\r\n  public show<T extends Graphic = Graphic>(nameOrGraphic: string | T, options?: GraphicsShowOptions): T {\r\n    options = { ...options };\r\n    let gfx: Graphic;\r\n    if (nameOrGraphic instanceof Graphic) {\r\n      gfx = this._graphics.copyGraphics ? nameOrGraphic.clone() : nameOrGraphic;\r\n    } else {\r\n      gfx = this._graphics.getGraphic(nameOrGraphic);\r\n      if (!gfx) {\r\n        Logger.getInstance().error(\r\n          `No such graphic added to component named ${nameOrGraphic}. These named graphics are available: `,\r\n          this._graphics.getNames()\r\n        );\r\n      }\r\n    }\r\n    if (gfx) {\r\n      this.graphics.push({ graphic: gfx, options });\r\n      this._graphics.recalculateBounds();\r\n      return gfx as T;\r\n    } else {\r\n      return null;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Use a specific graphic, swap out any current graphics being shown\r\n   * @param nameOrGraphic\r\n   * @param options\r\n   */\r\n  public use<T extends Graphic = Graphic>(nameOrGraphic: string | T, options?: GraphicsShowOptions): T {\r\n    options = { ...options };\r\n    this.hide();\r\n    return this.show<T>(nameOrGraphic, options);\r\n  }\r\n\r\n  /**\r\n   * Current order of the layer, higher numbers are on top, lower numbers are on the bottom.\r\n   *\r\n   * For example a layer with `order = -1` would be under a layer of `order = 1`\r\n   */\r\n  public get order(): number {\r\n    return this._options.order;\r\n  }\r\n\r\n  /**\r\n   * Set the order of the layer, higher numbers are on top, lower numbers are on the bottom.\r\n   *\r\n   * For example a layer with `order = -1` would be under a layer of `order = 1`\r\n   */\r\n  public set order(order: number) {\r\n    this._options.order = order;\r\n  }\r\n\r\n  /**\r\n   * Get or set the pixel offset from the layer anchor for all graphics in the layer\r\n   */\r\n  public get offset(): Vector {\r\n    return this._options.offset ?? Vector.Zero;\r\n  }\r\n\r\n  public set offset(value: Vector) {\r\n    this._options.offset = value;\r\n  }\r\n\r\n  public get currentKeys(): string {\r\n    return this.name ?? 'anonymous';\r\n  }\r\n}\r\n\r\nexport class GraphicsLayers {\r\n  private _layers: GraphicsLayer[] = [];\r\n  private _layerMap: { [layerName: string]: GraphicsLayer } = {};\r\n  public default: GraphicsLayer;\r\n  constructor(private _component: GraphicsComponent) {\r\n    this.default = new GraphicsLayer({ name: 'default', order: 0 }, _component);\r\n    this._maybeAddLayer(this.default);\r\n  }\r\n  public create(options: GraphicsLayerOptions): GraphicsLayer {\r\n    const layer = new GraphicsLayer(options, this._component);\r\n    return this._maybeAddLayer(layer);\r\n  }\r\n\r\n  /**\r\n   * Retrieve a single layer by name\r\n   * @param name\r\n   */\r\n  public get(name: string): GraphicsLayer;\r\n  /**\r\n   * Retrieve all layers\r\n   */\r\n  public get(): readonly GraphicsLayer[];\r\n  public get(name?: string): GraphicsLayer | readonly GraphicsLayer[] {\r\n    if (name) {\r\n      return this._getLayer(name);\r\n    }\r\n    return this._layers;\r\n  }\r\n\r\n  public currentKeys() {\r\n    const graphicsLayerKeys = [];\r\n    for (const layer of this._layers) {\r\n      graphicsLayerKeys.push(layer.currentKeys);\r\n    }\r\n    return graphicsLayerKeys;\r\n  }\r\n\r\n  public has(name: string): boolean {\r\n    return name in this._layerMap;\r\n  }\r\n\r\n  private _maybeAddLayer(layer: GraphicsLayer) {\r\n    if (this._layerMap[layer.name]) {\r\n      // todo log warning\r\n      return this._layerMap[layer.name];\r\n    }\r\n    this._layerMap[layer.name] = layer;\r\n    this._layers.push(layer);\r\n    this._layers.sort((a, b) => a.order - b.order);\r\n    return layer;\r\n  }\r\n\r\n  private _getLayer(name: string): GraphicsLayer | undefined {\r\n    return this._layerMap[name];\r\n  }\r\n}\r\n\r\n/**\r\n * Component to manage drawings, using with the position component\r\n */\r\nexport class GraphicsComponent extends Component<'ex.graphics'> {\r\n  readonly type = 'ex.graphics';\r\n\r\n  private _graphics: { [graphicName: string]: Graphic } = {};\r\n\r\n  public layers: GraphicsLayers;\r\n\r\n  public getGraphic(name: string): Graphic | undefined {\r\n    return this._graphics[name];\r\n  }\r\n\r\n  /**\r\n   * Get registered graphics names\r\n   */\r\n  public getNames(): string[] {\r\n    return Object.keys(this._graphics);\r\n  }\r\n\r\n  /**\r\n   * Draws after the entity transform has bene applied, but before graphics component graphics have been drawn\r\n   */\r\n  public onPreDraw: (ctx: ExcaliburGraphicsContext, elapsedMilliseconds: number) => void;\r\n\r\n  /**\r\n   * Draws after the entity transform has been applied, and after graphics component graphics has been drawn\r\n   */\r\n  public onPostDraw: (ctx: ExcaliburGraphicsContext, elapsedMilliseconds: number) => void;\r\n\r\n  /**\r\n   * Sets or gets wether any drawing should be visible in this component\r\n   */\r\n  public visible: boolean = true;\r\n\r\n  /**\r\n   * Sets or gets wither all drawings should have an opacity applied\r\n   */\r\n  public opacity: number = 1;\r\n\r\n  /**\r\n   * Offset to apply to graphics by default\r\n   */\r\n  public offset: Vector = Vector.Zero;\r\n\r\n  /**\r\n   * Anchor to apply to graphics by default\r\n   */\r\n  public anchor: Vector = Vector.Half;\r\n\r\n  /**\r\n   * If set to true graphics added to the component will be copied. This can affect performance\r\n   */\r\n  public copyGraphics: boolean = false;\r\n\r\n  constructor(options?: GraphicsComponentOptions) {\r\n    super();\r\n    // Defaults\r\n    options = {\r\n      visible: this.visible,\r\n      ...options\r\n    };\r\n\r\n    const { current, anchor, opacity, visible, graphics, offset, copyGraphics, onPreDraw, onPostDraw } = options;\r\n\r\n    this._graphics = graphics || {};\r\n    this.offset = offset ?? this.offset;\r\n    this.opacity = opacity ?? this.opacity;\r\n    this.anchor = anchor ?? this.anchor;\r\n    this.copyGraphics = copyGraphics ?? this.copyGraphics;\r\n    this.onPreDraw = onPreDraw ?? this.onPreDraw;\r\n    this.onPostDraw = onPostDraw ?? this.onPostDraw;\r\n    this.visible = !!visible;\r\n\r\n    this.layers = new GraphicsLayers(this);\r\n    if (current && this._graphics[current]) {\r\n      this.show(this._graphics[current]);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Returns the currently displayed graphics and their offsets, empty array if hidden\r\n   */\r\n  public get current(): { graphic: Graphic; options: GraphicsShowOptions }[] {\r\n    return this.layers.default.graphics;\r\n  }\r\n\r\n  /**\r\n   * Returns all graphics associated with this component\r\n   */\r\n  public get graphics(): { [graphicName: string]: Graphic } {\r\n    return this._graphics;\r\n  }\r\n\r\n  /**\r\n   * Adds a named graphic to this component, if the name is \"default\" or not specified, it will be shown by default without needing to call\r\n   * `show(\"default\")`\r\n   * @param graphic\r\n   */\r\n  public add(graphic: Graphic): Graphic;\r\n  public add(name: string, graphic: Graphic): Graphic;\r\n  public add(nameOrGraphic: string | Graphic, graphic?: Graphic): Graphic {\r\n    let name = 'default';\r\n    let graphicToSet: Graphic = null;\r\n    if (typeof nameOrGraphic === 'string') {\r\n      name = nameOrGraphic;\r\n      graphicToSet = graphic;\r\n    } else {\r\n      graphicToSet = nameOrGraphic;\r\n    }\r\n\r\n    this._graphics[name] = this.copyGraphics ? graphicToSet.clone() : graphicToSet;\r\n    if (name === 'default') {\r\n      this.show('default');\r\n    }\r\n    return graphicToSet;\r\n  }\r\n\r\n  /**\r\n   * Show a graphic by name on the **default** layer, returns the new [[Graphic]]\r\n   */\r\n  public show<T extends Graphic = Graphic>(nameOrGraphic: string | T, options?: GraphicsShowOptions): T {\r\n    const result = this.layers.default.show<T>(nameOrGraphic, options);\r\n    this.recalculateBounds();\r\n    return result;\r\n  }\r\n\r\n  /**\r\n   * Use a graphic only, swap out any graphics on the **default** layer, returns the new [[Graphic]]\r\n   * @param nameOrGraphic\r\n   * @param options\r\n   */\r\n  public use<T extends Graphic = Graphic>(nameOrGraphic: string | T, options?: GraphicsShowOptions): T {\r\n    const result = this.layers.default.use<T>(nameOrGraphic, options);\r\n    this.recalculateBounds();\r\n    return result;\r\n  }\r\n\r\n  /**\r\n   * Remove any instance(s) of a graphic currently being shown in the **default** layer\r\n   */\r\n  public hide(nameOrGraphic: string | Graphic): void;\r\n  /**\r\n   * Remove all currently shown graphics in the **default** layer\r\n   */\r\n  public hide(): void;\r\n  public hide(nameOrGraphic?: string | Graphic): void {\r\n    this.layers.default.hide(nameOrGraphic);\r\n  }\r\n\r\n  private _localBounds: BoundingBox = null;\r\n  public set localBounds(bounds: BoundingBox) {\r\n    this._localBounds = bounds;\r\n  }\r\n\r\n  public recalculateBounds() {\r\n    let bb = new BoundingBox();\r\n    for (const layer of this.layers.get()) {\r\n      for (const { graphic, options } of layer.graphics) {\r\n        let anchor = this.anchor;\r\n        let offset = this.offset;\r\n        if (options?.anchor) {\r\n          anchor = options.anchor;\r\n        }\r\n        if (options?.offset) {\r\n          offset = options.offset;\r\n        }\r\n        const bounds = graphic.localBounds;\r\n        const offsetX = -bounds.width *  anchor.x + offset.x;\r\n        const offsetY = -bounds.height *  anchor.y + offset.y;\r\n        bb = graphic?.localBounds.translate(vec(offsetX + layer.offset.x, offsetY + layer.offset.y)).combine(bb);\r\n      }\r\n    }\r\n    this._localBounds = bb;\r\n  }\r\n\r\n  public get localBounds(): BoundingBox {\r\n    if (!this._localBounds || this._localBounds.hasZeroDimensions()) {\r\n      this.recalculateBounds();\r\n    }\r\n    return this._localBounds;\r\n  }\r\n\r\n  /**\r\n   * Update underlying graphics if necesary, called internally\r\n   * @param elapsed\r\n   * @internal\r\n   */\r\n  public update(elapsed: number, idempotencyToken: number = 0) {\r\n    for (const layer of this.layers.get()) {\r\n      for (const { graphic } of layer.graphics) {\r\n        if (hasGraphicsTick(graphic)) {\r\n          graphic?.tick(elapsed, idempotencyToken);\r\n        }\r\n      }\r\n    }\r\n  }\r\n}\r\n","import { Raster, RasterOptions } from './Raster';\r\n\r\nexport interface RectangleOptions {\r\n  width: number;\r\n  height: number;\r\n}\r\n\r\n/**\r\n * A Rectangle [[Graphic]] for drawing rectangles to the [[ExcaliburGraphicsContext]]\r\n */\r\nexport class Rectangle extends Raster {\r\n  constructor(options: RasterOptions & RectangleOptions) {\r\n    super(options);\r\n    this.width = options.width;\r\n    this.height = options.height;\r\n    this.rasterize();\r\n  }\r\n\r\n  public clone(): Rectangle {\r\n    return new Rectangle({\r\n      width: this.width,\r\n      height: this.height,\r\n      ...this.cloneGraphicOptions(),\r\n      ...this.cloneRasterOptions()\r\n    });\r\n  }\r\n\r\n  execute(ctx: CanvasRenderingContext2D): void {\r\n    if (this.color) {\r\n      ctx.fillRect(0, 0, this.width, this.height);\r\n    }\r\n    if (this.strokeColor) {\r\n      ctx.strokeRect(0, 0, this.width, this.height);\r\n    }\r\n  }\r\n}\r\n","import { ImageFiltering } from '.';\r\nimport { Raster, RasterOptions } from './Raster';\r\n\r\nexport interface CircleOptions {\r\n  radius: number;\r\n}\r\n\r\n/**\r\n * A circle [[Graphic]] for drawing circles to the [[ExcaliburGraphicsContext]]\r\n *\r\n * Circles default to [[ImageFiltering.Blended]]\r\n */\r\nexport class Circle extends Raster {\r\n  private _radius: number = 0;\r\n  public get radius() {\r\n    return this._radius;\r\n  }\r\n  public set radius(value: number) {\r\n    this._radius = value;\r\n    this.width = this._radius * 2;\r\n    this.height = this._radius * 2;\r\n    this.flagDirty();\r\n  }\r\n  constructor(options: RasterOptions & CircleOptions) {\r\n    super(options);\r\n    this.padding = options.padding ?? 2; // default 2 padding for circles looks nice\r\n    this.radius = options.radius;\r\n    this.filtering = options.filtering ?? ImageFiltering.Blended;\r\n    this.rasterize();\r\n  }\r\n\r\n  public clone(): Circle {\r\n    return new Circle({\r\n      radius: this.radius,\r\n      ...this.cloneGraphicOptions(),\r\n      ...this.cloneRasterOptions()\r\n    });\r\n  }\r\n\r\n  execute(ctx: CanvasRenderingContext2D): void {\r\n    if (this.radius > 0) {\r\n      ctx.beginPath();\r\n      ctx.arc(this.radius, this.radius, this.radius, 0, Math.PI * 2);\r\n\r\n      if (this.color) {\r\n        ctx.fill();\r\n      }\r\n\r\n      if (this.strokeColor) {\r\n        ctx.stroke();\r\n      }\r\n    }\r\n  }\r\n}\r\n","import { Component } from '../EntityComponentSystem/Component';\r\n\r\n/**\r\n * Add this component to optionally configure how the pointer\r\n * system detects pointer events.\r\n *\r\n * By default the collider shape is used and graphics bounds is not.\r\n *\r\n * If both collider shape and graphics bounds are enabled it will fire events if either or\r\n * are intersecting the pointer.\r\n */\r\nexport class PointerComponent extends Component<'ex.pointer'> {\r\n  public readonly type = 'ex.pointer';\r\n  /**\r\n   * Use any existing Collider component geometry for pointer events. This is useful if you want\r\n   * user pointer events only to trigger on the same collision geometry used in the collider component\r\n   * for collision resolution. Default is `true`.\r\n   */\r\n  public useColliderShape = true;\r\n  /**\r\n   * Use any existing Graphics component bounds for pointers. This is useful if you want the axis aligned\r\n   * bounds around the graphic to trigger pointer events. Default is `false`.\r\n   */\r\n  public useGraphicsBounds = false;\r\n}","import { Vector } from '../Math/vector';\r\n\r\n/**\r\n * A definition of an EasingFunction. See [[EasingFunctions]].\r\n */\r\n// tslint:disable-next-line\r\nexport interface EasingFunction {\r\n  (currentTime: number, startValue: number, endValue: number, duration: number): number;\r\n}\r\n\r\n/**\r\n * Standard easing functions for motion in Excalibur, defined on a domain of [0, duration] and a range from [+startValue,+endValue]\r\n * Given a time, the function will return a value from positive startValue to positive endValue.\r\n *\r\n * ```js\r\n * function Linear (t) {\r\n *    return t * t;\r\n * }\r\n *\r\n * // accelerating from zero velocity\r\n * function EaseInQuad (t) {\r\n *    return t * t;\r\n * }\r\n *\r\n * // decelerating to zero velocity\r\n * function EaseOutQuad (t) {\r\n *    return t * (2 - t);\r\n * }\r\n *\r\n * // acceleration until halfway, then deceleration\r\n * function EaseInOutQuad (t) {\r\n *    return t < .5 ? 2 * t * t : -1 + (4 - 2 * t) * t;\r\n * }\r\n *\r\n * // accelerating from zero velocity\r\n * function EaseInCubic (t) {\r\n *    return t * t * t;\r\n * }\r\n *\r\n * // decelerating to zero velocity\r\n * function EaseOutCubic (t) {\r\n *    return (--t) * t * t + 1;\r\n * }\r\n *\r\n * // acceleration until halfway, then deceleration\r\n * function EaseInOutCubic (t) {\r\n *    return t < .5 ? 4 * t * t * t : (t - 1) * (2 * t - 2) * (2 * t - 2) + 1;\r\n * }\r\n * ```\r\n */\r\nexport class EasingFunctions {\r\n  public static CreateReversibleEasingFunction(easing: EasingFunction) {\r\n    return (time: number, start: number, end: number, duration: number) => {\r\n      if (end < start) {\r\n        return start - (easing(time, end, start, duration) - end);\r\n      } else {\r\n        return easing(time, start, end, duration);\r\n      }\r\n    };\r\n  }\r\n\r\n  public static CreateVectorEasingFunction(easing: EasingFunction) {\r\n    return (time: number, start: Vector, end: Vector, duration: number) => {\r\n      return new Vector(easing(time, start.x, end.x, duration), easing(time, start.y, end.y, duration));\r\n    };\r\n  }\r\n\r\n  public static Linear: EasingFunction = EasingFunctions.CreateReversibleEasingFunction(\r\n    (currentTime: number, startValue: number, endValue: number, duration: number) => {\r\n      endValue = endValue - startValue;\r\n      return (endValue * currentTime) / duration + startValue;\r\n    }\r\n  );\r\n\r\n  public static EaseInQuad = EasingFunctions.CreateReversibleEasingFunction(\r\n    (currentTime: number, startValue: number, endValue: number, duration: number) => {\r\n      endValue = endValue - startValue;\r\n      currentTime /= duration;\r\n\r\n      return endValue * currentTime * currentTime + startValue;\r\n    }\r\n  );\r\n\r\n  public static EaseOutQuad: EasingFunction = EasingFunctions.CreateReversibleEasingFunction(\r\n    (currentTime: number, startValue: number, endValue: number, duration: number) => {\r\n      endValue = endValue - startValue;\r\n      currentTime /= duration;\r\n      return -endValue * currentTime * (currentTime - 2) + startValue;\r\n    }\r\n  );\r\n\r\n  public static EaseInOutQuad: EasingFunction = EasingFunctions.CreateReversibleEasingFunction(\r\n    (currentTime: number, startValue: number, endValue: number, duration: number) => {\r\n      endValue = endValue - startValue;\r\n      currentTime /= duration / 2;\r\n\r\n      if (currentTime < 1) {\r\n        return (endValue / 2) * currentTime * currentTime + startValue;\r\n      }\r\n      currentTime--;\r\n\r\n      return (-endValue / 2) * (currentTime * (currentTime - 2) - 1) + startValue;\r\n    }\r\n  );\r\n\r\n  public static EaseInCubic: EasingFunction = EasingFunctions.CreateReversibleEasingFunction(\r\n    (currentTime: number, startValue: number, endValue: number, duration: number) => {\r\n      endValue = endValue - startValue;\r\n      currentTime /= duration;\r\n      return endValue * currentTime * currentTime * currentTime + startValue;\r\n    }\r\n  );\r\n\r\n  public static EaseOutCubic: EasingFunction = EasingFunctions.CreateReversibleEasingFunction(\r\n    (currentTime: number, startValue: number, endValue: number, duration: number) => {\r\n      endValue = endValue - startValue;\r\n      currentTime /= duration;\r\n      currentTime--;\r\n      return endValue * (currentTime * currentTime * currentTime + 1) + startValue;\r\n    }\r\n  );\r\n\r\n  public static EaseInOutCubic: EasingFunction = EasingFunctions.CreateReversibleEasingFunction(\r\n    (currentTime: number, startValue: number, endValue: number, duration: number) => {\r\n      endValue = endValue - startValue;\r\n      currentTime /= duration / 2;\r\n      if (currentTime < 1) {\r\n        return (endValue / 2) * currentTime * currentTime * currentTime + startValue;\r\n      }\r\n      currentTime -= 2;\r\n      return (endValue / 2) * (currentTime * currentTime * currentTime + 2) + startValue;\r\n    }\r\n  );\r\n}\r\n","import { Entity } from '../EntityComponentSystem/Entity';\r\nimport { Action } from './Action';\r\n\r\n/**\r\n * Action Queues represent an ordered sequence of actions\r\n *\r\n * Action queues are part of the [[ActionContext|Action API]] and\r\n * store the list of actions to be executed for an [[Actor]].\r\n *\r\n * Actors implement [[Actor.actions]] which can be manipulated by\r\n * advanced users to adjust the actions currently being executed in the\r\n * queue.\r\n */\r\nexport class ActionQueue {\r\n  private _entity: Entity;\r\n  private _actions: Action[] = [];\r\n  private _currentAction: Action;\r\n  private _completedActions: Action[] = [];\r\n  constructor(entity: Entity) {\r\n    this._entity = entity;\r\n  }\r\n\r\n  /**\r\n   * Add an action to the sequence\r\n   * @param action\r\n   */\r\n  public add(action: Action) {\r\n    this._actions.push(action);\r\n  }\r\n\r\n  /**\r\n   * Remove an action by reference from the sequence\r\n   * @param action\r\n   */\r\n  public remove(action: Action) {\r\n    const index = this._actions.indexOf(action);\r\n    this._actions.splice(index, 1);\r\n  }\r\n\r\n  /**\r\n   * Removes all actions from this sequence\r\n   */\r\n  public clearActions(): void {\r\n    this._actions.length = 0;\r\n    this._completedActions.length = 0;\r\n    if (this._currentAction) {\r\n      this._currentAction.stop();\r\n    }\r\n  }\r\n\r\n  /**\r\n   *\r\n   * @returns The total list of actions in this sequence complete or not\r\n   */\r\n  public getActions(): Action[] {\r\n    return this._actions.concat(this._completedActions);\r\n  }\r\n\r\n  /**\r\n   *\r\n   * @returns `true` if there are more actions to process in the sequence\r\n   */\r\n  public hasNext(): boolean {\r\n    return this._actions.length > 0;\r\n  }\r\n\r\n  /**\r\n   * @returns `true` if the current sequence of actions is done\r\n   */\r\n  public isComplete(): boolean {\r\n    return this._actions.length === 0;\r\n  }\r\n\r\n  /**\r\n   * Resets the sequence of actions, this is used to restart a sequence from the beginning\r\n   */\r\n  public reset(): void {\r\n    this._actions = this.getActions();\r\n\r\n    const len = this._actions.length;\r\n    for (let i = 0; i < len; i++) {\r\n      this._actions[i].reset();\r\n    }\r\n    this._completedActions = [];\r\n  }\r\n\r\n  /**\r\n   * Update the queue which updates actions and handles completing actions\r\n   * @param elapsedMs\r\n   */\r\n  public update(elapsedMs: number) {\r\n    if (this._actions.length > 0) {\r\n      this._currentAction = this._actions[0];\r\n      this._currentAction.update(elapsedMs);\r\n\r\n      if (this._currentAction.isComplete(this._entity)) {\r\n        this._completedActions.push(this._actions.shift());\r\n      }\r\n    }\r\n  }\r\n}\r\n","import { Entity } from '../../EntityComponentSystem/Entity';\r\nimport { Action } from '../Action';\r\nimport { ActionContext } from '../ActionContext';\r\nimport { ActionQueue } from '../ActionQueue';\r\n\r\nexport class Repeat implements Action {\r\n  private _actionQueue: ActionQueue;\r\n  private _repeat: number;\r\n  private _originalRepeat: number;\r\n  private _stopped: boolean = false;\r\n  private _repeatContext: ActionContext;\r\n  private _repeatBuilder: (repeatContext: ActionContext) => any;\r\n  constructor(entity: Entity, repeatBuilder: (repeatContext: ActionContext) => any, repeat: number) {\r\n    this._repeatBuilder = repeatBuilder;\r\n    this._repeatContext = new ActionContext(entity);\r\n    this._actionQueue = this._repeatContext.getQueue();\r\n\r\n    this._repeat = repeat;\r\n    this._originalRepeat = repeat;\r\n\r\n    this._repeatBuilder(this._repeatContext);\r\n    this._repeat--; // current execution is the first repeat\r\n  }\r\n\r\n  public update(delta: number): void {\r\n    if (this._actionQueue.isComplete()) {\r\n      this._actionQueue.clearActions();\r\n      this._repeatBuilder(this._repeatContext);\r\n      this._repeat--;\r\n    }\r\n    this._actionQueue.update(delta);\r\n  }\r\n\r\n  public isComplete(): boolean {\r\n    return this._stopped || (this._repeat <= 0 && this._actionQueue.isComplete());\r\n  }\r\n\r\n  public stop(): void {\r\n    this._stopped = true;\r\n  }\r\n\r\n  public reset(): void {\r\n    this._repeat = this._originalRepeat;\r\n  }\r\n}\r\n","import { Entity } from '../../EntityComponentSystem/Entity';\r\nimport { Action } from '../Action';\r\nimport { ActionContext } from '../ActionContext';\r\nimport { ActionQueue } from '../ActionQueue';\r\n\r\n/**\r\n * RepeatForever Action implementation, it is recommended you use the fluent action\r\n * context API.\r\n *\r\n *\r\n */\r\nexport class RepeatForever implements Action {\r\n  private _actionQueue: ActionQueue;\r\n  private _stopped: boolean = false;\r\n  private _repeatContext: ActionContext;\r\n  private _repeatBuilder: (repeatContext: ActionContext) => any;\r\n  constructor(entity: Entity, repeatBuilder: (repeatContext: ActionContext) => any) {\r\n    this._repeatBuilder = repeatBuilder;\r\n    this._repeatContext = new ActionContext(entity);\r\n    this._actionQueue = this._repeatContext.getQueue();\r\n\r\n    this._repeatBuilder(this._repeatContext);\r\n  }\r\n\r\n  public update(delta: number): void {\r\n    if (this._stopped) {\r\n      return;\r\n    }\r\n\r\n    if (this._actionQueue.isComplete()) {\r\n      this._actionQueue.clearActions();\r\n      this._repeatBuilder(this._repeatContext);\r\n    }\r\n\r\n    this._actionQueue.update(delta);\r\n  }\r\n\r\n  public isComplete(): boolean {\r\n    return this._stopped;\r\n  }\r\n\r\n  public stop(): void {\r\n    this._stopped = true;\r\n    this._actionQueue.clearActions();\r\n  }\r\n\r\n  public reset(): void {\r\n    return;\r\n  }\r\n}\r\n","import { MotionComponent } from '../../EntityComponentSystem/Components/MotionComponent';\r\nimport { TransformComponent } from '../../EntityComponentSystem/Components/TransformComponent';\r\nimport { Entity } from '../../EntityComponentSystem/Entity';\r\nimport { Vector, vec } from '../../Math/vector';\r\nimport { Logger } from '../../Util/Log';\r\nimport { Action } from '../Action';\r\n\r\nexport class MoveBy implements Action {\r\n  private _tx: TransformComponent;\r\n  private _motion: MotionComponent;\r\n  private _entity: Entity;\r\n  public x: number;\r\n  public y: number;\r\n  private _distance: number;\r\n  private _speed: number;\r\n\r\n  private _start: Vector;\r\n  private _offset: Vector;\r\n  private _end: Vector;\r\n  private _dir: Vector;\r\n  private _started = false;\r\n  private _stopped = false;\r\n\r\n  constructor(entity: Entity, offsetX: number, offsetY: number, speed: number) {\r\n    this._entity = entity;\r\n    this._tx = entity.get(TransformComponent);\r\n    this._motion = entity.get(MotionComponent);\r\n    this._speed = speed;\r\n    this._offset = new Vector(offsetX, offsetY);\r\n    if (speed <= 0) {\r\n      Logger.getInstance().error('Attempted to moveBy with speed less than or equal to zero : ' + speed);\r\n      throw new Error('Speed must be greater than 0 pixels per second');\r\n    }\r\n  }\r\n\r\n  public update(_delta: number) {\r\n    if (!this._started) {\r\n      this._started = true;\r\n      this._start = new Vector(this._tx.pos.x, this._tx.pos.y);\r\n      this._end = this._start.add(this._offset);\r\n      this._distance = this._offset.size;\r\n      this._dir = this._end.sub(this._start).normalize();\r\n    }\r\n\r\n    if (this.isComplete(this._entity)) {\r\n      this._tx.pos = vec(this._end.x, this._end.y);\r\n      this._motion.vel = vec(0, 0);\r\n    } else {\r\n      this._motion.vel = this._dir.scale(this._speed);\r\n    }\r\n  }\r\n\r\n  public isComplete(entity: Entity): boolean {\r\n    const tx = entity.get(TransformComponent);\r\n    return this._stopped || tx.pos.distance(this._start) >= this._distance;\r\n  }\r\n\r\n  public stop(): void {\r\n    this._motion.vel = vec(0, 0);\r\n    this._stopped = true;\r\n  }\r\n\r\n  public reset(): void {\r\n    this._started = false;\r\n  }\r\n}\r\n","import { MotionComponent } from '../../EntityComponentSystem/Components/MotionComponent';\r\nimport { TransformComponent } from '../../EntityComponentSystem/Components/TransformComponent';\r\nimport { Entity } from '../../EntityComponentSystem/Entity';\r\nimport { Vector, vec } from '../../Math/vector';\r\nimport { Action } from '../Action';\r\n\r\nexport class MoveTo implements Action {\r\n  private _tx: TransformComponent;\r\n  private _motion: MotionComponent;\r\n  public x: number;\r\n  public y: number;\r\n  private _start: Vector;\r\n  private _end: Vector;\r\n  private _dir: Vector;\r\n  private _speed: number;\r\n  private _distance: number;\r\n  private _started = false;\r\n  private _stopped = false;\r\n  constructor(public entity: Entity, destx: number, desty: number, speed: number) {\r\n    this._tx = entity.get(TransformComponent);\r\n    this._motion = entity.get(MotionComponent);\r\n    this._end = new Vector(destx, desty);\r\n    this._speed = speed;\r\n  }\r\n\r\n  public update(_delta: number): void {\r\n    if (!this._started) {\r\n      this._started = true;\r\n      this._start = new Vector(this._tx.pos.x, this._tx.pos.y);\r\n      this._distance = this._start.distance(this._end);\r\n      this._dir = this._end.sub(this._start).normalize();\r\n    }\r\n    const m = this._dir.scale(this._speed);\r\n    this._motion.vel = vec(m.x, m.y);\r\n\r\n    if (this.isComplete(this.entity)) {\r\n      this._tx.pos = vec(this._end.x, this._end.y);\r\n      this._motion.vel = vec(0, 0);\r\n    }\r\n  }\r\n\r\n  public isComplete(entity: Entity): boolean {\r\n    const tx = entity.get(TransformComponent);\r\n    return this._stopped || new Vector(tx.pos.x, tx.pos.y).distance(this._start) >= this._distance;\r\n  }\r\n\r\n  public stop(): void {\r\n    this._motion.vel = vec(0, 0);\r\n    this._stopped = true;\r\n  }\r\n\r\n  public reset(): void {\r\n    this._started = false;\r\n  }\r\n}\r\n","/**\r\n * An enum that describes the strategies that rotation actions can use\r\n */\r\nexport enum RotationType {\r\n  /**\r\n   * Rotation via `ShortestPath` will use the smallest angle\r\n   * between the starting and ending points. This strategy is the default behavior.\r\n   */\r\n  ShortestPath = 0,\r\n  /**\r\n   * Rotation via `LongestPath` will use the largest angle\r\n   * between the starting and ending points.\r\n   */\r\n  LongestPath = 1,\r\n  /**\r\n   * Rotation via `Clockwise` will travel in a clockwise direction,\r\n   * regardless of the starting and ending points.\r\n   */\r\n  Clockwise = 2,\r\n  /**\r\n   * Rotation via `CounterClockwise` will travel in a counterclockwise direction,\r\n   * regardless of the starting and ending points.\r\n   */\r\n  CounterClockwise = 3\r\n}\r\n","import { Action } from '../Action';\r\nimport { RotationType } from '../RotationType';\r\nimport { TransformComponent } from '../../EntityComponentSystem/Components/TransformComponent';\r\nimport { MotionComponent } from '../../EntityComponentSystem/Components/MotionComponent';\r\nimport { Entity } from '../../EntityComponentSystem/Entity';\r\nimport { TwoPI } from '../../Math/util';\r\n\r\nexport class RotateTo implements Action {\r\n  private _tx: TransformComponent;\r\n  private _motion: MotionComponent;\r\n  public x: number;\r\n  public y: number;\r\n  private _start: number;\r\n  private _end: number;\r\n  private _speed: number;\r\n  private _rotationType: RotationType;\r\n  private _direction: number;\r\n  private _distance: number;\r\n  private _shortDistance: number;\r\n  private _longDistance: number;\r\n  private _shortestPathIsPositive: boolean;\r\n  private _currentNonCannonAngle: number;\r\n  private _started = false;\r\n  private _stopped = false;\r\n  constructor(entity: Entity, angleRadians: number, speed: number, rotationType?: RotationType) {\r\n    this._tx = entity.get(TransformComponent);\r\n    this._motion = entity.get(MotionComponent);\r\n    this._end = angleRadians;\r\n    this._speed = speed;\r\n    this._rotationType = rotationType || RotationType.ShortestPath;\r\n  }\r\n\r\n  public update(_delta: number): void {\r\n    if (!this._started) {\r\n      this._started = true;\r\n      this._start = this._tx.rotation;\r\n      this._currentNonCannonAngle = this._tx.rotation;\r\n      const distance1 = Math.abs(this._end - this._start);\r\n      const distance2 = TwoPI - distance1;\r\n      if (distance1 > distance2) {\r\n        this._shortDistance = distance2;\r\n        this._longDistance = distance1;\r\n      } else {\r\n        this._shortDistance = distance1;\r\n        this._longDistance = distance2;\r\n      }\r\n\r\n      this._shortestPathIsPositive = (this._start - this._end + TwoPI) % TwoPI >= Math.PI;\r\n\r\n      switch (this._rotationType) {\r\n        case RotationType.ShortestPath:\r\n          this._distance = this._shortDistance;\r\n          if (this._shortestPathIsPositive) {\r\n            this._direction = 1;\r\n          } else {\r\n            this._direction = -1;\r\n          }\r\n          break;\r\n        case RotationType.LongestPath:\r\n          this._distance = this._longDistance;\r\n          if (this._shortestPathIsPositive) {\r\n            this._direction = -1;\r\n          } else {\r\n            this._direction = 1;\r\n          }\r\n          break;\r\n        case RotationType.Clockwise:\r\n          this._direction = 1;\r\n          if (this._shortestPathIsPositive) {\r\n            this._distance = this._shortDistance;\r\n          } else {\r\n            this._distance = this._longDistance;\r\n          }\r\n          break;\r\n        case RotationType.CounterClockwise:\r\n          this._direction = -1;\r\n          if (!this._shortestPathIsPositive) {\r\n            this._distance = this._shortDistance;\r\n          } else {\r\n            this._distance = this._longDistance;\r\n          }\r\n          break;\r\n      }\r\n    }\r\n\r\n    this._motion.angularVelocity = this._direction * this._speed;\r\n    this._currentNonCannonAngle += this._direction * this._speed * (_delta / 1000);\r\n\r\n    if (this.isComplete()) {\r\n      this._tx.rotation = this._end;\r\n      this._motion.angularVelocity = 0;\r\n      this._stopped = true;\r\n    }\r\n  }\r\n\r\n  public isComplete(): boolean {\r\n    const distanceTravelled = Math.abs(this._currentNonCannonAngle - this._start);\r\n    return this._stopped || distanceTravelled >= Math.abs(this._distance);\r\n  }\r\n\r\n  public stop(): void {\r\n    this._motion.angularVelocity = 0;\r\n    this._stopped = true;\r\n  }\r\n\r\n  public reset(): void {\r\n    this._started = false;\r\n  }\r\n}\r\n","import { Action } from '../Action';\r\nimport { RotationType } from '../RotationType';\r\nimport { TransformComponent } from '../../EntityComponentSystem/Components/TransformComponent';\r\nimport { MotionComponent } from '../../EntityComponentSystem/Components/MotionComponent';\r\nimport { Entity } from '../../EntityComponentSystem/Entity';\r\nimport { TwoPI } from '../../Math/util';\r\n\r\nexport class RotateBy implements Action {\r\n  private _tx: TransformComponent;\r\n  private _motion: MotionComponent;\r\n  public x: number;\r\n  public y: number;\r\n  private _start: number;\r\n  private _end: number;\r\n  private _speed: number;\r\n  private _offset: number;\r\n\r\n  private _rotationType: RotationType;\r\n  private _direction: number;\r\n  private _distance: number;\r\n  private _shortDistance: number;\r\n  private _longDistance: number;\r\n  private _shortestPathIsPositive: boolean;\r\n  private _currentNonCannonAngle: number;\r\n  private _started = false;\r\n  private _stopped = false;\r\n  constructor(entity: Entity, angleRadiansOffset: number, speed: number, rotationType?: RotationType) {\r\n    this._tx = entity.get(TransformComponent);\r\n    this._motion = entity.get(MotionComponent);\r\n    this._speed = speed;\r\n    this._offset = angleRadiansOffset;\r\n    this._rotationType = rotationType || RotationType.ShortestPath;\r\n  }\r\n\r\n  public update(_delta: number): void {\r\n    if (!this._started) {\r\n      this._started = true;\r\n      this._start = this._tx.rotation;\r\n      this._currentNonCannonAngle = this._tx.rotation;\r\n      this._end = this._start + this._offset;\r\n\r\n      const distance1 = Math.abs(this._end - this._start);\r\n      const distance2 = TwoPI - distance1;\r\n      if (distance1 > distance2) {\r\n        this._shortDistance = distance2;\r\n        this._longDistance = distance1;\r\n      } else {\r\n        this._shortDistance = distance1;\r\n        this._longDistance = distance2;\r\n      }\r\n\r\n      this._shortestPathIsPositive = (this._start - this._end + TwoPI) % TwoPI >= Math.PI;\r\n\r\n      switch (this._rotationType) {\r\n        case RotationType.ShortestPath:\r\n          this._distance = this._shortDistance;\r\n          if (this._shortestPathIsPositive) {\r\n            this._direction = 1;\r\n          } else {\r\n            this._direction = -1;\r\n          }\r\n          break;\r\n        case RotationType.LongestPath:\r\n          this._distance = this._longDistance;\r\n          if (this._shortestPathIsPositive) {\r\n            this._direction = -1;\r\n          } else {\r\n            this._direction = 1;\r\n          }\r\n          break;\r\n        case RotationType.Clockwise:\r\n          this._direction = 1;\r\n          if (this._shortDistance >= 0) {\r\n            this._distance = this._shortDistance;\r\n          } else {\r\n            this._distance = this._longDistance;\r\n          }\r\n          break;\r\n        case RotationType.CounterClockwise:\r\n          this._direction = -1;\r\n          if (this._shortDistance <= 0) {\r\n            this._distance = this._shortDistance;\r\n          } else {\r\n            this._distance = this._longDistance;\r\n          }\r\n          break;\r\n      }\r\n    }\r\n\r\n    this._motion.angularVelocity = this._direction * this._speed;\r\n    this._currentNonCannonAngle += this._direction * this._speed * (_delta / 1000);\r\n\r\n    if (this.isComplete()) {\r\n      this._tx.rotation = this._end;\r\n      this._motion.angularVelocity = 0;\r\n      this._stopped = true;\r\n    }\r\n  }\r\n\r\n  public isComplete(): boolean {\r\n    const distanceTravelled = Math.abs(this._currentNonCannonAngle - this._start);\r\n    return this._stopped || distanceTravelled >= Math.abs(this._distance);\r\n  }\r\n\r\n  public stop(): void {\r\n    this._motion.angularVelocity = 0;\r\n    this._stopped = true;\r\n  }\r\n\r\n  public reset(): void {\r\n    this._started = false;\r\n  }\r\n}\r\n","import { vec } from '../../Math/vector';\r\nimport { MotionComponent } from '../../EntityComponentSystem/Components/MotionComponent';\r\nimport { TransformComponent } from '../../EntityComponentSystem/Components/TransformComponent';\r\nimport { Action } from '../Action';\r\nimport { Entity } from '../../EntityComponentSystem/Entity';\r\n\r\nexport class ScaleTo implements Action {\r\n  private _tx: TransformComponent;\r\n  private _motion: MotionComponent;\r\n  public x: number;\r\n  public y: number;\r\n  private _startX: number;\r\n  private _startY: number;\r\n  private _endX: number;\r\n  private _endY: number;\r\n  private _speedX: number;\r\n  private _speedY: number;\r\n  private _distanceX: number;\r\n  private _distanceY: number;\r\n  private _started = false;\r\n  private _stopped = false;\r\n  constructor(entity: Entity, scaleX: number, scaleY: number, speedX: number, speedY: number) {\r\n    this._tx = entity.get(TransformComponent);\r\n    this._motion = entity.get(MotionComponent);\r\n    this._endX = scaleX;\r\n    this._endY = scaleY;\r\n    this._speedX = speedX;\r\n    this._speedY = speedY;\r\n  }\r\n\r\n  public update(_delta: number): void {\r\n    if (!this._started) {\r\n      this._started = true;\r\n      this._startX = this._tx.scale.x;\r\n      this._startY = this._tx.scale.y;\r\n      this._distanceX = Math.abs(this._endX - this._startX);\r\n      this._distanceY = Math.abs(this._endY - this._startY);\r\n    }\r\n\r\n    if (!(Math.abs(this._tx.scale.x - this._startX) >= this._distanceX)) {\r\n      const directionX = this._endY < this._startY ? -1 : 1;\r\n      this._motion.scaleFactor.x = this._speedX * directionX;\r\n    } else {\r\n      this._motion.scaleFactor.x = 0;\r\n    }\r\n\r\n    if (!(Math.abs(this._tx.scale.y - this._startY) >= this._distanceY)) {\r\n      const directionY = this._endY < this._startY ? -1 : 1;\r\n      this._motion.scaleFactor.y = this._speedY * directionY;\r\n    } else {\r\n      this._motion.scaleFactor.y = 0;\r\n    }\r\n\r\n    if (this.isComplete()) {\r\n      this._tx.scale = vec(this._endX, this._endY);\r\n      this._motion.scaleFactor.x = 0;\r\n      this._motion.scaleFactor.y = 0;\r\n    }\r\n  }\r\n\r\n  public isComplete(): boolean {\r\n    return (\r\n      this._stopped ||\r\n      (Math.abs(this._tx.scale.y - this._startX) >= this._distanceX && Math.abs(this._tx.scale.y - this._startY) >= this._distanceY)\r\n    );\r\n  }\r\n\r\n  public stop(): void {\r\n    this._motion.scaleFactor.x = 0;\r\n    this._motion.scaleFactor.y = 0;\r\n    this._stopped = true;\r\n  }\r\n\r\n  public reset(): void {\r\n    this._started = false;\r\n  }\r\n}\r\n","import { Vector } from '../../Math/vector';\r\nimport { Entity } from '../../EntityComponentSystem/Entity';\r\nimport { MotionComponent } from '../../EntityComponentSystem/Components/MotionComponent';\r\nimport { TransformComponent } from '../../EntityComponentSystem/Components/TransformComponent';\r\nimport { Action } from '../Action';\r\n\r\nexport class ScaleBy implements Action {\r\n  private _tx: TransformComponent;\r\n  private _motion: MotionComponent;\r\n  public x: number;\r\n  public y: number;\r\n  private _startScale: Vector;\r\n  private _endScale: Vector;\r\n  private _offset: Vector;\r\n  private _distanceX: number;\r\n  private _distanceY: number;\r\n  private _directionX: number;\r\n  private _directionY: number;\r\n  private _started = false;\r\n  private _stopped = false;\r\n  private _speedX: number;\r\n  private _speedY: number;\r\n  constructor(entity: Entity, scaleOffsetX: number, scaleOffsetY: number, speed: number) {\r\n    this._tx = entity.get(TransformComponent);\r\n    this._motion = entity.get(MotionComponent);\r\n    this._offset = new Vector(scaleOffsetX, scaleOffsetY);\r\n    this._speedX = this._speedY = speed;\r\n  }\r\n\r\n  public update(_delta: number): void {\r\n    if (!this._started) {\r\n      this._started = true;\r\n      this._startScale = this._tx.scale.clone();\r\n      this._endScale = this._startScale.add(this._offset);\r\n      this._distanceX = Math.abs(this._endScale.x - this._startScale.x);\r\n      this._distanceY = Math.abs(this._endScale.y - this._startScale.y);\r\n      this._directionX = this._endScale.x < this._startScale.x ? -1 : 1;\r\n      this._directionY = this._endScale.y < this._startScale.y ? -1 : 1;\r\n    }\r\n\r\n    this._motion.scaleFactor.x = this._speedX * this._directionX;\r\n    this._motion.scaleFactor.y = this._speedY * this._directionY;\r\n\r\n    if (this.isComplete()) {\r\n      this._tx.scale = this._endScale;\r\n      this._motion.scaleFactor.x = 0;\r\n      this._motion.scaleFactor.y = 0;\r\n    }\r\n  }\r\n\r\n  public isComplete(): boolean {\r\n    return (\r\n      this._stopped ||\r\n      (Math.abs(this._tx.scale.x - this._startScale.x) >= this._distanceX &&\r\n        Math.abs(this._tx.scale.y - this._startScale.y) >= this._distanceY)\r\n    );\r\n  }\r\n\r\n  public stop(): void {\r\n    this._motion.scaleFactor.x = 0;\r\n    this._motion.scaleFactor.y = 0;\r\n    this._stopped = true;\r\n  }\r\n\r\n  public reset(): void {\r\n    this._started = false;\r\n  }\r\n}\r\n","import { Action } from '../Action';\r\n\r\nexport class CallMethod implements Action {\r\n  private _method: () => any = null;\r\n  private _hasBeenCalled: boolean = false;\r\n  constructor(method: () => any) {\r\n    this._method = method;\r\n  }\r\n\r\n  public update(_delta: number) {\r\n    this._method();\r\n    this._hasBeenCalled = true;\r\n  }\r\n  public isComplete() {\r\n    return this._hasBeenCalled;\r\n  }\r\n  public reset() {\r\n    this._hasBeenCalled = false;\r\n  }\r\n  public stop() {\r\n    this._hasBeenCalled = true;\r\n  }\r\n}\r\n","import { Entity} from '../../EntityComponentSystem/Entity';\r\nimport { TransformComponent } from '../../EntityComponentSystem/Components/TransformComponent';\r\nimport { MotionComponent } from '../../EntityComponentSystem/Components/MotionComponent';\r\nimport { Actor } from '../../Actor';\r\nimport { vec, Vector } from '../../Math/vector';\r\nimport { Action } from '../Action';\r\n\r\nexport class EaseTo implements Action {\r\n  private _tx: TransformComponent;\r\n  private _motion: MotionComponent;\r\n  private _currentLerpTime: number = 0;\r\n  private _lerpDuration: number = 1 * 1000; // 1 second\r\n  private _lerpStart: Vector = new Vector(0, 0);\r\n  private _lerpEnd: Vector = new Vector(0, 0);\r\n  private _initialized: boolean = false;\r\n  private _stopped: boolean = false;\r\n  private _distance: number = 0;\r\n  constructor(\r\n    entity: Entity,\r\n    x: number,\r\n    y: number,\r\n    duration: number,\r\n    public easingFcn: (currentTime: number, startValue: number, endValue: number, duration: number) => number\r\n  ) {\r\n    this._tx = entity.get(TransformComponent);\r\n    this._motion = entity.get(MotionComponent);\r\n    this._lerpDuration = duration;\r\n    this._lerpEnd = new Vector(x, y);\r\n  }\r\n  private _initialize() {\r\n    this._lerpStart = new Vector(this._tx.pos.x, this._tx.pos.y);\r\n    this._currentLerpTime = 0;\r\n    this._distance = this._lerpStart.distance(this._lerpEnd);\r\n  }\r\n\r\n  public update(delta: number): void {\r\n    if (!this._initialized) {\r\n      this._initialize();\r\n      this._initialized = true;\r\n    }\r\n\r\n    // Need to update lerp time first, otherwise the first update will always be zero\r\n    this._currentLerpTime += delta;\r\n    let newX = this._tx.pos.x;\r\n    let newY = this._tx.pos.y;\r\n    if (this._currentLerpTime < this._lerpDuration) {\r\n      if (this._lerpEnd.x < this._lerpStart.x) {\r\n        newX =\r\n          this._lerpStart.x -\r\n          (this.easingFcn(this._currentLerpTime, this._lerpEnd.x, this._lerpStart.x, this._lerpDuration) - this._lerpEnd.x);\r\n      } else {\r\n        newX = this.easingFcn(this._currentLerpTime, this._lerpStart.x, this._lerpEnd.x, this._lerpDuration);\r\n      }\r\n\r\n      if (this._lerpEnd.y < this._lerpStart.y) {\r\n        newY =\r\n          this._lerpStart.y -\r\n          (this.easingFcn(this._currentLerpTime, this._lerpEnd.y, this._lerpStart.y, this._lerpDuration) - this._lerpEnd.y);\r\n      } else {\r\n        newY = this.easingFcn(this._currentLerpTime, this._lerpStart.y, this._lerpEnd.y, this._lerpDuration);\r\n      }\r\n      // Given the lerp position figure out the velocity in pixels per second\r\n      this._motion.vel = vec((newX - this._tx.pos.x) / (delta / 1000), (newY - this._tx.pos.y) / (delta / 1000));\r\n    } else {\r\n      this._tx.pos = vec(this._lerpEnd.x, this._lerpEnd.y);\r\n      this._motion.vel = Vector.Zero;\r\n    }\r\n  }\r\n  public isComplete(actor: Actor): boolean {\r\n    return this._stopped || new Vector(actor.pos.x, actor.pos.y).distance(this._lerpStart) >= this._distance;\r\n  }\r\n\r\n  public reset(): void {\r\n    this._initialized = false;\r\n  }\r\n  public stop(): void {\r\n    this._motion.vel = vec(0, 0);\r\n    this._stopped = true;\r\n  }\r\n}\r\n","import { GraphicsComponent } from '../../Graphics/GraphicsComponent';\r\nimport { Entity } from '../../EntityComponentSystem/Entity';\r\nimport { Action } from '../Action';\r\n\r\nexport class Blink implements Action {\r\n  private _graphics: GraphicsComponent;\r\n  private _timeVisible: number = 0;\r\n  private _timeNotVisible: number = 0;\r\n  private _elapsedTime: number = 0;\r\n  private _totalTime: number = 0;\r\n  private _duration: number;\r\n  private _stopped: boolean = false;\r\n  private _started: boolean = false;\r\n  constructor(entity: Entity, timeVisible: number, timeNotVisible: number, numBlinks: number = 1) {\r\n    this._graphics = entity.get(GraphicsComponent);\r\n    this._timeVisible = timeVisible;\r\n    this._timeNotVisible = timeNotVisible;\r\n    this._duration = (timeVisible + timeNotVisible) * numBlinks;\r\n  }\r\n\r\n  public update(delta: number): void {\r\n    if (!this._started) {\r\n      this._started = true;\r\n    }\r\n    if (!this._graphics) {\r\n      return;\r\n    }\r\n\r\n    this._elapsedTime += delta;\r\n    this._totalTime += delta;\r\n    if (this._graphics.visible && this._elapsedTime >= this._timeVisible) {\r\n      this._graphics.visible = false;\r\n      this._elapsedTime = 0;\r\n    }\r\n\r\n    if (!this._graphics.visible && this._elapsedTime >= this._timeNotVisible) {\r\n      this._graphics.visible = true;\r\n      this._elapsedTime = 0;\r\n    }\r\n\r\n    if (this.isComplete()) {\r\n      this._graphics.visible = true;\r\n    }\r\n  }\r\n\r\n  public isComplete(): boolean {\r\n    return this._stopped || this._totalTime >= this._duration;\r\n  }\r\n\r\n  public stop(): void {\r\n    if (this._graphics) {\r\n      this._graphics.visible = true;\r\n    }\r\n    this._stopped = true;\r\n  }\r\n\r\n  public reset() {\r\n    this._started = false;\r\n    this._elapsedTime = 0;\r\n    this._totalTime = 0;\r\n  }\r\n}\r\n","import { Entity } from '../../EntityComponentSystem/Entity';\r\nimport { GraphicsComponent } from '../../Graphics/GraphicsComponent';\r\nimport { Logger } from '../../Util/Log';\r\nimport { Action } from '../Action';\r\n\r\nexport class Fade implements Action {\r\n  private _graphics: GraphicsComponent;\r\n  public x: number;\r\n  public y: number;\r\n\r\n  private _endOpacity: number;\r\n  private _speed: number;\r\n  private _multiplier: number = 1;\r\n  private _started = false;\r\n  private _stopped = false;\r\n\r\n  constructor(entity: Entity, endOpacity: number, speed: number) {\r\n    this._graphics = entity.get(GraphicsComponent);\r\n    this._endOpacity = endOpacity;\r\n    this._speed = speed;\r\n  }\r\n\r\n  public update(delta: number): void {\r\n    if (!this._graphics) {\r\n      return;\r\n    }\r\n\r\n    if (!this._started) {\r\n      this._started = true;\r\n\r\n      // determine direction when we start\r\n      if (this._endOpacity < this._graphics.opacity) {\r\n        this._multiplier = -1;\r\n      } else {\r\n        this._multiplier = 1;\r\n      }\r\n    }\r\n\r\n    if (this._speed > 0) {\r\n      this._graphics.opacity += (this._multiplier *\r\n        (Math.abs(this._graphics.opacity - this._endOpacity) * delta)) / this._speed;\r\n    }\r\n\r\n    this._speed -= delta;\r\n\r\n    if (this.isComplete()) {\r\n      this._graphics.opacity = this._endOpacity;\r\n    }\r\n\r\n    Logger.getInstance().debug('[Action fade] Actor opacity:', this._graphics.opacity);\r\n  }\r\n\r\n  public isComplete(): boolean {\r\n    return this._stopped || Math.abs(this._graphics.opacity - this._endOpacity) < 0.05;\r\n  }\r\n\r\n  public stop(): void {\r\n    this._stopped = true;\r\n  }\r\n\r\n  public reset(): void {\r\n    this._started = false;\r\n  }\r\n}\r\n","import { Action } from '../Action';\r\n\r\nexport class Delay implements Action {\r\n  private _elapsedTime: number = 0;\r\n  private _delay: number;\r\n  private _started: boolean = false;\r\n  private _stopped = false;\r\n  constructor(delay: number) {\r\n    this._delay = delay;\r\n  }\r\n\r\n  public update(delta: number): void {\r\n    if (!this._started) {\r\n      this._started = true;\r\n    }\r\n\r\n    this._elapsedTime += delta;\r\n  }\r\n\r\n  isComplete(): boolean {\r\n    return this._stopped || this._elapsedTime >= this._delay;\r\n  }\r\n\r\n  public stop(): void {\r\n    this._stopped = true;\r\n  }\r\n\r\n  reset(): void {\r\n    this._elapsedTime = 0;\r\n    this._started = false;\r\n  }\r\n}\r\n","import { Entity } from '../../EntityComponentSystem/Entity';\r\nimport { Action } from '../Action';\r\nimport { ActionsComponent } from '../ActionsComponent';\r\n\r\nexport class Die implements Action {\r\n  private _entity: Entity;\r\n  private _stopped = false;\r\n\r\n  constructor(entity: Entity) {\r\n    this._entity = entity;\r\n  }\r\n\r\n  public update(_delta: number): void {\r\n    this._entity.get(ActionsComponent).clearActions();\r\n    this._entity.kill();\r\n    this._stopped = true;\r\n  }\r\n\r\n  public isComplete(): boolean {\r\n    return this._stopped;\r\n  }\r\n\r\n  public stop(): void {\r\n    return;\r\n  }\r\n\r\n  public reset(): void {\r\n    return;\r\n  }\r\n}\r\n","import { MotionComponent } from '../../EntityComponentSystem/Components/MotionComponent';\r\nimport { TransformComponent } from '../../EntityComponentSystem/Components/TransformComponent';\r\nimport { Entity } from '../../EntityComponentSystem/Entity';\r\nimport { vec, Vector } from '../../Math/vector';\r\nimport { Action } from '../Action';\r\n\r\nexport class Follow implements Action {\r\n  private _tx: TransformComponent;\r\n  private _motion: MotionComponent;\r\n  private _followTx: TransformComponent;\r\n  private _followMotion: MotionComponent;\r\n\r\n  public x: number;\r\n  public y: number;\r\n  private _current: Vector;\r\n  private _end: Vector;\r\n  private _dir: Vector;\r\n  private _speed: number;\r\n  private _maximumDistance: number;\r\n  private _distanceBetween: number;\r\n  private _started = false;\r\n  private _stopped = false;\r\n\r\n  constructor(entity: Entity, entityToFollow: Entity, followDistance?: number) {\r\n    this._tx = entity.get(TransformComponent);\r\n    this._motion = entity.get(MotionComponent);\r\n    this._followTx = entityToFollow.get(TransformComponent);\r\n    this._followMotion = entityToFollow.get(MotionComponent);\r\n    this._current = new Vector(this._tx.pos.x, this._tx.pos.y);\r\n    this._end = new Vector(this._followTx.pos.x, this._followTx.pos.y);\r\n    this._maximumDistance = followDistance !== undefined ? followDistance : this._current.distance(this._end);\r\n    this._speed = 0;\r\n  }\r\n\r\n  public update(_delta: number): void {\r\n    if (!this._started) {\r\n      this._started = true;\r\n      this._distanceBetween = this._current.distance(this._end);\r\n      this._dir = this._end.sub(this._current).normalize();\r\n    }\r\n\r\n    const actorToFollowSpeed = Math.sqrt(Math.pow(this._followMotion.vel.x, 2) + Math.pow(this._followMotion.vel.y, 2));\r\n    if (actorToFollowSpeed !== 0) {\r\n      this._speed = actorToFollowSpeed;\r\n    }\r\n    this._current = vec(this._tx.pos.x, this._tx.pos.y);\r\n\r\n    this._end = vec(this._followTx.pos.x, this._followTx.pos.y);\r\n    this._distanceBetween = this._current.distance(this._end);\r\n    this._dir = this._end.sub(this._current).normalize();\r\n\r\n    if (this._distanceBetween >= this._maximumDistance) {\r\n      const m = this._dir.scale(this._speed);\r\n      this._motion.vel = vec(m.x, m.y);\r\n    } else {\r\n      this._motion.vel = vec(0, 0);\r\n    }\r\n\r\n    if (this.isComplete()) {\r\n      this._tx.pos = vec(this._end.x, this._end.y);\r\n      this._motion.vel = vec(0, 0);\r\n    }\r\n  }\r\n\r\n  public stop(): void {\r\n    this._motion.vel = vec(0, 0);\r\n    this._stopped = true;\r\n  }\r\n\r\n  public isComplete(): boolean {\r\n    // the actor following should never stop unless specified to do so\r\n    return this._stopped;\r\n  }\r\n\r\n  public reset(): void {\r\n    this._started = false;\r\n  }\r\n}\r\n","import { MotionComponent } from '../../EntityComponentSystem/Components/MotionComponent';\r\nimport { TransformComponent } from '../../EntityComponentSystem/Components/TransformComponent';\r\nimport { Entity } from '../../EntityComponentSystem/Entity';\r\nimport { Vector, vec } from '../../Math/vector';\r\nimport { Action } from '../Action';\r\n\r\nexport class Meet implements Action {\r\n  private _tx: TransformComponent;\r\n  private _motion: MotionComponent;\r\n  private _meetTx: TransformComponent;\r\n  private _meetMotion: MotionComponent;\r\n  public x: number;\r\n  public y: number;\r\n  private _current: Vector;\r\n  private _end: Vector;\r\n  private _dir: Vector;\r\n  private _speed: number;\r\n  private _distanceBetween: number;\r\n  private _started = false;\r\n  private _stopped = false;\r\n  private _speedWasSpecified = false;\r\n\r\n  constructor(actor: Entity, actorToMeet: Entity, speed?: number) {\r\n    this._tx = actor.get(TransformComponent);\r\n    this._motion = actor.get(MotionComponent);\r\n    this._meetTx = actorToMeet.get(TransformComponent);\r\n    this._meetMotion = actorToMeet.get(MotionComponent);\r\n    this._current = new Vector(this._tx.pos.x, this._tx.pos.y);\r\n    this._end = new Vector(this._meetTx.pos.x, this._meetTx.pos.y);\r\n    this._speed = speed || 0;\r\n\r\n    if (speed !== undefined) {\r\n      this._speedWasSpecified = true;\r\n    }\r\n  }\r\n\r\n  public update(_delta: number): void {\r\n    if (!this._started) {\r\n      this._started = true;\r\n      this._distanceBetween = this._current.distance(this._end);\r\n      this._dir = this._end.sub(this._current).normalize();\r\n    }\r\n\r\n    const actorToMeetSpeed = Math.sqrt(Math.pow(this._meetMotion.vel.x, 2) + Math.pow(this._meetMotion.vel.y, 2));\r\n    if (actorToMeetSpeed !== 0 && !this._speedWasSpecified) {\r\n      this._speed = actorToMeetSpeed;\r\n    }\r\n    this._current = vec(this._tx.pos.x, this._tx.pos.y);\r\n\r\n    this._end = vec(this._meetTx.pos.x, this._meetTx.pos.y);\r\n    this._distanceBetween = this._current.distance(this._end);\r\n    this._dir = this._end.sub(this._current).normalize();\r\n\r\n    const m = this._dir.scale(this._speed);\r\n    this._motion.vel = vec(m.x, m.y);\r\n\r\n    if (this.isComplete()) {\r\n      this._tx.pos = vec(this._end.x, this._end.y);\r\n      this._motion.vel = vec(0, 0);\r\n    }\r\n  }\r\n\r\n  public isComplete(): boolean {\r\n    return this._stopped || this._distanceBetween <= 1;\r\n  }\r\n\r\n  public stop(): void {\r\n    this._motion.vel = vec(0, 0);\r\n    this._stopped = true;\r\n  }\r\n\r\n  public reset(): void {\r\n    this._started = false;\r\n  }\r\n}\r\n","import { RotationType } from './RotationType';\r\n\r\nimport { EasingFunction, EasingFunctions } from '../Util/EasingFunctions';\r\nimport { ActionQueue } from './ActionQueue';\r\nimport { Repeat } from './Action/Repeat';\r\nimport { RepeatForever } from './Action/RepeatForever';\r\nimport { MoveBy } from './Action/MoveBy';\r\nimport { MoveTo } from './Action/MoveTo';\r\nimport { RotateTo } from './Action/RotateTo';\r\nimport { RotateBy } from './Action/RotateBy';\r\nimport { ScaleTo } from './Action/ScaleTo';\r\nimport { ScaleBy } from './Action/ScaleBy';\r\nimport { CallMethod } from './Action/CallMethod';\r\nimport { EaseTo } from './Action/EaseTo';\r\nimport { Blink } from './Action/Blink';\r\nimport { Fade } from './Action/Fade';\r\nimport { Delay } from './Action/Delay';\r\nimport { Die } from './Action/Die';\r\nimport { Follow } from './Action/Follow';\r\nimport { Meet } from './Action/Meet';\r\nimport { Vector } from '../Math/vector';\r\nimport { Entity } from '../EntityComponentSystem/Entity';\r\n\r\n/**\r\n * The fluent Action API allows you to perform \"actions\" on\r\n * [[Actor|Actors]] such as following, moving, rotating, and\r\n * more. You can implement your own actions by implementing\r\n * the [[Action]] interface.\r\n */\r\nexport class ActionContext {\r\n  private _entity: Entity;\r\n  private _queue: ActionQueue;\r\n\r\n  constructor(entity: Entity) {\r\n    this._entity = entity;\r\n    this._queue = new ActionQueue(entity);\r\n  }\r\n\r\n  public getQueue(): ActionQueue {\r\n    return this._queue;\r\n  }\r\n\r\n  public update(elapsedMs: number) {\r\n    this._queue.update(elapsedMs);\r\n  }\r\n\r\n  /**\r\n   * Clears all queued actions from the Actor\r\n   */\r\n  public clearActions(): void {\r\n    this._queue.clearActions();\r\n  }\r\n\r\n  /**\r\n   * This method will move an actor to the specified `x` and `y` position over the\r\n   * specified duration using a given [[EasingFunctions]] and return back the actor. This\r\n   * method is part of the actor 'Action' fluent API allowing action chaining.\r\n   * @param pos       The x,y vector location to move the actor to\r\n   * @param duration  The time it should take the actor to move to the new location in milliseconds\r\n   * @param easingFcn Use [[EasingFunctions]] or a custom function to use to calculate position, Default is [[EasingFunctions.Linear]]\r\n   */\r\n  public easeTo(pos: Vector, duration: number, easingFcn?: EasingFunction): ActionContext\r\n  /**\r\n   * This method will move an actor to the specified `x` and `y` position over the\r\n   * specified duration using a given [[EasingFunctions]] and return back the actor. This\r\n   * method is part of the actor 'Action' fluent API allowing action chaining.\r\n   * @param x         The x location to move the actor to\r\n   * @param y         The y location to move the actor to\r\n   * @param duration  The time it should take the actor to move to the new location in milliseconds\r\n   * @param easingFcn Use [[EasingFunctions]] or a custom function to use to calculate position, Default is [[EasingFunctions.Linear]]\r\n   */\r\n  public easeTo(x: number, y: number, duration: number, easingFcn?: EasingFunction): ActionContext\r\n  public easeTo(...args: any[]): ActionContext {\r\n    let x = 0;\r\n    let y = 0;\r\n    let duration = 0;\r\n    let easingFcn = EasingFunctions.Linear;\r\n    if (args[0] instanceof Vector) {\r\n      x = args[0].x;\r\n      y = args[0].y;\r\n      duration = args[1];\r\n      easingFcn = args[2] ?? easingFcn;\r\n    } else {\r\n      x = args[0];\r\n      y = args[1];\r\n      duration = args[2];\r\n      easingFcn = args[3] ?? easingFcn;\r\n    }\r\n\r\n    this._queue.add(new EaseTo(this._entity, x, y, duration, easingFcn));\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * This method will move an actor to the specified x and y position at the\r\n   * speed specified (in pixels per second) and return back the actor. This\r\n   * method is part of the actor 'Action' fluent API allowing action chaining.\r\n   * @param pos    The x,y vector location to move the actor to\r\n   * @param speed  The speed in pixels per second to move\r\n   */\r\n  public moveTo(pos: Vector, speed: number): ActionContext;\r\n  /**\r\n   * This method will move an actor to the specified x and y position at the\r\n   * speed specified (in pixels per second) and return back the actor. This\r\n   * method is part of the actor 'Action' fluent API allowing action chaining.\r\n   * @param x      The x location to move the actor to\r\n   * @param y      The y location to move the actor to\r\n   * @param speed  The speed in pixels per second to move\r\n   */\r\n  public moveTo(x: number, y: number, speed: number): ActionContext;\r\n  public moveTo(xOrPos: number | Vector, yOrSpeed: number, speedOrUndefined?: number | undefined): ActionContext {\r\n    let x = 0;\r\n    let y = 0;\r\n    let speed = 0;\r\n    if (xOrPos instanceof Vector) {\r\n      x = xOrPos.x;\r\n      y = xOrPos.y;\r\n      speed = yOrSpeed;\r\n    } else {\r\n      x = xOrPos;\r\n      y = yOrSpeed;\r\n      speed = speedOrUndefined;\r\n    }\r\n    this._queue.add(new MoveTo(this._entity, x, y, speed));\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * This method will move an actor by the specified x offset and y offset from its current position, at a certain speed.\r\n   * This method is part of the actor 'Action' fluent API allowing action chaining.\r\n   * @param xOffset     The x offset to apply to this actor\r\n   * @param yOffset     The y location to move the actor to\r\n   * @param speed  The speed in pixels per second the actor should move\r\n   */\r\n  public moveBy(offset: Vector, speed: number): ActionContext;\r\n  public moveBy(xOffset: number, yOffset: number, speed: number): ActionContext;\r\n  public moveBy(xOffsetOrVector: number | Vector, yOffsetOrSpeed: number, speedOrUndefined?: number | undefined): ActionContext {\r\n    let xOffset = 0;\r\n    let yOffset = 0;\r\n    let speed = 0;\r\n    if (xOffsetOrVector instanceof Vector) {\r\n      xOffset = xOffsetOrVector.x;\r\n      yOffset = xOffsetOrVector.y;\r\n      speed = yOffsetOrSpeed;\r\n    } else {\r\n      xOffset = xOffsetOrVector;\r\n      yOffset = yOffsetOrSpeed;\r\n      speed = speedOrUndefined;\r\n    }\r\n    this._queue.add(new MoveBy(this._entity, xOffset, yOffset, speed));\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * This method will rotate an actor to the specified angle at the speed\r\n   * specified (in radians per second) and return back the actor. This\r\n   * method is part of the actor 'Action' fluent API allowing action chaining.\r\n   * @param angleRadians  The angle to rotate to in radians\r\n   * @param speed         The angular velocity of the rotation specified in radians per second\r\n   * @param rotationType  The [[RotationType]] to use for this rotation\r\n   */\r\n  public rotateTo(angleRadians: number, speed: number, rotationType?: RotationType): ActionContext {\r\n    this._queue.add(new RotateTo(this._entity, angleRadians, speed, rotationType));\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * This method will rotate an actor by the specified angle offset, from it's current rotation given a certain speed\r\n   * in radians/sec and return back the actor. This method is part\r\n   * of the actor 'Action' fluent API allowing action chaining.\r\n   * @param angleRadiansOffset  The angle to rotate to in radians relative to the current rotation\r\n   * @param speed          The speed in radians/sec the actor should rotate at\r\n   * @param rotationType  The [[RotationType]] to use for this rotation, default is shortest path\r\n   */\r\n  public rotateBy(angleRadiansOffset: number, speed: number, rotationType?: RotationType): ActionContext {\r\n    this._queue.add(new RotateBy(this._entity, angleRadiansOffset, speed, rotationType));\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * This method will scale an actor to the specified size at the speed\r\n   * specified (in magnitude increase per second) and return back the\r\n   * actor. This method is part of the actor 'Action' fluent API allowing\r\n   * action chaining.\r\n   * @param size    The scale to adjust the actor to over time\r\n   * @param speed   The speed of scaling specified in magnitude increase per second\r\n   */\r\n  public scaleTo(size: Vector, speed: Vector): ActionContext;\r\n  /**\r\n   * This method will scale an actor to the specified size at the speed\r\n   * specified (in magnitude increase per second) and return back the\r\n   * actor. This method is part of the actor 'Action' fluent API allowing\r\n   * action chaining.\r\n   * @param sizeX   The scaling factor to apply on X axis\r\n   * @param sizeY   The scaling factor to apply on Y axis\r\n   * @param speedX  The speed of scaling specified in magnitude increase per second on X axis\r\n   * @param speedY  The speed of scaling specified in magnitude increase per second on Y axis\r\n   */\r\n  public scaleTo(sizeX: number, sizeY: number, speedX: number, speedY: number): ActionContext;\r\n  public scaleTo(sizeXOrVector: number | Vector,\r\n    sizeYOrSpeed: number | Vector,\r\n    speedXOrUndefined?: number | undefined,\r\n    speedYOrUndefined?: number | undefined): ActionContext {\r\n\r\n    let sizeX = 1;\r\n    let sizeY = 1;\r\n    let speedX = 0;\r\n    let speedY = 0;\r\n\r\n    if (sizeXOrVector instanceof Vector && sizeYOrSpeed instanceof Vector) {\r\n      sizeX = sizeXOrVector.x;\r\n      sizeY = sizeXOrVector.y;\r\n\r\n      speedX = sizeYOrSpeed.x;\r\n      speedY = sizeYOrSpeed.y;\r\n    }\r\n    if (typeof sizeXOrVector === 'number' && typeof sizeYOrSpeed === 'number') {\r\n      sizeX = sizeXOrVector;\r\n      sizeY = sizeYOrSpeed;\r\n\r\n      speedX = speedXOrUndefined;\r\n      speedY = speedYOrUndefined;\r\n    }\r\n\r\n    this._queue.add(new ScaleTo(this._entity, sizeX, sizeY, speedX, speedY));\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * This method will scale an actor by an amount relative to the current scale at a certain speed in scale units/sec\r\n   * and return back the actor. This method is part of the\r\n   * actor 'Action' fluent API allowing action chaining.\r\n   * @param offset   The scaling factor to apply to the actor\r\n   * @param speed    The speed to scale at in scale units/sec\r\n   */\r\n  public scaleBy(offset: Vector, speed: number): ActionContext;\r\n  /**\r\n   * This method will scale an actor by an amount relative to the current scale at a certain speed in scale units/sec\r\n   * and return back the actor. This method is part of the\r\n   * actor 'Action' fluent API allowing action chaining.\r\n   * @param sizeOffsetX   The scaling factor to apply on X axis\r\n   * @param sizeOffsetY   The scaling factor to apply on Y axis\r\n   * @param speed    The speed to scale at in scale units/sec\r\n   */\r\n  public scaleBy(sizeOffsetX: number, sizeOffsetY: number, speed: number): ActionContext;\r\n  public scaleBy(sizeOffsetXOrVector: number | Vector, sizeOffsetYOrSpeed: number, speed?: number | undefined): ActionContext {\r\n    let sizeOffsetX = 1;\r\n    let sizeOffsetY = 1;\r\n\r\n    if (sizeOffsetXOrVector instanceof Vector) {\r\n      sizeOffsetX = sizeOffsetXOrVector.x;\r\n      sizeOffsetY = sizeOffsetXOrVector.y;\r\n\r\n      speed = sizeOffsetYOrSpeed;\r\n    }\r\n    if (typeof sizeOffsetXOrVector === 'number' && typeof sizeOffsetYOrSpeed === 'number') {\r\n      sizeOffsetX = sizeOffsetXOrVector;\r\n      sizeOffsetY = sizeOffsetYOrSpeed;\r\n    }\r\n\r\n    this._queue.add(new ScaleBy(this._entity, sizeOffsetX, sizeOffsetY, speed));\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * This method will cause an actor to blink (become visible and not\r\n   * visible). Optionally, you may specify the number of blinks. Specify the amount of time\r\n   * the actor should be visible per blink, and the amount of time not visible.\r\n   * This method is part of the actor 'Action' fluent API allowing action chaining.\r\n   * @param timeVisible     The amount of time to stay visible per blink in milliseconds\r\n   * @param timeNotVisible  The amount of time to stay not visible per blink in milliseconds\r\n   * @param numBlinks       The number of times to blink\r\n   */\r\n  public blink(timeVisible: number, timeNotVisible: number, numBlinks: number = 1): ActionContext {\r\n    this._queue.add(new Blink(this._entity, timeVisible, timeNotVisible, numBlinks));\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * This method will cause an actor's opacity to change from its current value\r\n   * to the provided value by a specified time (in milliseconds). This method is\r\n   * part of the actor 'Action' fluent API allowing action chaining.\r\n   * @param opacity  The ending opacity\r\n   * @param time     The time it should take to fade the actor (in milliseconds)\r\n   */\r\n  public fade(opacity: number, time: number): ActionContext {\r\n    this._queue.add(new Fade(this._entity, opacity, time));\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * This method will delay the next action from executing for a certain\r\n   * amount of time (in milliseconds). This method is part of the actor\r\n   * 'Action' fluent API allowing action chaining.\r\n   * @param time  The amount of time to delay the next action in the queue from executing in milliseconds\r\n   */\r\n  public delay(time: number): ActionContext {\r\n    this._queue.add(new Delay(time));\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * This method will add an action to the queue that will remove the actor from the\r\n   * scene once it has completed its previous  Any actions on the\r\n   * action queue after this action will not be executed.\r\n   */\r\n  public die(): ActionContext {\r\n    this._queue.add(new Die(this._entity));\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * This method allows you to call an arbitrary method as the next action in the\r\n   * action queue. This is useful if you want to execute code in after a specific\r\n   * action, i.e An actor arrives at a destination after traversing a path\r\n   */\r\n  public callMethod(method: () => any): ActionContext {\r\n    this._queue.add(new CallMethod(method));\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * This method will cause the actor to repeat all of the actions built in\r\n   * the `repeatBuilder` callback. If the number of repeats\r\n   * is not specified it will repeat forever. This method is part of\r\n   * the actor 'Action' fluent API allowing action chaining\r\n   *\r\n   * ```typescript\r\n   * // Move up in a zig-zag by repeated moveBy's\r\n   * actor.actions.repeat(repeatCtx => {\r\n   *  repeatCtx.moveBy(10, 0, 10);\r\n   *  repeatCtx.moveBy(0, 10, 10);\r\n   * }, 5);\r\n   * ```\r\n   *\r\n   * @param repeatBuilder The builder to specify the repeatable list of actions\r\n   * @param times  The number of times to repeat all the previous actions in the action queue. If nothing is specified the actions\r\n   * will repeat forever\r\n   */\r\n  public repeat(repeatBuilder: (repeatContext: ActionContext) => any, times?: number): ActionContext {\r\n    if (!times) {\r\n      this.repeatForever(repeatBuilder);\r\n      return this;\r\n    }\r\n    this._queue.add(new Repeat(this._entity, repeatBuilder, times));\r\n\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * This method will cause the actor to repeat all of the actions built in\r\n   * the `repeatBuilder` callback. If the number of repeats\r\n   * is not specified it will repeat forever. This method is part of\r\n   * the actor 'Action' fluent API allowing action chaining\r\n   *\r\n   * ```typescript\r\n   * // Move up in a zig-zag by repeated moveBy's\r\n   * actor.actions.repeat(repeatCtx => {\r\n   *  repeatCtx.moveBy(10, 0, 10);\r\n   *  repeatCtx.moveBy(0, 10, 10);\r\n   * }, 5);\r\n   * ```\r\n   *\r\n   * @param repeatBuilder The builder to specify the repeatable list of actions\r\n   */\r\n  public repeatForever(repeatBuilder: (repeatContext: ActionContext) => any): ActionContext {\r\n    this._queue.add(new RepeatForever(this._entity, repeatBuilder));\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * This method will cause the entity to follow another at a specified distance\r\n   * @param entity           The entity to follow\r\n   * @param followDistance  The distance to maintain when following, if not specified the actor will follow at the current distance.\r\n   */\r\n  public follow(entity: Entity, followDistance?: number): ActionContext {\r\n    if (followDistance === undefined) {\r\n      this._queue.add(new Follow(this._entity, entity));\r\n    } else {\r\n      this._queue.add(new Follow(this._entity, entity, followDistance));\r\n    }\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * This method will cause the entity to move towards another until they\r\n   * collide \"meet\" at a specified speed.\r\n   * @param entity  The entity to meet\r\n   * @param speed  The speed in pixels per second to move, if not specified it will match the speed of the other actor\r\n   */\r\n  public meet(entity: Entity, speed?: number): ActionContext {\r\n    if (speed === undefined) {\r\n      this._queue.add(new Meet(this._entity, entity));\r\n    } else {\r\n      this._queue.add(new Meet(this._entity, entity, speed));\r\n    }\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Returns a promise that resolves when the current action queue up to now\r\n   * is finished.\r\n   */\r\n  public toPromise(): Promise<void> {\r\n    const temp = new Promise<void>((resolve) => {\r\n      this._queue.add(\r\n        new CallMethod(() => {\r\n          resolve();\r\n        })\r\n      );\r\n    });\r\n    return temp;\r\n  }\r\n}\r\n","import { ActionContext } from './ActionContext';\r\nimport { Component } from '../EntityComponentSystem/Component';\r\nimport { Entity } from '../EntityComponentSystem/Entity';\r\nimport { Actor } from '../Actor';\r\nimport { MotionComponent } from '../EntityComponentSystem/Components/MotionComponent';\r\nimport { TransformComponent } from '../EntityComponentSystem/Components/TransformComponent';\r\nimport { Vector } from '../Math/vector';\r\nimport { EasingFunction } from '../Util/EasingFunctions';\r\nimport { ActionQueue } from './ActionQueue';\r\nimport { RotationType } from './RotationType';\r\n\r\nexport interface ActionContextMethods extends Pick<ActionContext, keyof ActionContext> { };\r\n\r\nexport class ActionsComponent extends Component<'ex.actions'> implements ActionContextMethods {\r\n  public readonly type = 'ex.actions';\r\n  dependencies = [TransformComponent, MotionComponent];\r\n  private _ctx: ActionContext;\r\n\r\n  onAdd(entity: Entity) {\r\n    this._ctx = new ActionContext(entity);\r\n  }\r\n\r\n  onRemove() {\r\n    this._ctx = null;\r\n  }\r\n\r\n  /**\r\n   * Returns the internal action queue\r\n   * @returns action queue\r\n   */\r\n  public getQueue(): ActionQueue {\r\n    return this._ctx?.getQueue();\r\n  }\r\n\r\n  /**\r\n   * Updates the internal action context, performing action and moving through the internal queue\r\n   * @param elapsedMs\r\n   */\r\n  public update(elapsedMs: number): void {\r\n    return this._ctx?.update(elapsedMs);\r\n  }\r\n\r\n  /**\r\n   * Clears all queued actions from the Actor\r\n   */\r\n  public clearActions(): void {\r\n    this._ctx?.clearActions();\r\n  }\r\n\r\n  /**\r\n   * This method will move an actor to the specified `x` and `y` position over the\r\n   * specified duration using a given [[EasingFunctions]] and return back the actor. This\r\n   * method is part of the actor 'Action' fluent API allowing action chaining.\r\n   * @param pos       The x,y vector location to move the actor to\r\n   * @param duration  The time it should take the actor to move to the new location in milliseconds\r\n   * @param easingFcn Use [[EasingFunctions]] or a custom function to use to calculate position, Default is [[EasingFunctions.Linear]]\r\n   */\r\n  public easeTo(pos: Vector, duration: number, easingFcn?: EasingFunction): ActionContext;\r\n  /**\r\n   * This method will move an actor to the specified `x` and `y` position over the\r\n   * specified duration using a given [[EasingFunctions]] and return back the actor. This\r\n   * method is part of the actor 'Action' fluent API allowing action chaining.\r\n   * @param x         The x location to move the actor to\r\n   * @param y         The y location to move the actor to\r\n   * @param duration  The time it should take the actor to move to the new location in milliseconds\r\n   * @param easingFcn Use [[EasingFunctions]] or a custom function to use to calculate position, Default is [[EasingFunctions.Linear]]\r\n   */\r\n  public easeTo(x: number, y: number, duration: number, easingFcn?: EasingFunction): ActionContext;\r\n  public easeTo(...args: any[]): ActionContext {\r\n    return this._ctx.easeTo.apply(this._ctx, args);\r\n  }\r\n\r\n  /**\r\n   * This method will move an actor to the specified x and y position at the\r\n   * speed specified (in pixels per second) and return back the actor. This\r\n   * method is part of the actor 'Action' fluent API allowing action chaining.\r\n   * @param pos    The x,y vector location to move the actor to\r\n   * @param speed  The speed in pixels per second to move\r\n   */\r\n  public moveTo(pos: Vector, speed: number): ActionContext;\r\n  /**\r\n   * This method will move an actor to the specified x and y position at the\r\n   * speed specified (in pixels per second) and return back the actor. This\r\n   * method is part of the actor 'Action' fluent API allowing action chaining.\r\n   * @param x      The x location to move the actor to\r\n   * @param y      The y location to move the actor to\r\n   * @param speed  The speed in pixels per second to move\r\n   */\r\n  public moveTo(x: number, y: number, speed: number): ActionContext;\r\n  public moveTo(xOrPos: number | Vector, yOrSpeed: number, speedOrUndefined?: number): ActionContext {\r\n    return this._ctx.moveTo.apply(this._ctx, [xOrPos, yOrSpeed, speedOrUndefined]);\r\n  }\r\n\r\n  /**\r\n   * This method will move an actor by the specified x offset and y offset from its current position, at a certain speed.\r\n   * This method is part of the actor 'Action' fluent API allowing action chaining.\r\n   * @param offset The (x, y) offset to apply to this actor\r\n   * @param speed  The speed in pixels per second the actor should move\r\n   */\r\n  public moveBy(offset: Vector, speed: number): ActionContext;\r\n  /**\r\n   * This method will move an actor by the specified x offset and y offset from its current position, at a certain speed.\r\n   * This method is part of the actor 'Action' fluent API allowing action chaining.\r\n   * @param xOffset     The x offset to apply to this actor\r\n   * @param yOffset     The y location to move the actor to\r\n   * @param speed  The speed in pixels per second the actor should move\r\n   */\r\n  public moveBy(xOffset: number, yOffset: number, speed: number): ActionContext;\r\n  public moveBy(xOffsetOrVector: number | Vector, yOffsetOrSpeed: number, speedOrUndefined?: number): ActionContext {\r\n    return this._ctx.moveBy.apply(this._ctx, [xOffsetOrVector, yOffsetOrSpeed, speedOrUndefined]);\r\n  }\r\n\r\n  /**\r\n   * This method will rotate an actor to the specified angle at the speed\r\n   * specified (in radians per second) and return back the actor. This\r\n   * method is part of the actor 'Action' fluent API allowing action chaining.\r\n   * @param angleRadians  The angle to rotate to in radians\r\n   * @param speed         The angular velocity of the rotation specified in radians per second\r\n   * @param rotationType  The [[RotationType]] to use for this rotation\r\n   */\r\n  public rotateTo(angleRadians: number, speed: number, rotationType?: RotationType): ActionContext {\r\n    return this._ctx.rotateTo(angleRadians, speed, rotationType);\r\n  }\r\n\r\n  /**\r\n   * This method will rotate an actor by the specified angle offset, from it's current rotation given a certain speed\r\n   * in radians/sec and return back the actor. This method is part\r\n   * of the actor 'Action' fluent API allowing action chaining.\r\n   * @param angleRadiansOffset  The angle to rotate to in radians relative to the current rotation\r\n   * @param speed          The speed in radians/sec the actor should rotate at\r\n   * @param rotationType  The [[RotationType]] to use for this rotation, default is shortest path\r\n   */\r\n  public rotateBy(angleRadiansOffset: number, speed: number, rotationType?: RotationType): ActionContext {\r\n    return this._ctx.rotateBy(angleRadiansOffset, speed, rotationType);\r\n  }\r\n\r\n  /**\r\n   * This method will scale an actor to the specified size at the speed\r\n   * specified (in magnitude increase per second) and return back the\r\n   * actor. This method is part of the actor 'Action' fluent API allowing\r\n   * action chaining.\r\n   * @param size    The scale to adjust the actor to over time\r\n   * @param speed   The speed of scaling specified in magnitude increase per second\r\n   */\r\n  public scaleTo(size: Vector, speed: Vector): ActionContext;\r\n  /**\r\n   * This method will scale an actor to the specified size at the speed\r\n   * specified (in magnitude increase per second) and return back the\r\n   * actor. This method is part of the actor 'Action' fluent API allowing\r\n   * action chaining.\r\n   * @param sizeX   The scaling factor to apply on X axis\r\n   * @param sizeY   The scaling factor to apply on Y axis\r\n   * @param speedX  The speed of scaling specified in magnitude increase per second on X axis\r\n   * @param speedY  The speed of scaling specified in magnitude increase per second on Y axis\r\n   */\r\n  public scaleTo(sizeX: number, sizeY: number, speedX: number, speedY: number): ActionContext;\r\n  public scaleTo(\r\n    sizeXOrVector: number | Vector,\r\n    sizeYOrSpeed: number | Vector,\r\n    speedXOrUndefined?: number,\r\n    speedYOrUndefined?: number): ActionContext {\r\n    return this._ctx.scaleTo.apply(this._ctx, [sizeXOrVector, sizeYOrSpeed, speedXOrUndefined, speedYOrUndefined]);\r\n  }\r\n\r\n  /**\r\n   * This method will scale an actor by an amount relative to the current scale at a certain speed in scale units/sec\r\n   * and return back the actor. This method is part of the\r\n   * actor 'Action' fluent API allowing action chaining.\r\n   * @param offset   The scaling factor to apply to the actor\r\n   * @param speed    The speed to scale at in scale units/sec\r\n   */\r\n  public scaleBy(offset: Vector, speed: number): ActionContext;\r\n  /**\r\n   * This method will scale an actor by an amount relative to the current scale at a certain speed in scale units/sec\r\n   * and return back the actor. This method is part of the\r\n   * actor 'Action' fluent API allowing action chaining.\r\n   * @param sizeOffsetX   The scaling factor to apply on X axis\r\n   * @param sizeOffsetY   The scaling factor to apply on Y axis\r\n   * @param speed    The speed to scale at in scale units/sec\r\n   */\r\n  public scaleBy(sizeOffsetX: number, sizeOffsetY: number, speed: number): ActionContext;\r\n  public scaleBy(sizeOffsetXOrVector: number | Vector, sizeOffsetYOrSpeed: number, speed?: number): ActionContext {\r\n    return this._ctx.scaleBy.apply(this._ctx, [sizeOffsetXOrVector, sizeOffsetYOrSpeed, speed]);\r\n  }\r\n\r\n  /**\r\n   * This method will cause an actor to blink (become visible and not\r\n   * visible). Optionally, you may specify the number of blinks. Specify the amount of time\r\n   * the actor should be visible per blink, and the amount of time not visible.\r\n   * This method is part of the actor 'Action' fluent API allowing action chaining.\r\n   * @param timeVisible     The amount of time to stay visible per blink in milliseconds\r\n   * @param timeNotVisible  The amount of time to stay not visible per blink in milliseconds\r\n   * @param numBlinks       The number of times to blink\r\n   */\r\n  public blink(timeVisible: number, timeNotVisible: number, numBlinks?: number): ActionContext {\r\n    return this._ctx.blink(timeVisible, timeNotVisible, numBlinks);\r\n  }\r\n\r\n  /**\r\n   * This method will cause an actor's opacity to change from its current value\r\n   * to the provided value by a specified time (in milliseconds). This method is\r\n   * part of the actor 'Action' fluent API allowing action chaining.\r\n   * @param opacity  The ending opacity\r\n   * @param time     The time it should take to fade the actor (in milliseconds)\r\n   */\r\n  public fade(opacity: number, time: number): ActionContext {\r\n    return this._ctx.fade(opacity, time);\r\n  }\r\n\r\n  /**\r\n   * This method will delay the next action from executing for a certain\r\n   * amount of time (in milliseconds). This method is part of the actor\r\n   * 'Action' fluent API allowing action chaining.\r\n   * @param time  The amount of time to delay the next action in the queue from executing in milliseconds\r\n   */\r\n  public delay(time: number): ActionContext {\r\n    return this._ctx.delay(time);\r\n  }\r\n\r\n  /**\r\n   * This method will add an action to the queue that will remove the actor from the\r\n   * scene once it has completed its previous  Any actions on the\r\n   * action queue after this action will not be executed.\r\n   */\r\n  public die(): ActionContext {\r\n    return this._ctx.die();\r\n  }\r\n\r\n  /**\r\n   * This method allows you to call an arbitrary method as the next action in the\r\n   * action queue. This is useful if you want to execute code in after a specific\r\n   * action, i.e An actor arrives at a destination after traversing a path\r\n   */\r\n  public callMethod(method: () => any): ActionContext {\r\n    return this._ctx.callMethod(method);\r\n  }\r\n\r\n  /**\r\n   * This method will cause the actor to repeat all of the actions built in\r\n   * the `repeatBuilder` callback. If the number of repeats\r\n   * is not specified it will repeat forever. This method is part of\r\n   * the actor 'Action' fluent API allowing action chaining\r\n   *\r\n   * ```typescript\r\n   * // Move up in a zig-zag by repeated moveBy's\r\n   * actor.actions.repeat(repeatCtx => {\r\n   *  repeatCtx.moveBy(10, 0, 10);\r\n   *  repeatCtx.moveBy(0, 10, 10);\r\n   * }, 5);\r\n   * ```\r\n   *\r\n   * @param repeatBuilder The builder to specify the repeatable list of actions\r\n   * @param times  The number of times to repeat all the previous actions in the action queue. If nothing is specified the actions\r\n   * will repeat forever\r\n   */\r\n  public repeat(repeatBuilder: (repeatContext: ActionContext) => any, times?: number): ActionContext {\r\n    return this._ctx.repeat(repeatBuilder, times);\r\n  }\r\n\r\n  /**\r\n   * This method will cause the actor to repeat all of the actions built in\r\n   * the `repeatBuilder` callback. If the number of repeats\r\n   * is not specified it will repeat forever. This method is part of\r\n   * the actor 'Action' fluent API allowing action chaining\r\n   *\r\n   * ```typescript\r\n   * // Move up in a zig-zag by repeated moveBy's\r\n   * actor.actions.repeat(repeatCtx => {\r\n   *  repeatCtx.moveBy(10, 0, 10);\r\n   *  repeatCtx.moveBy(0, 10, 10);\r\n   * }, 5);\r\n   * ```\r\n   *\r\n   * @param repeatBuilder The builder to specify the repeatable list of actions\r\n   */\r\n  public repeatForever(repeatBuilder: (repeatContext: ActionContext) => any): ActionContext {\r\n    return this._ctx.repeatForever(repeatBuilder);\r\n  }\r\n\r\n  /**\r\n   * This method will cause the entity to follow another at a specified distance\r\n   * @param entity           The entity to follow\r\n   * @param followDistance  The distance to maintain when following, if not specified the actor will follow at the current distance.\r\n   */\r\n  public follow(entity: Actor, followDistance?: number): ActionContext {\r\n    return this._ctx.follow(entity, followDistance);\r\n  }\r\n\r\n  /**\r\n   * This method will cause the entity to move towards another until they\r\n   * collide \"meet\" at a specified speed.\r\n   * @param entity  The entity to meet\r\n   * @param speed  The speed in pixels per second to move, if not specified it will match the speed of the other actor\r\n   */\r\n  public meet(entity: Actor, speed?: number): ActionContext {\r\n    return this._ctx.meet(entity, speed);\r\n  }\r\n\r\n  /**\r\n   * Returns a promise that resolves when the current action queue up to now\r\n   * is finished.\r\n   */\r\n  public toPromise(): Promise<void> {\r\n    return this._ctx.toPromise();\r\n  }\r\n}","import { BoundingBox } from '../Collision/BoundingBox';\r\nimport { Color } from '../Color';\r\nimport { Vector } from '../Math/vector';\r\nimport { ExcaliburGraphicsContext } from './Context/ExcaliburGraphicsContext';\r\n\r\n/**\r\n * Enum representing the different font size units\r\n * https://developer.mozilla.org/en-US/docs/Web/CSS/font-size\r\n */\r\nexport enum FontUnit {\r\n  /**\r\n   * Em is a scalable unit, 1 em is equal to the current font size of the current element, parent elements can effect em values\r\n   */\r\n  Em = 'em',\r\n  /**\r\n   * Rem is similar to the Em, it is a scalable unit. 1 rem is equal to the font size of the root element\r\n   */\r\n  Rem = 'rem',\r\n  /**\r\n   * Pixel is a unit of length in screen pixels\r\n   */\r\n  Px = 'px',\r\n  /**\r\n   * Point is a physical unit length (1/72 of an inch)\r\n   */\r\n  Pt = 'pt',\r\n  /**\r\n   * Percent is a scalable unit similar to Em, the only difference is the Em units scale faster when Text-Size stuff\r\n   */\r\n  Percent = '%'\r\n}\r\n\r\n/**\r\n * Enum representing the different horizontal text alignments\r\n */\r\nexport enum TextAlign {\r\n  /**\r\n   * The text is left-aligned.\r\n   */\r\n  Left = 'left',\r\n  /**\r\n   * The text is right-aligned.\r\n   */\r\n  Right = 'right',\r\n  /**\r\n   * The text is centered.\r\n   */\r\n  Center = 'center',\r\n  /**\r\n   * The text is aligned at the normal start of the line (left-aligned for left-to-right locales,\r\n   * right-aligned for right-to-left locales).\r\n   */\r\n  Start = 'start',\r\n  /**\r\n   * The text is aligned at the normal end of the line (right-aligned for left-to-right locales,\r\n   * left-aligned for right-to-left locales).\r\n   */\r\n  End = 'end'\r\n}\r\n\r\n/**\r\n * Enum representing the different baseline text alignments\r\n */\r\nexport enum BaseAlign {\r\n  /**\r\n   * The text baseline is the top of the em square.\r\n   */\r\n  Top = 'top',\r\n  /**\r\n   * The text baseline is the hanging baseline.  Currently unsupported; this will act like\r\n   * alphabetic.\r\n   */\r\n  Hanging = 'hanging',\r\n  /**\r\n   * The text baseline is the middle of the em square.\r\n   */\r\n  Middle = 'middle',\r\n  /**\r\n   * The text baseline is the normal alphabetic baseline.\r\n   */\r\n  Alphabetic = 'alphabetic',\r\n  /**\r\n   * The text baseline is the ideographic baseline; this is the bottom of\r\n   * the body of the characters, if the main body of characters protrudes\r\n   * beneath the alphabetic baseline.  Currently unsupported; this will\r\n   * act like alphabetic.\r\n   */\r\n  Ideographic = 'ideographic',\r\n  /**\r\n   * The text baseline is the bottom of the bounding box.  This differs\r\n   * from the ideographic baseline in that the ideographic baseline\r\n   * doesn't consider descenders.\r\n   */\r\n  Bottom = 'bottom'\r\n}\r\n\r\n/**\r\n * Enum representing the different possible font styles\r\n */\r\nexport enum FontStyle {\r\n  Normal = 'normal',\r\n  Italic = 'italic',\r\n  Oblique = 'oblique'\r\n}\r\n\r\n/**\r\n * Enum representing the text direction, useful for other languages, or writing text in reverse\r\n */\r\nexport enum Direction {\r\n  LeftToRight = 'ltr',\r\n  RightToLeft = 'rtl'\r\n}\r\n\r\n/**\r\n * Font rendering option\r\n */\r\nexport interface FontOptions {\r\n  /**\r\n   * Optionally the size of the font in the specified [[FontUnit]] by default 10.\r\n   */\r\n  size?: number;\r\n  /**\r\n   * Optionally specify unit to measure fonts in, by default Pixels\r\n   */\r\n  unit?: FontUnit;\r\n  /**\r\n   * Optionally specify the font family, by default 'sans-serif'\r\n   */\r\n  family?: string;\r\n  /**\r\n   * Optionally specify the font style, by default Normal\r\n   */\r\n  style?: FontStyle;\r\n  /**\r\n   * Optionally set whether the font is bold, by default false\r\n   */\r\n  bold?: boolean;\r\n  /**\r\n   * Optionally specify the text align, by default Left\r\n   */\r\n  textAlign?: TextAlign;\r\n  /**\r\n   * Optionally specify the text base align, by default Alphabetic\r\n   */\r\n  baseAlign?: BaseAlign;\r\n  /**\r\n   * Optionally specify the text direction, by default LeftToRight\r\n   */\r\n  direction?: Direction;\r\n  /**\r\n   * Optionally specify the quality of the text bitmap, it is a multiplier on the size size, by default 2.\r\n   * Higher quality text has a higher memory impact\r\n   */\r\n  quality?: number;\r\n  /**\r\n   * Optionally specify a text shadow, by default none is specified\r\n   */\r\n  shadow?: {\r\n    blur?: number;\r\n    offset?: Vector;\r\n    color?: Color;\r\n  };\r\n}\r\n\r\n/**\r\n * @internal\r\n */\r\nexport interface FontRenderer {\r\n  measureText(text: string): BoundingBox;\r\n  render(ex: ExcaliburGraphicsContext, text: string, color: Color, x: number, y: number): void;\r\n}\r\n","import { Vector } from '../Math/vector';\r\nimport { BoundingBox } from '../Collision/Index';\r\nimport { Color } from '../Color';\r\nimport { line } from '../Util/DrawUtil';\r\nimport { ExcaliburGraphicsContext } from './Context/ExcaliburGraphicsContext';\r\nimport { BaseAlign, Direction, FontOptions, FontStyle, FontUnit, TextAlign, FontRenderer } from './FontCommon';\r\nimport { Graphic, GraphicOptions } from './Graphic';\r\nimport { RasterOptions } from './Raster';\r\nimport { TextureLoader } from '.';\r\nimport { ImageFiltering } from './Filtering';\r\n\r\n/**\r\n * Represents a system or web font in Excalibur\r\n *\r\n * If no options specified, the system sans-serif 10 pixel is used\r\n *\r\n * If loading a custom web font be sure to have the font loaded before you use it https://erikonarheim.com/posts/dont-test-fonts/\r\n */\r\nexport class Font extends Graphic implements FontRenderer {\r\n  /**\r\n   * Set the font filtering mode, by default set to [[ImageFiltering.Blended]] regardless of the engine default smoothing\r\n   *\r\n   * If you have a pixel style font that may be a reason to switch this to [[ImageFiltering.Pixel]]\r\n   */\r\n  public filtering: ImageFiltering = ImageFiltering.Blended;\r\n  constructor(options: FontOptions & GraphicOptions & RasterOptions = {}) {\r\n    super(options); // <- Graphics properties\r\n\r\n    // Raster properties\r\n    this.smoothing = options?.smoothing ?? this.smoothing;\r\n    this.padding = options?.padding ?? this.padding;\r\n    this.color = options?.color ?? this.color;\r\n    this.strokeColor = options?.strokeColor ?? this.strokeColor;\r\n    this.lineDash = options?.lineDash ?? this.lineDash;\r\n    this.lineWidth = options?.lineWidth ?? this.lineWidth;\r\n    this.filtering = options?.filtering ?? this.filtering;\r\n\r\n    // Font specific properties\r\n    this.family = options?.family ?? this.family;\r\n    this.style = options?.style ?? this.style;\r\n    this.bold = options?.bold ?? this.bold;\r\n    this.size = options?.size ?? this.size;\r\n    this.unit = options?.unit ?? this.unit;\r\n    this.textAlign = options?.textAlign ?? this.textAlign;\r\n    this.baseAlign = options?.baseAlign ?? this.baseAlign;\r\n    this.direction = options?.direction ?? this.direction;\r\n    this.quality = options?.quality ?? this.quality;\r\n    if (options?.shadow) {\r\n      this.shadow = {};\r\n      this.shadow.blur = options.shadow.blur ?? this.shadow.blur;\r\n      this.shadow.offset = options.shadow.offset ?? this.shadow.offset;\r\n      this.shadow.color = options.shadow.color ?? this.shadow.color;\r\n    }\r\n  }\r\n\r\n  public clone() {\r\n    return new Font({\r\n      ...this.cloneGraphicOptions(),\r\n      size: this.size,\r\n      unit: this.unit,\r\n      family: this.family,\r\n      style: this.style,\r\n      bold: this.bold,\r\n      textAlign: this.textAlign,\r\n      baseAlign: this.baseAlign,\r\n      direction: this.direction,\r\n      shadow: this.shadow\r\n        ? {\r\n          blur: this.shadow.blur,\r\n          offset: this.shadow.offset,\r\n          color: this.shadow.color\r\n        }\r\n        : null\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Font quality determines the size of the underlying raster text, higher quality means less jagged edges.\r\n   * If quality is set to 1, then just enough raster bitmap is generated to render the text.\r\n   *\r\n   * You can think of quality as how zoomed in to the text you can get before seeing jagged edges.\r\n   *\r\n   * (Default 2)\r\n   */\r\n  public quality = 2;\r\n\r\n  // Raster properties for fonts\r\n  public padding = 2;\r\n  public smoothing = false;\r\n  public lineWidth = 1;\r\n  public lineDash: number[] = [];\r\n  public color: Color = Color.Black;\r\n  public strokeColor: Color;\r\n\r\n  public family: string = 'sans-serif';\r\n  public style: FontStyle = FontStyle.Normal;\r\n  public bold: boolean = false;\r\n  public unit: FontUnit = FontUnit.Px;\r\n  public textAlign: TextAlign = TextAlign.Left;\r\n  public baseAlign: BaseAlign = BaseAlign.Alphabetic;\r\n  public direction: Direction = Direction.LeftToRight;\r\n  public size: number = 10;\r\n  public shadow: { blur?: number; offset?: Vector; color?: Color } = null;\r\n\r\n  public get fontString() {\r\n    return `${this.style} ${this.bold ? 'bold' : ''} ${this.size}${this.unit} ${this.family}`;\r\n  }\r\n\r\n  private _textBounds: BoundingBox = new BoundingBox();\r\n\r\n  public get localBounds(): BoundingBox {\r\n    return this._textBounds;\r\n  }\r\n\r\n\r\n  protected _drawImage(_ex: ExcaliburGraphicsContext, _x: number, _y: number) {\r\n    // TODO weird vestigial drawimage\r\n  }\r\n\r\n\r\n  protected _rotate(ex: ExcaliburGraphicsContext) {\r\n    // TODO this needs to change depending on the bounding box...\r\n    const origin = this.origin ?? this._textBounds.center;\r\n    ex.translate(origin.x, origin.y);\r\n    ex.rotate(this.rotation);\r\n    ex.translate(-origin.x, -origin.y);\r\n  }\r\n\r\n  protected _flip(ex: ExcaliburGraphicsContext) {\r\n    if (this.flipHorizontal) {\r\n      ex.translate(this._textBounds.width / this.scale.x, 0);\r\n      ex.scale(-1, 1);\r\n    }\r\n\r\n    if (this.flipVertical) {\r\n      ex.translate(0, -this._textBounds.height / 2 / this.scale.y);\r\n      ex.scale(1, -1);\r\n    }\r\n  }\r\n\r\n\r\n  private _cachedTextMeasurement = new Map<string, {text: string, measurement: BoundingBox, rasterProps: string}>();\r\n  private _bitmapToTextMeasurement = new Map<CanvasRenderingContext2D, {text: string, measurement: BoundingBox, rasterProps: string}>();\r\n  /**\r\n   * Returns a BoundingBox that is the total size of the text including multiple lines\r\n   *\r\n   * Does not include any padding or adjustment\r\n   * @param text\r\n   * @returns BoundingBox\r\n   */\r\n  public measureText(text: string): BoundingBox {\r\n    let measurementDirty = false;\r\n    let cached = this._cachedTextMeasurement.get(text);\r\n    if (!cached) {\r\n      measurementDirty = true;\r\n    }\r\n\r\n    const rasterProps = this._getRasterPropertiesHash();\r\n    if (!cached || rasterProps !== cached.rasterProps) {\r\n      measurementDirty = true;\r\n    }\r\n\r\n    if (measurementDirty) {\r\n      const lines = text.split('\\n');\r\n      const maxWidthLine = lines.reduce((a, b) => {\r\n        return a.length > b.length ? a : b;\r\n      });\r\n      const ctx = this._getTextBitmap(text);\r\n\r\n      this._applyFont(ctx); // font must be applied to the context to measure it\r\n      const metrics = ctx.measureText(maxWidthLine);\r\n      let textHeight = Math.abs(metrics.actualBoundingBoxAscent) + Math.abs(metrics.actualBoundingBoxDescent);\r\n\r\n      // TODO lineheight makes the text bounds wonky\r\n      const lineAdjustedHeight = textHeight * lines.length;\r\n      textHeight = lineAdjustedHeight;\r\n      const bottomBounds = lineAdjustedHeight - Math.abs(metrics.actualBoundingBoxAscent);\r\n      const x = 0;\r\n      const y = 0;\r\n      // this._cachedText = text;\r\n      // this._cachedRasterProps = rasterProps;\r\n      // this._measurementDirty = false;\r\n      const measurement = new BoundingBox({\r\n        left: x - Math.abs(metrics.actualBoundingBoxLeft) - this.padding,\r\n        top: y - Math.abs(metrics.actualBoundingBoxAscent) - this.padding,\r\n        bottom: y + bottomBounds + this.padding,\r\n        right: x + Math.abs(metrics.actualBoundingBoxRight) + this.padding\r\n      });\r\n      cached = {\r\n        text,\r\n        rasterProps,\r\n        measurement\r\n      };\r\n      this._cachedTextMeasurement.set(text, cached);\r\n      this._bitmapToTextMeasurement.set(ctx, cached);\r\n      return cached.measurement;\r\n    } else {\r\n      return cached.measurement;\r\n    }\r\n  }\r\n\r\n  private _setDimension(textBounds: BoundingBox, bitmap: CanvasRenderingContext2D) {\r\n\r\n    // Changing the width and height clears the context properties\r\n    // We double the bitmap width to account for all possible alignment\r\n    // We scale by \"quality\" so we render text without jaggies\r\n    bitmap.canvas.width = (textBounds.width + this.padding * 2) * 2 * this.quality;\r\n    bitmap.canvas.height = (textBounds.height + this.padding * 2) * 2 * this.quality;\r\n  }\r\n\r\n  protected _postDraw(ex: ExcaliburGraphicsContext): void {\r\n    ex.restore();\r\n  }\r\n\r\n  /**\r\n   * We need to identify bitmaps with more than just the text content\r\n   *\r\n   * Any properties that can change the rendering of the text\r\n   */\r\n  private _getRasterPropertiesHash(color?: Color): string {\r\n    const hash = '__hashcode__' +\r\n    this.fontString +\r\n    this.showDebug +\r\n    this.textAlign +\r\n    this.baseAlign +\r\n    this.direction +\r\n    JSON.stringify(this.shadow) +\r\n    (this.padding.toString() +\r\n    this.smoothing.toString() +\r\n    this.lineWidth.toString() +\r\n    this.lineDash.toString() +\r\n    this.strokeColor?.toString() +\r\n    ( color ? color.toString() : this.color?.toString()).toString());\r\n    return hash;\r\n  }\r\n\r\n  protected _applyRasterProperties(ctx: CanvasRenderingContext2D, color: Color) {\r\n    ctx.translate(this.padding, this.padding);\r\n    ctx.imageSmoothingEnabled = this.smoothing;\r\n    ctx.lineWidth = this.lineWidth;\r\n    ctx.setLineDash(this.lineDash ?? ctx.getLineDash());\r\n    ctx.strokeStyle = this.strokeColor?.toString();\r\n    ctx.fillStyle = color ? color.toString() : this.color?.toString();\r\n  }\r\n\r\n  private _applyFont(ctx: CanvasRenderingContext2D) {\r\n    ctx.translate(this.padding + ctx.canvas.width / 2, this.padding + ctx.canvas.height / 2);\r\n    ctx.scale(this.quality, this.quality);\r\n    ctx.textAlign = this.textAlign;\r\n    ctx.textBaseline = this.baseAlign;\r\n    ctx.font = this.fontString;\r\n    ctx.direction = this.direction;\r\n\r\n    if (this.shadow) {\r\n      ctx.shadowColor = this.shadow.color.toString();\r\n      ctx.shadowBlur = this.shadow.blur;\r\n      ctx.shadowOffsetX = this.shadow.offset.x;\r\n      ctx.shadowOffsetY = this.shadow.offset.y;\r\n    }\r\n  }\r\n\r\n  private _drawText(ctx: CanvasRenderingContext2D, text: string, colorOverride: Color, lineHeight: number): void {\r\n    const lines = text.split('\\n');\r\n    this._applyRasterProperties(ctx, colorOverride);\r\n    this._applyFont(ctx);\r\n\r\n    for (let i = 0; i < lines.length; i++) {\r\n      const line = lines[i];\r\n      if (this.color) {\r\n        ctx.fillText(line, 0, i * lineHeight);\r\n      }\r\n\r\n      if (this.strokeColor) {\r\n        ctx.strokeText(line, 0, i * lineHeight);\r\n      }\r\n    }\r\n\r\n    if (this.showDebug) {\r\n      // Horizontal line\r\n      /* istanbul ignore next */\r\n      line(ctx, Color.Red, -ctx.canvas.width / 2, 0, ctx.canvas.width / 2, 0, 2);\r\n      // Vertical line\r\n      /* istanbul ignore next */\r\n      line(ctx, Color.Red, 0, -ctx.canvas.height / 2, 0, ctx.canvas.height / 2, 2);\r\n    }\r\n  }\r\n\r\n  private _textToBitmap = new Map<string, CanvasRenderingContext2D>();\r\n  private _bitmapUsage = new Map<CanvasRenderingContext2D, number>();\r\n  private _getTextBitmap(text: string, color?: Color): CanvasRenderingContext2D {\r\n    const textAndHash = text + this._getRasterPropertiesHash(color);\r\n    const bitmap = this._textToBitmap.get(textAndHash);\r\n    if (bitmap) {\r\n      return bitmap;\r\n    }\r\n\r\n    const canvas = document.createElement('canvas');\r\n    const ctx = canvas.getContext('2d');\r\n    this._textToBitmap.set(textAndHash, ctx);\r\n    return ctx;\r\n  }\r\n\r\n  private _splitTextBitmap(bitmap: CanvasRenderingContext2D) {\r\n    const textImages: {x: number, y: number, canvas: HTMLCanvasElement}[] = [];\r\n    let currentX = 0;\r\n    let currentY = 0;\r\n    // 4k is the max for mobile devices\r\n    const width = Math.min(4096, bitmap.canvas.width);\r\n    const height = Math.min(4096, bitmap.canvas.height);\r\n\r\n    // Splits the original bitmap into 4k max chunks\r\n    while (currentX < bitmap.canvas.width) {\r\n      while (currentY < bitmap.canvas.height) {\r\n        // create new bitmap\r\n        const canvas = document.createElement('canvas');\r\n        canvas.width = width;\r\n        canvas.height = height;\r\n        const ctx = canvas.getContext('2d');\r\n\r\n        // draw current slice to new bitmap in < 4k chunks\r\n        ctx.drawImage(bitmap.canvas, currentX, currentY, width, height, 0, 0, width, height);\r\n\r\n        textImages.push({x: currentX, y: currentY, canvas});\r\n        currentY += height;\r\n      }\r\n      currentX += width;\r\n      currentY = 0;\r\n    }\r\n    return textImages;\r\n  }\r\n\r\n  private _textFragments: {x: number, y: number, canvas: HTMLCanvasElement}[] = [];\r\n  public render(ex: ExcaliburGraphicsContext, text: string, colorOverride: Color, x: number, y: number) {\r\n    if (this.showDebug) {\r\n      this.clearCache();\r\n    }\r\n    this.checkAndClearCache();\r\n    // Get bitmap for rastering text, this is cached by raster properties\r\n    const bitmap = this._getTextBitmap(text, colorOverride);\r\n    const isNewBitmap = !this._bitmapUsage.get(bitmap);\r\n\r\n    // Bounds of the text\r\n    this._textBounds = this.measureText(text);\r\n\r\n    if (isNewBitmap) {\r\n      // Setting dimension is expensive because it invalidates the bitmap\r\n      this._setDimension(this._textBounds, bitmap);\r\n    }\r\n\r\n    // Apply affine transformations\r\n    this._preDraw(ex, x, y);\r\n\r\n    const lines = text.split('\\n');\r\n    const lineHeight = this._textBounds.height / lines.length;\r\n\r\n    if (isNewBitmap) {\r\n      // draws the text to the bitmap\r\n      this._drawText(bitmap, text, colorOverride, lineHeight);\r\n\r\n      // clean up any existing fragments\r\n      for (const frag of this._textFragments) {\r\n        TextureLoader.delete(frag.canvas);\r\n      }\r\n\r\n      this._textFragments = this._splitTextBitmap(bitmap);\r\n\r\n      for (const frag of this._textFragments) {\r\n        TextureLoader.load(frag.canvas, this.filtering, true);\r\n      }\r\n    }\r\n\r\n    // draws the bitmap fragments to excalibur graphics context\r\n    for (const frag of this._textFragments) {\r\n      ex.drawImage(\r\n        frag.canvas,\r\n        0,\r\n        0,\r\n        frag.canvas.width,\r\n        frag.canvas.height,\r\n        frag.x / this.quality + x - bitmap.canvas.width / this.quality / 2,\r\n        frag.y / this.quality + y - bitmap.canvas.height / this.quality / 2,\r\n        frag.canvas.width / this.quality,\r\n        frag.canvas.height / this.quality\r\n      );\r\n    }\r\n\r\n    this._postDraw(ex);\r\n\r\n    // Cache the bitmap for certain amount of time\r\n    this._bitmapUsage.set(bitmap, performance.now());\r\n  }\r\n\r\n  /**\r\n   * Get the internal cache size of the font\r\n   * This is useful when debugging memory usage, these numbers indicate the number of cached in memory text bitmaps\r\n   */\r\n  public get cacheSize() {\r\n    return this._bitmapUsage.size;\r\n  }\r\n\r\n  /**\r\n   * Force clear all cached text bitmaps\r\n   */\r\n  public clearCache() {\r\n    this._bitmapUsage.clear();\r\n  }\r\n\r\n  /**\r\n   * Remove any expired cached text bitmaps\r\n   */\r\n  public checkAndClearCache() {\r\n    for (const [bitmap, time] of this._bitmapUsage.entries()) {\r\n      // if bitmap hasn't been used in 1 second clear it\r\n      if (time + 1000 < performance.now()) {\r\n        this._bitmapUsage.delete(bitmap);\r\n        // Cleanup measurements\r\n        const measurement = this._bitmapToTextMeasurement.get(bitmap);\r\n        if (measurement) {\r\n          this._cachedTextMeasurement.delete(measurement.text);\r\n          this._bitmapToTextMeasurement.delete(bitmap);\r\n        }\r\n        TextureLoader.delete(bitmap.canvas);\r\n      }\r\n    }\r\n  }\r\n}\r\n","import { ExcaliburGraphicsContext } from './Context/ExcaliburGraphicsContext';\r\nimport { BoundingBox } from '../Collision/BoundingBox';\r\nimport { SpriteFont } from './SpriteFont';\r\nimport { Graphic, GraphicOptions } from './Graphic';\r\nimport { Color } from '../Color';\r\nimport { Font } from './Font';\r\n\r\nexport interface TextOptions {\r\n  /**\r\n   * Text to draw\r\n   */\r\n  text: string;\r\n\r\n  /**\r\n   * Optionally override the font color, currently unsupported by SpriteFont\r\n   */\r\n  color?: Color;\r\n\r\n  /**\r\n   * Optionally specify a font, if none specified a default font is used (System sans-serif 10 pixel)\r\n   */\r\n  font?: Font | SpriteFont;\r\n}\r\n\r\n/**\r\n * Represent Text graphics in excalibur\r\n *\r\n * Useful for in game labels, ui, or overlays\r\n */\r\nexport class Text extends Graphic {\r\n  public color?: Color;\r\n  constructor(options: TextOptions & GraphicOptions) {\r\n    super(options);\r\n    // This order is important font, color, then text\r\n    this.font = options.font ?? new Font();\r\n    this.color = options.color ?? this.color;\r\n    this.text = options.text;\r\n  }\r\n\r\n  public clone(): Text {\r\n    return new Text({\r\n      text: this.text.slice(),\r\n      color: this.color?.clone() ?? Color.Black,\r\n      font: this.font.clone()\r\n    });\r\n  }\r\n\r\n  private _text: string = '';\r\n  public get text() {\r\n    return this._text;\r\n  }\r\n\r\n  public set text(value: string) {\r\n    this._text = value;\r\n    const bounds = this.font.measureText(this._text);\r\n    this._textWidth = bounds.width;\r\n    this._textHeight = bounds.height;\r\n  }\r\n\r\n  private _font: Font | SpriteFont;\r\n  public get font(): Font | SpriteFont {\r\n    return this._font;\r\n  }\r\n  public set font(font: Font | SpriteFont) {\r\n    this._font = font;\r\n  }\r\n\r\n  private _textWidth: number = 0;\r\n\r\n  public get width() {\r\n    if (this._textWidth === 0) {\r\n      this._calculateDimension();\r\n    }\r\n    return this._textWidth * this.scale.x;\r\n  }\r\n\r\n  private _textHeight: number = 0;\r\n  public get height() {\r\n    if (this._textHeight === 0) {\r\n      this._calculateDimension();\r\n    }\r\n    return this._textHeight * this.scale.y;\r\n  }\r\n\r\n  private _calculateDimension() {\r\n    const { width, height } = this.font.measureText(this._text);\r\n    this._textWidth = width;\r\n    this._textHeight = height;\r\n  }\r\n\r\n  public get localBounds(): BoundingBox {\r\n    return this.font.measureText(this._text).scale(this.scale);\r\n  }\r\n\r\n  protected override _rotate(_ex: ExcaliburGraphicsContext) {\r\n    // None this is delegated to font\r\n    // This override erases the default behavior\r\n  }\r\n\r\n  protected override _flip(_ex: ExcaliburGraphicsContext) {\r\n    // None this is delegated to font\r\n    // This override erases the default behavior\r\n  }\r\n\r\n  protected override _drawImage(ex: ExcaliburGraphicsContext, x: number, y: number) {\r\n    let color = Color.Black;\r\n    if (this.font instanceof Font) {\r\n      color = this.color ?? this.font.color;\r\n    }\r\n\r\n    if (this.isStale() || this.font.isStale()) {\r\n      this.font.flipHorizontal = this.flipHorizontal;\r\n      this.font.flipVertical = this.flipVertical;\r\n      this.font.rotation = this.rotation;\r\n      this.font.origin = this.origin;\r\n      this.font.opacity = this.opacity;\r\n    }\r\n\r\n    const { width, height } = this.font.measureText(this._text);\r\n    this._textWidth = width;\r\n    this._textHeight = height;\r\n\r\n    this.font.render(ex, this._text, color, x, y);\r\n    if (this.font.showDebug) {\r\n      ex.debug.drawRect(x - width, y - height, width * 2, height * 2);\r\n    }\r\n  }\r\n}\r\n","import { Engine } from './Engine';\r\nimport { EventDispatcher } from './EventDispatcher';\r\nimport { Vector } from './Math/vector';\r\nimport { ExitTriggerEvent, EnterTriggerEvent, CollisionEndEvent, CollisionStartEvent } from './Events';\r\nimport { CollisionType } from './Collision/CollisionType';\r\nimport { Entity } from './EntityComponentSystem';\r\nimport { Actor } from './Actor';\r\n\r\n/**\r\n * ITriggerOptions\r\n */\r\nexport interface TriggerOptions {\r\n  // position of the trigger\r\n  pos: Vector;\r\n  // width of the trigger\r\n  width: number;\r\n  // height of the trigger\r\n  height: number;\r\n  // whether the trigger is visible or not\r\n  visible: boolean;\r\n  // action to take when triggered\r\n  action: () => void;\r\n  // if specified the trigger will only fire on a specific actor and overrides any filter\r\n  target: Entity;\r\n  // Returns true if the triggers should fire on the collided actor\r\n  filter: (actor: Entity) => boolean;\r\n  // -1 if it should repeat forever\r\n  repeat: number;\r\n}\r\n\r\nconst triggerDefaults: Partial<TriggerOptions> = {\r\n  pos: Vector.Zero,\r\n  width: 10,\r\n  height: 10,\r\n  visible: false,\r\n  action: () => {\r\n    return;\r\n  },\r\n  filter: () => true,\r\n  repeat: -1\r\n};\r\n\r\n/**\r\n * Triggers are a method of firing arbitrary code on collision. These are useful\r\n * as 'buttons', 'switches', or to trigger effects in a game. By default triggers\r\n * are invisible, and can only be seen when [[Trigger.visible]] is set to `true`.\r\n */\r\nexport class Trigger extends Actor {\r\n  private _target: Entity;\r\n  /**\r\n   * Action to fire when triggered by collision\r\n   */\r\n  public action: () => void = () => {\r\n    return;\r\n  };\r\n  /**\r\n   * Filter to add additional granularity to action dispatch, if a filter is specified the action will only fire when\r\n   * filter return true for the collided actor.\r\n   */\r\n  public filter: (actor: Entity) => boolean = () => true;\r\n  /**\r\n   * Number of times to repeat before killing the trigger,\r\n   */\r\n  public repeat: number = -1;\r\n\r\n  /**\r\n   *\r\n   * @param opts Trigger options\r\n   */\r\n  constructor(opts: Partial<TriggerOptions>) {\r\n    super({ x: opts.pos.x, y: opts.pos.y, width: opts.width, height: opts.height });\r\n    opts = {\r\n      ...triggerDefaults,\r\n      ...opts\r\n    };\r\n\r\n    this.filter = opts.filter || this.filter;\r\n    this.repeat = opts.repeat || this.repeat;\r\n    this.action = opts.action || this.action;\r\n    if (opts.target) {\r\n      this.target = opts.target;\r\n    }\r\n\r\n    this.graphics.visible = opts.visible;\r\n    this.body.collisionType = CollisionType.Passive;\r\n    this.eventDispatcher = new EventDispatcher();\r\n\r\n    this.events.on('collisionstart', (evt: CollisionStartEvent<Actor>) => {\r\n      if (this.filter(evt.other)) {\r\n        this.emit('enter', new EnterTriggerEvent(this, evt.other));\r\n        this._dispatchAction();\r\n        // remove trigger if its done, -1 repeat forever\r\n        if (this.repeat === 0) {\r\n          this.kill();\r\n        }\r\n      }\r\n    });\r\n\r\n    this.events.on('collisionend', (evt: CollisionEndEvent<Actor>) => {\r\n      if (this.filter(evt.other)) {\r\n        this.emit('exit', new ExitTriggerEvent(this, evt.other));\r\n      }\r\n    });\r\n  }\r\n\r\n  public set target(target: Entity) {\r\n    this._target = target;\r\n    this.filter = (actor: Entity) => actor === target;\r\n  }\r\n\r\n  public get target() {\r\n    return this._target;\r\n  }\r\n\r\n  public _initialize(engine: Engine) {\r\n    super._initialize(engine);\r\n  }\r\n\r\n  private _dispatchAction() {\r\n    if (this.repeat !== 0) {\r\n      this.action.call(this);\r\n      this.repeat--;\r\n    }\r\n  }\r\n}\r\n","import { Graphic, GraphicOptions } from './Graphic';\r\nimport { ExcaliburGraphicsContext } from './Context/ExcaliburGraphicsContext';\r\nimport { EventDispatcher } from '../EventDispatcher';\r\nimport { SpriteSheet } from './SpriteSheet';\r\nimport { Logger } from '../Util/Log';\r\nimport { clamp } from '../Math/util';\r\n\r\nexport interface HasTick {\r\n  /**\r\n   *\r\n   * @param elapsedMilliseconds The amount of real world time in milliseconds that has elapsed that must be updated in the animation\r\n   * @param idempotencyToken Optional idempotencyToken prevents a ticking animation from updating twice per frame\r\n   */\r\n  tick(elapsedMilliseconds: number, idempotencyToken?: number): void;\r\n}\r\n\r\nexport enum AnimationDirection {\r\n  /**\r\n   * Animation is playing forwards\r\n   */\r\n  Forward = 'forward',\r\n  /**\r\n   * Animation is play backwards\r\n   */\r\n  Backward = 'backward'\r\n}\r\n\r\nexport enum AnimationStrategy {\r\n  /**\r\n   * Animation ends without displaying anything\r\n   */\r\n  End = 'end',\r\n  /**\r\n   * Animation loops to the first frame after the last frame\r\n   */\r\n  Loop = 'loop',\r\n  /**\r\n   * Animation plays to the last frame, then backwards to the first frame, then repeats\r\n   */\r\n  PingPong = 'pingpong',\r\n  /**\r\n   * Animation ends stopping on the last frame\r\n   */\r\n  Freeze = 'freeze'\r\n}\r\n\r\n/**\r\n * Frame of animation\r\n */\r\nexport interface Frame {\r\n  /**\r\n   * Optionally specify a graphic to show, no graphic shows an empty frame\r\n   */\r\n  graphic?: Graphic;\r\n  /**\r\n   * Optionally specify the number of ms the frame should be visible, overrides the animation duration (default 100 ms)\r\n   */\r\n  duration?: number;\r\n}\r\n\r\n/**\r\n * Animation options for building an animation via constructor.\r\n */\r\nexport interface AnimationOptions {\r\n  /**\r\n   * List of frames in the order you wish to play them\r\n   */\r\n  frames: Frame[];\r\n  /**\r\n   * Optionally reverse the direction of play\r\n   */\r\n  reverse?: boolean;\r\n  /**\r\n   * Optionally specify a default frame duration in ms (Default is 1000)\r\n   */\r\n  frameDuration?: number;\r\n  /**\r\n   * Optionally specify a total duration of the animation in ms to calculate each frame's duration\r\n   */\r\n  totalDuration?: number;\r\n  /**\r\n   * Optionally specify the [[AnimationStrategy]] for the Animation\r\n   */\r\n  strategy?: AnimationStrategy;\r\n}\r\n\r\n// TODO wire up to new Emitter\r\nexport type AnimationEvents = {\r\n  frame: Frame;\r\n  loop: Animation;\r\n  ended: Animation;\r\n};\r\n\r\n/**\r\n * Create an Animation given a list of [[Frame|frames]] in [[AnimationOptions]]\r\n *\r\n * To create an Animation from a [[SpriteSheet]], use [[Animation.fromSpriteSheet]]\r\n */\r\nexport class Animation extends Graphic implements HasTick {\r\n  private static _LOGGER = Logger.getInstance();\r\n  public events = new EventDispatcher<any>(); // TODO replace with new Emitter\r\n  public frames: Frame[] = [];\r\n  public strategy: AnimationStrategy = AnimationStrategy.Loop;\r\n  public frameDuration: number = 100;\r\n  public timeScale: number = 1;\r\n\r\n  private _idempotencyToken = -1;\r\n\r\n  private _firstTick = true;\r\n  private _currentFrame = 0;\r\n  private _timeLeftInFrame = 0;\r\n  private _direction = 1; // TODO only used in ping-pong\r\n  private _done = false;\r\n  private _playing = true;\r\n\r\n  constructor(options: GraphicOptions & AnimationOptions) {\r\n    super(options);\r\n    this.frames = options.frames;\r\n    this.strategy = options.strategy ?? this.strategy;\r\n    this.frameDuration = options.totalDuration ? options.totalDuration / this.frames.length : options.frameDuration ?? this.frameDuration;\r\n    if (options.reverse) {\r\n      this.reverse();\r\n    }\r\n    this.goToFrame(0);\r\n  }\r\n\r\n  public clone(): Animation {\r\n    return new Animation({\r\n      frames: this.frames.map((f) => ({ ...f })),\r\n      frameDuration: this.frameDuration,\r\n      reverse: this._reversed,\r\n      strategy: this.strategy,\r\n      ...this.cloneGraphicOptions()\r\n    });\r\n  }\r\n\r\n  public override get width(): number {\r\n    const maybeFrame = this.currentFrame;\r\n    if (maybeFrame) {\r\n      return Math.abs(maybeFrame.graphic.width * this.scale.x);\r\n    }\r\n    return 0;\r\n  }\r\n\r\n  public override get height(): number {\r\n    const maybeFrame = this.currentFrame;\r\n    if (maybeFrame) {\r\n      return Math.abs(maybeFrame.graphic.height * this.scale.y);\r\n    }\r\n    return 0;\r\n  }\r\n\r\n\r\n  /**\r\n   * Create an Animation from a [[SpriteSheet]], a list of indices into the sprite sheet, a duration per frame\r\n   * and optional [[AnimationStrategy]]\r\n   *\r\n   * Example:\r\n   * ```typescript\r\n   * const spriteSheet = SpriteSheet.fromImageSource({...});\r\n   *\r\n   * const anim = Animation.fromSpriteSheet(spriteSheet, range(0, 5), 200, AnimationStrategy.Loop);\r\n   * ```\r\n   *\r\n   * @param spriteSheet\r\n   * @param frameIndices\r\n   * @param durationPerFrameMs\r\n   * @param strategy\r\n   */\r\n  public static fromSpriteSheet(\r\n    spriteSheet: SpriteSheet,\r\n    frameIndices: number[],\r\n    durationPerFrameMs: number,\r\n    strategy: AnimationStrategy = AnimationStrategy.Loop\r\n  ): Animation {\r\n    const maxIndex = spriteSheet.sprites.length - 1;\r\n    const invalidIndices = frameIndices.filter((index) => index < 0 || index > maxIndex);\r\n    if (invalidIndices.length) {\r\n      Animation._LOGGER.warn(\r\n        `Indices into SpriteSheet were provided that don\\'t exist: ${invalidIndices.join(',')} no frame will be shown`\r\n      );\r\n    }\r\n    return new Animation({\r\n      frames: spriteSheet.sprites\r\n        .filter((_, index) => frameIndices.indexOf(index) > -1)\r\n        .map((f) => ({\r\n          graphic: f,\r\n          duration: durationPerFrameMs\r\n        })),\r\n      strategy: strategy\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Returns the current Frame of the animation\r\n   */\r\n  public get currentFrame(): Frame | null {\r\n    if (this._currentFrame >= 0 && this._currentFrame < this.frames.length) {\r\n      return this.frames[this._currentFrame];\r\n    }\r\n    return null;\r\n  }\r\n\r\n  /**\r\n   * Returns the current frame index of the animation\r\n   */\r\n  public get currentFrameIndex(): number {\r\n    return this._currentFrame;\r\n  }\r\n\r\n  /**\r\n   * Returns `true` if the animation is playing\r\n   */\r\n  public get isPlaying(): boolean {\r\n    return this._playing;\r\n  }\r\n\r\n  private _reversed = false;\r\n  /**\r\n   * Reverses the play direction of the Animation, this preserves the current frame\r\n   */\r\n  public reverse(): void {\r\n    // Don't mutate with the original frame list, create a copy\r\n    this.frames = this.frames.slice().reverse();\r\n    this._reversed = !this._reversed;\r\n  }\r\n\r\n  /**\r\n   * Returns the current play direction of the animation\r\n   */\r\n  public get direction(): AnimationDirection {\r\n    // Keep logically consistent with ping-pong direction\r\n    // If ping-pong is forward = 1 and reversed is true then we are logically reversed\r\n    const reversed = (this._reversed && this._direction === 1) ? true : false;\r\n    return reversed ? AnimationDirection.Backward : AnimationDirection.Forward;\r\n  }\r\n\r\n  /**\r\n   * Plays or resumes the animation from the current frame\r\n   */\r\n  public play(): void {\r\n    this._playing = true;\r\n  }\r\n\r\n  /**\r\n   * Pauses the animation on the current frame\r\n   */\r\n  public pause(): void {\r\n    this._playing = false;\r\n    this._firstTick = true; // firstTick must be set to emit the proper frame event\r\n  }\r\n\r\n  /**\r\n   * Reset the animation back to the beginning, including if the animation were done\r\n   */\r\n  public reset(): void {\r\n    this._done = false;\r\n    this._firstTick = true;\r\n    this._currentFrame = 0;\r\n  }\r\n\r\n  /**\r\n   * Returns `true` if the animation can end\r\n   */\r\n  public get canFinish(): boolean {\r\n    switch (this.strategy) {\r\n      case AnimationStrategy.End:\r\n      case AnimationStrategy.Freeze: {\r\n        return true;\r\n      }\r\n      default: {\r\n        return false;\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Returns `true` if the animation is done, for looping type animations\r\n   * `ex.AnimationStrategy.PingPong` and `ex.AnimationStrategy.Loop` this will always return `false`\r\n   *\r\n   * See the `ex.Animation.canFinish()` method to know if an animation type can end\r\n   */\r\n  public get done(): boolean {\r\n    return this._done;\r\n  }\r\n\r\n  /**\r\n   * Jump the animation immediately to a specific frame if it exists\r\n   * @param frameNumber\r\n   */\r\n  public goToFrame(frameNumber: number) {\r\n    this._currentFrame = frameNumber;\r\n    this._timeLeftInFrame = this.frameDuration;\r\n    const maybeFrame = this.frames[this._currentFrame];\r\n    if (maybeFrame && !this._done) {\r\n      this._timeLeftInFrame = maybeFrame?.duration || this.frameDuration;\r\n      this.events.emit('frame', maybeFrame as any);\r\n    }\r\n  }\r\n\r\n  private _nextFrame(): number {\r\n    const currentFrame = this._currentFrame;\r\n    if (this._done) {\r\n      return currentFrame;\r\n    }\r\n    let next = -1;\r\n\r\n    switch (this.strategy) {\r\n      case AnimationStrategy.Loop: {\r\n        next = (currentFrame + 1) % this.frames.length;\r\n        if (next === 0) {\r\n          this.events.emit('loop', this as any);\r\n        }\r\n        break;\r\n      }\r\n      case AnimationStrategy.End: {\r\n        next = currentFrame + 1;\r\n        if (next >= this.frames.length) {\r\n          this._done = true;\r\n          this._currentFrame = this.frames.length;\r\n          this.events.emit('end', this as any);\r\n        }\r\n        break;\r\n      }\r\n      case AnimationStrategy.Freeze: {\r\n        next = clamp(currentFrame + 1, 0, this.frames.length - 1);\r\n        if (next >= this.frames.length - 1) {\r\n          this._done = true;\r\n          this.events.emit('end', this as any);\r\n        }\r\n        break;\r\n      }\r\n      case AnimationStrategy.PingPong: {\r\n        if (currentFrame + this._direction >= this.frames.length) {\r\n          this._direction = -1;\r\n          this.events.emit('loop', this as any);\r\n        }\r\n\r\n        if (currentFrame + this._direction < 0) {\r\n          this._direction = 1;\r\n          this.events.emit('loop', this as any);\r\n        }\r\n\r\n        next = currentFrame + (this._direction % this.frames.length);\r\n        break;\r\n      }\r\n    }\r\n    return next;\r\n  }\r\n\r\n  /**\r\n   * Called internally by Excalibur to update the state of the animation potential update the current frame\r\n   * @param elapsedMilliseconds Milliseconds elapsed\r\n   * @param idempotencyToken Prevents double ticking in a frame by passing a unique token to the frame\r\n   */\r\n  public tick(elapsedMilliseconds: number, idempotencyToken: number = 0): void {\r\n    if (this._idempotencyToken === idempotencyToken) {\r\n      return;\r\n    }\r\n    this._idempotencyToken = idempotencyToken;\r\n    if (!this._playing) {\r\n      return;\r\n    }\r\n\r\n    // if it's the first frame emit frame event\r\n    if (this._firstTick) {\r\n      this._firstTick = false;\r\n      this.events.emit('frame', this.currentFrame as any);\r\n    }\r\n\r\n    this._timeLeftInFrame -= elapsedMilliseconds * this.timeScale;\r\n    if (this._timeLeftInFrame <= 0) {\r\n      this.goToFrame(this._nextFrame());\r\n    }\r\n  }\r\n\r\n  protected _drawImage(ctx: ExcaliburGraphicsContext, x: number, y: number) {\r\n    if (this.currentFrame) {\r\n      this.currentFrame.graphic.draw(ctx, x, y);\r\n    }\r\n  }\r\n}\r\n","import { Vector } from '../Math/vector';\r\nimport { Graphic, GraphicOptions } from './Graphic';\r\nimport { Animation, HasTick } from './Animation';\r\nimport { ExcaliburGraphicsContext } from './Context/ExcaliburGraphicsContext';\r\nimport { BoundingBox } from '../Collision/Index';\r\n\r\nexport interface GraphicsGroupingOptions {\r\n  members: GraphicsGrouping[];\r\n}\r\n\r\nexport interface GraphicsGrouping {\r\n  pos: Vector;\r\n  graphic: Graphic;\r\n}\r\n\r\nexport class GraphicsGroup extends Graphic implements HasTick {\r\n  public members: GraphicsGrouping[] = [];\r\n\r\n  constructor(options: GraphicsGroupingOptions & GraphicOptions) {\r\n    super(options);\r\n    this.members = options.members;\r\n    this._updateDimensions();\r\n  }\r\n\r\n  public clone(): GraphicsGroup {\r\n    return new GraphicsGroup({\r\n      members: [...this.members],\r\n      ...this.cloneGraphicOptions()\r\n    });\r\n  }\r\n\r\n  private _updateDimensions(): BoundingBox {\r\n    let bb = new BoundingBox();\r\n    for (const { graphic, pos } of this.members) {\r\n      bb = graphic.localBounds.translate(pos).combine(bb);\r\n    }\r\n\r\n    this.width = bb.width;\r\n    this.height = bb.height;\r\n\r\n    return bb;\r\n  }\r\n\r\n  public get localBounds(): BoundingBox {\r\n    let bb = new BoundingBox();\r\n    for (const { graphic, pos } of this.members) {\r\n      bb = graphic.localBounds.translate(pos).combine(bb);\r\n    }\r\n    return bb;\r\n  }\r\n\r\n  private _isAnimationOrGroup(graphic: Graphic): graphic is Animation | GraphicsGroup {\r\n    return graphic instanceof Animation || graphic instanceof GraphicsGroup;\r\n  }\r\n\r\n  public tick(elapsedMilliseconds: number, idempotencyToken?: number) {\r\n    for (const member of this.members) {\r\n      const maybeAnimation = member.graphic;\r\n      if (this._isAnimationOrGroup(maybeAnimation)) {\r\n        maybeAnimation.tick(elapsedMilliseconds, idempotencyToken);\r\n      }\r\n    }\r\n  }\r\n\r\n  public reset() {\r\n    for (const member of this.members) {\r\n      const maybeAnimation = member.graphic;\r\n      if (this._isAnimationOrGroup(maybeAnimation)) {\r\n        maybeAnimation.reset();\r\n      }\r\n    }\r\n  }\r\n\r\n  protected _preDraw(ex: ExcaliburGraphicsContext, x: number, y: number) {\r\n    this._updateDimensions();\r\n    super._preDraw(ex, x, y);\r\n  }\r\n\r\n  protected _drawImage(ex: ExcaliburGraphicsContext, x: number, y: number) {\r\n    for (const member of this.members) {\r\n      ex.save();\r\n      ex.translate(x, y);\r\n      member.graphic.draw(ex, member.pos.x, member.pos.y);\r\n      if (this.showDebug) {\r\n        /* istanbul ignore next */\r\n        ex.debug.drawRect(0, 0, this.width, this.height);\r\n      }\r\n      ex.restore();\r\n    }\r\n  }\r\n}\r\n","import { Logger } from '../Util/Log';\r\nimport { Class } from '../Class';\r\nimport * as Events from '../Events';\r\n\r\n/**\r\n * Enum representing physical input key codes\r\n */\r\nexport enum Keys {\r\n  // NUMPAD\r\n  Num0 = 'Numpad0',\r\n  Num1 = 'Numpad1',\r\n  Num2 = 'Numpad2',\r\n  Num3 = 'Numpad3',\r\n  Num4 = 'Numpad4',\r\n  Num5 = 'Numpad5',\r\n  Num6 = 'Numpad6',\r\n  Num7 = 'Numpad7',\r\n  Num8 = 'Numpad8',\r\n  Num9 = 'Numpad9',\r\n  NumAdd = 'NumpadAdd',\r\n  NumSubtract = 'NumpadSubtract',\r\n  NumMultiply = 'NumpadMultiply',\r\n  NumDivide = 'NumpadDivide',\r\n  // NumComma = 'NumpadComma', // not x-browser\r\n  NumDecimal = 'NumpadDecimal',\r\n  Numpad0 = 'Numpad0',\r\n  Numpad1 = 'Numpad1',\r\n  Numpad2 = 'Numpad2',\r\n  Numpad3 = 'Numpad3',\r\n  Numpad4 = 'Numpad4',\r\n  Numpad5 = 'Numpad5',\r\n  Numpad6 = 'Numpad6',\r\n  Numpad7 = 'Numpad7',\r\n  Numpad8 = 'Numpad8',\r\n  Numpad9 = 'Numpad9',\r\n  NumpadAdd = 'NumpadAdd',\r\n  NumpadSubtract = 'NumpadSubtract',\r\n  NumpadMultiply = 'NumpadMultiply',\r\n  NumpadDivide = 'NumpadDivide',\r\n  // NumpadComma = 'NumpadComma', // not x-browser\r\n  NumpadDecimal = 'NumpadDecimal',\r\n\r\n  // MODIFIERS\r\n  NumLock = 'NumLock',\r\n  ShiftLeft = 'ShiftLeft',\r\n  ShiftRight = 'ShiftRight',\r\n  AltLeft = 'AltLeft',\r\n  AltRight = 'AltRight',\r\n  ControlLeft = 'ControlLeft',\r\n  ControlRight = 'ControlRight',\r\n  MetaLeft = 'MetaLeft',\r\n  MetaRight = 'MetaRight',\r\n\r\n  // NUMBERS\r\n  Key0 = 'Digit0',\r\n  Key1 = 'Digit1',\r\n  Key2 = 'Digit2',\r\n  Key3 = 'Digit3',\r\n  Key4 = 'Digit4',\r\n  Key5 = 'Digit5',\r\n  Key6 = 'Digit6',\r\n  Key7 = 'Digit7',\r\n  Key8 = 'Digit8',\r\n  Key9 = 'Digit9',\r\n  Digit0 = 'Digit0',\r\n  Digit1 = 'Digit1',\r\n  Digit2 = 'Digit2',\r\n  Digit3 = 'Digit3',\r\n  Digit4 = 'Digit4',\r\n  Digit5 = 'Digit5',\r\n  Digit6 = 'Digit6',\r\n  Digit7 = 'Digit7',\r\n  Digit8 = 'Digit8',\r\n  Digit9 = 'Digit9',\r\n\r\n  // FUNCTION KEYS\r\n  F1 = 'F1',\r\n  F2 = 'F2',\r\n  F3 = 'F3',\r\n  F4 = 'F4',\r\n  F5 = 'F5',\r\n  F6 = 'F6',\r\n  F7 = 'F7',\r\n  F8 = 'F8',\r\n  F9 = 'F9',\r\n  F10 = 'F10',\r\n  F11 = 'F11',\r\n  F12 = 'F12',\r\n\r\n  // LETTERS\r\n  A = 'KeyA',\r\n  B = 'KeyB',\r\n  C = 'KeyC',\r\n  D = 'KeyD',\r\n  E = 'KeyE',\r\n  F = 'KeyF',\r\n  G = 'KeyG',\r\n  H = 'KeyH',\r\n  I = 'KeyI',\r\n  J = 'KeyJ',\r\n  K = 'KeyK',\r\n  L = 'KeyL',\r\n  M = 'KeyM',\r\n  N = 'KeyN',\r\n  O = 'KeyO',\r\n  P = 'KeyP',\r\n  Q = 'KeyQ',\r\n  R = 'KeyR',\r\n  S = 'KeyS',\r\n  T = 'KeyT',\r\n  U = 'KeyU',\r\n  V = 'KeyV',\r\n  W = 'KeyW',\r\n  X = 'KeyX',\r\n  Y = 'KeyY',\r\n  Z = 'KeyZ',\r\n  KeyA = 'KeyA',\r\n  KeyB = 'KeyB',\r\n  KeyC = 'KeyC',\r\n  KeyD = 'KeyD',\r\n  KeyE = 'KeyE',\r\n  KeyF = 'KeyF',\r\n  KeyG = 'KeyG',\r\n  KeyH = 'KeyH',\r\n  KeyI = 'KeyI',\r\n  KeyJ = 'KeyJ',\r\n  KeyK = 'KeyK',\r\n  KeyL = 'KeyL',\r\n  KeyM = 'KeyM',\r\n  KeyN = 'KeyN',\r\n  KeyO = 'KeyO',\r\n  KeyP = 'KeyP',\r\n  KeyQ = 'KeyQ',\r\n  KeyR = 'KeyR',\r\n  KeyS = 'KeyS',\r\n  KeyT = 'KeyT',\r\n  KeyU = 'KeyU',\r\n  KeyV = 'KeyV',\r\n  KeyW = 'KeyW',\r\n  KeyX = 'KeyX',\r\n  KeyY = 'KeyY',\r\n  KeyZ = 'KeyZ',\r\n\r\n  // SYMBOLS\r\n  Semicolon = 'Semicolon',\r\n  Quote = 'Quote',\r\n  Comma = 'Comma',\r\n  Minus = 'Minus',\r\n  Period = 'Period',\r\n  Slash = 'Slash',\r\n  Equal = 'Equal',\r\n  BracketLeft = 'BracketLeft',\r\n  Backslash = 'Backslash',\r\n  BracketRight = 'BracketRight',\r\n  Backquote = 'Backquote',\r\n\r\n  // DIRECTIONS\r\n  Up = 'ArrowUp',\r\n  Down = 'ArrowDown',\r\n  Left = 'ArrowLeft',\r\n  Right = 'ArrowRight',\r\n  ArrowUp = 'ArrowUp',\r\n  ArrowDown = 'ArrowDown',\r\n  ArrowLeft = 'ArrowLeft',\r\n  ArrowRight = 'ArrowRight',\r\n\r\n  // OTHER\r\n  Space = 'Space',\r\n  Backspace = 'Backspace',\r\n  Delete = 'Delete',\r\n  Esc = 'Escape',\r\n  Escape = 'Escape',\r\n  Enter = 'Enter',\r\n  NumpadEnter = 'NumpadEnter',\r\n  ContextMenu = 'ContextMenu'\r\n}\r\n\r\n/**\r\n * Event thrown on a game object for a key event\r\n */\r\nexport class KeyEvent extends Events.GameEvent<any> {\r\n  /**\r\n   * @param key  The key responsible for throwing the event\r\n   * @param value The key's typed value the browser detected\r\n   * @param originalEvent The original keyboard event that Excalibur handled\r\n   */\r\n  constructor(public key: Keys, public value?: string, public originalEvent?: KeyboardEvent) {\r\n    super();\r\n  }\r\n}\r\n\r\n/**\r\n * Provides keyboard support for Excalibur.\r\n */\r\nexport class Keyboard extends Class {\r\n  private _keys: Keys[] = [];\r\n  private _keysUp: Keys[] = [];\r\n  private _keysDown: Keys[] = [];\r\n\r\n  constructor() {\r\n    super();\r\n  }\r\n\r\n  public on(eventName: Events.press, handler: (event: KeyEvent) => void): void;\r\n  public on(eventName: Events.release, handler: (event: KeyEvent) => void): void;\r\n  public on(eventName: Events.hold, handler: (event: KeyEvent) => void): void;\r\n  public on(eventName: string, handler: (event: Events.GameEvent<any>) => void): void;\r\n  public on(eventName: string, handler: (event: any) => void): void {\r\n    super.on(eventName, handler);\r\n  }\r\n\r\n  /**\r\n   * Initialize Keyboard event listeners\r\n   */\r\n  init(global?: GlobalEventHandlers): void {\r\n    if (!global) {\r\n      try {\r\n        // Try and listen to events on top window frame if within an iframe.\r\n        //\r\n        // See https://github.com/excaliburjs/Excalibur/issues/1294\r\n        //\r\n        // Attempt to add an event listener, which triggers a DOMException on\r\n        // cross-origin iframes\r\n        const noop = () => {\r\n          return;\r\n        };\r\n        window.top.addEventListener('blur', noop);\r\n        window.top.removeEventListener('blur', noop);\r\n\r\n        // this will be the same as window if not embedded within an iframe\r\n        global = window.top;\r\n      } catch {\r\n        // fallback to current frame\r\n        global = window;\r\n\r\n        Logger.getInstance().warn(\r\n          'Failed to bind to keyboard events to top frame. ' +\r\n            'If you are trying to embed Excalibur in a cross-origin iframe, keyboard events will not fire.'\r\n        );\r\n      }\r\n    }\r\n\r\n    global.addEventListener('blur', () => {\r\n      this._keys.length = 0; // empties array efficiently\r\n    });\r\n\r\n    // key up is on window because canvas cannot have focus\r\n    global.addEventListener('keyup', this._handleKeyUp);\r\n\r\n    // key down is on window because canvas cannot have focus\r\n    global.addEventListener('keydown', this._handleKeyDown);\r\n  }\r\n\r\n  private _handleKeyDown = (ev: KeyboardEvent) => {\r\n    const code = ev.code as Keys;\r\n    if (this._keys.indexOf(code) === -1) {\r\n      this._keys.push(code);\r\n      this._keysDown.push(code);\r\n      const keyEvent = new KeyEvent(code, ev.key, ev);\r\n      this.eventDispatcher.emit('down', keyEvent);\r\n      this.eventDispatcher.emit('press', keyEvent);\r\n    }\r\n  };\r\n\r\n  private _handleKeyUp = (ev: KeyboardEvent) => {\r\n    const code = ev.code as Keys;\r\n    const key = this._keys.indexOf(code);\r\n    this._keys.splice(key, 1);\r\n    this._keysUp.push(code);\r\n    const keyEvent = new KeyEvent(code, ev.key, ev);\r\n\r\n    // alias the old api, we may want to deprecate this in the future\r\n    this.eventDispatcher.emit('up', keyEvent);\r\n    this.eventDispatcher.emit('release', keyEvent);\r\n  };\r\n\r\n  public update() {\r\n    // Reset keysDown and keysUp after update is complete\r\n    this._keysDown.length = 0;\r\n    this._keysUp.length = 0;\r\n\r\n    // Emit synthetic \"hold\" event\r\n    for (let i = 0; i < this._keys.length; i++) {\r\n      this.eventDispatcher.emit('hold', new KeyEvent(this._keys[i]));\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Gets list of keys being pressed down\r\n   */\r\n  public getKeys(): Keys[] {\r\n    return this._keys;\r\n  }\r\n\r\n  /**\r\n   * Tests if a certain key was just pressed this frame. This is cleared at the end of the update frame.\r\n   * @param key Test whether a key was just pressed\r\n   */\r\n  public wasPressed(key: Keys): boolean {\r\n    return this._keysDown.indexOf(key) > -1;\r\n  }\r\n\r\n  /**\r\n   * Tests if a certain key is held down. This is persisted between frames.\r\n   * @param key  Test whether a key is held down\r\n   */\r\n  public isHeld(key: Keys): boolean {\r\n    return this._keys.indexOf(key) > -1;\r\n  }\r\n\r\n  /**\r\n   * Tests if a certain key was just released this frame. This is cleared at the end of the update frame.\r\n   * @param key  Test whether a key was just released\r\n   */\r\n  public wasReleased(key: Keys): boolean {\r\n    return this._keysUp.indexOf(key) > -1;\r\n  }\r\n\r\n  /**\r\n   * Trigger a manual key event\r\n   * @param type\r\n   * @param key\r\n   * @param character\r\n   */\r\n  public triggerEvent(type: 'down' | 'up', key: Keys, character?: string) {\r\n    if (type === 'down') {\r\n      this._handleKeyDown(new KeyboardEvent('keydown', {\r\n        code: key,\r\n        key: character ?? null\r\n      }));\r\n    }\r\n    if (type === 'up') {\r\n      this._handleKeyUp(new KeyboardEvent('keyup', {\r\n        code: key,\r\n        key: character ?? null\r\n      }));\r\n    }\r\n  }\r\n}\r\n","import {\r\n  InitializeEvent,\r\n  KillEvent,\r\n  PreUpdateEvent,\r\n  PostUpdateEvent,\r\n  PostCollisionEvent,\r\n  PreCollisionEvent,\r\n  CollisionStartEvent,\r\n  CollisionEndEvent,\r\n  PostKillEvent,\r\n  PreKillEvent,\r\n  GameEvent,\r\n  ExitTriggerEvent,\r\n  EnterTriggerEvent,\r\n  EnterViewPortEvent,\r\n  ExitViewPortEvent\r\n} from './Events';\r\nimport { Engine } from './Engine';\r\nimport { Color } from './Color';\r\nimport { CanInitialize, CanUpdate, CanBeKilled } from './Interfaces/LifecycleEvents';\r\nimport { Scene } from './Scene';\r\nimport { Logger } from './Util/Log';\r\nimport { Vector, vec } from './Math/vector';\r\nimport { BodyComponent } from './Collision/BodyComponent';\r\nimport { Eventable } from './Interfaces/Evented';\r\nimport * as Events from './Events';\r\nimport { PointerEvents } from './Interfaces/PointerEventHandlers';\r\nimport { CollisionType } from './Collision/CollisionType';\r\n\r\nimport { Entity } from './EntityComponentSystem/Entity';\r\nimport { CoordPlane, TransformComponent } from './EntityComponentSystem/Components/TransformComponent';\r\nimport { MotionComponent } from './EntityComponentSystem/Components/MotionComponent';\r\nimport { GraphicsComponent } from './Graphics/GraphicsComponent';\r\nimport { Rectangle } from './Graphics/Rectangle';\r\nimport { ColliderComponent } from './Collision/ColliderComponent';\r\nimport { Shape } from './Collision/Colliders/Shape';\r\nimport { watch } from './Util/Watch';\r\nimport { Collider, CollisionGroup } from './Collision/Index';\r\nimport { Circle } from './Graphics/Circle';\r\nimport { PointerEvent } from './Input/PointerEvent';\r\nimport { WheelEvent } from './Input/WheelEvent';\r\nimport { PointerComponent } from './Input/PointerComponent';\r\nimport { ActionsComponent } from './Actions/ActionsComponent';\r\nimport { Raster } from './Graphics/Raster';\r\nimport { Text } from './Graphics/Text';\r\n\r\n/**\r\n * Type guard for checking if something is an Actor\r\n * @param x\r\n */\r\nexport function isActor(x: any): x is Actor {\r\n  return x instanceof Actor;\r\n}\r\n\r\n/**\r\n * Actor contructor options\r\n */\r\nexport interface ActorArgs {\r\n  /**\r\n   * Optionally set the name of the actor, default is 'anonymous'\r\n   */\r\n  name?: string;\r\n  /**\r\n   * Optionally set the x position of the actor, default is 0\r\n   */\r\n  x?: number;\r\n  /**\r\n   * Optionally set the y position of the actor, default is 0\r\n   */\r\n  y?: number;\r\n  /**\r\n   * Optionally set the (x, y) position of the actor as a vector, default is (0, 0)\r\n   */\r\n  pos?: Vector;\r\n  /**\r\n   * Optionally set the coordinate plane of the actor, default is [[CoordPlane.World]] meaning actor is subject to camera positioning\r\n   */\r\n  coordPlane?: CoordPlane;\r\n  /**\r\n   * Optionally set the width of a box collider for the actor\r\n   */\r\n  width?: number;\r\n  /**\r\n   * Optionally set the height of a box collider for the actor\r\n   */\r\n  height?: number;\r\n  /**\r\n   * Optionally set the radius of the circle collider for the actor\r\n   */\r\n  radius?: number;\r\n  /**\r\n   * Optionally set the velocity of the actor in pixels/sec\r\n   */\r\n  vel?: Vector;\r\n  /**\r\n   * Optionally set the acceleration of the actor in pixels/sec^2\r\n   */\r\n  acc?: Vector;\r\n  /**\r\n   * Optionally se the rotation in radians (180 degrees = Math.PI radians)\r\n   */\r\n  rotation?: number;\r\n  /**\r\n   * Optionally set the angular velocity of the actor in radians/sec (180 degrees = Math.PI radians)\r\n   */\r\n  angularVelocity?: number;\r\n  /**\r\n   * Optionally set the scale of the actor's transform\r\n   */\r\n  scale?: Vector;\r\n  /**\r\n   * Optionally set the z index of the actor, default is 0\r\n   */\r\n  z?: number;\r\n  /**\r\n   * Optionally set the color of an actor, only used if no graphics are present\r\n   * If a width/height or a radius was set a default graphic will be added\r\n   */\r\n  color?: Color;\r\n  /**\r\n   * Optionally set the visibility of the actor\r\n   */\r\n  visible?: boolean;\r\n  /**\r\n   * Optionally set the anchor for graphics in the actor\r\n   */\r\n  anchor?: Vector;\r\n  /**\r\n   * Optionally set the collision type\r\n   */\r\n  collisionType?: CollisionType;\r\n  /**\r\n   * Optionally supply a collider for an actor, if supplied ignores any supplied width/height\r\n   */\r\n  collider?: Collider;\r\n  /**\r\n   * Optionally suppy a [[CollisionGroup]]\r\n   */\r\n  collisionGroup?: CollisionGroup;\r\n}\r\n\r\n/**\r\n * The most important primitive in Excalibur is an `Actor`. Anything that\r\n * can move on the screen, collide with another `Actor`, respond to events,\r\n * or interact with the current scene, must be an actor. An `Actor` **must**\r\n * be part of a [[Scene]] for it to be drawn to the screen.\r\n */\r\nexport class Actor extends Entity implements Eventable, PointerEvents, CanInitialize, CanUpdate, CanBeKilled {\r\n  // #region Properties\r\n\r\n  /**\r\n   * Set defaults for all Actors\r\n   */\r\n  public static defaults = {\r\n    anchor: Vector.Half\r\n  };\r\n\r\n  /**\r\n   * The physics body the is associated with this actor. The body is the container for all physical properties, like position, velocity,\r\n   * acceleration, mass, inertia, etc.\r\n   */\r\n  public get body(): BodyComponent {\r\n    return this.get(BodyComponent);\r\n  }\r\n\r\n  /**\r\n   * Access the Actor's built in [[TransformComponent]]\r\n   */\r\n  public get transform(): TransformComponent {\r\n    return this.get(TransformComponent);\r\n  }\r\n\r\n  /**\r\n   * Access the Actor's built in [[MotionComponent]]\r\n   */\r\n  public get motion(): MotionComponent {\r\n    return this.get(MotionComponent);\r\n  }\r\n\r\n  /**\r\n   * Access to the Actor's built in [[GraphicsComponent]]\r\n   */\r\n  public get graphics(): GraphicsComponent {\r\n    return this.get(GraphicsComponent);\r\n  }\r\n\r\n  /**\r\n   * Access to the Actor's built in [[ColliderComponent]]\r\n   */\r\n  public get collider(): ColliderComponent {\r\n    return this.get(ColliderComponent);\r\n  }\r\n\r\n  /**\r\n   * Access to the Actor's built in [[PointerComponent]] config\r\n   */\r\n  public get pointer(): PointerComponent {\r\n    return this.get(PointerComponent);\r\n  }\r\n\r\n  /**\r\n   * Useful for quickly scripting actor behavior, like moving to a place, patrolling back and forth, blinking, etc.\r\n   *\r\n   *  Access to the Actor's built in [[ActionsComponent]] which forwards to the\r\n   * [[ActionContext|Action context]] of the actor.\r\n   */\r\n  public get actions(): ActionsComponent {\r\n    return this.get(ActionsComponent);\r\n  }\r\n\r\n  /**\r\n   * Gets the position vector of the actor in pixels\r\n   */\r\n  public get pos(): Vector {\r\n    return this.transform.pos;\r\n  }\r\n\r\n  /**\r\n   * Sets the position vector of the actor in pixels\r\n   */\r\n  public set pos(thePos: Vector) {\r\n    this.transform.pos = thePos.clone();\r\n  }\r\n\r\n  /**\r\n   * Gets the position vector of the actor from the last frame\r\n   */\r\n  public get oldPos(): Vector {\r\n    return this.body.oldPos;\r\n  }\r\n\r\n  /**\r\n   * Sets the position vector of the actor in the last frame\r\n   */\r\n  public set oldPos(thePos: Vector) {\r\n    this.body.oldPos.setTo(thePos.x, thePos.y);\r\n  }\r\n\r\n  /**\r\n   * Gets the velocity vector of the actor in pixels/sec\r\n   */\r\n  public get vel(): Vector {\r\n    return this.motion.vel;\r\n  }\r\n\r\n  /**\r\n   * Sets the velocity vector of the actor in pixels/sec\r\n   */\r\n  public set vel(theVel: Vector) {\r\n    this.motion.vel = theVel.clone();\r\n  }\r\n\r\n  /**\r\n   * Gets the velocity vector of the actor from the last frame\r\n   */\r\n  public get oldVel(): Vector {\r\n    return this.body.oldVel;\r\n  }\r\n\r\n  /**\r\n   * Sets the velocity vector of the actor from the last frame\r\n   */\r\n  public set oldVel(theVel: Vector) {\r\n    this.body.oldVel.setTo(theVel.x, theVel.y);\r\n  }\r\n\r\n  /**\r\n   * Gets the acceleration vector of the actor in pixels/second/second. An acceleration pointing down such as (0, 100) may be\r\n   * useful to simulate a gravitational effect.\r\n   */\r\n  public get acc(): Vector {\r\n    return this.motion.acc;\r\n  }\r\n\r\n  /**\r\n   * Sets the acceleration vector of teh actor in pixels/second/second\r\n   */\r\n  public set acc(theAcc: Vector) {\r\n    this.motion.acc = theAcc.clone();\r\n  }\r\n\r\n  /**\r\n   * Sets the acceleration of the actor from the last frame. This does not include the global acc [[Physics.acc]].\r\n   */\r\n  public set oldAcc(theAcc: Vector) {\r\n    this.body.oldAcc.setTo(theAcc.x, theAcc.y);\r\n  }\r\n\r\n  /**\r\n   * Gets the acceleration of the actor from the last frame. This does not include the global acc [[Physics.acc]].\r\n   */\r\n  public get oldAcc(): Vector {\r\n    return this.body.oldAcc;\r\n  }\r\n\r\n  /**\r\n   * Gets the rotation of the actor in radians. 1 radian = 180/PI Degrees.\r\n   */\r\n  public get rotation(): number {\r\n    return this.transform.rotation;\r\n  }\r\n\r\n  /**\r\n   * Sets the rotation of the actor in radians. 1 radian = 180/PI Degrees.\r\n   */\r\n  public set rotation(theAngle: number) {\r\n    this.transform.rotation = theAngle;\r\n  }\r\n\r\n  /**\r\n   * Gets the rotational velocity of the actor in radians/second\r\n   */\r\n  public get angularVelocity(): number {\r\n    return this.motion.angularVelocity;\r\n  }\r\n\r\n  /**\r\n   * Sets the rotational velocity of the actor in radians/sec\r\n   */\r\n  public set angularVelocity(angularVelocity: number) {\r\n    this.motion.angularVelocity = angularVelocity;\r\n  }\r\n\r\n  public get scale(): Vector {\r\n    return this.get(TransformComponent).scale;\r\n  }\r\n\r\n  public set scale(scale: Vector) {\r\n    this.get(TransformComponent).scale = scale;\r\n  }\r\n\r\n  /**\r\n   * The anchor to apply all actor related transformations like rotation,\r\n   * translation, and scaling. By default the anchor is in the center of\r\n   * the actor. By default it is set to the center of the actor (.5, .5)\r\n   *\r\n   * An anchor of (.5, .5) will ensure that drawings are centered.\r\n   *\r\n   * Use `anchor.setTo` to set the anchor to a different point using\r\n   * values between 0 and 1. For example, anchoring to the top-left would be\r\n   * `Actor.anchor.setTo(0, 0)` and top-right would be `Actor.anchor.setTo(0, 1)`.\r\n   */\r\n  private _anchor: Vector = watch(Vector.Half, (v) => this._handleAnchorChange(v));\r\n  public get anchor(): Vector {\r\n    return this._anchor;\r\n  }\r\n\r\n  public set anchor(vec: Vector) {\r\n    this._anchor = watch(vec, (v) => this._handleAnchorChange(v));\r\n    this._handleAnchorChange(vec);\r\n  }\r\n\r\n  private _handleAnchorChange(v: Vector) {\r\n    if (this.graphics) {\r\n      this.graphics.anchor = v;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Indicates whether the actor is physically in the viewport\r\n   */\r\n  public get isOffScreen(): boolean {\r\n    return this.hasTag('ex.offscreen');\r\n  }\r\n\r\n  /**\r\n   * Convenience reference to the global logger\r\n   */\r\n  public logger: Logger = Logger.getInstance();\r\n\r\n  /**\r\n   * The scene that the actor is in\r\n   */\r\n  public scene: Scene = null;\r\n\r\n  /**\r\n   * Draggable helper\r\n   */\r\n  private _draggable: boolean = false;\r\n  private _dragging: boolean = false;\r\n\r\n  private _pointerDragStartHandler = () => {\r\n    this._dragging = true;\r\n  };\r\n\r\n  private _pointerDragEndHandler = () => {\r\n    this._dragging = false;\r\n  };\r\n\r\n  private _pointerDragMoveHandler = (pe: PointerEvent) => {\r\n    if (this._dragging) {\r\n      this.pos = pe.worldPos;\r\n    }\r\n  };\r\n\r\n  private _pointerDragLeaveHandler = (pe: PointerEvent) => {\r\n    if (this._dragging) {\r\n      this.pos = pe.worldPos;\r\n    }\r\n  };\r\n\r\n  public get draggable(): boolean {\r\n    return this._draggable;\r\n  }\r\n\r\n  public set draggable(isDraggable: boolean) {\r\n    if (isDraggable) {\r\n      if (isDraggable && !this._draggable) {\r\n        this.on('pointerdragstart', this._pointerDragStartHandler);\r\n        this.on('pointerdragend', this._pointerDragEndHandler);\r\n        this.on('pointerdragmove', this._pointerDragMoveHandler);\r\n        this.on('pointerdragleave', this._pointerDragLeaveHandler);\r\n      } else if (!isDraggable && this._draggable) {\r\n        this.off('pointerdragstart', this._pointerDragStartHandler);\r\n        this.off('pointerdragend', this._pointerDragEndHandler);\r\n        this.off('pointerdragmove', this._pointerDragMoveHandler);\r\n        this.off('pointerdragleave', this._pointerDragLeaveHandler);\r\n      }\r\n\r\n      this._draggable = isDraggable;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Sets the color of the actor's current graphic\r\n   */\r\n  public get color(): Color {\r\n    return this._color;\r\n  }\r\n  public set color(v: Color) {\r\n    this._color = v.clone();\r\n    const defaultLayer = this.graphics.layers.default;\r\n    const currentGraphic = defaultLayer.graphics[0]?.graphic;\r\n    if (currentGraphic instanceof Raster || currentGraphic instanceof Text) {\r\n      currentGraphic.color = this._color;\r\n    }\r\n  }\r\n  private _color: Color;\r\n\r\n  // #endregion\r\n\r\n  /**\r\n   *\r\n   * @param config\r\n   */\r\n  constructor(config?: ActorArgs) {\r\n    super();\r\n\r\n    const {\r\n      name,\r\n      x,\r\n      y,\r\n      pos,\r\n      coordPlane,\r\n      scale,\r\n      width,\r\n      height,\r\n      radius,\r\n      collider,\r\n      vel,\r\n      acc,\r\n      rotation,\r\n      angularVelocity,\r\n      z,\r\n      color,\r\n      visible,\r\n      anchor,\r\n      collisionType,\r\n      collisionGroup\r\n    } = {\r\n      ...config\r\n    };\r\n\r\n    this._setName(name);\r\n    this.anchor = anchor ?? Actor.defaults.anchor.clone();\r\n    const tx = new TransformComponent();\r\n    this.addComponent(tx);\r\n    this.pos = pos ?? vec(x ?? 0, y ?? 0);\r\n    this.rotation = rotation ?? 0;\r\n    this.scale = scale ?? vec(1, 1);\r\n    this.z = z ?? 0;\r\n    tx.coordPlane = coordPlane ?? CoordPlane.World;\r\n\r\n    this.addComponent(new PointerComponent);\r\n\r\n    this.addComponent(new GraphicsComponent({\r\n      anchor: this.anchor\r\n    }));\r\n    this.addComponent(new MotionComponent());\r\n    this.vel = vel ?? Vector.Zero;\r\n    this.acc = acc ?? Vector.Zero;\r\n    this.angularVelocity = angularVelocity ?? 0;\r\n\r\n    this.addComponent(new ActionsComponent());\r\n\r\n    this.addComponent(new BodyComponent());\r\n    this.body.collisionType = collisionType ?? CollisionType.Passive;\r\n    if (collisionGroup) {\r\n      this.body.group = collisionGroup;\r\n    }\r\n\r\n    if (collider) {\r\n      this.addComponent(new ColliderComponent(collider));\r\n    } else if (radius) {\r\n      this.addComponent(new ColliderComponent(Shape.Circle(radius, this.anchor)));\r\n    } else {\r\n      if (width > 0 && height > 0) {\r\n        this.addComponent(new ColliderComponent(Shape.Box(width, height, this.anchor)));\r\n      } else {\r\n        this.addComponent(new ColliderComponent()); // no collider\r\n      }\r\n    }\r\n\r\n    this.graphics.visible = visible ?? true;\r\n\r\n    if (color) {\r\n      this.color = color;\r\n      if (width && height) {\r\n        this.graphics.add(\r\n          new Rectangle({\r\n            color: color,\r\n            width,\r\n            height\r\n          })\r\n        );\r\n      } else if (radius) {\r\n        this.graphics.add(\r\n          new Circle({\r\n            color: color,\r\n            radius\r\n          })\r\n        );\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * `onInitialize` is called before the first update of the actor. This method is meant to be\r\n   * overridden. This is where initialization of child actors should take place.\r\n   *\r\n   * Synonymous with the event handler `.on('initialize', (evt) => {...})`\r\n   */\r\n  public onInitialize(_engine: Engine): void {\r\n    // Override me\r\n  }\r\n\r\n  /**\r\n   * Initializes this actor and all it's child actors, meant to be called by the Scene before first update not by users of Excalibur.\r\n   *\r\n   * It is not recommended that internal excalibur methods be overridden, do so at your own risk.\r\n   *\r\n   * @internal\r\n   */\r\n  public _initialize(engine: Engine) {\r\n    super._initialize(engine);\r\n    for (const child of this.children) {\r\n      child._initialize(engine);\r\n    }\r\n  }\r\n\r\n  // #region Events\r\n\r\n  public on(eventName: Events.exittrigger, handler: (event: ExitTriggerEvent) => void): void;\r\n  public on(eventName: Events.entertrigger, handler: (event: EnterTriggerEvent) => void): void;\r\n  /**\r\n   * The **collisionstart** event is fired when a [[BodyComponent|physics body]], usually attached to an actor,\r\n   *  first starts colliding with another [[BodyComponent|body]], and will not fire again while in contact until\r\n   *  the the pair separates and collides again.\r\n   * Use cases for the **collisionstart** event may be detecting when an actor has touched a surface\r\n   * (like landing) or if a item has been touched and needs to be picked up.\r\n   */\r\n  public on(eventName: Events.collisionstart, handler: (event: CollisionStartEvent) => void): void;\r\n  /**\r\n   * The **collisionend** event is fired when two [[BodyComponent|physics bodies]] are no longer in contact.\r\n   * This event will not fire again until another collision and separation.\r\n   *\r\n   * Use cases for the **collisionend** event might be to detect when an actor has left a surface\r\n   * (like jumping) or has left an area.\r\n   */\r\n  public on(eventName: Events.collisionend, handler: (event: CollisionEndEvent) => void): void;\r\n  /**\r\n   * The **precollision** event is fired **every frame** where a collision pair is found and two\r\n   * bodies are intersecting.\r\n   *\r\n   * This event is useful for building in custom collision resolution logic in Passive-Passive or\r\n   * Active-Passive scenarios. For example in a breakout game you may want to tweak the angle of\r\n   * ricochet of the ball depending on which side of the paddle you hit.\r\n   */\r\n  public on(eventName: Events.precollision, handler: (event: PreCollisionEvent) => void): void;\r\n  /**\r\n   * The **postcollision** event is fired for **every frame** where collision resolution was performed.\r\n   * Collision resolution is when two bodies influence each other and cause a response like bouncing\r\n   * off one another. It is only possible to have *postcollision* event in Active-Active and Active-Fixed\r\n   * type collision pairs.\r\n   *\r\n   * Post collision would be useful if you need to know that collision resolution is happening or need to\r\n   * tweak the default resolution.\r\n   */\r\n  public on(eventName: Events.postcollision, handler: (event: PostCollisionEvent) => void): void;\r\n  public on(eventName: Events.kill, handler: (event: KillEvent) => void): void;\r\n  public on(eventName: Events.prekill, handler: (event: PreKillEvent) => void): void;\r\n  public on(eventName: Events.postkill, handler: (event: PostKillEvent) => void): void;\r\n  public on(eventName: Events.initialize, handler: (event: InitializeEvent<Actor>) => void): void;\r\n  public on(eventName: Events.preupdate, handler: (event: PreUpdateEvent<Actor>) => void): void;\r\n  public on(eventName: Events.postupdate, handler: (event: PostUpdateEvent<Actor>) => void): void;\r\n  public on(eventName: Events.pointerup, handler: (event: PointerEvent) => void): void;\r\n  public on(eventName: Events.pointerdown, handler: (event: PointerEvent) => void): void;\r\n  public on(eventName: Events.pointerenter, handler: (event: PointerEvent) => void): void;\r\n  public on(eventName: Events.pointerleave, handler: (event: PointerEvent) => void): void;\r\n  public on(eventName: Events.pointermove, handler: (event: PointerEvent) => void): void;\r\n  public on(eventName: Events.pointercancel, handler: (event: PointerEvent) => void): void;\r\n  public on(eventName: Events.pointerwheel, handler: (event: WheelEvent) => void): void;\r\n  public on(eventName: Events.pointerdragstart, handler: (event: PointerEvent) => void): void;\r\n  public on(eventName: Events.pointerdragend, handler: (event: PointerEvent) => void): void;\r\n  public on(eventName: Events.pointerdragenter, handler: (event: PointerEvent) => void): void;\r\n  public on(eventName: Events.pointerdragleave, handler: (event: PointerEvent) => void): void;\r\n  public on(eventName: Events.pointerdragmove, handler: (event: PointerEvent) => void): void;\r\n  public on(eventName: Events.enterviewport, handler: (event: EnterViewPortEvent) => void): void;\r\n  public on(eventName: Events.exitviewport, handler: (event: ExitViewPortEvent) => void): void;\r\n  public on(eventName: string, handler: (event: GameEvent<Actor>) => void): void;\r\n  public on(eventName: string, handler: (event: any) => void): void {\r\n    super.on(eventName, handler);\r\n  }\r\n\r\n  public once(eventName: Events.exittrigger, handler: (event: ExitTriggerEvent) => void): void;\r\n  public once(eventName: Events.entertrigger, handler: (event: EnterTriggerEvent) => void): void;\r\n  /**\r\n   * The **collisionstart** event is fired when a [[BodyComponent|physics body]], usually attached to an actor,\r\n   *  first starts colliding with another [[BodyComponent|body]], and will not fire again while in contact until\r\n   *  the the pair separates and collides again.\r\n   * Use cases for the **collisionstart** event may be detecting when an actor has touch a surface\r\n   * (like landing) or if a item has been touched and needs to be picked up.\r\n   */\r\n  public once(eventName: Events.collisionstart, handler: (event: CollisionStartEvent) => void): void;\r\n  /**\r\n   * The **collisionend** event is fired when two [[BodyComponent|physics bodies]] are no longer in contact.\r\n   * This event will not fire again until another collision and separation.\r\n   *\r\n   * Use cases for the **collisionend** event might be to detect when an actor has left a surface\r\n   * (like jumping) or has left an area.\r\n   */\r\n  public once(eventName: Events.collisionend, handler: (event: CollisionEndEvent) => void): void;\r\n  /**\r\n   * The **precollision** event is fired **every frame** where a collision pair is found and two\r\n   * bodies are intersecting.\r\n   *\r\n   * This event is useful for building in custom collision resolution logic in Passive-Passive or\r\n   * Active-Passive scenarios. For example in a breakout game you may want to tweak the angle of\r\n   * ricochet of the ball depending on which side of the paddle you hit.\r\n   */\r\n  public once(eventName: Events.precollision, handler: (event: PreCollisionEvent) => void): void;\r\n  /**\r\n   * The **postcollision** event is fired for **every frame** where collision resolution was performed.\r\n   * Collision resolution is when two bodies influence each other and cause a response like bouncing\r\n   * off one another. It is only possible to have *postcollision* event in Active-Active and Active-Fixed\r\n   * type collision pairs.\r\n   *\r\n   * Post collision would be useful if you need to know that collision resolution is happening or need to\r\n   * tweak the default resolution.\r\n   */\r\n  public once(eventName: Events.postcollision, handler: (event: PostCollisionEvent) => void): void;\r\n  public once(eventName: Events.kill, handler: (event: KillEvent) => void): void;\r\n  public once(eventName: Events.postkill, handler: (event: PostKillEvent) => void): void;\r\n  public once(eventName: Events.prekill, handler: (event: PreKillEvent) => void): void;\r\n  public once(eventName: Events.initialize, handler: (event: InitializeEvent<Actor>) => void): void;\r\n  public once(eventName: Events.preupdate, handler: (event: PreUpdateEvent<Actor>) => void): void;\r\n  public once(eventName: Events.postupdate, handler: (event: PostUpdateEvent<Actor>) => void): void;\r\n  public once(eventName: Events.pointerup, handler: (event: PointerEvent) => void): void;\r\n  public once(eventName: Events.pointerdown, handler: (event: PointerEvent) => void): void;\r\n  public once(eventName: Events.pointerenter, handler: (event: PointerEvent) => void): void;\r\n  public once(eventName: Events.pointerleave, handler: (event: PointerEvent) => void): void;\r\n  public once(eventName: Events.pointermove, handler: (event: PointerEvent) => void): void;\r\n  public once(eventName: Events.pointercancel, handler: (event: PointerEvent) => void): void;\r\n  public once(eventName: Events.pointerwheel, handler: (event: WheelEvent) => void): void;\r\n  public once(eventName: Events.pointerdragstart, handler: (event: PointerEvent) => void): void;\r\n  public once(eventName: Events.pointerdragend, handler: (event: PointerEvent) => void): void;\r\n  public once(eventName: Events.pointerdragenter, handler: (event: PointerEvent) => void): void;\r\n  public once(eventName: Events.pointerdragleave, handler: (event: PointerEvent) => void): void;\r\n  public once(eventName: Events.pointerdragmove, handler: (event: PointerEvent) => void): void;\r\n  public once(eventName: Events.enterviewport, handler: (event: EnterViewPortEvent) => void): void;\r\n  public once(eventName: Events.exitviewport, handler: (event: ExitViewPortEvent) => void): void;\r\n  public once(eventName: string, handler: (event: GameEvent<Actor>) => void): void;\r\n  public once(eventName: string, handler: (event: any) => void): void {\r\n    super.once(eventName, handler);\r\n  }\r\n\r\n  public off(eventName: Events.exittrigger, handler?: (event: ExitTriggerEvent) => void): void;\r\n  public off(eventName: Events.entertrigger, handler?: (event: EnterTriggerEvent) => void): void;\r\n  /**\r\n   * The **collisionstart** event is fired when a [[BodyComponent|physics body]], usually attached to an actor,\r\n   *  first starts colliding with another [[BodyComponent|body]], and will not fire again while in contact until\r\n   *  the the pair separates and collides again.\r\n   * Use cases for the **collisionstart** event may be detecting when an actor has touch a surface\r\n   * (like landing) or if a item has been touched and needs to be picked up.\r\n   */\r\n  public off(eventName: Events.collisionstart, handler?: (event: CollisionStartEvent) => void): void;\r\n  /**\r\n   * The **collisionend** event is fired when two [[BodyComponent|physics bodies]] are no longer in contact.\r\n   * This event will not fire again until another collision and separation.\r\n   *\r\n   * Use cases for the **collisionend** event might be to detect when an actor has left a surface\r\n   * (like jumping) or has left an area.\r\n   */\r\n  public off(eventName: Events.collisionend, handler?: (event: CollisionEndEvent) => void): void;\r\n  /**\r\n   * The **precollision** event is fired **every frame** where a collision pair is found and two\r\n   * bodies are intersecting.\r\n   *\r\n   * This event is useful for building in custom collision resolution logic in Passive-Passive or\r\n   * Active-Passive scenarios. For example in a breakout game you may want to tweak the angle of\r\n   * ricochet of the ball depending on which side of the paddle you hit.\r\n   */\r\n  public off(eventName: Events.precollision, handler?: (event: PreCollisionEvent) => void): void;\r\n  /**\r\n   * The **postcollision** event is fired for **every frame** where collision resolution was performed.\r\n   * Collision resolution is when two bodies influence each other and cause a response like bouncing\r\n   * off one another. It is only possible to have *postcollision* event in Active-Active and Active-Fixed\r\n   * type collision pairs.\r\n   *\r\n   * Post collision would be useful if you need to know that collision resolution is happening or need to\r\n   * tweak the default resolution.\r\n   */\r\n  public off(eventName: Events.postcollision, handler: (event: PostCollisionEvent) => void): void;\r\n  public off(eventName: Events.pointerup, handler?: (event: PointerEvent) => void): void;\r\n  public off(eventName: Events.pointerdown, handler?: (event: PointerEvent) => void): void;\r\n  public off(eventName: Events.pointerenter, handler?: (event: PointerEvent) => void): void;\r\n  public off(eventName: Events.pointerleave, handler?: (event: PointerEvent) => void): void;\r\n  public off(eventName: Events.pointermove, handler?: (event: PointerEvent) => void): void;\r\n  public off(eventName: Events.pointercancel, handler?: (event: PointerEvent) => void): void;\r\n  public off(eventName: Events.pointerwheel, handler?: (event: WheelEvent) => void): void;\r\n  public off(eventName: Events.pointerdragstart, handler?: (event: PointerEvent) => void): void;\r\n  public off(eventName: Events.pointerdragend, handler?: (event: PointerEvent) => void): void;\r\n  public off(eventName: Events.pointerdragenter, handler?: (event: PointerEvent) => void): void;\r\n  public off(eventName: Events.pointerdragleave, handler?: (event: PointerEvent) => void): void;\r\n  public off(eventName: Events.pointerdragmove, handler?: (event: PointerEvent) => void): void;\r\n  public off(eventName: Events.prekill, handler?: (event: PreKillEvent) => void): void;\r\n  public off(eventName: Events.postkill, handler?: (event: PostKillEvent) => void): void;\r\n  public off(eventName: Events.initialize, handler?: (event: Events.InitializeEvent<Actor>) => void): void;\r\n  public off(eventName: Events.postupdate, handler?: (event: Events.PostUpdateEvent<Actor>) => void): void;\r\n  public off(eventName: Events.preupdate, handler?: (event: Events.PreUpdateEvent<Actor>) => void): void;\r\n  public off(eventName: Events.enterviewport, handler?: (event: EnterViewPortEvent) => void): void;\r\n  public off(eventName: Events.exitviewport, handler?: (event: ExitViewPortEvent) => void): void;\r\n  public off(eventName: string, handler?: (event: GameEvent<Actor>) => void): void;\r\n  public off(eventName: string, handler?: (event: any) => void): void {\r\n    super.off(eventName, handler);\r\n  }\r\n\r\n  // #endregion\r\n\r\n  /**\r\n   * It is not recommended that internal excalibur methods be overridden, do so at your own risk.\r\n   *\r\n   * Internal _prekill handler for [[onPreKill]] lifecycle event\r\n   * @internal\r\n   */\r\n  public _prekill(_scene: Scene) {\r\n    super.emit('prekill', new PreKillEvent(this));\r\n    this.onPreKill(_scene);\r\n  }\r\n\r\n  /**\r\n   * Safe to override onPreKill lifecycle event handler. Synonymous with `.on('prekill', (evt) =>{...})`\r\n   *\r\n   * `onPreKill` is called directly before an actor is killed and removed from its current [[Scene]].\r\n   */\r\n  public onPreKill(_scene: Scene) {\r\n    // Override me\r\n  }\r\n\r\n  /**\r\n   * It is not recommended that internal excalibur methods be overridden, do so at your own risk.\r\n   *\r\n   * Internal _prekill handler for [[onPostKill]] lifecycle event\r\n   * @internal\r\n   */\r\n  public _postkill(_scene: Scene) {\r\n    super.emit('postkill', new PostKillEvent(this));\r\n    this.onPostKill(_scene);\r\n  }\r\n\r\n  /**\r\n   * Safe to override onPostKill lifecycle event handler. Synonymous with `.on('postkill', (evt) => {...})`\r\n   *\r\n   * `onPostKill` is called directly after an actor is killed and remove from its current [[Scene]].\r\n   */\r\n  public onPostKill(_scene: Scene) {\r\n    // Override me\r\n  }\r\n\r\n  /**\r\n   * If the current actor is a member of the scene, this will remove\r\n   * it from the scene graph. It will no longer be drawn or updated.\r\n   */\r\n  public kill() {\r\n    if (this.scene) {\r\n      this._prekill(this.scene);\r\n      this.emit('kill', new KillEvent(this));\r\n      super.kill();\r\n      this._postkill(this.scene);\r\n    } else {\r\n      this.logger.warn('Cannot kill actor, it was never added to the Scene');\r\n    }\r\n  }\r\n\r\n  /**\r\n   * If the current actor is killed, it will now not be killed.\r\n   */\r\n  public unkill() {\r\n    this.active = true;\r\n  }\r\n\r\n  /**\r\n   * Indicates wether the actor has been killed.\r\n   */\r\n  public isKilled(): boolean {\r\n    return !this.active;\r\n  }\r\n\r\n  /**\r\n   * Gets the z-index of an actor. The z-index determines the relative order an actor is drawn in.\r\n   * Actors with a higher z-index are drawn on top of actors with a lower z-index\r\n   */\r\n  public get z(): number {\r\n    return this.get(TransformComponent).z;\r\n  }\r\n\r\n\r\n  /**\r\n   * Sets the z-index of an actor and updates it in the drawing list for the scene.\r\n   * The z-index determines the relative order an actor is drawn in.\r\n   * Actors with a higher z-index are drawn on top of actors with a lower z-index\r\n   * @param newZ new z-index to assign\r\n   */\r\n  public set z(newZ: number) {\r\n    this.get(TransformComponent).z = newZ;\r\n  }\r\n\r\n  /**\r\n   * Get the center point of an actor (global position)\r\n   */\r\n  public get center(): Vector {\r\n    const globalPos = this.getGlobalPos();\r\n    return new Vector(\r\n      globalPos.x + this.width / 2 - this.anchor.x * this.width,\r\n      globalPos.y + this.height / 2 - this.anchor.y * this.height);\r\n  }\r\n\r\n  /**\r\n   * Get the local center point of an actor\r\n   */\r\n  public get localCenter(): Vector {\r\n    return new Vector(\r\n      this.pos.x + this.width / 2 - this.anchor.x * this.width,\r\n      this.pos.y + this.height / 2 - this.anchor.y * this.height);\r\n  }\r\n\r\n  public get width() {\r\n    return this.collider.localBounds.width * this.getGlobalScale().x;\r\n  }\r\n\r\n  public get height() {\r\n    return this.collider.localBounds.height * this.getGlobalScale().y;\r\n  }\r\n\r\n  /**\r\n   * Gets this actor's rotation taking into account any parent relationships\r\n   *\r\n   * @returns Rotation angle in radians\r\n   */\r\n  public getGlobalRotation(): number {\r\n    return this.get(TransformComponent).globalRotation;\r\n  }\r\n\r\n  /**\r\n   * Gets an actor's world position taking into account parent relationships, scaling, rotation, and translation\r\n   *\r\n   * @returns Position in world coordinates\r\n   */\r\n  public getGlobalPos(): Vector {\r\n    return this.get(TransformComponent).globalPos;\r\n  }\r\n\r\n  /**\r\n   * Gets the global scale of the Actor\r\n   */\r\n  public getGlobalScale(): Vector {\r\n    return this.get(TransformComponent).globalScale;\r\n  }\r\n\r\n  // #region Collision\r\n\r\n  /**\r\n   * Tests whether the x/y specified are contained in the actor\r\n   * @param x  X coordinate to test (in world coordinates)\r\n   * @param y  Y coordinate to test (in world coordinates)\r\n   * @param recurse checks whether the x/y are contained in any child actors (if they exist).\r\n   */\r\n  public contains(x: number, y: number, recurse: boolean = false): boolean {\r\n    const point = vec(x, y);\r\n    const collider = this.get(ColliderComponent);\r\n    collider.update();\r\n    const geom = collider.get();\r\n    if (!geom) {\r\n      return false;\r\n    }\r\n    const containment = geom.contains(point);\r\n\r\n    if (recurse) {\r\n      return (\r\n        containment ||\r\n        this.children.some((child: Actor) => {\r\n          return child.contains(x, y, true);\r\n        })\r\n      );\r\n    }\r\n\r\n    return containment;\r\n  }\r\n\r\n  /**\r\n   * Returns true if the two actor.collider's surfaces are less than or equal to the distance specified from each other\r\n   * @param actor     Actor to test\r\n   * @param distance  Distance in pixels to test\r\n   */\r\n  public within(actor: Actor, distance: number): boolean {\r\n    const collider = this.get(ColliderComponent);\r\n    const otherCollider = actor.get(ColliderComponent);\r\n    const me = collider.get();\r\n    const other = otherCollider.get();\r\n    if (me && other) {\r\n      return me.getClosestLineBetween(other).getLength() <= distance;\r\n    }\r\n    return false;\r\n  }\r\n\r\n  // #endregion\r\n\r\n  // #region Update\r\n\r\n  /**\r\n   * Called by the Engine, updates the state of the actor\r\n   * @internal\r\n   * @param engine The reference to the current game engine\r\n   * @param delta  The time elapsed since the last update in milliseconds\r\n   */\r\n  public update(engine: Engine, delta: number) {\r\n    this._initialize(engine);\r\n    this._preupdate(engine, delta);\r\n    this._postupdate(engine, delta);\r\n  }\r\n\r\n  /**\r\n   * Safe to override onPreUpdate lifecycle event handler. Synonymous with `.on('preupdate', (evt) =>{...})`\r\n   *\r\n   * `onPreUpdate` is called directly before an actor is updated.\r\n   */\r\n  public onPreUpdate(_engine: Engine, _delta: number): void {\r\n    // Override me\r\n  }\r\n\r\n  /**\r\n   * Safe to override onPostUpdate lifecycle event handler. Synonymous with `.on('postupdate', (evt) =>{...})`\r\n   *\r\n   * `onPostUpdate` is called directly after an actor is updated.\r\n   */\r\n  public onPostUpdate(_engine: Engine, _delta: number): void {\r\n    // Override me\r\n  }\r\n\r\n  /**\r\n   * It is not recommended that internal excalibur methods be overridden, do so at your own risk.\r\n   *\r\n   * Internal _preupdate handler for [[onPreUpdate]] lifecycle event\r\n   * @internal\r\n   */\r\n  public _preupdate(engine: Engine, delta: number): void {\r\n    this.emit('preupdate', new PreUpdateEvent(engine, delta, this));\r\n    this.onPreUpdate(engine, delta);\r\n  }\r\n\r\n  /**\r\n   * It is not recommended that internal excalibur methods be overridden, do so at your own risk.\r\n   *\r\n   * Internal _preupdate handler for [[onPostUpdate]] lifecycle event\r\n   * @internal\r\n   */\r\n  public _postupdate(engine: Engine, delta: number): void {\r\n    this.emit('postupdate', new PreUpdateEvent(engine, delta, this));\r\n    this.onPostUpdate(engine, delta);\r\n  }\r\n\r\n  // endregion\r\n}\r\n","import { Vector, vec } from './Math/vector';\r\nimport { Engine } from './Engine';\r\nimport { Actor, ActorArgs } from './Actor';\r\nimport { CoordPlane, TransformComponent } from './EntityComponentSystem/Components/TransformComponent';\r\nimport { CollisionType } from './Collision/CollisionType';\r\n\r\n/**\r\n * Type guard to detect a screen element\r\n */\r\nexport function isScreenElement(actor: Actor) {\r\n  return actor instanceof ScreenElement;\r\n}\r\n\r\n/**\r\n * Helper [[Actor]] primitive for drawing UI's, optimized for UI drawing. Does\r\n * not participate in collisions. Drawn on top of all other actors.\r\n */\r\nexport class ScreenElement extends Actor {\r\n  protected _engine: Engine;\r\n\r\n  constructor();\r\n  constructor(config?: ActorArgs);\r\n\r\n  constructor(config?: ActorArgs) {\r\n    super({ ...config });\r\n    this.get(TransformComponent).coordPlane = CoordPlane.Screen;\r\n    this.anchor = vec(0, 0);\r\n    this.body.collisionType = CollisionType.PreventCollision;\r\n    this.collider.useBoxCollider(this.width, this.height, this.anchor);\r\n  }\r\n\r\n  public _initialize(engine: Engine) {\r\n    this._engine = engine;\r\n    super._initialize(engine);\r\n  }\r\n\r\n  public contains(x: number, y: number, useWorld: boolean = true) {\r\n    if (useWorld) {\r\n      return super.contains(x, y);\r\n    }\r\n\r\n    const coords = this._engine.worldToScreenCoordinates(new Vector(x, y));\r\n    return super.contains(coords.x, coords.y);\r\n  }\r\n}\r\n","import { Scene } from './Scene';\r\nimport { Logger } from './Util/Log';\r\n\r\nexport interface TimerOptions {\r\n  repeats?: boolean;\r\n  numberOfRepeats?: number;\r\n  fcn?: () => void;\r\n  interval: number;\r\n}\r\n\r\n/**\r\n * The Excalibur timer hooks into the internal timer and fires callbacks,\r\n * after a certain interval, optionally repeating.\r\n */\r\nexport class Timer {\r\n  private _logger = Logger.getInstance();\r\n  private static _MAX_ID: number = 0;\r\n  public id: number = 0;\r\n\r\n  private _elapsedTime: number = 0;\r\n  private _totalTimeAlive: number = 0;\r\n\r\n  private _running = false;\r\n\r\n  private _numberOfTicks: number = 0;\r\n  private _callbacks: Array<() => void>;\r\n\r\n  public interval: number = 10;\r\n  public repeats: boolean = false;\r\n  public maxNumberOfRepeats: number = -1;\r\n\r\n  private _complete = false;\r\n  public get complete() {\r\n    return this._complete;\r\n  }\r\n  public scene: Scene = null;\r\n\r\n  /**\r\n   * @param options    Options - repeats, numberOfRepeats, fcn, interval\r\n   * @param repeats    Indicates whether this call back should be fired only once, or repeat after every interval as completed.\r\n   * @param numberOfRepeats Specifies a maximum number of times that this timer will execute.\r\n   * @param fcn        The callback to be fired after the interval is complete.\r\n   */\r\n  constructor(options: TimerOptions);\r\n  constructor(fcn: TimerOptions | (() => void), interval?: number, repeats?: boolean, numberOfRepeats?: number) {\r\n    if (typeof fcn !== 'function') {\r\n      const options = fcn;\r\n      fcn = options.fcn;\r\n      interval = options.interval;\r\n      repeats = options.repeats;\r\n      numberOfRepeats = options.numberOfRepeats;\r\n    }\r\n\r\n    if (!!numberOfRepeats && numberOfRepeats >= 0) {\r\n      this.maxNumberOfRepeats = numberOfRepeats;\r\n      if (!repeats) {\r\n        throw new Error('repeats must be set to true if numberOfRepeats is set');\r\n      }\r\n    }\r\n\r\n    this.id = Timer._MAX_ID++;\r\n    this.interval = interval || this.interval;\r\n    this.repeats = repeats || this.repeats;\r\n\r\n    this._callbacks = [];\r\n\r\n    if (fcn) {\r\n      this.on(fcn);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Adds a new callback to be fired after the interval is complete\r\n   * @param fcn The callback to be added to the callback list, to be fired after the interval is complete.\r\n   */\r\n  public on(fcn: () => void) {\r\n    this._callbacks.push(fcn);\r\n  }\r\n\r\n  /**\r\n   * Removes a callback from the callback list to be fired after the interval is complete.\r\n   * @param fcn The callback to be removed from the callback list, to be fired after the interval is complete.\r\n   */\r\n  public off(fcn: () => void) {\r\n    const index = this._callbacks.indexOf(fcn);\r\n    this._callbacks.splice(index, 1);\r\n  }\r\n\r\n  /**\r\n   * Updates the timer after a certain number of milliseconds have elapsed. This is used internally by the engine.\r\n   * @param delta  Number of elapsed milliseconds since the last update.\r\n   */\r\n  public update(delta: number) {\r\n    if (this._running) {\r\n      this._totalTimeAlive += delta;\r\n      this._elapsedTime += delta;\r\n\r\n      if (this.maxNumberOfRepeats > -1 && this._numberOfTicks >= this.maxNumberOfRepeats) {\r\n        this._complete = true;\r\n        this._running = false;\r\n        this._elapsedTime = 0;\r\n      }\r\n\r\n      if (!this.complete && this._elapsedTime >= this.interval) {\r\n        this._callbacks.forEach((c) => {\r\n          c.call(this);\r\n        });\r\n\r\n        this._numberOfTicks++;\r\n        if (this.repeats) {\r\n          this._elapsedTime = 0;\r\n        } else {\r\n          this._complete = true;\r\n          this._running = false;\r\n          this._elapsedTime = 0;\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Resets the timer so that it can be reused, and optionally reconfigure the timers interval.\r\n   *\r\n   * Warning** you may need to call `timer.start()` again if the timer had completed\r\n   * @param newInterval If specified, sets a new non-negative interval in milliseconds to refire the callback\r\n   * @param newNumberOfRepeats If specified, sets a new non-negative upper limit to the number of time this timer executes\r\n   */\r\n  public reset(newInterval?: number, newNumberOfRepeats?: number) {\r\n    if (!!newInterval && newInterval >= 0) {\r\n      this.interval = newInterval;\r\n    }\r\n\r\n    if (!!this.maxNumberOfRepeats && this.maxNumberOfRepeats >= 0) {\r\n      this.maxNumberOfRepeats = newNumberOfRepeats;\r\n      if (!this.repeats) {\r\n        throw new Error('repeats must be set to true if numberOfRepeats is set');\r\n      }\r\n    }\r\n\r\n    this._complete = false;\r\n    this._elapsedTime = 0;\r\n    this._numberOfTicks = 0;\r\n  }\r\n\r\n  public get timesRepeated(): number {\r\n    return this._numberOfTicks;\r\n  }\r\n\r\n  public getTimeRunning(): number {\r\n    return this._totalTimeAlive;\r\n  }\r\n\r\n  /**\r\n   * @returns milliseconds until the next action callback, if complete will return 0\r\n   */\r\n  public get timeToNextAction() {\r\n    if (this.complete) {\r\n      return 0;\r\n    }\r\n    return this.interval - this._elapsedTime;\r\n  }\r\n\r\n  /**\r\n   * @returns milliseconds elapsed toward the next action\r\n   */\r\n  public get timeElapsedTowardNextAction() {\r\n    return this._elapsedTime;\r\n  }\r\n\r\n  public get isRunning() {\r\n    return this._running;\r\n  }\r\n\r\n  /**\r\n   * Pauses the timer, time will no longer increment towards the next call\r\n   */\r\n  public pause(): Timer {\r\n    this._running = false;\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Resumes the timer, time will now increment towards the next call.\r\n   */\r\n  public resume(): Timer {\r\n    this._running = true;\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Starts the timer, if the timer was complete it will restart the timer and reset the elapsed time counter\r\n   */\r\n  public start(): Timer {\r\n    if (!this.scene) {\r\n      this._logger.warn('Cannot start a timer not part of a scene, timer wont start until added');\r\n    }\r\n\r\n    this._running = true;\r\n    if (this.complete) {\r\n      this._complete = false;\r\n      this._elapsedTime = 0;\r\n      this._numberOfTicks = 0;\r\n    }\r\n\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Stops the timer and resets the elapsed time counter towards the next action invocation\r\n   */\r\n  public stop(): Timer {\r\n    this._running = false;\r\n    this._elapsedTime = 0;\r\n    this._numberOfTicks = 0;\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Cancels the timer, preventing any further executions.\r\n   */\r\n  public cancel() {\r\n    this.pause();\r\n    if (this.scene) {\r\n      this.scene.cancelTimer(this);\r\n    }\r\n  }\r\n}\r\n","import { Component } from '../EntityComponentSystem/Component';\r\nimport { vec, Vector } from '../Math/vector';\r\n\r\nexport class ParallaxComponent extends Component<'ex.parallax'> {\r\n  readonly type = 'ex.parallax';\r\n\r\n  parallaxFactor = vec(1.0, 1.0);\r\n\r\n  constructor(parallaxFactor?: Vector) {\r\n    super();\r\n    this.parallaxFactor = parallaxFactor ?? this.parallaxFactor;\r\n  }\r\n}","import { ExcaliburGraphicsContext } from '.';\r\nimport { Component } from '../EntityComponentSystem/Component';\r\n\r\n\r\n/**\r\n * Provide arbitrary drawing for the purposes of debugging your game\r\n *\r\n * Will only show when the Engine is set to debug mode [[Engine.showDebug]] or [[Engine.toggleDebug]]\r\n *\r\n */\r\nexport class DebugGraphicsComponent extends Component<'ex.debuggraphics'> {\r\n  readonly type = 'ex.debuggraphics';\r\n  constructor(public draw: (ctx: ExcaliburGraphicsContext) => void, public useTransform = true) {\r\n    super();\r\n  }\r\n}","import { BoundingBox } from '../Collision/BoundingBox';\r\nimport { Engine } from '../Engine';\r\nimport { Vector, vec } from '../Math/vector';\r\nimport { Logger } from '../Util/Log';\r\nimport * as Events from '../Events';\r\nimport { Entity } from '../EntityComponentSystem/Entity';\r\nimport { TransformComponent } from '../EntityComponentSystem/Components/TransformComponent';\r\nimport { BodyComponent } from '../Collision/BodyComponent';\r\nimport { CollisionType } from '../Collision/CollisionType';\r\nimport { Shape } from '../Collision/Colliders/Shape';\r\nimport { ExcaliburGraphicsContext, Graphic, GraphicsComponent, hasGraphicsTick, ParallaxComponent } from '../Graphics';\r\nimport { removeItemFromArray } from '../Util/Util';\r\nimport { MotionComponent } from '../EntityComponentSystem/Components/MotionComponent';\r\nimport { ColliderComponent } from '../Collision/ColliderComponent';\r\nimport { CompositeCollider } from '../Collision/Colliders/CompositeCollider';\r\nimport { Color } from '../Color';\r\nimport { DebugGraphicsComponent } from '../Graphics/DebugGraphicsComponent';\r\nimport { Collider } from '../Collision/Colliders/Collider';\r\n\r\nexport interface TileMapOptions {\r\n  /**\r\n   * Optionally name the isometric tile map\r\n   */\r\n  name?: string;\r\n  /**\r\n   * Optionally specify the position of the isometric tile map\r\n   */\r\n  pos?: Vector;\r\n  /**\r\n   * Width of an individual tile in pixels\r\n   */\r\n  tileWidth: number;\r\n  /**\r\n   * Height of an individual tile in pixels\r\n   */\r\n  tileHeight: number;\r\n  /**\r\n   * The number of tile columns, or the number of tiles wide\r\n   */\r\n  columns: number;\r\n  /**\r\n   * The number of tile  rows, or the number of tiles high\r\n   */\r\n  rows: number;\r\n}\r\n\r\n/**\r\n * The TileMap provides a mechanism for doing flat 2D tiles rendered in a grid.\r\n *\r\n * TileMaps are useful for top down or side scrolling grid oriented games.\r\n */\r\nexport class TileMap extends Entity {\r\n  private _token = 0;\r\n  private _onScreenXStart: number = 0;\r\n  private _onScreenXEnd: number = Number.MAX_VALUE;\r\n  private _onScreenYStart: number = 0;\r\n  private _onScreenYEnd: number = Number.MAX_VALUE;\r\n\r\n  public logger: Logger = Logger.getInstance();\r\n  public readonly tiles: Tile[] = [];\r\n  private _rows: Tile[][] = [];\r\n  private _cols: Tile[][] = [];\r\n\r\n  public readonly tileWidth: number;\r\n  public readonly tileHeight: number;\r\n  public readonly rows: number;\r\n  public readonly columns: number;\r\n\r\n  private _collidersDirty = true;\r\n  public flagCollidersDirty() {\r\n    this._collidersDirty = true;\r\n  }\r\n  private _transform: TransformComponent;\r\n  private _motion: MotionComponent;\r\n  private _graphics: GraphicsComponent;\r\n  private _collider: ColliderComponent;\r\n  private _composite: CompositeCollider;\r\n\r\n  public get x(): number {\r\n    return this._transform.pos.x ?? 0;\r\n  }\r\n\r\n  public set x(val: number) {\r\n    if (this._transform?.pos) {\r\n      this.get(TransformComponent).pos = vec(val, this.y);\r\n    }\r\n  }\r\n\r\n  public get y(): number {\r\n    return this._transform?.pos.y ?? 0;\r\n  }\r\n\r\n  public set y(val: number) {\r\n    if (this._transform?.pos) {\r\n      this._transform.pos = vec(this.x, val);\r\n    }\r\n  }\r\n\r\n  public get z(): number {\r\n    return this._transform.z ?? 0;\r\n  }\r\n\r\n  public set z(val: number) {\r\n    if (this._transform) {\r\n      this._transform.z = val;\r\n    }\r\n  }\r\n\r\n  public get rotation(): number {\r\n    return this._transform?.rotation ?? 0;\r\n  }\r\n\r\n  public set rotation(val: number) {\r\n    if (this._transform?.rotation) {\r\n      this._transform.rotation = val;\r\n    }\r\n  }\r\n\r\n  public get scale(): Vector {\r\n    return this._transform?.scale ?? Vector.One;\r\n  }\r\n\r\n  public set scale(val: Vector) {\r\n    if (this._transform?.scale) {\r\n      this._transform.scale = val;\r\n    }\r\n  }\r\n\r\n  public get pos(): Vector {\r\n    return this._transform.pos;\r\n  }\r\n\r\n  public set pos(val: Vector) {\r\n    this._transform.pos = val;\r\n  }\r\n\r\n  public get vel(): Vector {\r\n    return this._motion.vel;\r\n  }\r\n\r\n  public set vel(val: Vector) {\r\n    this._motion.vel = val;\r\n  }\r\n\r\n  public on(eventName: Events.preupdate, handler: (event: Events.PreUpdateEvent<TileMap>) => void): void;\r\n  public on(eventName: Events.postupdate, handler: (event: Events.PostUpdateEvent<TileMap>) => void): void;\r\n  public on(eventName: Events.predraw, handler: (event: Events.PreDrawEvent) => void): void;\r\n  public on(eventName: Events.postdraw, handler: (event: Events.PostDrawEvent) => void): void;\r\n  public on(eventName: string, handler: (event: Events.GameEvent<any>) => void): void;\r\n  public on(eventName: string, handler: (event: any) => void): void {\r\n    super.on(eventName, handler);\r\n  }\r\n\r\n\r\n  /**\r\n   * @param options\r\n   */\r\n  constructor(options: TileMapOptions) {\r\n    super(null, options.name);\r\n    this.addComponent(new TransformComponent());\r\n    this.addComponent(new MotionComponent());\r\n    this.addComponent(\r\n      new BodyComponent({\r\n        type: CollisionType.Fixed\r\n      })\r\n    );\r\n    this.addComponent(\r\n      new GraphicsComponent({\r\n        onPostDraw: (ctx, delta) => this.draw(ctx, delta)\r\n      })\r\n    );\r\n    this.addComponent(new DebugGraphicsComponent((ctx) => this.debug(ctx)));\r\n    this.addComponent(new ColliderComponent());\r\n    this._graphics = this.get(GraphicsComponent);\r\n    this._transform = this.get(TransformComponent);\r\n    this._motion = this.get(MotionComponent);\r\n    this._collider = this.get(ColliderComponent);\r\n    this._composite = this._collider.useCompositeCollider([]);\r\n\r\n    this._transform.pos = options.pos ?? Vector.Zero;\r\n    this._transform.posChanged$.subscribe(() => this.flagCollidersDirty());\r\n    this.tileWidth = options.tileWidth;\r\n    this.tileHeight = options.tileHeight;\r\n    this.rows = options.rows;\r\n    this.columns = options.columns;\r\n    this.tiles = new Array<Tile>(this.rows * this.columns);\r\n    this._rows = new Array(this.rows);\r\n    this._cols = new Array(this.columns);\r\n    let currentCol: Tile[] = [];\r\n    for (let i = 0; i < this.columns; i++) {\r\n      for (let j = 0; j < this.rows; j++) {\r\n        const cd = new Tile({\r\n          x: i,\r\n          y: j,\r\n          map: this\r\n        });\r\n        cd.map = this;\r\n        this.tiles[i + j * this.columns] = cd;\r\n        currentCol.push(cd);\r\n        if (!this._rows[j]) {\r\n          this._rows[j] = [];\r\n        }\r\n        this._rows[j].push(cd);\r\n      }\r\n      this._cols[i] = currentCol;\r\n      currentCol = [];\r\n    }\r\n\r\n    this._graphics.localBounds = new BoundingBox({\r\n      left: 0,\r\n      top: 0,\r\n      right: this.columns * this.tileWidth,\r\n      bottom: this.rows * this.tileHeight\r\n    });\r\n  }\r\n\r\n  public _initialize(engine: Engine) {\r\n    super._initialize(engine);\r\n  }\r\n\r\n\r\n  private _originalOffsets = new WeakMap<Collider, Vector>();\r\n  private _getOrSetColliderOriginalOffset(collider: Collider): Vector {\r\n    if (!this._originalOffsets.has(collider)) {\r\n      const originalOffset = collider.offset;\r\n      this._originalOffsets.set(collider, originalOffset);\r\n      return originalOffset;\r\n    } else {\r\n      return this._originalOffsets.get(collider);\r\n    }\r\n  }\r\n  /**\r\n   * Tiles colliders based on the solid tiles in the tilemap.\r\n   */\r\n  private _updateColliders(): void {\r\n    this._composite.clearColliders();\r\n    const colliders: BoundingBox[] = [];\r\n    this._composite = this._collider.useCompositeCollider([]);\r\n    let current: BoundingBox;\r\n    // Bad square tesselation algo\r\n    for (let i = 0; i < this.columns; i++) {\r\n      // Scan column for colliders\r\n      for (let j = 0; j < this.rows; j++) {\r\n        // Columns start with a new collider\r\n        if (j === 0) {\r\n          current = null;\r\n        }\r\n        const tile = this.tiles[i + j * this.columns];\r\n        // Current tile in column is solid build up current collider\r\n        if (tile.solid) {\r\n          // Use custom collider otherwise bounding box\r\n          if (tile.getColliders().length > 0) {\r\n            for (const collider of tile.getColliders()) {\r\n              const originalOffset = this._getOrSetColliderOriginalOffset(collider);\r\n              collider.offset = vec(tile.x * this.tileWidth, tile.y * this.tileHeight).add(originalOffset);\r\n              collider.owner = this;\r\n              this._composite.addCollider(collider);\r\n            }\r\n            current = null;\r\n          } else {\r\n            if (!current) {\r\n              current = tile.bounds;\r\n            } else {\r\n              current = current.combine(tile.bounds);\r\n            }\r\n          }\r\n        } else {\r\n          // Not solid skip and cut off the current collider\r\n          if (current) {\r\n            colliders.push(current);\r\n          }\r\n          current = null;\r\n        }\r\n      }\r\n      // After a column is complete check to see if it can be merged into the last one\r\n      if (current) {\r\n        // if previous is the same combine it\r\n        const prev = colliders[colliders.length - 1];\r\n        if (prev && prev.top === current.top && prev.bottom === current.bottom) {\r\n          colliders[colliders.length - 1] = prev.combine(current);\r\n        } else {\r\n          // else new collider\r\n          colliders.push(current);\r\n        }\r\n      }\r\n    }\r\n\r\n    for (const c of colliders) {\r\n      const collider = Shape.Box(c.width, c.height, Vector.Zero, vec(c.left - this.pos.x, c.top - this.pos.y));\r\n      collider.owner = this;\r\n      this._composite.addCollider(collider);\r\n    }\r\n    this._collider.update();\r\n  }\r\n\r\n  /**\r\n   * Returns the [[Tile]] by index (row major order)\r\n   */\r\n  public getTileByIndex(index: number): Tile {\r\n    return this.tiles[index];\r\n  }\r\n  /**\r\n   * Returns the [[Tile]] by its x and y integer coordinates\r\n   */\r\n  public getTile(x: number, y: number): Tile {\r\n    if (x < 0 || y < 0 || x >= this.columns || y >= this.rows) {\r\n      return null;\r\n    }\r\n    return this.tiles[x + y * this.columns];\r\n  }\r\n  /**\r\n   * Returns the [[Tile]] by testing a point in world coordinates,\r\n   * returns `null` if no Tile was found.\r\n   */\r\n  public getTileByPoint(point: Vector): Tile {\r\n    const x = Math.floor((point.x - this.pos.x) / this.tileWidth);\r\n    const y = Math.floor((point.y - this.pos.y) / this.tileHeight);\r\n    const tile = this.getTile(x, y);\r\n    if (x >= 0 && y >= 0 && x < this.columns && y < this.rows && tile) {\r\n      return tile;\r\n    }\r\n    return null;\r\n  }\r\n\r\n  public getRows(): readonly Tile[][] {\r\n    return this._rows;\r\n  }\r\n\r\n  public getColumns(): readonly Tile[][] {\r\n    return this._cols;\r\n  }\r\n\r\n  public update(engine: Engine, delta: number) {\r\n    this.onPreUpdate(engine, delta);\r\n    this.emit('preupdate', new Events.PreUpdateEvent(engine, delta, this));\r\n    if (this._collidersDirty) {\r\n      this._collidersDirty = false;\r\n      this._updateColliders();\r\n    }\r\n\r\n    this._token++;\r\n    const worldBounds = engine.getWorldBounds();\r\n    const worldCoordsUpperLeft = vec(worldBounds.left, worldBounds.top);\r\n    const worldCoordsLowerRight = vec(worldBounds.right, worldBounds.bottom);\r\n\r\n    let pos = this.pos;\r\n    const maybeParallax = this.get(ParallaxComponent);\r\n    let parallaxOffset = Vector.One;\r\n    if (maybeParallax) {\r\n      const oneMinusFactor = Vector.One.sub(maybeParallax.parallaxFactor);\r\n      parallaxOffset = engine.currentScene.camera.pos.scale(oneMinusFactor);\r\n      pos = pos.add(parallaxOffset);\r\n    }\r\n\r\n    this._onScreenXStart = Math.max(Math.floor((worldCoordsUpperLeft.x - pos.x) / this.tileWidth) - 2, 0);\r\n    this._onScreenYStart = Math.max(Math.floor((worldCoordsUpperLeft.y - pos.y) / this.tileHeight) - 2, 0);\r\n    this._onScreenXEnd = Math.max(Math.floor((worldCoordsLowerRight.x - pos.x) / this.tileWidth) + 2, 0);\r\n    this._onScreenYEnd = Math.max(Math.floor((worldCoordsLowerRight.y - pos.y) / this.tileHeight) + 2, 0);\r\n    // why are we resetting pos?\r\n    this._transform.pos = vec(this.x, this.y);\r\n\r\n    this.onPostUpdate(engine, delta);\r\n    this.emit('postupdate', new Events.PostUpdateEvent(engine, delta, this));\r\n  }\r\n\r\n  /**\r\n   * Draws the tile map to the screen. Called by the [[Scene]].\r\n   * @param ctx ExcaliburGraphicsContext\r\n   * @param delta  The number of milliseconds since the last draw\r\n   */\r\n  public draw(ctx: ExcaliburGraphicsContext, delta: number): void {\r\n    this.emit('predraw', new Events.PreDrawEvent(ctx as any, delta, this)); // TODO fix event\r\n\r\n    let x = this._onScreenXStart;\r\n    const xEnd = Math.min(this._onScreenXEnd, this.columns);\r\n    let y = this._onScreenYStart;\r\n    const yEnd = Math.min(this._onScreenYEnd, this.rows);\r\n\r\n    let graphics: readonly Graphic[], graphicsIndex: number, graphicsLen: number;\r\n\r\n    for (x; x < xEnd; x++) {\r\n      for (y; y < yEnd; y++) {\r\n        // get non-negative tile sprites\r\n        graphics = this.getTile(x, y).getGraphics();\r\n\r\n        for (graphicsIndex = 0, graphicsLen = graphics.length; graphicsIndex < graphicsLen; graphicsIndex++) {\r\n          // draw sprite, warning if sprite doesn't exist\r\n          const graphic = graphics[graphicsIndex];\r\n          if (graphic) {\r\n            if (hasGraphicsTick(graphic)) {\r\n              graphic?.tick(delta, this._token);\r\n            }\r\n            graphic.draw(ctx, x * this.tileWidth, y * this.tileHeight);\r\n          }\r\n        }\r\n      }\r\n      y = this._onScreenYStart;\r\n    }\r\n\r\n    this.emit('postdraw', new Events.PostDrawEvent(ctx as any, delta, this));\r\n  }\r\n\r\n  public debug(gfx: ExcaliburGraphicsContext) {\r\n    const width = this.tileWidth * this.columns;\r\n    const height = this.tileHeight * this.rows;\r\n    const pos = Vector.Zero;\r\n    for (let r = 0; r < this.rows + 1; r++) {\r\n      const yOffset = vec(0, r * this.tileHeight);\r\n      gfx.drawLine(pos.add(yOffset), pos.add(vec(width, yOffset.y)), Color.Red, 2);\r\n    }\r\n\r\n    for (let c = 0; c < this.columns + 1; c++) {\r\n      const xOffset = vec(c * this.tileWidth, 0);\r\n      gfx.drawLine(pos.add(xOffset), pos.add(vec(xOffset.x, height)), Color.Red, 2);\r\n    }\r\n\r\n    const colliders = this._composite.getColliders();\r\n    for (const collider of colliders) {\r\n      const grayish = Color.Gray;\r\n      grayish.a = 0.5;\r\n      const bounds = collider.localBounds;\r\n      const pos = collider.worldPos.sub(this.pos);\r\n      gfx.drawRectangle(pos, bounds.width, bounds.height, grayish);\r\n    }\r\n  }\r\n}\r\n\r\nexport interface TileOptions {\r\n  /**\r\n   * Integer tile x coordinate\r\n   */\r\n  x: number;\r\n  /**\r\n   * Integer tile y coordinate\r\n   */\r\n  y: number;\r\n  map: TileMap;\r\n  solid?: boolean;\r\n  graphics?: Graphic[];\r\n}\r\n\r\n/**\r\n * TileMap Tile\r\n *\r\n * A light-weight object that occupies a space in a collision map. Generally\r\n * created by a [[TileMap]].\r\n *\r\n * Tiles can draw multiple sprites. Note that the order of drawing is the order\r\n * of the sprites in the array so the last one will be drawn on top. You can\r\n * use transparency to create layers this way.\r\n */\r\nexport class Tile extends Entity {\r\n  private _bounds: BoundingBox;\r\n  private _pos: Vector;\r\n  private _posDirty = false;\r\n  private _transform: TransformComponent;\r\n\r\n  /**\r\n   * Return the world position of the top left corner of the tile\r\n   */\r\n  public get pos() {\r\n    if (this._posDirty) {\r\n      this._recalculate();\r\n      this._posDirty = false;\r\n    }\r\n    return this._pos;\r\n  }\r\n\r\n  /**\r\n   * Integer x coordinate of the tile\r\n   */\r\n  public readonly x: number;\r\n\r\n  /**\r\n   * Integer y coordinate of the tile\r\n   */\r\n  public readonly y: number;\r\n\r\n  /**\r\n   * Width of the tile in pixels\r\n   */\r\n  public readonly width: number;\r\n\r\n  /**\r\n   * Height of the tile in pixels\r\n   */\r\n  public readonly height: number;\r\n\r\n  /**\r\n   * Reference to the TileMap this tile is associated with\r\n   */\r\n  public map: TileMap;\r\n\r\n  private _solid = false;\r\n  /**\r\n   * Wether this tile should be treated as solid by the tilemap\r\n   */\r\n  public get solid(): boolean {\r\n    return this._solid;\r\n  }\r\n  /**\r\n   * Wether this tile should be treated as solid by the tilemap\r\n   */\r\n  public set solid(val: boolean) {\r\n    this.map?.flagCollidersDirty();\r\n    this._solid = val;\r\n  }\r\n\r\n  private _graphics: Graphic[] = [];\r\n\r\n  /**\r\n   * Current list of graphics for this tile\r\n   */\r\n  public getGraphics(): readonly Graphic[] {\r\n    return this._graphics;\r\n  }\r\n\r\n  /**\r\n   * Add another [[Graphic]] to this TileMap tile\r\n   * @param graphic\r\n   */\r\n  public addGraphic(graphic: Graphic) {\r\n    this._graphics.push(graphic);\r\n  }\r\n\r\n  /**\r\n   * Remove an instance of a [[Graphic]] from this tile\r\n   */\r\n  public removeGraphic(graphic: Graphic) {\r\n    removeItemFromArray(graphic, this._graphics);\r\n  }\r\n\r\n  /**\r\n   * Clear all graphics from this tile\r\n   */\r\n  public clearGraphics() {\r\n    this._graphics.length = 0;\r\n  }\r\n\r\n  /**\r\n   * Current list of colliders for this tile\r\n   */\r\n  private _colliders: Collider[] = [];\r\n\r\n  /**\r\n   * Returns the list of colliders\r\n   */\r\n  public getColliders(): readonly Collider[] {\r\n    return this._colliders;\r\n  }\r\n\r\n  /**\r\n   * Adds a custom collider to the [[Tile]] to use instead of it's bounds\r\n   *\r\n   * If no collider is set but [[Tile.solid]] is set, the tile bounds are used as a collider.\r\n   *\r\n   * **Note!** the [[Tile.solid]] must be set to true for it to act as a \"fixed\" collider\r\n   * @param collider\r\n   */\r\n  public addCollider(collider: Collider) {\r\n    this._colliders.push(collider);\r\n    this.map.flagCollidersDirty();\r\n  }\r\n\r\n  /**\r\n   * Removes a collider from the [[Tile]]\r\n   * @param collider\r\n   */\r\n  public removeCollider(collider: Collider) {\r\n    const index = this._colliders.indexOf(collider);\r\n    if (index > -1) {\r\n      this._colliders.splice(index, 1);\r\n    }\r\n    this.map.flagCollidersDirty();\r\n  }\r\n\r\n  /**\r\n   * Clears all colliders from the [[Tile]]\r\n   */\r\n  public clearColliders() {\r\n    this._colliders.length = 0;\r\n    this.map.flagCollidersDirty();\r\n  }\r\n\r\n  /**\r\n   * Arbitrary data storage per tile, useful for any game specific data\r\n   */\r\n  public data = new Map<string, any>();\r\n\r\n  constructor(options: TileOptions) {\r\n    super();\r\n    this.x = options.x;\r\n    this.y = options.y;\r\n    this.map = options.map;\r\n    this.width = options.map.tileWidth;\r\n    this.height = options.map.tileHeight;\r\n    this.solid = options.solid ?? this.solid;\r\n    this._graphics = options.graphics ?? [];\r\n    this._recalculate();\r\n    this._transform = options.map.get(TransformComponent);\r\n    this._transform.posChanged$.subscribe(() => {\r\n      this._posDirty = true;\r\n    });\r\n  }\r\n\r\n  private _recalculate() {\r\n    this._pos = this.map.pos.add(\r\n      vec(\r\n        this.x * this.map.tileWidth,\r\n        this.y * this.map.tileHeight));\r\n    this._bounds = new BoundingBox(this._pos.x, this._pos.y, this._pos.x + this.width, this._pos.y + this.height);\r\n  }\r\n\r\n  public get bounds() {\r\n    if (this._posDirty) {\r\n      this._recalculate();\r\n      this._posDirty = false;\r\n    }\r\n    return this._bounds;\r\n  }\r\n\r\n  public get center(): Vector {\r\n    return new Vector(this._pos.x + this.width / 2, this._pos.y + this.height / 2);\r\n  }\r\n}","import { Engine } from './Engine';\r\nimport { Screen } from './Screen';\r\nimport { EasingFunction, EasingFunctions } from './Util/EasingFunctions';\r\nimport { Vector, vec } from './Math/vector';\r\nimport { Actor } from './Actor';\r\nimport { removeItemFromArray } from './Util/Util';\r\nimport { CanUpdate, CanInitialize } from './Interfaces/LifecycleEvents';\r\nimport { PreUpdateEvent, PostUpdateEvent, GameEvent, InitializeEvent } from './Events';\r\nimport { Class } from './Class';\r\nimport { BoundingBox } from './Collision/BoundingBox';\r\nimport { Logger } from './Util/Log';\r\nimport { ExcaliburGraphicsContext } from './Graphics/Context/ExcaliburGraphicsContext';\r\nimport { watchAny } from './Util/Watch';\r\nimport { Matrix } from './Math/matrix';\r\n\r\n/**\r\n * Interface that describes a custom camera strategy for tracking targets\r\n */\r\nexport interface CameraStrategy<T> {\r\n  /**\r\n   * Target of the camera strategy that will be passed to the action\r\n   */\r\n  target: T;\r\n\r\n  /**\r\n   * Camera strategies perform an action to calculate a new focus returned out of the strategy\r\n   * @param target The target object to apply this camera strategy (if any)\r\n   * @param camera The current camera implementation in excalibur running the game\r\n   * @param engine The current engine running the game\r\n   * @param delta The elapsed time in milliseconds since the last frame\r\n   */\r\n  action: (target: T, camera: Camera, engine: Engine, delta: number) => Vector;\r\n}\r\n\r\n/**\r\n * Container to house convenience strategy methods\r\n * @internal\r\n */\r\nexport class StrategyContainer {\r\n  constructor(public camera: Camera) {}\r\n\r\n  /**\r\n   * Creates and adds the [[LockCameraToActorStrategy]] on the current camera.\r\n   * @param actor The actor to lock the camera to\r\n   */\r\n  public lockToActor(actor: Actor) {\r\n    this.camera.addStrategy(new LockCameraToActorStrategy(actor));\r\n  }\r\n\r\n  /**\r\n   * Creates and adds the [[LockCameraToActorAxisStrategy]] on the current camera\r\n   * @param actor The actor to lock the camera to\r\n   * @param axis The axis to follow the actor on\r\n   */\r\n  public lockToActorAxis(actor: Actor, axis: Axis) {\r\n    this.camera.addStrategy(new LockCameraToActorAxisStrategy(actor, axis));\r\n  }\r\n\r\n  /**\r\n   * Creates and adds the [[ElasticToActorStrategy]] on the current camera\r\n   * If cameraElasticity < cameraFriction < 1.0, the behavior will be a dampened spring that will slowly end at the target without bouncing\r\n   * If cameraFriction < cameraElasticity < 1.0, the behavior will be an oscillating spring that will over\r\n   * correct and bounce around the target\r\n   *\r\n   * @param actor Target actor to elastically follow\r\n   * @param cameraElasticity [0 - 1.0] The higher the elasticity the more force that will drive the camera towards the target\r\n   * @param cameraFriction [0 - 1.0] The higher the friction the more that the camera will resist motion towards the target\r\n   */\r\n  public elasticToActor(actor: Actor, cameraElasticity: number, cameraFriction: number) {\r\n    this.camera.addStrategy(new ElasticToActorStrategy(actor, cameraElasticity, cameraFriction));\r\n  }\r\n\r\n  /**\r\n   * Creates and adds the [[RadiusAroundActorStrategy]] on the current camera\r\n   * @param actor Target actor to follow when it is \"radius\" pixels away\r\n   * @param radius Number of pixels away before the camera will follow\r\n   */\r\n  public radiusAroundActor(actor: Actor, radius: number) {\r\n    this.camera.addStrategy(new RadiusAroundActorStrategy(actor, radius));\r\n  }\r\n\r\n  /**\r\n   * Creates and adds the [[LimitCameraBoundsStrategy]] on the current camera\r\n   * @param box The bounding box to limit the camera to.\r\n   */\r\n  public limitCameraBounds(box: BoundingBox) {\r\n    this.camera.addStrategy(new LimitCameraBoundsStrategy(box));\r\n  }\r\n}\r\n\r\n/**\r\n * Camera axis enum\r\n */\r\nexport enum Axis {\r\n  X,\r\n  Y\r\n}\r\n\r\n/**\r\n * Lock a camera to the exact x/y position of an actor.\r\n */\r\nexport class LockCameraToActorStrategy implements CameraStrategy<Actor> {\r\n  constructor(public target: Actor) {}\r\n  public action = (target: Actor, _cam: Camera, _eng: Engine, _delta: number) => {\r\n    const center = target.center;\r\n    return center;\r\n  };\r\n}\r\n\r\n/**\r\n * Lock a camera to a specific axis around an actor.\r\n */\r\nexport class LockCameraToActorAxisStrategy implements CameraStrategy<Actor> {\r\n  constructor(public target: Actor, public axis: Axis) {}\r\n  public action = (target: Actor, cam: Camera, _eng: Engine, _delta: number) => {\r\n    const center = target.center;\r\n    const currentFocus = cam.getFocus();\r\n    if (this.axis === Axis.X) {\r\n      return new Vector(center.x, currentFocus.y);\r\n    } else {\r\n      return new Vector(currentFocus.x, center.y);\r\n    }\r\n  };\r\n}\r\n\r\n/**\r\n * Using [Hook's law](https://en.wikipedia.org/wiki/Hooke's_law), elastically move the camera towards the target actor.\r\n */\r\nexport class ElasticToActorStrategy implements CameraStrategy<Actor> {\r\n  /**\r\n   * If cameraElasticity < cameraFriction < 1.0, the behavior will be a dampened spring that will slowly end at the target without bouncing\r\n   * If cameraFriction < cameraElasticity < 1.0, the behavior will be an oscillating spring that will over\r\n   * correct and bounce around the target\r\n   *\r\n   * @param target Target actor to elastically follow\r\n   * @param cameraElasticity [0 - 1.0] The higher the elasticity the more force that will drive the camera towards the target\r\n   * @param cameraFriction [0 - 1.0] The higher the friction the more that the camera will resist motion towards the target\r\n   */\r\n  constructor(public target: Actor, public cameraElasticity: number, public cameraFriction: number) {}\r\n  public action = (target: Actor, cam: Camera, _eng: Engine, _delta: number) => {\r\n    const position = target.center;\r\n    let focus = cam.getFocus();\r\n    let cameraVel = cam.vel.clone();\r\n\r\n    // Calculate the stretch vector, using the spring equation\r\n    // F = kX\r\n    // https://en.wikipedia.org/wiki/Hooke's_law\r\n    // Apply to the current camera velocity\r\n    const stretch = position.sub(focus).scale(this.cameraElasticity); // stretch is X\r\n    cameraVel = cameraVel.add(stretch);\r\n\r\n    // Calculate the friction (-1 to apply a force in the opposition of motion)\r\n    // Apply to the current camera velocity\r\n    const friction = cameraVel.scale(-1).scale(this.cameraFriction);\r\n    cameraVel = cameraVel.add(friction);\r\n\r\n    // Update position by velocity deltas\r\n    focus = focus.add(cameraVel);\r\n\r\n    return focus;\r\n  };\r\n}\r\n\r\nexport class RadiusAroundActorStrategy implements CameraStrategy<Actor> {\r\n  /**\r\n   *\r\n   * @param target Target actor to follow when it is \"radius\" pixels away\r\n   * @param radius Number of pixels away before the camera will follow\r\n   */\r\n  constructor(public target: Actor, public radius: number) {}\r\n  public action = (target: Actor, cam: Camera, _eng: Engine, _delta: number) => {\r\n    const position = target.center;\r\n    const focus = cam.getFocus();\r\n\r\n    const direction = position.sub(focus);\r\n    const distance = direction.size;\r\n    if (distance >= this.radius) {\r\n      const offset = distance - this.radius;\r\n      return focus.add(direction.normalize().scale(offset));\r\n    }\r\n    return focus;\r\n  };\r\n}\r\n\r\n/**\r\n * Prevent a camera from going beyond the given camera dimensions.\r\n */\r\nexport class LimitCameraBoundsStrategy implements CameraStrategy<BoundingBox> {\r\n  /**\r\n   * Useful for limiting the camera to a [[TileMap]]'s dimensions, or a specific area inside the map.\r\n   *\r\n   * Note that this strategy does not perform any movement by itself.\r\n   * It only sets the camera position to within the given bounds when the camera has gone beyond them.\r\n   * Thus, it is a good idea to combine it with other camera strategies and set this strategy as the last one.\r\n   *\r\n   * Make sure that the camera bounds are at least as large as the viewport size.\r\n   *\r\n   * @param target The bounding box to limit the camera to\r\n   */\r\n\r\n  boundSizeChecked: boolean = false; // Check and warn only once\r\n\r\n  constructor(public target: BoundingBox) {}\r\n\r\n  public action = (target: BoundingBox, cam: Camera, _eng: Engine, _delta: number) => {\r\n    const focus = cam.getFocus();\r\n\r\n    if (!this.boundSizeChecked) {\r\n      if (target.bottom - target.top < _eng.drawHeight || target.right - target.left < _eng.drawWidth) {\r\n        Logger.getInstance().warn('Camera bounds should not be smaller than the engine viewport');\r\n      }\r\n      this.boundSizeChecked = true;\r\n    }\r\n\r\n    let focusX = focus.x;\r\n    let focusY = focus.y;\r\n    if (focus.x < target.left + _eng.halfDrawWidth) {\r\n      focusX = target.left + _eng.halfDrawWidth;\r\n    } else if (focus.x > target.right - _eng.halfDrawWidth) {\r\n      focusX = target.right - _eng.halfDrawWidth;\r\n    }\r\n\r\n    if (focus.y < target.top + _eng.halfDrawHeight) {\r\n      focusY = target.top + _eng.halfDrawHeight;\r\n    } else if (focus.y > target.bottom - _eng.halfDrawHeight) {\r\n      focusY = target.bottom - _eng.halfDrawHeight;\r\n    }\r\n\r\n    return vec(focusX, focusY);\r\n  };\r\n}\r\n\r\n/**\r\n * Cameras\r\n *\r\n * [[Camera]] is the base class for all Excalibur cameras. Cameras are used\r\n * to move around your game and set focus. They are used to determine\r\n * what is \"off screen\" and can be used to scale the game.\r\n *\r\n */\r\nexport class Camera extends Class implements CanUpdate, CanInitialize {\r\n  public transform: Matrix = Matrix.identity();\r\n  public inverse: Matrix = Matrix.identity();\r\n\r\n\r\n  protected _follow: Actor;\r\n\r\n  private _cameraStrategies: CameraStrategy<any>[] = [];\r\n\r\n  public strategy: StrategyContainer = new StrategyContainer(this);\r\n\r\n  /**\r\n   * Get or set current zoom of the camera, defaults to 1\r\n   */\r\n  private _z = 1;\r\n  public get zoom(): number {\r\n    return this._z;\r\n  }\r\n\r\n  public set zoom(val: number) {\r\n    this._z = val;\r\n    if (this._engine) {\r\n      this._halfWidth = this._engine.halfDrawWidth;\r\n      this._halfHeight = this._engine.halfDrawHeight;\r\n    }\r\n  }\r\n  /**\r\n   * Get or set rate of change in zoom, defaults to 0\r\n   */\r\n  public dz: number = 0;\r\n  /**\r\n   * Get or set zoom acceleration\r\n   */\r\n  public az: number = 0;\r\n\r\n  /**\r\n   * Current rotation of the camera\r\n   */\r\n  public rotation: number = 0;\r\n\r\n  private _angularVelocity: number = 0;\r\n\r\n  /**\r\n   * Get or set the camera's angular velocity\r\n   */\r\n  public get angularVelocity(): number {\r\n    return this._angularVelocity;\r\n  }\r\n\r\n  public set angularVelocity(value: number) {\r\n    this._angularVelocity = value;\r\n  }\r\n\r\n  /**\r\n   * Get or set the camera's position\r\n   */\r\n  private _posChanged = false;\r\n  private _pos: Vector = watchAny(Vector.Zero, () => (this._posChanged = true));\r\n  public get pos(): Vector {\r\n    return this._pos;\r\n  }\r\n  public set pos(vec: Vector) {\r\n    this._pos = watchAny(vec, () => (this._posChanged = true));\r\n    this._posChanged = true;\r\n  }\r\n\r\n  /**\r\n   * Get or set the camera's velocity\r\n   */\r\n  public vel: Vector = Vector.Zero;\r\n\r\n  /**\r\n   * Get or set the camera's acceleration\r\n   */\r\n  public acc: Vector = Vector.Zero;\r\n\r\n  private _cameraMoving: boolean = false;\r\n  private _currentLerpTime: number = 0;\r\n  private _lerpDuration: number = 1000; // 1 second\r\n  private _lerpStart: Vector = null;\r\n  private _lerpEnd: Vector = null;\r\n  private _lerpResolve: (value: Vector) => void;\r\n  private _lerpPromise: Promise<Vector>;\r\n\r\n  //camera effects\r\n  protected _isShaking: boolean = false;\r\n  private _shakeMagnitudeX: number = 0;\r\n  private _shakeMagnitudeY: number = 0;\r\n  private _shakeDuration: number = 0;\r\n  private _elapsedShakeTime: number = 0;\r\n  private _xShake: number = 0;\r\n  private _yShake: number = 0;\r\n\r\n  protected _isZooming: boolean = false;\r\n  private _zoomStart: number = 1;\r\n  private _zoomEnd: number = 1;\r\n  private _currentZoomTime: number = 0;\r\n  private _zoomDuration: number = 0;\r\n\r\n  private _zoomResolve: (val: boolean) => void;\r\n  private _zoomPromise: Promise<boolean>;\r\n  private _zoomEasing: EasingFunction = EasingFunctions.EaseInOutCubic;\r\n  private _easing: EasingFunction = EasingFunctions.EaseInOutCubic;\r\n\r\n  private _halfWidth: number = 0;\r\n  private _halfHeight: number = 0;\r\n\r\n  /**\r\n   * Get the camera's x position\r\n   */\r\n  public get x() {\r\n    return this.pos.x;\r\n  }\r\n\r\n  /**\r\n   * Set the camera's x position (cannot be set when following an [[Actor]] or when moving)\r\n   */\r\n  public set x(value: number) {\r\n    if (!this._follow && !this._cameraMoving) {\r\n      this.pos = vec(value, this.pos.y);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get the camera's y position\r\n   */\r\n  public get y() {\r\n    return this.pos.y;\r\n  }\r\n\r\n  /**\r\n   * Set the camera's y position (cannot be set when following an [[Actor]] or when moving)\r\n   */\r\n  public set y(value: number) {\r\n    if (!this._follow && !this._cameraMoving) {\r\n      this.pos = vec(this.pos.x, value);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get or set the camera's x velocity\r\n   */\r\n  public get dx() {\r\n    return this.vel.x;\r\n  }\r\n\r\n  public set dx(value: number) {\r\n    this.vel = vec(value, this.vel.y);\r\n  }\r\n\r\n  /**\r\n   * Get or set the camera's y velocity\r\n   */\r\n  public get dy() {\r\n    return this.vel.y;\r\n  }\r\n\r\n  public set dy(value: number) {\r\n    this.vel = vec(this.vel.x, value);\r\n  }\r\n\r\n  /**\r\n   * Get or set the camera's x acceleration\r\n   */\r\n  public get ax() {\r\n    return this.acc.x;\r\n  }\r\n\r\n  public set ax(value: number) {\r\n    this.acc = vec(value, this.acc.y);\r\n  }\r\n\r\n  /**\r\n   * Get or set the camera's y acceleration\r\n   */\r\n  public get ay() {\r\n    return this.acc.y;\r\n  }\r\n\r\n  public set ay(value: number) {\r\n    this.acc = vec(this.acc.x, value);\r\n  }\r\n\r\n  /**\r\n   * Returns the focal point of the camera, a new point giving the x and y position of the camera\r\n   */\r\n  public getFocus() {\r\n    return this.pos;\r\n  }\r\n\r\n  /**\r\n   * This moves the camera focal point to the specified position using specified easing function. Cannot move when following an Actor.\r\n   *\r\n   * @param pos The target position to move to\r\n   * @param duration The duration in milliseconds the move should last\r\n   * @param [easingFn] An optional easing function ([[ex.EasingFunctions.EaseInOutCubic]] by default)\r\n   * @returns A [[Promise]] that resolves when movement is finished, including if it's interrupted.\r\n   *          The [[Promise]] value is the [[Vector]] of the target position. It will be rejected if a move cannot be made.\r\n   */\r\n  public move(pos: Vector, duration: number, easingFn: EasingFunction = EasingFunctions.EaseInOutCubic): Promise<Vector> {\r\n    if (typeof easingFn !== 'function') {\r\n      throw 'Please specify an EasingFunction';\r\n    }\r\n\r\n    // cannot move when following an actor\r\n    if (this._follow) {\r\n      return Promise.reject(pos);\r\n    }\r\n\r\n    // resolve existing promise, if any\r\n    if (this._lerpPromise && this._lerpResolve) {\r\n      this._lerpResolve(pos);\r\n    }\r\n\r\n    this._lerpPromise = new Promise<Vector>((resolve) => {\r\n      this._lerpResolve = resolve;\r\n    });\r\n    this._lerpStart = this.getFocus().clone();\r\n    this._lerpDuration = duration;\r\n    this._lerpEnd = pos;\r\n    this._currentLerpTime = 0;\r\n    this._cameraMoving = true;\r\n    this._easing = easingFn;\r\n\r\n    return this._lerpPromise;\r\n  }\r\n\r\n  /**\r\n   * Sets the camera to shake at the specified magnitudes for the specified duration\r\n   * @param magnitudeX  The x magnitude of the shake\r\n   * @param magnitudeY  The y magnitude of the shake\r\n   * @param duration    The duration of the shake in milliseconds\r\n   */\r\n  public shake(magnitudeX: number, magnitudeY: number, duration: number) {\r\n    this._isShaking = true;\r\n    this._shakeMagnitudeX = magnitudeX;\r\n    this._shakeMagnitudeY = magnitudeY;\r\n    this._shakeDuration = duration;\r\n  }\r\n\r\n  /**\r\n   * Zooms the camera in or out by the specified scale over the specified duration.\r\n   * If no duration is specified, it take effect immediately.\r\n   * @param scale    The scale of the zoom\r\n   * @param duration The duration of the zoom in milliseconds\r\n   */\r\n  public zoomOverTime(scale: number, duration: number = 0, easingFn: EasingFunction = EasingFunctions.EaseInOutCubic): Promise<boolean> {\r\n    this._zoomPromise = new Promise<boolean>((resolve) => {\r\n      this._zoomResolve = resolve;\r\n    });\r\n\r\n    if (duration) {\r\n      this._isZooming = true;\r\n      this._zoomEasing = easingFn;\r\n      this._currentZoomTime = 0;\r\n      this._zoomDuration = duration;\r\n      this._zoomStart = this.zoom;\r\n      this._zoomEnd = scale;\r\n    } else {\r\n      this._isZooming = false;\r\n      this.zoom = scale;\r\n      return Promise.resolve(true);\r\n    }\r\n\r\n    return this._zoomPromise;\r\n  }\r\n\r\n  private _viewport: BoundingBox = null;\r\n  /**\r\n   * Gets the bounding box of the viewport of this camera in world coordinates\r\n   */\r\n  public get viewport(): BoundingBox {\r\n    if (this._viewport) {\r\n      return this._viewport;\r\n    }\r\n\r\n    return new BoundingBox(0, 0, 0, 0);\r\n  }\r\n\r\n  /**\r\n   * Adds a new camera strategy to this camera\r\n   * @param cameraStrategy Instance of an [[CameraStrategy]]\r\n   */\r\n  public addStrategy<T>(cameraStrategy: CameraStrategy<T>) {\r\n    this._cameraStrategies.push(cameraStrategy);\r\n  }\r\n\r\n  /**\r\n   * Removes a camera strategy by reference\r\n   * @param cameraStrategy Instance of an [[CameraStrategy]]\r\n   */\r\n  public removeStrategy<T>(cameraStrategy: CameraStrategy<T>) {\r\n    removeItemFromArray(cameraStrategy, this._cameraStrategies);\r\n  }\r\n\r\n  /**\r\n   * Clears all camera strategies from the camera\r\n   */\r\n  public clearAllStrategies() {\r\n    this._cameraStrategies.length = 0;\r\n  }\r\n\r\n  /**\r\n   * It is not recommended that internal excalibur methods be overridden, do so at your own risk.\r\n   *\r\n   * Internal _preupdate handler for [[onPreUpdate]] lifecycle event\r\n   * @internal\r\n   */\r\n  public _preupdate(engine: Engine, delta: number): void {\r\n    this.emit('preupdate', new PreUpdateEvent(engine, delta, this));\r\n    this.onPreUpdate(engine, delta);\r\n  }\r\n\r\n  /**\r\n   * Safe to override onPreUpdate lifecycle event handler. Synonymous with `.on('preupdate', (evt) =>{...})`\r\n   *\r\n   * `onPreUpdate` is called directly before a scene is updated.\r\n   */\r\n  public onPreUpdate(_engine: Engine, _delta: number): void {\r\n    // Overridable\r\n  }\r\n\r\n  /**\r\n   *  It is not recommended that internal excalibur methods be overridden, do so at your own risk.\r\n   *\r\n   * Internal _preupdate handler for [[onPostUpdate]] lifecycle event\r\n   * @internal\r\n   */\r\n  public _postupdate(engine: Engine, delta: number): void {\r\n    this.emit('postupdate', new PostUpdateEvent(engine, delta, this));\r\n    this.onPostUpdate(engine, delta);\r\n  }\r\n\r\n  /**\r\n   * Safe to override onPostUpdate lifecycle event handler. Synonymous with `.on('preupdate', (evt) =>{...})`\r\n   *\r\n   * `onPostUpdate` is called directly after a scene is updated.\r\n   */\r\n  public onPostUpdate(_engine: Engine, _delta: number): void {\r\n    // Overridable\r\n  }\r\n\r\n  private _engine: Engine;\r\n  private _screen: Screen;\r\n  private _isInitialized = false;\r\n  public get isInitialized() {\r\n    return this._isInitialized;\r\n  }\r\n\r\n  public _initialize(_engine: Engine) {\r\n    if (!this.isInitialized) {\r\n      this._engine = _engine;\r\n      this._screen = _engine.screen;\r\n\r\n      const currentRes = this._screen.resolution;\r\n      let center = vec(currentRes.width / 2, currentRes.height / 2);\r\n      if (!this._engine.loadingComplete) {\r\n        // If there was a loading screen, we peek the configured resolution\r\n        const res = this._screen.peekResolution();\r\n        if (res) {\r\n          center = vec(res.width / 2, res.height / 2);\r\n        }\r\n      }\r\n      this._halfWidth = center.x;\r\n      this._halfHeight = center.y;\r\n\r\n      // If the user has not set the camera pos, apply default center screen position\r\n      if (!this._posChanged) {\r\n        this.pos = center;\r\n      }\r\n      // First frame bootstrap\r\n\r\n      // Ensure camera tx is correct\r\n      // Run update twice to ensure properties are init'd\r\n      this.updateTransform();\r\n\r\n      // Run strategies for first frame\r\n      this.runStrategies(_engine, _engine.clock.elapsed());\r\n\r\n      // Setup the first frame viewport\r\n      this.updateViewport();\r\n\r\n      // It's important to update the camera after strategies\r\n      // This prevents jitter\r\n      this.updateTransform();\r\n\r\n      this.onInitialize(_engine);\r\n      super.emit('initialize', new InitializeEvent(_engine, this));\r\n      this._isInitialized = true;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Safe to override onPostUpdate lifecycle event handler. Synonymous with `.on('preupdate', (evt) =>{...})`\r\n   *\r\n   * `onPostUpdate` is called directly after a scene is updated.\r\n   */\r\n  public onInitialize(_engine: Engine) {\r\n    // Overridable\r\n  }\r\n\r\n  public on(eventName: 'initialize', handler: (event: InitializeEvent) => void): void;\r\n  public on(eventName: 'preupdate', handler: (event: PreUpdateEvent) => void): void;\r\n  public on(eventName: 'postupdate', handler: (event: PostUpdateEvent) => void): void;\r\n  public on(eventName: any, handler: any) {\r\n    super.on(eventName, handler);\r\n  }\r\n\r\n  public off(eventName: 'initialize', handler?: (event: InitializeEvent) => void): void;\r\n  public off(eventName: 'preupdate', handler?: (event: PreUpdateEvent) => void): void;\r\n  public off(eventName: 'postupdate', handler?: (event: PostUpdateEvent) => void): void;\r\n  public off(eventName: string, handler: (event: GameEvent<Camera>) => void): void;\r\n  public off(eventName: string, handler: (event: any) => void): void {\r\n    super.off(eventName, handler);\r\n  }\r\n\r\n  public once(eventName: 'initialize', handler: (event: InitializeEvent) => void): void;\r\n  public once(eventName: 'preupdate', handler: (event: PreUpdateEvent) => void): void;\r\n  public once(eventName: 'postupdate', handler: (event: PostUpdateEvent) => void): void;\r\n  public once(eventName: string, handler: (event: GameEvent<Camera>) => void): void;\r\n  public once(eventName: string, handler: (event: any) => void): void {\r\n    super.once(eventName, handler);\r\n  }\r\n\r\n  public runStrategies(engine: Engine, delta: number) {\r\n    for (const s of this._cameraStrategies) {\r\n      this.pos = s.action.call(s, s.target, this, engine, delta);\r\n    }\r\n  }\r\n\r\n  public updateViewport() {\r\n    // recalc viewport\r\n    this._viewport = new BoundingBox(\r\n      this.x - this._halfWidth,\r\n      this.y - this._halfHeight,\r\n      this.x + this._halfWidth,\r\n      this.y + this._halfHeight\r\n    );\r\n  }\r\n\r\n  public update(_engine: Engine, delta: number) {\r\n    this._initialize(_engine);\r\n    this._preupdate(_engine, delta);\r\n\r\n    // Update placements based on linear algebra\r\n    this.pos = this.pos.add(this.vel.scale(delta / 1000));\r\n    this.zoom += (this.dz * delta) / 1000;\r\n\r\n    this.vel = this.vel.add(this.acc.scale(delta / 1000));\r\n    this.dz += (this.az * delta) / 1000;\r\n\r\n    this.rotation += (this.angularVelocity * delta) / 1000;\r\n\r\n    if (this._isZooming) {\r\n      if (this._currentZoomTime < this._zoomDuration) {\r\n        const zoomEasing = this._zoomEasing;\r\n        const newZoom = zoomEasing(this._currentZoomTime, this._zoomStart, this._zoomEnd, this._zoomDuration);\r\n\r\n        this.zoom = newZoom;\r\n        this._currentZoomTime += delta;\r\n      } else {\r\n        this._isZooming = false;\r\n        this.zoom = this._zoomEnd;\r\n        this._currentZoomTime = 0;\r\n        this._zoomResolve(true);\r\n      }\r\n    }\r\n\r\n    if (this._cameraMoving) {\r\n      if (this._currentLerpTime < this._lerpDuration) {\r\n        const moveEasing = EasingFunctions.CreateVectorEasingFunction(this._easing);\r\n\r\n        const lerpPoint = moveEasing(this._currentLerpTime, this._lerpStart, this._lerpEnd, this._lerpDuration);\r\n\r\n        this.pos = lerpPoint;\r\n\r\n        this._currentLerpTime += delta;\r\n      } else {\r\n        this.pos = this._lerpEnd;\r\n        const end = this._lerpEnd.clone();\r\n\r\n        this._lerpStart = null;\r\n        this._lerpEnd = null;\r\n        this._currentLerpTime = 0;\r\n        this._cameraMoving = false;\r\n        // Order matters here, resolve should be last so any chain promises have a clean slate\r\n        this._lerpResolve(end);\r\n      }\r\n    }\r\n\r\n    if (this._isDoneShaking()) {\r\n      this._isShaking = false;\r\n      this._elapsedShakeTime = 0;\r\n      this._shakeMagnitudeX = 0;\r\n      this._shakeMagnitudeY = 0;\r\n      this._shakeDuration = 0;\r\n      this._xShake = 0;\r\n      this._yShake = 0;\r\n    } else {\r\n      this._elapsedShakeTime += delta;\r\n      this._xShake = ((Math.random() * this._shakeMagnitudeX) | 0) + 1;\r\n      this._yShake = ((Math.random() * this._shakeMagnitudeY) | 0) + 1;\r\n    }\r\n\r\n    this.runStrategies(_engine, delta);\r\n\r\n    this.updateViewport();\r\n\r\n    // It's important to update the camera after strategies\r\n    // This prevents jitter\r\n    this.updateTransform();\r\n\r\n    this._postupdate(_engine, delta);\r\n  }\r\n\r\n  /**\r\n   * Applies the relevant transformations to the game canvas to \"move\" or apply effects to the Camera\r\n   * @param ctx Canvas context to apply transformations\r\n   */\r\n  public draw(ctx: ExcaliburGraphicsContext): void {\r\n    ctx.multiply(this.transform);\r\n  }\r\n\r\n  public updateTransform() {\r\n    // center the camera\r\n    const newCanvasWidth = this._screen.resolution.width / this.zoom;\r\n    const newCanvasHeight = this._screen.resolution.height / this.zoom;\r\n    const cameraPos = vec(-this.x + newCanvasWidth / 2 + this._xShake, -this.y + newCanvasHeight / 2 + this._yShake);\r\n\r\n    // Calculate camera transform\r\n    this.transform.reset();\r\n    this.transform.scale(this.zoom, this.zoom);\r\n    this.transform.translate(cameraPos.x, cameraPos.y);\r\n    this.transform.getAffineInverse(this.inverse);\r\n  }\r\n\r\n  private _isDoneShaking(): boolean {\r\n    return !this._isShaking || this._elapsedShakeTime >= this._shakeDuration;\r\n  }\r\n}\r\n","import { Entity } from './Entity';\r\nimport { Message, Observer } from '../Util/Observable';\r\nimport { Component } from './Component';\r\nimport { Scene } from '../Scene';\r\n\r\n/**\r\n * Enum that determines whether to run the system in the update or draw phase\r\n */\r\nexport enum SystemType {\r\n  Update = 'update',\r\n  Draw = 'draw'\r\n}\r\n\r\nexport type SystemTypes<ComponentTypes> = ComponentTypes extends Component<infer TypeName> ? TypeName : never;\r\n\r\n/**\r\n * An Excalibur [[System]] that updates entities of certain types.\r\n * Systems are scene specific\r\n *\r\n * Excalibur Systems currently require at least 1 Component type to operated\r\n *\r\n * Multiple types are declared as a type union\r\n * For example:\r\n *\r\n * ```typescript\r\n * class MySystem extends System<ComponentA | ComponentB> {\r\n *   public readonly types = ['a', 'b'] as const;\r\n *   public readonly systemType = SystemType.Update;\r\n *   public update(entities: Entity<ComponentA | ComponentB>) {\r\n *      ...\r\n *   }\r\n * }\r\n * ```\r\n */\r\nexport abstract class System<ComponentTypeUnion extends Component = Component, ContextType = Scene>\r\nimplements Observer<AddedEntity | RemovedEntity> {\r\n  /**\r\n   * The types of entities that this system operates on\r\n   * For example ['transform', 'motion']\r\n   */\r\n  abstract readonly types: readonly SystemTypes<ComponentTypeUnion>[];\r\n\r\n  /**\r\n   * Determine whether the system is called in the [[SystemType.Update]] or the [[SystemType.Draw]] phase. Update is first, then Draw.\r\n   */\r\n  abstract readonly systemType: SystemType;\r\n\r\n  /**\r\n   * System can execute in priority order, by default all systems are priority 0. Lower values indicated higher priority.\r\n   * For a system to execute before all other a lower priority value (-1 for example) must be set.\r\n   * For a system to execute after all other a higher priority value (10 for example) must be set.\r\n   */\r\n  public priority: number = 0;\r\n\r\n  /**\r\n   * Optionally specify a sort order for entities passed to the your system\r\n   * @param a The left entity\r\n   * @param b The right entity\r\n   */\r\n  sort?(a: Entity, b: Entity): number;\r\n\r\n  /**\r\n   * Optionally specify an initialize handler\r\n   * @param scene\r\n   */\r\n  initialize?(engine: ContextType): void;\r\n\r\n  /**\r\n   * Update all entities that match this system's types\r\n   * @param entities Entities to update that match this system's types\r\n   * @param delta Time in milliseconds\r\n   */\r\n  abstract update(entities: Entity[], delta: number): void;\r\n\r\n  /**\r\n   * Optionally run a preupdate before the system processes matching entities\r\n   * @param engine\r\n   * @param elapsedMs Time in milliseconds since the last frame\r\n   */\r\n  preupdate?(engine: ContextType, elapsedMs: number): void;\r\n\r\n  /**\r\n   * Optionally run a postupdate after the system processes matching entities\r\n   * @param engine\r\n   * @param elapsedMs Time in milliseconds since the last frame\r\n   */\r\n  postupdate?(engine: ContextType, elapsedMs: number): void;\r\n\r\n  /**\r\n   * Systems observe when entities match their types or no longer match their types, override\r\n   * @param _entityAddedOrRemoved\r\n   */\r\n  public notify(_entityAddedOrRemoved: AddedEntity | RemovedEntity) {\r\n    // Override me\r\n  }\r\n}\r\n\r\n/**\r\n * An [[Entity]] with [[Component]] types that matches a [[System]] types exists in the current scene.\r\n */\r\nexport class AddedEntity implements Message<Entity> {\r\n  readonly type: 'Entity Added' = 'Entity Added';\r\n  constructor(public data: Entity) {}\r\n}\r\n\r\n/**\r\n * Type guard to check for AddedEntity messages\r\n * @param x\r\n */\r\nexport function isAddedSystemEntity(x: Message<Entity>): x is AddedEntity {\r\n  return !!x && x.type === 'Entity Added';\r\n}\r\n\r\n/**\r\n * An [[Entity]] with [[Component]] types that no longer matches a [[System]] types exists in the current scene.\r\n */\r\nexport class RemovedEntity implements Message<Entity> {\r\n  readonly type: 'Entity Removed' = 'Entity Removed';\r\n  constructor(public data: Entity) {}\r\n}\r\n\r\n/**\r\n * type guard to check for the RemovedEntity message\r\n */\r\nexport function isRemoveSystemEntity(x: Message<Entity>): x is RemovedEntity {\r\n  return !!x && x.type === 'Entity Removed';\r\n}\r\n","import { Entity, RemovedComponent, AddedComponent, isAddedComponent, isRemovedComponent } from './Entity';\r\nimport { Observer } from '../Util/Observable';\r\nimport { World } from './World';\r\nimport { Util } from '..';\r\n\r\n// Add/Remove entities and components\r\n\r\nexport class EntityManager<ContextType = any> implements Observer<RemovedComponent | AddedComponent> {\r\n  public entities: Entity[] = [];\r\n  public _entityIndex: { [entityId: string]: Entity } = {};\r\n\r\n  constructor(private _world: World<ContextType>) {}\r\n\r\n  /**\r\n   * Runs the entity lifecycle\r\n   * @param _context\r\n   */\r\n  public updateEntities(_context: ContextType, elapsed: number) {\r\n    for (const entity of this.entities) {\r\n      // TODO is this right?\r\n      entity.update((_context as any).engine, elapsed);\r\n      if (!entity.active) {\r\n        this.removeEntity(entity);\r\n      }\r\n    }\r\n  }\r\n\r\n  public findEntitiesForRemoval() {\r\n    for (const entity of this.entities) {\r\n      if (!entity.active) {\r\n        this.removeEntity(entity);\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * EntityManager observes changes on entities\r\n   * @param message\r\n   */\r\n  public notify(message: RemovedComponent | AddedComponent): void {\r\n    if (isAddedComponent(message)) {\r\n      // we don't need the component, it's already on the entity\r\n      this._world.queryManager.addEntity(message.data.entity);\r\n    }\r\n\r\n    if (isRemovedComponent(message)) {\r\n      this._world.queryManager.removeComponent(message.data.entity, message.data.component);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Adds an entity to be tracked by the EntityManager\r\n   * @param entity\r\n   */\r\n  public addEntity(entity: Entity): void {\r\n    entity.active = true;\r\n    if (entity && !this._entityIndex[entity.id]) {\r\n      this._entityIndex[entity.id] = entity;\r\n      this.entities.push(entity);\r\n      this._world.queryManager.addEntity(entity);\r\n      entity.componentAdded$.register(this);\r\n      entity.componentRemoved$.register(this);\r\n\r\n      // if entity has children\r\n      entity.children.forEach((c) => this.addEntity(c));\r\n      entity.childrenAdded$.register({\r\n        notify: (e) => {\r\n          this.addEntity(e);\r\n        }\r\n      });\r\n      entity.childrenRemoved$.register({\r\n        notify: (e) => {\r\n          this.removeEntity(e, false);\r\n        }\r\n      });\r\n    }\r\n  }\r\n\r\n  public removeEntity(entity: Entity, deferred?: boolean): void;\r\n  public removeEntity(id: number, deferred?: boolean): void;\r\n  public removeEntity(idOrEntity: number | Entity, deferred = true): void {\r\n    let id = 0;\r\n    if (idOrEntity instanceof Entity) {\r\n      id = idOrEntity.id;\r\n    } else {\r\n      id = idOrEntity;\r\n    }\r\n    const entity = this._entityIndex[id];\r\n    if (entity && entity.active) {\r\n      entity.kill();\r\n    }\r\n\r\n    if (entity && deferred) {\r\n      this._entitiesToRemove.push(entity);\r\n      return;\r\n    }\r\n\r\n    delete this._entityIndex[id];\r\n    if (entity) {\r\n      Util.removeItemFromArray(entity, this.entities);\r\n      this._world.queryManager.removeEntity(entity);\r\n      entity.componentAdded$.unregister(this);\r\n      entity.componentRemoved$.unregister(this);\r\n\r\n      // if entity has children\r\n      entity.children.forEach((c) => this.removeEntity(c, deferred));\r\n      entity.childrenAdded$.clear();\r\n      entity.childrenRemoved$.clear();\r\n\r\n      // stats\r\n      if ((this._world.context as any)?.engine) {\r\n        (this._world.context as any).engine.stats.currFrame.actors.killed++;\r\n      }\r\n    }\r\n  }\r\n\r\n  private _entitiesToRemove: Entity[] = [];\r\n  public processEntityRemovals(): void {\r\n    for (const entity of this._entitiesToRemove) {\r\n      if (entity.active) {\r\n        continue;\r\n      }\r\n      this.removeEntity(entity, false);\r\n    }\r\n  }\r\n\r\n  public processComponentRemovals(): void {\r\n    for (const entity of this.entities) {\r\n      entity.processComponentRemoval();\r\n    }\r\n  }\r\n\r\n  public getById(id: number): Entity {\r\n    return this._entityIndex[id];\r\n  }\r\n\r\n  public getByName(name: string): Entity[]{\r\n    return this.entities.filter(e => e.name === name);\r\n  }\r\n\r\n  public clear(): void {\r\n    for (const entity of this.entities) {\r\n      this.removeEntity(entity);\r\n    }\r\n  }\r\n}\r\n","export const buildTypeKey = (types: readonly string[]) => {\r\n  const key = [...types].sort((a, b) => a.localeCompare(b)).join('+');\r\n  return key;\r\n};\r\n","import { Entity } from './Entity';\r\nimport { buildTypeKey } from './Util';\r\nimport { Observable } from '../Util/Observable';\r\nimport { Util, Component, ComponentCtor } from '..';\r\nimport { AddedEntity, RemovedEntity } from './System';\r\n\r\n/**\r\n * Represents query for entities that match a list of types that is cached and observable\r\n *\r\n * Queries can be strongly typed by supplying a type union in the optional type parameter\r\n * ```typescript\r\n * const queryAB = new ex.Query<ComponentTypeA | ComponentTypeB>(['A', 'B']);\r\n * ```\r\n */\r\nexport class Query<T extends Component = Component> extends Observable<AddedEntity | RemovedEntity> {\r\n  public types: readonly string[];\r\n  private _entities: Entity[] = [];\r\n  private _key: string;\r\n  public get key(): string {\r\n    if (this._key) {\r\n      return this._key;\r\n    }\r\n    return (this._key = buildTypeKey(this.types));\r\n  }\r\n\r\n  constructor(types: readonly string[]);\r\n  constructor(types: readonly ComponentCtor<T>[]);\r\n  constructor(types: readonly string[] | readonly ComponentCtor<T>[]) {\r\n    super();\r\n    if (types[0] instanceof Function) {\r\n      this.types = (types as ComponentCtor<T>[]).map(T =>  (new T).type);\r\n    } else {\r\n      this.types = types as string[];\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Returns a list of entities that match the query\r\n   *\r\n   * @param sort Optional sorting function to sort entities returned from the query\r\n   */\r\n  public getEntities(sort?: (a: Entity, b: Entity) => number): Entity[] {\r\n    if (sort) {\r\n      this._entities.sort(sort);\r\n    }\r\n    return this._entities;\r\n  }\r\n\r\n  /**\r\n   * Add an entity to the query, will only be added if the entity matches the query types\r\n   * @param entity\r\n   */\r\n  public addEntity(entity: Entity): void {\r\n    if (!Util.contains(this._entities, entity) && this.matches(entity)) {\r\n      this._entities.push(entity);\r\n      this.notifyAll(new AddedEntity(entity));\r\n    }\r\n  }\r\n\r\n  /**\r\n   * If the entity is part of the query it will be removed regardless of types\r\n   * @param entity\r\n   */\r\n  public removeEntity(entity: Entity): void {\r\n    if (Util.removeItemFromArray(entity, this._entities)) {\r\n      this.notifyAll(new RemovedEntity(entity));\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Removes all entities and observers from the query\r\n   */\r\n  public clear(): void {\r\n    this._entities.length = 0;\r\n    for (const observer of this.observers) {\r\n      this.unregister(observer);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Returns whether the entity's types match query\r\n   * @param entity\r\n   */\r\n  public matches(entity: Entity): boolean;\r\n\r\n  /**\r\n   * Returns whether the list of ComponentTypes have at least the same types as the query\r\n   * @param types\r\n   */\r\n  public matches(types: string[]): boolean;\r\n  public matches(typesOrEntity: string[] | Entity): boolean {\r\n    let types: string[] = [];\r\n    if (typesOrEntity instanceof Entity) {\r\n      types = typesOrEntity.types;\r\n    } else {\r\n      types = typesOrEntity;\r\n    }\r\n\r\n    let matches = true;\r\n    for (const type of this.types) {\r\n      matches = matches && types.indexOf(type) > -1;\r\n      if (!matches) {\r\n        return false;\r\n      }\r\n    }\r\n    return matches;\r\n  }\r\n\r\n  public contain(type: string) {\r\n    return this.types.indexOf(type) > -1;\r\n  }\r\n}\r\n","import { Entity } from './Entity';\r\nimport { buildTypeKey } from './Util';\r\nimport { Query } from './Query';\r\nimport { Component } from './Component';\r\nimport { World } from './World';\r\n\r\n/**\r\n * The query manager is responsible for updating all queries when entities/components change\r\n */\r\nexport class QueryManager {\r\n  private _queries: { [entityComponentKey: string]: Query<any> } = {};\r\n\r\n  constructor(private _world: World<any>) {}\r\n\r\n  /**\r\n   * Adds a query to the manager and populates with any entities that match\r\n   * @param query\r\n   */\r\n  private _addQuery(query: Query<any>) {\r\n    this._queries[buildTypeKey(query.types)] = query;\r\n    for (const entity of this._world.entityManager.entities) {\r\n      query.addEntity(entity);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Removes the query if there are no observers left\r\n   * @param query\r\n   */\r\n  public maybeRemoveQuery(query: Query): void {\r\n    if (query.observers.length === 0) {\r\n      query.clear();\r\n      delete this._queries[buildTypeKey(query.types)];\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Adds the entity to any matching query in the query manage\r\n   * @param entity\r\n   */\r\n  public addEntity(entity: Entity) {\r\n    for (const queryType in this._queries) {\r\n      if (this._queries[queryType]) {\r\n        this._queries[queryType].addEntity(entity);\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Removes an entity from queries if the removed component disqualifies it\r\n   * @param entity\r\n   * @param component\r\n   */\r\n  public removeComponent(entity: Entity, component: Component) {\r\n    for (const queryType in this._queries) {\r\n      // If the component being removed from an entity is a part of a query,\r\n      // it is now disqualified from that query, remove it\r\n      if (this._queries[queryType].contain(component.type)) {\r\n        this._queries[queryType].removeEntity(entity);\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Removes an entity from all queries it is currently a part of\r\n   * @param entity\r\n   */\r\n  public removeEntity(entity: Entity) {\r\n    for (const queryType in this._queries) {\r\n      this._queries[queryType].removeEntity(entity);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Creates a populated query and returns, if the query already exists that will be returned instead of a new instance\r\n   * @param types\r\n   */\r\n  public createQuery<T extends Component = Component>(types: readonly string[]): Query<T> {\r\n    const maybeExistingQuery = this.getQuery<T>(types);\r\n    if (maybeExistingQuery) {\r\n      return maybeExistingQuery;\r\n    }\r\n    const query = new Query<T>(types);\r\n    this._addQuery(query);\r\n    return query;\r\n  }\r\n\r\n  /**\r\n   * Retrieves an existing query by types if it exists otherwise returns null\r\n   * @param types\r\n   */\r\n  public getQuery<T extends Component = Component>(types: readonly string[]): Query<T> {\r\n    const key = buildTypeKey(types);\r\n    if (this._queries[key]) {\r\n      return this._queries[key] as Query<T>;\r\n    }\r\n    return null;\r\n  }\r\n}\r\n","import { System, SystemType } from './System';\r\nimport { Scene, Util } from '..';\r\nimport { World } from './World';\r\n\r\nexport interface SystemCtor<T extends System> {\r\n  new (): T;\r\n}\r\n\r\n/**\r\n * The SystemManager is responsible for keeping track of all systems in a scene.\r\n * Systems are scene specific\r\n */\r\nexport class SystemManager<ContextType> {\r\n  /**\r\n   * List of systems, to add a new system call [[SystemManager.addSystem]]\r\n   */\r\n  public systems: System<any, ContextType>[] = [];\r\n  public _keyToSystem: { [key: string]: System<any, ContextType> };\r\n  public initialized = false;\r\n  constructor(private _world: World<ContextType>) {}\r\n\r\n  /**\r\n   * Get a system registered in the manager by type\r\n   * @param systemType\r\n   */\r\n  public get<T extends System>(systemType: SystemCtor<T>): T | null {\r\n    return this.systems.find((s) => s instanceof systemType) as unknown as T;\r\n  }\r\n\r\n  /**\r\n   * Adds a system to the manager, it will now be updated every frame\r\n   * @param system\r\n   */\r\n  public addSystem(system: System<any, ContextType>): void {\r\n    // validate system has types\r\n    if (!system.types || system.types.length === 0) {\r\n      throw new Error(`Attempted to add a System without any types`);\r\n    }\r\n\r\n    const query = this._world.queryManager.createQuery(system.types);\r\n    this.systems.push(system);\r\n    this.systems.sort((a, b) => a.priority - b.priority);\r\n    query.register(system);\r\n    if (this.initialized && system.initialize) {\r\n      system.initialize(this._world.context);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Removes a system from the manager, it will no longer be updated\r\n   * @param system\r\n   */\r\n  public removeSystem(system: System<any, ContextType>) {\r\n    Util.removeItemFromArray(system, this.systems);\r\n    const query = this._world.queryManager.getQuery(system.types);\r\n    if (query) {\r\n      query.unregister(system);\r\n      this._world.queryManager.maybeRemoveQuery(query);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Initialize all systems in the manager\r\n   *\r\n   * Systems added after initialize() will be initialized on add\r\n   */\r\n  public initialize() {\r\n    if (!this.initialized) {\r\n      this.initialized = true;\r\n      for (const s of this.systems) {\r\n        if (s.initialize) {\r\n          s.initialize(this._world.context);\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Updates all systems\r\n   * @param type whether this is an update or draw system\r\n   * @param context context reference\r\n   * @param delta time in milliseconds\r\n   */\r\n  public updateSystems(type: SystemType, context: ContextType, delta: number) {\r\n    const systems = this.systems.filter((s) => s.systemType === type);\r\n    for (const s of systems) {\r\n      if (s.preupdate) {\r\n        s.preupdate(context, delta);\r\n      }\r\n    }\r\n\r\n    for (const s of systems) {\r\n      // Get entities that match the system types, pre-sort\r\n      const entities = this._world.queryManager.getQuery(s.types).getEntities(s.sort);\r\n      // Initialize entities if needed\r\n      if (context instanceof Scene) {\r\n        for (const entity of entities) {\r\n          entity._initialize(context?.engine);\r\n        }\r\n      }\r\n      s.update(entities, delta);\r\n    }\r\n\r\n    for (const s of systems) {\r\n      if (s.postupdate) {\r\n        s.postupdate(context, delta);\r\n      }\r\n    }\r\n  }\r\n\r\n  public clear(): void {\r\n    for (const system of this.systems) {\r\n      this.removeSystem(system);\r\n    }\r\n  }\r\n}\r\n","import { Entity } from './Entity';\r\nimport { EntityManager } from './EntityManager';\r\nimport { QueryManager } from './QueryManager';\r\nimport { System, SystemType } from './System';\r\nimport { SystemManager } from './SystemManager';\r\n\r\n/**\r\n * The World is a self-contained entity component system for a particular context.\r\n */\r\nexport class World<ContextType> {\r\n  public queryManager: QueryManager = new QueryManager(this);\r\n  public entityManager: EntityManager<ContextType> = new EntityManager<ContextType>(this);\r\n  public systemManager: SystemManager<ContextType> = new SystemManager<ContextType>(this);\r\n\r\n  /**\r\n   * The context type is passed to the system updates\r\n   * @param context\r\n   */\r\n  constructor(public context: ContextType) {}\r\n\r\n  /**\r\n   * Update systems by type and time elapsed in milliseconds\r\n   */\r\n  update(type: SystemType, delta: number) {\r\n    if (type === SystemType.Update) {\r\n      this.entityManager.updateEntities(this.context, delta);\r\n    }\r\n    this.systemManager.updateSystems(type, this.context, delta);\r\n    this.entityManager.findEntitiesForRemoval();\r\n    this.entityManager.processComponentRemovals();\r\n    this.entityManager.processEntityRemovals();\r\n  }\r\n\r\n  /**\r\n   * Add an entity to the ECS world\r\n   * @param entity\r\n   */\r\n  add(entity: Entity): void;\r\n  /**\r\n   * Add a system to the ECS world\r\n   * @param system\r\n   */\r\n  add(system: System<any, ContextType>): void;\r\n  add(entityOrSystem: Entity | System<any, ContextType>): void {\r\n    if (entityOrSystem instanceof Entity) {\r\n      this.entityManager.addEntity(entityOrSystem);\r\n    }\r\n\r\n    if (entityOrSystem instanceof System) {\r\n      this.systemManager.addSystem(entityOrSystem);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Remove an entity from the ECS world\r\n   * @param entity\r\n   */\r\n  remove(entity: Entity, deferred?: boolean): void;\r\n  /**\r\n   * Remove a system from the ECS world\r\n   * @param system\r\n   */\r\n  remove(system: System<any, ContextType>): void;\r\n  remove(entityOrSystem: Entity | System<any, ContextType>, deferred = true): void {\r\n    if (entityOrSystem instanceof Entity) {\r\n      this.entityManager.removeEntity(entityOrSystem, deferred);\r\n    }\r\n\r\n    if (entityOrSystem instanceof System) {\r\n      this.systemManager.removeSystem(entityOrSystem);\r\n    }\r\n  }\r\n\r\n  clearEntities(): void {\r\n    this.entityManager.clear();\r\n  }\r\n\r\n  clearSystems(): void {\r\n    this.systemManager.clear();\r\n  }\r\n}\r\n","import { Vector } from '../Math/vector';\r\nimport { TransformComponent } from '../EntityComponentSystem';\r\nimport { MotionComponent } from '../EntityComponentSystem/Components/MotionComponent';\r\n\r\nexport class EulerIntegrator {\r\n  static integrate(transform: TransformComponent, motion: MotionComponent, totalAcc: Vector, elapsedMs: number): void {\r\n    const seconds = elapsedMs / 1000;\r\n    motion.vel.addEqual(totalAcc.scale(seconds));\r\n    transform.pos.addEqual(motion.vel.scale(seconds)).addEqual(totalAcc.scale(0.5 * seconds * seconds));\r\n\r\n    motion.angularVelocity += motion.torque * (1.0 / motion.inertia) * seconds;\r\n    transform.rotation += motion.angularVelocity * seconds;\r\n\r\n    transform.scale.addEqual(motion.scaleFactor.scale(seconds));\r\n  }\r\n}\r\n","import { Entity } from '../EntityComponentSystem';\r\nimport { MotionComponent } from '../EntityComponentSystem/Components/MotionComponent';\r\nimport { TransformComponent } from '../EntityComponentSystem/Components/TransformComponent';\r\nimport { System, SystemType } from '../EntityComponentSystem/System';\r\nimport { Physics } from './Physics';\r\nimport { BodyComponent } from './BodyComponent';\r\nimport { CollisionType } from './CollisionType';\r\nimport { EulerIntegrator } from './Integrator';\r\n\r\nexport class MotionSystem extends System<TransformComponent | MotionComponent> {\r\n  public readonly types = ['ex.transform', 'ex.motion'] as const;\r\n  public systemType = SystemType.Update;\r\n  public priority = -1;\r\n\r\n  update(_entities: Entity[], elapsedMs: number): void {\r\n    let transform: TransformComponent;\r\n    let motion: MotionComponent;\r\n    for (const entity of _entities) {\r\n      transform = entity.get(TransformComponent);\r\n      motion = entity.get(MotionComponent);\r\n\r\n      const optionalBody = entity.get(BodyComponent);\r\n      if (optionalBody?.sleeping) {\r\n        continue;\r\n      }\r\n\r\n      const totalAcc = motion.acc.clone();\r\n      if (optionalBody?.collisionType === CollisionType.Active && optionalBody?.useGravity) {\r\n        totalAcc.addEqual(Physics.gravity);\r\n      }\r\n      optionalBody?.captureOldTransform();\r\n\r\n      // Update transform and motion based on Euler linear algebra\r\n      EulerIntegrator.integrate(transform, motion, totalAcc, elapsedMs);\r\n    }\r\n  }\r\n}\r\n","import { CollisionContact } from '../Detection/CollisionContact';\r\n\r\n/**\r\n * A collision solver figures out how to position colliders such that they are no longer overlapping\r\n *\r\n * Solvers are executed in the order\r\n *\r\n * 1. preSolve\r\n * 2. solveVelocity\r\n * 3. solvePosition\r\n * 4. postSolve\r\n * @inheritdoc\r\n */\r\nexport abstract class CollisionSolver {\r\n  /**\r\n   * Pre-solve is fired on contacts before any resolution is started. It is used for any setup work before collision resolution\r\n   * can proceed. Optionally contacts can be \"opted out\" of any collision processing by calling `contact.cancel()`\r\n   * @param contacts\r\n   * @inheritdoc\r\n   */\r\n  abstract preSolve(contacts: CollisionContact[]): void;\r\n\r\n  /**\r\n   * Post-solve is fired after all resolution is complete\r\n   * @param contacts\r\n   * @inheritdoc\r\n   */\r\n  abstract postSolve(contacts: CollisionContact[]): void;\r\n\r\n  /**\r\n   * Solve velocity adjusts the velocity of colliders so that they are not overlapping or will not be overlapping from velocity\r\n   * @param contacts\r\n   * @inheritdoc\r\n   */\r\n  abstract solveVelocity(contacts: CollisionContact[]): void;\r\n\r\n  /**\r\n   * Solve position adjust the position of colliders so that they are not overlapping\r\n   * @param contacts\r\n   * @inheritdoc\r\n   */\r\n  abstract solvePosition(contacts: CollisionContact[]): void;\r\n\r\n  /**\r\n   * Solves overlapping contact in\r\n   *\r\n   * Solvers are executed in the order\r\n   * 1. preSolve\r\n   * 2. solveVelocity\r\n   * 3. solvePosition\r\n   * 4. postSolve\r\n   * @param contacts\r\n   */\r\n  public solve(contacts: CollisionContact[]): CollisionContact[] {\r\n    // Events and init\r\n    this.preSolve(contacts);\r\n\r\n    // Remove any canceled contacts\r\n    contacts = contacts.filter(c => !c.isCanceled());\r\n\r\n    // Solve velocity first\r\n    this.solveVelocity(contacts);\r\n\r\n    // Solve position last because non-overlap is the most important\r\n    this.solvePosition(contacts);\r\n\r\n    // Events and any contact house-keeping the solver needs\r\n    this.postSolve(contacts);\r\n\r\n    return contacts;\r\n  }\r\n}","import { PostCollisionEvent, PreCollisionEvent } from '../../Events';\r\nimport { CollisionContact } from '../Detection/CollisionContact';\r\nimport { CollisionType } from '../CollisionType';\r\nimport { Side } from '../Side';\r\nimport { CollisionSolver } from './Solver';\r\nimport { BodyComponent } from '../BodyComponent';\r\n\r\n/**\r\n * ArcadeSolver is the default in Excalibur. It solves collisions so that there is no overlap between contacts,\r\n * and negates velocity along the collision normal.\r\n *\r\n * This is usually the type of collisions used for 2D games that don't need a more realistic collision simulation.\r\n *\r\n */\r\nexport class ArcadeSolver extends CollisionSolver {\r\n  public preSolve(contacts: CollisionContact[]) {\r\n    for (const contact of contacts) {\r\n      const side = Side.fromDirection(contact.mtv);\r\n      const mtv = contact.mtv.negate();\r\n      // Publish collision events on both participants\r\n      contact.colliderA.events.emit('precollision', new PreCollisionEvent(contact.colliderA, contact.colliderB, side, mtv));\r\n      contact.colliderB.events.emit(\r\n        'precollision',\r\n        new PreCollisionEvent(contact.colliderB, contact.colliderA, Side.getOpposite(side), mtv.negate())\r\n      );\r\n    }\r\n  }\r\n\r\n  public postSolve(contacts: CollisionContact[]) {\r\n    for (const contact of contacts) {\r\n      const colliderA = contact.colliderA;\r\n      const colliderB = contact.colliderB;\r\n      const bodyA = colliderA.owner?.get(BodyComponent);\r\n      const bodyB = colliderB.owner?.get(BodyComponent);\r\n      if (bodyA && bodyB) {\r\n        if (bodyA.collisionType === CollisionType.Passive || bodyB.collisionType === CollisionType.Passive) {\r\n          continue;\r\n        }\r\n      }\r\n      const side = Side.fromDirection(contact.mtv);\r\n      const mtv = contact.mtv.negate();\r\n      // Publish collision events on both participants\r\n      contact.colliderA.events.emit('postcollision', new PostCollisionEvent(contact.colliderA, contact.colliderB, side, mtv));\r\n      contact.colliderB.events.emit(\r\n        'postcollision',\r\n        new PostCollisionEvent(contact.colliderB, contact.colliderA, Side.getOpposite(side), mtv.negate())\r\n      );\r\n    }\r\n  }\r\n\r\n  public solvePosition(contacts: CollisionContact[]) {\r\n    for (const contact of contacts) {\r\n      // if bounds no longer interesect skip to the next\r\n      // this removes jitter from overlapping/stacked solid tiles or a wall of solid tiles\r\n      if (!contact.colliderA.bounds.overlaps(contact.colliderB.bounds)) {\r\n        continue;\r\n      }\r\n      let mtv = contact.mtv;\r\n      const colliderA = contact.colliderA;\r\n      const colliderB = contact.colliderB;\r\n      const bodyA = colliderA.owner?.get(BodyComponent);\r\n      const bodyB = colliderB.owner?.get(BodyComponent);\r\n      if (bodyA && bodyB) {\r\n        if (bodyA.collisionType === CollisionType.Passive || bodyB.collisionType === CollisionType.Passive) {\r\n          continue;\r\n        }\r\n\r\n        if (bodyA.collisionType === CollisionType.Active && bodyB.collisionType === CollisionType.Active) {\r\n          // split overlaps if both are Active\r\n          mtv = mtv.scale(0.5);\r\n        }\r\n\r\n        // Resolve overlaps\r\n        if (bodyA.collisionType === CollisionType.Active) {\r\n          bodyA.pos.x -= mtv.x;\r\n          bodyA.pos.y -= mtv.y;\r\n          colliderA.update(bodyA.transform);\r\n        }\r\n\r\n        if (bodyB.collisionType === CollisionType.Active) {\r\n          bodyB.pos.x += mtv.x;\r\n          bodyB.pos.y += mtv.y;\r\n          colliderB.update(bodyB.transform);\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  public solveVelocity(contacts: CollisionContact[]) {\r\n    for (const contact of contacts) {\r\n      const colliderA = contact.colliderA;\r\n      const colliderB = contact.colliderB;\r\n      const bodyA = colliderA.owner?.get(BodyComponent);\r\n      const bodyB = colliderB.owner?.get(BodyComponent);\r\n\r\n      if (bodyA && bodyB) {\r\n\r\n        if (bodyA.collisionType === CollisionType.Passive || bodyB.collisionType === CollisionType.Passive) {\r\n          continue;\r\n        }\r\n\r\n        const normal = contact.normal;\r\n        const opposite = normal.negate();\r\n\r\n        // Cancel out velocity opposite direction of collision normal\r\n        if (bodyA.collisionType === CollisionType.Active) {\r\n          const velAdj = normal.scale(normal.dot(bodyA.vel.negate()));\r\n          bodyA.vel = bodyA.vel.add(velAdj);\r\n        }\r\n\r\n        if (bodyB.collisionType === CollisionType.Active) {\r\n          const velAdj = opposite.scale(opposite.dot(bodyB.vel.negate()));\r\n          bodyB.vel = bodyB.vel.add(velAdj);\r\n        }\r\n      }\r\n    }\r\n  }\r\n}\r\n","import { Vector } from '../../Math/vector';\r\nimport { BodyComponent } from '../BodyComponent';\r\nimport { CollisionContact } from '../Detection/CollisionContact';\r\n\r\n/**\r\n * Holds information about contact points, meant to be reused over multiple frames of contact\r\n */\r\nexport class ContactConstraintPoint {\r\n  constructor(public point: Vector, public local: Vector, public contact: CollisionContact) {\r\n    this.update();\r\n  }\r\n\r\n  /**\r\n   * Updates the contact information\r\n   */\r\n  update() {\r\n    const bodyA = this.contact.colliderA.owner?.get(BodyComponent);\r\n    const bodyB = this.contact.colliderB.owner?.get(BodyComponent);\r\n\r\n    if (bodyA && bodyB) {\r\n      const normal = this.contact.normal;\r\n      const tangent = this.contact.tangent;\r\n\r\n      this.aToContact = this.point.sub(bodyA.pos);\r\n      this.bToContact = this.point.sub(bodyB.pos);\r\n\r\n      const aToContactNormal = this.aToContact.cross(normal);\r\n      const bToContactNormal = this.bToContact.cross(normal);\r\n\r\n      this.normalMass =\r\n        bodyA.inverseMass +\r\n        bodyB.inverseMass +\r\n        bodyA.inverseInertia * aToContactNormal * aToContactNormal +\r\n        bodyB.inverseInertia * bToContactNormal * bToContactNormal;\r\n\r\n      const aToContactTangent = this.aToContact.cross(tangent);\r\n      const bToContactTangent = this.bToContact.cross(tangent);\r\n\r\n      this.tangentMass =\r\n        bodyA.inverseMass +\r\n        bodyB.inverseMass +\r\n        bodyA.inverseInertia * aToContactTangent * aToContactTangent +\r\n        bodyB.inverseInertia * bToContactTangent * bToContactTangent;\r\n    }\r\n\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Returns the relative velocity between bodyA and bodyB\r\n   */\r\n  public getRelativeVelocity() {\r\n    const bodyA = this.contact.colliderA.owner?.get(BodyComponent);\r\n    const bodyB = this.contact.colliderB.owner?.get(BodyComponent);\r\n    if (bodyA && bodyB) {\r\n      // Relative velocity in linear terms\r\n      // Angular to linear velocity formula -> omega = velocity/radius so omega x radius = velocity\r\n      const velA = bodyA.vel.add(Vector.cross(bodyA.angularVelocity, this.aToContact));\r\n      const velB = bodyB.vel.add(Vector.cross(bodyB.angularVelocity, this.bToContact));\r\n      return velB.sub(velA);\r\n    }\r\n    return Vector.Zero;\r\n  }\r\n\r\n  /**\r\n   * Impulse accumulated over time in normal direction\r\n   */\r\n  public normalImpulse: number = 0;\r\n\r\n  /**\r\n   * Impulse accumulated over time in the tangent direction\r\n   */\r\n  public tangentImpulse: number = 0;\r\n\r\n  /**\r\n   * Effective mass seen in the normal direction\r\n   */\r\n  public normalMass: number = 0;\r\n\r\n  /**\r\n   * Effective mass seen in the tangent direction\r\n   */\r\n  public tangentMass: number = 0;\r\n\r\n  /**\r\n   * Direction from center of mass of bodyA to contact point\r\n   */\r\n  public aToContact: Vector = new Vector(0, 0);\r\n\r\n  /**\r\n   * Direction from center of mass of bodyB to contact point\r\n   */\r\n  public bToContact: Vector = new Vector(0, 0);\r\n}\r\n","import { CollisionPostSolveEvent, CollisionPreSolveEvent, PostCollisionEvent, PreCollisionEvent } from '../../Events';\r\nimport { clamp } from '../../Math/util';\r\nimport { CollisionContact } from '../Detection/CollisionContact';\r\nimport { CollisionType } from '../CollisionType';\r\nimport { ContactConstraintPoint } from './ContactConstraintPoint';\r\nimport { Side } from '../Side';\r\nimport { Physics } from '../Physics';\r\nimport { CollisionSolver } from './Solver';\r\nimport { BodyComponent } from '../BodyComponent';\r\nimport { CollisionJumpTable } from '../Colliders/CollisionJumpTable';\r\n\r\nexport class RealisticSolver extends CollisionSolver {\r\n  lastFrameContacts: Map<string, CollisionContact> = new Map();\r\n\r\n  // map contact id to contact points\r\n  idToContactConstraint: Map<string, ContactConstraintPoint[]> = new Map();\r\n\r\n  getContactConstraints(id: string) {\r\n    return this.idToContactConstraint.get(id) ?? [];\r\n  }\r\n\r\n  preSolve(contacts: CollisionContact[]) {\r\n    for (const contact of contacts) {\r\n      // Publish collision events on both participants\r\n      const side = Side.fromDirection(contact.mtv);\r\n      contact.colliderA.events.emit('precollision', new PreCollisionEvent(contact.colliderA, contact.colliderB, side, contact.mtv));\r\n      contact.colliderA.events.emit(\r\n        'beforecollisionresolve',\r\n        new CollisionPreSolveEvent(contact.colliderA, contact.colliderB, side, contact.mtv, contact) as any\r\n      );\r\n      contact.colliderB.events.emit(\r\n        'precollision',\r\n        new PreCollisionEvent(contact.colliderB, contact.colliderA, Side.getOpposite(side), contact.mtv.negate())\r\n      );\r\n      contact.colliderB.events.emit(\r\n        'beforecollisionresolve',\r\n        new CollisionPreSolveEvent(contact.colliderB, contact.colliderA, Side.getOpposite(side), contact.mtv.negate(), contact) as any\r\n      );\r\n\r\n      // Match awake state for sleeping\r\n      contact.matchAwake();\r\n    }\r\n\r\n    // Keep track of contacts that done\r\n    const finishedContactIds = Array.from(this.idToContactConstraint.keys());\r\n    for (const contact of contacts) {\r\n      // Remove all current contacts that are not done\r\n      const index = finishedContactIds.indexOf(contact.id);\r\n      if (index > -1) {\r\n        finishedContactIds.splice(index, 1);\r\n      }\r\n      const contactPoints = this.idToContactConstraint.get(contact.id) ?? [];\r\n\r\n      let pointIndex = 0;\r\n      const bodyA = contact.colliderA.owner.get(BodyComponent);\r\n      const bodyB = contact.colliderB.owner.get(BodyComponent);\r\n      if (bodyA && bodyB) {\r\n        for (const point of contact.points) {\r\n          const normal = contact.normal;\r\n          const tangent = contact.tangent;\r\n\r\n          const aToContact = point.sub(bodyA.pos);\r\n          const bToContact = point.sub(bodyB.pos);\r\n\r\n          const aToContactNormal = aToContact.cross(normal);\r\n          const bToContactNormal = bToContact.cross(normal);\r\n\r\n          const normalMass =\r\n            bodyA.inverseMass +\r\n            bodyB.inverseMass +\r\n            bodyA.inverseInertia * aToContactNormal * aToContactNormal +\r\n            bodyB.inverseInertia * bToContactNormal * bToContactNormal;\r\n\r\n          const aToContactTangent = aToContact.cross(tangent);\r\n          const bToContactTangent = bToContact.cross(tangent);\r\n\r\n          const tangentMass =\r\n            bodyA.inverseMass +\r\n            bodyB.inverseMass +\r\n            bodyA.inverseInertia * aToContactTangent * aToContactTangent +\r\n            bodyB.inverseInertia * bToContactTangent * bToContactTangent;\r\n\r\n          // Preserve normal/tangent impulse by re-using the contact point if it's close\r\n          if (contactPoints[pointIndex] && contactPoints[pointIndex]?.point?.squareDistance(point) < 4) {\r\n            contactPoints[pointIndex].point = point;\r\n            contactPoints[pointIndex].local = contact.localPoints[pointIndex];\r\n          } else {\r\n            // new contact if it's not close or doesn't exist\r\n            contactPoints[pointIndex] = new ContactConstraintPoint(point, contact.localPoints[pointIndex], contact);\r\n          }\r\n\r\n          // Update contact point calculations\r\n          contactPoints[pointIndex].aToContact = aToContact;\r\n          contactPoints[pointIndex].bToContact = bToContact;\r\n          contactPoints[pointIndex].normalMass = normalMass;\r\n          contactPoints[pointIndex].tangentMass = tangentMass;\r\n\r\n          pointIndex++;\r\n        }\r\n      }\r\n      this.idToContactConstraint.set(contact.id, contactPoints);\r\n    }\r\n\r\n    // Clean up any contacts that did not occur last frame\r\n    for (const id of finishedContactIds) {\r\n      this.idToContactConstraint.delete(id);\r\n    }\r\n\r\n    // Warm contacts with accumulated impulse\r\n    // Useful for tall stacks\r\n    if (Physics.warmStart) {\r\n      this.warmStart(contacts);\r\n    } else {\r\n      for (const contact of contacts) {\r\n        const contactPoints = this.getContactConstraints(contact.id);\r\n        for (const point of contactPoints) {\r\n          point.normalImpulse = 0;\r\n          point.tangentImpulse = 0;\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  postSolve(contacts: CollisionContact[]) {\r\n    for (const contact of contacts) {\r\n      const bodyA = contact.colliderA.owner.get(BodyComponent);\r\n      const bodyB = contact.colliderB.owner.get(BodyComponent);\r\n\r\n      if (bodyA && bodyB) {\r\n        // Skip post solve for active+passive collisions\r\n        if (bodyA.collisionType === CollisionType.Passive || bodyB.collisionType === CollisionType.Passive) {\r\n          continue;\r\n        }\r\n\r\n        // Update motion values for sleeping\r\n        bodyA.updateMotion();\r\n        bodyB.updateMotion();\r\n      }\r\n\r\n      // Publish collision events on both participants\r\n      const side = Side.fromDirection(contact.mtv);\r\n      contact.colliderA.events.emit('postcollision', new PostCollisionEvent(contact.colliderA, contact.colliderB, side, contact.mtv));\r\n      contact.colliderA.events.emit(\r\n        'aftercollisionresolve',\r\n        new CollisionPostSolveEvent(contact.colliderA, contact.colliderB, side, contact.mtv, contact) as any\r\n      );\r\n      contact.colliderB.events.emit(\r\n        'postcollision',\r\n        new PostCollisionEvent(contact.colliderB, contact.colliderA, Side.getOpposite(side), contact.mtv.negate())\r\n      );\r\n      contact.colliderB.events.emit(\r\n        'aftercollisionresolve',\r\n        new CollisionPostSolveEvent(contact.colliderB, contact.colliderA, Side.getOpposite(side), contact.mtv.negate(), contact) as any\r\n      );\r\n    }\r\n\r\n    // Store contacts\r\n    this.lastFrameContacts.clear();\r\n    for (const c of contacts) {\r\n      this.lastFrameContacts.set(c.id, c);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Warm up body's based on previous frame contact points\r\n   * @param contacts\r\n   */\r\n  warmStart(contacts: CollisionContact[]) {\r\n    for (const contact of contacts) {\r\n      const bodyA = contact.colliderA.owner?.get(BodyComponent);\r\n      const bodyB = contact.colliderB.owner?.get(BodyComponent);\r\n      if (bodyA && bodyB) {\r\n        const contactPoints = this.idToContactConstraint.get(contact.id) ?? [];\r\n        for (const point of contactPoints) {\r\n          if (Physics.warmStart) {\r\n            const normalImpulse = contact.normal.scale(point.normalImpulse);\r\n            const tangentImpulse = contact.tangent.scale(point.tangentImpulse);\r\n            const impulse = normalImpulse.add(tangentImpulse);\r\n\r\n            bodyA.applyImpulse(point.point, impulse.negate());\r\n            bodyB.applyImpulse(point.point, impulse);\r\n          } else {\r\n            point.normalImpulse = 0;\r\n            point.tangentImpulse = 0;\r\n          }\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Iteratively solve the position overlap constraint\r\n   * @param contacts\r\n   */\r\n  solvePosition(contacts: CollisionContact[]) {\r\n    for (let i = 0; i < Physics.positionIterations; i++) {\r\n      for (const contact of contacts) {\r\n        const bodyA = contact.colliderA.owner?.get(BodyComponent);\r\n        const bodyB = contact.colliderB.owner?.get(BodyComponent);\r\n\r\n        if (bodyA && bodyB) {\r\n          // Skip solving active+passive\r\n          if (bodyA.collisionType === CollisionType.Passive || bodyB.collisionType === CollisionType.Passive) {\r\n            continue;\r\n          }\r\n\r\n          const constraints = this.idToContactConstraint.get(contact.id) ?? [];\r\n          for (const point of constraints) {\r\n            const normal = contact.normal;\r\n            const separation = CollisionJumpTable.FindContactSeparation(contact, point.local);\r\n\r\n            const steeringConstant = Physics.steeringFactor; //0.2;\r\n            const maxCorrection = -5;\r\n            const slop = Physics.slop; //1;\r\n\r\n            // Clamp to avoid over-correction\r\n            // Remember that we are shooting for 0 overlap in the end\r\n            const steeringForce = clamp(steeringConstant * (separation + slop), maxCorrection, 0);\r\n            const impulse = normal.scale(-steeringForce / point.normalMass);\r\n\r\n            // This is a pseudo impulse, meaning we aren't doing a real impulse calculation\r\n            // We adjust position and rotation instead of doing the velocity\r\n            if (bodyA.collisionType === CollisionType.Active) {\r\n              bodyA.pos = bodyA.pos.add(impulse.negate().scale(bodyA.inverseMass));\r\n              bodyA.rotation -= point.aToContact.cross(impulse) * bodyA.inverseInertia;\r\n            }\r\n\r\n            if (bodyB.collisionType === CollisionType.Active) {\r\n              bodyB.pos = bodyB.pos.add(impulse.scale(bodyB.inverseMass));\r\n              bodyB.rotation += point.bToContact.cross(impulse) * bodyB.inverseInertia;\r\n            }\r\n          }\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  solveVelocity(contacts: CollisionContact[]) {\r\n    for (let i = 0; i < Physics.velocityIterations; i++) {\r\n      for (const contact of contacts) {\r\n        const bodyA = contact.colliderA.owner?.get(BodyComponent);\r\n        const bodyB = contact.colliderB.owner?.get(BodyComponent);\r\n\r\n        if (bodyA && bodyB) {\r\n          // Skip solving active+passive\r\n          if (bodyA.collisionType === CollisionType.Passive || bodyB.collisionType === CollisionType.Passive) {\r\n            continue;\r\n          }\r\n\r\n          const restitution = bodyA.bounciness * bodyB.bounciness;\r\n          const friction = Math.min(bodyA.friction, bodyB.friction);\r\n\r\n          const constraints = this.idToContactConstraint.get(contact.id) ?? [];\r\n\r\n          for (const point of constraints) {\r\n            const relativeVelocity = point.getRelativeVelocity();\r\n\r\n            // Negate velocity in tangent direction to simulate friction\r\n            const tangentVelocity = -relativeVelocity.dot(contact.tangent);\r\n            let impulseDelta = tangentVelocity / point.tangentMass;\r\n\r\n            // Clamping based in Erin Catto's GDC 2006 talk\r\n            // Correct clamping https://github.com/erincatto/box2d-lite/blob/master/docs/GDC2006_Catto_Erin_PhysicsTutorial.pdf\r\n            // Accumulated fiction impulse is always between -uMaxFriction < dT < uMaxFriction\r\n            // But deltas can vary\r\n            const maxFriction = friction * point.normalImpulse;\r\n            const newImpulse = clamp(point.tangentImpulse + impulseDelta, -maxFriction, maxFriction);\r\n            impulseDelta = newImpulse - point.tangentImpulse;\r\n            point.tangentImpulse = newImpulse;\r\n\r\n            const impulse = contact.tangent.scale(impulseDelta);\r\n            bodyA.applyImpulse(point.point, impulse.negate());\r\n            bodyB.applyImpulse(point.point, impulse);\r\n          }\r\n\r\n          for (const point of constraints) {\r\n            // Need to recalc relative velocity because the previous step could have changed vel\r\n            const relativeVelocity = point.getRelativeVelocity();\r\n\r\n            // Compute impulse in normal direction\r\n            const normalVelocity = relativeVelocity.dot(contact.normal);\r\n            // See https://en.wikipedia.org/wiki/Collision_response\r\n            let impulseDelta = (-(1 + restitution) * normalVelocity) / point.normalMass;\r\n\r\n            // Clamping based in Erin Catto's GDC 2014 talk\r\n            // Accumulated impulse stored in the contact is always positive (dV > 0)\r\n            // But deltas can be negative\r\n            const newImpulse = Math.max(point.normalImpulse + impulseDelta, 0);\r\n            impulseDelta = newImpulse - point.normalImpulse;\r\n            point.normalImpulse = newImpulse;\r\n\r\n            const impulse = contact.normal.scale(impulseDelta);\r\n            bodyA.applyImpulse(point.point, impulse.negate());\r\n            bodyB.applyImpulse(point.point, impulse);\r\n          }\r\n        }\r\n      }\r\n    }\r\n  }\r\n}\r\n","import { Entity } from '../EntityComponentSystem';\r\nimport { MotionComponent } from '../EntityComponentSystem/Components/MotionComponent';\r\nimport { TransformComponent } from '../EntityComponentSystem/Components/TransformComponent';\r\nimport { AddedEntity, isAddedSystemEntity, RemovedEntity, System, SystemType } from '../EntityComponentSystem/System';\r\nimport { CollisionEndEvent, CollisionStartEvent, ContactEndEvent, ContactStartEvent } from '../Events';\r\nimport { CollisionResolutionStrategy, Physics } from './Physics';\r\nimport { ArcadeSolver } from './Solver/ArcadeSolver';\r\nimport { Collider } from './Colliders/Collider';\r\nimport { CollisionContact } from './Detection/CollisionContact';\r\nimport { DynamicTreeCollisionProcessor } from './Detection/DynamicTreeCollisionProcessor';\r\nimport { RealisticSolver } from './Solver/RealisticSolver';\r\nimport { CollisionSolver } from './Solver/Solver';\r\nimport { ColliderComponent } from './ColliderComponent';\r\nimport { CompositeCollider } from './Colliders/CompositeCollider';\r\nimport { Engine, ExcaliburGraphicsContext, Scene } from '..';\r\n\r\nexport class CollisionSystem extends System<TransformComponent | MotionComponent | ColliderComponent> {\r\n  public readonly types = ['ex.transform', 'ex.motion', 'ex.collider'] as const;\r\n  public systemType = SystemType.Update;\r\n  public priority = -1;\r\n\r\n  private _engine: Engine;\r\n  private _realisticSolver = new RealisticSolver();\r\n  private _arcadeSolver = new ArcadeSolver();\r\n  private _processor = new DynamicTreeCollisionProcessor();\r\n  private _lastFrameContacts = new Map<string, CollisionContact>();\r\n  private _currentFrameContacts = new Map<string, CollisionContact>();\r\n\r\n  private _trackCollider = (c: Collider) => this._processor.track(c);\r\n  private _untrackCollider = (c: Collider) => this._processor.untrack(c);\r\n\r\n  notify(message: AddedEntity | RemovedEntity) {\r\n    if (isAddedSystemEntity(message)) {\r\n      const colliderComponent = message.data.get(ColliderComponent);\r\n      colliderComponent.$colliderAdded.subscribe(this._trackCollider);\r\n      colliderComponent.$colliderRemoved.subscribe(this._untrackCollider);\r\n      const collider = colliderComponent.get();\r\n      if (collider) {\r\n        this._processor.track(collider);\r\n      }\r\n    } else {\r\n      const colliderComponent = message.data.get(ColliderComponent);\r\n      const collider = colliderComponent.get();\r\n      if (colliderComponent && collider) {\r\n        this._processor.untrack(collider);\r\n      }\r\n    }\r\n  }\r\n\r\n  initialize(scene: Scene) {\r\n    this._engine = scene.engine;\r\n  }\r\n\r\n  update(_entities: Entity[], elapsedMs: number): void {\r\n    if (!Physics.enabled) {\r\n      return;\r\n    }\r\n\r\n    // Collect up all the colliders\r\n    let colliders: Collider[] = [];\r\n    for (const entity of _entities) {\r\n      const colliderComp = entity.get(ColliderComponent);\r\n      const collider = colliderComp?.get();\r\n      if (colliderComp && colliderComp.owner?.active && collider) {\r\n        colliderComp.update();\r\n        if (collider instanceof CompositeCollider) {\r\n          colliders = colliders.concat(collider.getColliders());\r\n        } else {\r\n          colliders.push(collider);\r\n        }\r\n      }\r\n    }\r\n\r\n    // Update the spatial partitioning data structures\r\n    // TODO if collider invalid it will break the processor\r\n    // TODO rename \"update\" to something more specific\r\n    this._processor.update(colliders);\r\n\r\n    // Run broadphase on all colliders and locates potential collisions\r\n    const pairs = this._processor.broadphase(colliders, elapsedMs);\r\n\r\n    this._currentFrameContacts.clear();\r\n\r\n    // Given possible pairs find actual contacts\r\n    let contacts = this._processor.narrowphase(pairs, this._engine.debug.stats.currFrame);\r\n\r\n    const solver: CollisionSolver = this.getSolver();\r\n\r\n    // Solve, this resolves the position/velocity so entities aren't overlapping\r\n    contacts = solver.solve(contacts);\r\n\r\n    // Record contacts for start/end\r\n    for (const contact of contacts) {\r\n      // Process composite ids, things with the same composite id are treated as the same collider for start/end\r\n      const index = contact.id.indexOf('|');\r\n      if (index > 0) {\r\n        const compositeId = contact.id.substring(index + 1);\r\n        this._currentFrameContacts.set(compositeId, contact);\r\n      } else {\r\n        this._currentFrameContacts.set(contact.id, contact);\r\n      }\r\n    }\r\n\r\n    // Emit contact start/end events\r\n    this.runContactStartEnd();\r\n\r\n    // reset the last frame cache\r\n    this._lastFrameContacts.clear();\r\n\r\n    // Keep track of collisions contacts that have started or ended\r\n    this._lastFrameContacts = new Map(this._currentFrameContacts);\r\n  }\r\n\r\n  getSolver(): CollisionSolver {\r\n    return Physics.collisionResolutionStrategy === CollisionResolutionStrategy.Realistic ? this._realisticSolver : this._arcadeSolver;\r\n  }\r\n\r\n  debug(ex: ExcaliburGraphicsContext) {\r\n    this._processor.debug(ex);\r\n  }\r\n\r\n  public runContactStartEnd() {\r\n    // Composite collider collisions may have a duplicate id because we want to treat those as a singular start/end\r\n    for (const [id, c] of this._currentFrameContacts) {\r\n      // find all new contacts\r\n      if (!this._lastFrameContacts.has(id)) {\r\n        const colliderA = c.colliderA;\r\n        const colliderB = c.colliderB;\r\n        colliderA.events.emit('collisionstart', new CollisionStartEvent(colliderA, colliderB, c));\r\n        colliderA.events.emit('contactstart', new ContactStartEvent(colliderA, colliderB, c) as any);\r\n        colliderB.events.emit('collisionstart', new CollisionStartEvent(colliderB, colliderA, c));\r\n        colliderB.events.emit('contactstart', new ContactStartEvent(colliderB, colliderA, c) as any);\r\n      }\r\n    }\r\n\r\n    // find all contacts that have ceased\r\n    for (const [id, c] of this._lastFrameContacts) {\r\n      if (!this._currentFrameContacts.has(id)) {\r\n        const colliderA = c.colliderA;\r\n        const colliderB = c.colliderB;\r\n        colliderA.events.emit('collisionend', new CollisionEndEvent(colliderA, colliderB));\r\n        colliderA.events.emit('contactend', new ContactEndEvent(colliderA, colliderB) as any);\r\n        colliderB.events.emit('collisionend', new CollisionEndEvent(colliderB, colliderA));\r\n        colliderB.events.emit('contactend', new ContactEndEvent(colliderB, colliderA) as any);\r\n      }\r\n    }\r\n  }\r\n}\r\n","export type Constructor<T> = {\r\n  new (...args: any[]): T;\r\n};\r\n/**\r\n * Configurable helper extends base type and makes all properties available as option bag arguments\r\n * @internal\r\n * @param base\r\n */\r\nexport function Configurable<T extends Constructor<{}>>(base: T): T {\r\n  return class extends base {\r\n    public assign(props: Partial<T>) {\r\n      //set the value of every property that was passed in,\r\n      //if the constructor previously set this value, it will be overridden here\r\n      for (const k in props) {\r\n        // eslint-disable-next-line\r\n        if (typeof (<any>this)[k] !== 'function') {\r\n          // eslint-disable-next-line\r\n          (<any>this)[k] = (<any>props)[k];\r\n        }\r\n      }\r\n    }\r\n\r\n    constructor(...args: any[]) {\r\n      super(...args);\r\n      //get the number of arguments that aren't undefined. TS passes a value to all parameters\r\n      //of whatever ctor is the implementation, so args.length doesn't work here.\r\n      const size = args.filter(function(value) {\r\n        return value !== undefined;\r\n      }).length;\r\n      if (size === 1 && args[0] && typeof args[0] === 'object' && !(args[0] instanceof Array)) {\r\n        this.assign(args[0]);\r\n      }\r\n    }\r\n  };\r\n}\r\n","import { Engine } from './Engine';\r\nimport { Actor } from './Actor';\r\nimport { Color } from './Color';\r\nimport { Vector, vec } from './Math/vector';\r\nimport * as Util from './Util/Util';\r\nimport { Configurable } from './Configurable';\r\nimport { Random } from './Math/Random';\r\nimport { CollisionType } from './Collision/CollisionType';\r\nimport { TransformComponent } from './EntityComponentSystem/Components/TransformComponent';\r\nimport { GraphicsComponent } from './Graphics/GraphicsComponent';\r\nimport { Entity } from './EntityComponentSystem/Entity';\r\nimport { Sprite } from './Graphics/Sprite';\r\nimport { BoundingBox } from './Collision/BoundingBox';\r\nimport { clamp, randomInRange } from './Math/util';\r\n\r\n/**\r\n * An enum that represents the types of emitter nozzles\r\n */\r\nexport enum EmitterType {\r\n  /**\r\n   * Constant for the circular emitter type\r\n   */\r\n  Circle,\r\n  /**\r\n   * Constant for the rectangular emitter type\r\n   */\r\n  Rectangle\r\n}\r\n\r\n/**\r\n * @hidden\r\n */\r\nexport class ParticleImpl extends Entity {\r\n  public position: Vector = new Vector(0, 0);\r\n  public velocity: Vector = new Vector(0, 0);\r\n  public acceleration: Vector = new Vector(0, 0);\r\n  public particleRotationalVelocity: number = 0;\r\n  public currentRotation: number = 0;\r\n\r\n  public focus: Vector = null;\r\n  public focusAccel: number = 0;\r\n  public opacity: number = 1;\r\n  public beginColor: Color = Color.White;\r\n  public endColor: Color = Color.White;\r\n\r\n  // Life is counted in ms\r\n  public life: number = 300;\r\n  public fadeFlag: boolean = false;\r\n\r\n  // Color transitions\r\n  private _rRate: number = 1;\r\n  private _gRate: number = 1;\r\n  private _bRate: number = 1;\r\n  private _aRate: number = 0;\r\n  private _currentColor: Color = Color.White;\r\n\r\n  public emitter: ParticleEmitter = null;\r\n  public particleSize: number = 5;\r\n  public particleSprite: Sprite = null;\r\n\r\n  public startSize: number;\r\n  public endSize: number;\r\n  public sizeRate: number = 0;\r\n  public elapsedMultiplier: number = 0;\r\n\r\n  public visible = true;\r\n  public isOffscreen = false;\r\n\r\n  public transform: TransformComponent;\r\n  public graphics: GraphicsComponent;\r\n\r\n  constructor(\r\n    emitterOrConfig: ParticleEmitter | ParticleArgs,\r\n    life?: number,\r\n    opacity?: number,\r\n    beginColor?: Color,\r\n    endColor?: Color,\r\n    position?: Vector,\r\n    velocity?: Vector,\r\n    acceleration?: Vector,\r\n    startSize?: number,\r\n    endSize?: number\r\n  ) {\r\n    super();\r\n    let emitter = emitterOrConfig;\r\n    if (emitter && !(emitterOrConfig instanceof ParticleEmitter)) {\r\n      const config = emitterOrConfig;\r\n      emitter = config.emitter;\r\n      life = config.life;\r\n      opacity = config.opacity;\r\n      endColor = config.endColor;\r\n      beginColor = config.beginColor;\r\n      position = config.position;\r\n      velocity = config.velocity;\r\n      acceleration = config.acceleration;\r\n      startSize = config.startSize;\r\n      endSize = config.endSize;\r\n    }\r\n    this.emitter = <ParticleEmitter>emitter;\r\n    this.life = life || this.life;\r\n    this.opacity = opacity || this.opacity;\r\n    this.endColor = endColor || this.endColor.clone();\r\n    this.beginColor = beginColor || this.beginColor.clone();\r\n    this._currentColor = this.beginColor.clone();\r\n    this.position = (position || this.position).add(this.emitter.pos);\r\n    this.velocity = velocity || this.velocity;\r\n    this.acceleration = acceleration || this.acceleration;\r\n    this._rRate = (this.endColor.r - this.beginColor.r) / this.life;\r\n    this._gRate = (this.endColor.g - this.beginColor.g) / this.life;\r\n    this._bRate = (this.endColor.b - this.beginColor.b) / this.life;\r\n    this._aRate = this.opacity / this.life;\r\n\r\n    this.startSize = startSize || 0;\r\n    this.endSize = endSize || 0;\r\n\r\n    if (this.endSize > 0 && this.startSize > 0) {\r\n      this.sizeRate = (this.endSize - this.startSize) / this.life;\r\n      this.particleSize = this.startSize;\r\n    }\r\n\r\n    this.addComponent((this.transform = new TransformComponent()));\r\n    this.addComponent((this.graphics = new GraphicsComponent()));\r\n\r\n    this.transform.pos = this.position;\r\n    this.transform.rotation = this.currentRotation;\r\n    this.transform.scale = vec(1, 1); // TODO wut\r\n    if (this.particleSprite) {\r\n      this.graphics.opacity = this.opacity;\r\n      this.graphics.use(this.particleSprite);\r\n    } else {\r\n      this.graphics.localBounds = BoundingBox.fromDimension(this.particleSize, this.particleSize, Vector.Half);\r\n      this.graphics.onPostDraw = (ctx) => {\r\n        ctx.save();\r\n        this.graphics.opacity = this.opacity;\r\n        const tmpColor = this._currentColor.clone();\r\n        tmpColor.a = 1;\r\n        ctx.debug.drawPoint(vec(0, 0), { color: tmpColor, size: this.particleSize });\r\n        ctx.restore();\r\n      };\r\n    }\r\n  }\r\n\r\n  public kill() {\r\n    this.emitter.removeParticle(this);\r\n  }\r\n\r\n  public update(_engine: Engine, delta: number) {\r\n    this.life = this.life - delta;\r\n    this.elapsedMultiplier = this.elapsedMultiplier + delta;\r\n\r\n    if (this.life < 0) {\r\n      this.kill();\r\n    }\r\n\r\n    if (this.fadeFlag) {\r\n      this.opacity = clamp(this._aRate * this.life, 0.0001, 1);\r\n    }\r\n\r\n    if (this.startSize > 0 && this.endSize > 0) {\r\n      this.particleSize = clamp(\r\n        this.sizeRate * delta + this.particleSize,\r\n        Math.min(this.startSize, this.endSize),\r\n        Math.max(this.startSize, this.endSize)\r\n      );\r\n    }\r\n\r\n    this._currentColor.r = clamp(this._currentColor.r + this._rRate * delta, 0, 255);\r\n    this._currentColor.g = clamp(this._currentColor.g + this._gRate * delta, 0, 255);\r\n    this._currentColor.b = clamp(this._currentColor.b + this._bRate * delta, 0, 255);\r\n    this._currentColor.a = clamp(this.opacity, 0.0001, 1);\r\n\r\n    if (this.focus) {\r\n      const accel = this.focus\r\n        .sub(this.position)\r\n        .normalize()\r\n        .scale(this.focusAccel)\r\n        .scale(delta / 1000);\r\n      this.velocity = this.velocity.add(accel);\r\n    } else {\r\n      this.velocity = this.velocity.add(this.acceleration.scale(delta / 1000));\r\n    }\r\n    this.position = this.position.add(this.velocity.scale(delta / 1000));\r\n\r\n    if (this.particleRotationalVelocity) {\r\n      this.currentRotation = (this.currentRotation + (this.particleRotationalVelocity * delta) / 1000) % (2 * Math.PI);\r\n    }\r\n\r\n    this.transform.pos = this.position;\r\n    this.transform.rotation = this.currentRotation;\r\n    this.transform.scale = vec(1, 1); // todo wut\r\n    this.graphics.opacity = this.opacity;\r\n  }\r\n}\r\n\r\nexport interface ParticleArgs extends Partial<ParticleImpl> {\r\n  emitter: ParticleEmitter;\r\n  position?: Vector;\r\n  velocity?: Vector;\r\n  acceleration?: Vector;\r\n  particleRotationalVelocity?: number;\r\n  currentRotation?: number;\r\n  particleSize?: number;\r\n  particleSprite?: Sprite;\r\n}\r\n\r\n/**\r\n * Particle is used in a [[ParticleEmitter]]\r\n */\r\nexport class Particle extends Configurable(ParticleImpl) {\r\n  constructor(config: ParticleArgs);\r\n  constructor(\r\n    emitter: ParticleEmitter,\r\n    life?: number,\r\n    opacity?: number,\r\n    beginColor?: Color,\r\n    endColor?: Color,\r\n    position?: Vector,\r\n    velocity?: Vector,\r\n    acceleration?: Vector,\r\n    startSize?: number,\r\n    endSize?: number\r\n  );\r\n  constructor(\r\n    emitterOrConfig: ParticleEmitter | ParticleArgs,\r\n    life?: number,\r\n    opacity?: number,\r\n    beginColor?: Color,\r\n    endColor?: Color,\r\n    position?: Vector,\r\n    velocity?: Vector,\r\n    acceleration?: Vector,\r\n    startSize?: number,\r\n    endSize?: number\r\n  ) {\r\n    super(emitterOrConfig, life, opacity, beginColor, endColor, position, velocity, acceleration, startSize, endSize);\r\n  }\r\n}\r\n\r\nexport interface ParticleEmitterArgs {\r\n  x?: number;\r\n  y?: number;\r\n  pos?: Vector;\r\n  width?: number;\r\n  height?: number;\r\n  isEmitting?: boolean;\r\n  minVel?: number;\r\n  maxVel?: number;\r\n  acceleration?: Vector;\r\n  minAngle?: number;\r\n  maxAngle?: number;\r\n  emitRate?: number;\r\n  particleLife?: number;\r\n  opacity?: number;\r\n  fadeFlag?: boolean;\r\n  focus?: Vector;\r\n  focusAccel?: number;\r\n  startSize?: number;\r\n  endSize?: number;\r\n  minSize?: number;\r\n  maxSize?: number;\r\n  beginColor?: Color;\r\n  endColor?: Color;\r\n  particleSprite?: Sprite;\r\n  emitterType?: EmitterType;\r\n  radius?: number;\r\n  particleRotationalVelocity?: number;\r\n  randomRotation?: boolean;\r\n  random?: Random;\r\n}\r\n\r\n/**\r\n * Using a particle emitter is a great way to create interesting effects\r\n * in your game, like smoke, fire, water, explosions, etc. `ParticleEmitter`\r\n * extend [[Actor]] allowing you to use all of the features that come with.\r\n */\r\nexport class ParticleEmitter extends Actor {\r\n  private _particlesToEmit: number = 0;\r\n\r\n  public numParticles: number = 0;\r\n\r\n  /**\r\n   * Random number generator\r\n   */\r\n  public random: Random;\r\n\r\n  /**\r\n   * Gets or sets the isEmitting flag\r\n   */\r\n  public isEmitting: boolean = true;\r\n  /**\r\n   * Gets or sets the backing particle collection\r\n   */\r\n  public particles: Particle[] = [];\r\n\r\n  /**\r\n   * Gets or sets the backing deadParticle collection\r\n   */\r\n  public deadParticles: Particle[] = [];\r\n\r\n  /**\r\n   * Gets or sets the minimum particle velocity\r\n   */\r\n  public minVel: number = 0;\r\n  /**\r\n   * Gets or sets the maximum particle velocity\r\n   */\r\n  public maxVel: number = 0;\r\n\r\n  /**\r\n   * Gets or sets the acceleration vector for all particles\r\n   */\r\n  public acceleration: Vector = new Vector(0, 0);\r\n\r\n  /**\r\n   * Gets or sets the minimum angle in radians\r\n   */\r\n  public minAngle: number = 0;\r\n  /**\r\n   * Gets or sets the maximum angle in radians\r\n   */\r\n  public maxAngle: number = 0;\r\n\r\n  /**\r\n   * Gets or sets the emission rate for particles (particles/sec)\r\n   */\r\n  public emitRate: number = 1; //particles/sec\r\n  /**\r\n   * Gets or sets the life of each particle in milliseconds\r\n   */\r\n  public particleLife: number = 2000;\r\n  /**\r\n   * Gets the opacity of each particle from 0 to 1.0\r\n   */\r\n  public get opacity(): number {\r\n    return super.graphics.opacity;\r\n  }\r\n  /**\r\n   * Gets the opacity of each particle from 0 to 1.0\r\n   */\r\n  public set opacity(opacity: number) {\r\n    super.graphics.opacity = opacity;\r\n  }\r\n  /**\r\n   * Gets or sets the fade flag which causes particles to gradually fade out over the course of their life.\r\n   */\r\n  public fadeFlag: boolean = false;\r\n\r\n  /**\r\n   * Gets or sets the optional focus where all particles should accelerate towards\r\n   */\r\n  public focus: Vector = null;\r\n  /**\r\n   * Gets or sets the acceleration for focusing particles if a focus has been specified\r\n   */\r\n  public focusAccel: number = null;\r\n  /**\r\n   * Gets or sets the optional starting size for the particles\r\n   */\r\n  public startSize: number = null;\r\n  /**\r\n   * Gets or sets the optional ending size for the particles\r\n   */\r\n  public endSize: number = null;\r\n\r\n  /**\r\n   * Gets or sets the minimum size of all particles\r\n   */\r\n  public minSize: number = 5;\r\n  /**\r\n   * Gets or sets the maximum size of all particles\r\n   */\r\n  public maxSize: number = 5;\r\n\r\n  /**\r\n   * Gets or sets the beginning color of all particles\r\n   */\r\n  public beginColor: Color = Color.White;\r\n  /**\r\n   * Gets or sets the ending color of all particles\r\n   */\r\n  public endColor: Color = Color.White;\r\n\r\n  private _sprite: Sprite = null;\r\n  /**\r\n   * Gets or sets the sprite that a particle should use\r\n   */\r\n  public get particleSprite(): Sprite {\r\n    return this._sprite;\r\n  }\r\n\r\n  public set particleSprite(val: Sprite) {\r\n    if (val) {\r\n      this._sprite = val;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Gets or sets the emitter type for the particle emitter\r\n   */\r\n  public emitterType: EmitterType = EmitterType.Rectangle;\r\n\r\n  /**\r\n   * Gets or sets the emitter radius, only takes effect when the [[emitterType]] is [[EmitterType.Circle]]\r\n   */\r\n  public radius: number = 0;\r\n\r\n  /**\r\n   * Gets or sets the particle rotational speed velocity\r\n   */\r\n  public particleRotationalVelocity: number = 0;\r\n\r\n  /**\r\n   * Indicates whether particles should start with a random rotation\r\n   */\r\n  public randomRotation: boolean = false;\r\n\r\n  /**\r\n   * @param config particle emitter options bag\r\n   */\r\n  constructor(config: ParticleEmitterArgs) {\r\n    super({ width: config.width ?? 0, height: config.height ?? 0 });\r\n\r\n    const {\r\n      x,\r\n      y,\r\n      pos,\r\n      isEmitting,\r\n      minVel,\r\n      maxVel,\r\n      acceleration,\r\n      minAngle,\r\n      maxAngle,\r\n      emitRate,\r\n      particleLife,\r\n      opacity,\r\n      fadeFlag,\r\n      focus,\r\n      focusAccel,\r\n      startSize,\r\n      endSize,\r\n      minSize,\r\n      maxSize,\r\n      beginColor,\r\n      endColor,\r\n      particleSprite,\r\n      emitterType,\r\n      radius,\r\n      particleRotationalVelocity,\r\n      randomRotation,\r\n      random\r\n    } = { ...config };\r\n\r\n    this.pos = pos ?? vec(x ?? 0, y ?? 0);\r\n    this.isEmitting = isEmitting ?? this.isEmitting;\r\n    this.minVel = minVel ?? this.minVel;\r\n    this.maxVel = maxVel ?? this.maxVel;\r\n    this.acceleration = acceleration ?? this.acceleration;\r\n    this.minAngle = minAngle ?? this.minAngle;\r\n    this.maxAngle = maxAngle ?? this.maxAngle;\r\n    this.emitRate = emitRate ?? this.emitRate;\r\n    this.particleLife = particleLife ?? this.particleLife;\r\n    this.opacity = opacity ?? this.opacity;\r\n    this.fadeFlag = fadeFlag ?? this.fadeFlag;\r\n    this.focus = focus ?? this.focus;\r\n    this.focusAccel = focusAccel ?? this.focusAccel;\r\n    this.startSize = startSize ?? this.startSize;\r\n    this.endSize = endSize ?? this.endSize;\r\n    this.minSize = minSize ?? this.minSize;\r\n    this.maxSize = maxSize ?? this.maxSize;\r\n    this.beginColor = beginColor ?? this.beginColor;\r\n    this.endColor = endColor ?? this.endColor;\r\n    this.particleSprite = particleSprite ?? this.particleSprite;\r\n    this.emitterType = emitterType ?? this.emitterType;\r\n    this.radius = radius ?? this.radius;\r\n    this.particleRotationalVelocity = particleRotationalVelocity ?? this.particleRotationalVelocity;\r\n    this.randomRotation = randomRotation ?? this.randomRotation;\r\n\r\n    this.body.collisionType = CollisionType.PreventCollision;\r\n\r\n    this.random = random ?? new Random();\r\n  }\r\n\r\n  public removeParticle(particle: Particle) {\r\n    this.deadParticles.push(particle);\r\n  }\r\n\r\n  /**\r\n   * Causes the emitter to emit particles\r\n   * @param particleCount  Number of particles to emit right now\r\n   */\r\n  public emitParticles(particleCount: number) {\r\n    for (let i = 0; i < particleCount; i++) {\r\n      const p = this._createParticle();\r\n      this.particles.push(p);\r\n      if (this?.scene?.world) {\r\n        this.scene.world.add(p);\r\n      }\r\n    }\r\n  }\r\n\r\n  public clearParticles() {\r\n    this.particles.length = 0;\r\n  }\r\n\r\n  // Creates a new particle given the constraints of the emitter\r\n  private _createParticle(): Particle {\r\n    // todo implement emitter constraints;\r\n    let ranX = 0;\r\n    let ranY = 0;\r\n\r\n    const angle = randomInRange(this.minAngle, this.maxAngle, this.random);\r\n    const vel = randomInRange(this.minVel, this.maxVel, this.random);\r\n    const size = this.startSize || randomInRange(this.minSize, this.maxSize, this.random);\r\n    const dx = vel * Math.cos(angle);\r\n    const dy = vel * Math.sin(angle);\r\n\r\n    if (this.emitterType === EmitterType.Rectangle) {\r\n      ranX = randomInRange(0, this.width, this.random);\r\n      ranY = randomInRange(0, this.height, this.random);\r\n    } else if (this.emitterType === EmitterType.Circle) {\r\n      const radius = randomInRange(0, this.radius, this.random);\r\n      ranX = radius * Math.cos(angle);\r\n      ranY = radius * Math.sin(angle);\r\n    }\r\n\r\n    const p = new Particle(\r\n      this,\r\n      this.particleLife,\r\n      this.opacity,\r\n      this.beginColor,\r\n      this.endColor,\r\n      new Vector(ranX, ranY),\r\n      new Vector(dx, dy),\r\n      this.acceleration,\r\n      this.startSize,\r\n      this.endSize\r\n    );\r\n    p.fadeFlag = this.fadeFlag;\r\n    p.particleSize = size;\r\n    if (this.particleSprite) {\r\n      p.particleSprite = this.particleSprite;\r\n      p.graphics.opacity = this.opacity;\r\n      p.graphics.use(this._sprite);\r\n    }\r\n    p.particleRotationalVelocity = this.particleRotationalVelocity;\r\n    if (this.randomRotation) {\r\n      p.currentRotation = randomInRange(0, Math.PI * 2, this.random);\r\n    }\r\n    if (this.focus) {\r\n      p.focus = this.focus.add(new Vector(this.pos.x, this.pos.y));\r\n      p.focusAccel = this.focusAccel;\r\n    }\r\n    return p;\r\n  }\r\n\r\n  public update(engine: Engine, delta: number) {\r\n    super.update(engine, delta);\r\n\r\n    if (this.isEmitting) {\r\n      this._particlesToEmit += this.emitRate * (delta / 1000);\r\n      if (this._particlesToEmit > 1.0) {\r\n        this.emitParticles(Math.floor(this._particlesToEmit));\r\n        this._particlesToEmit = this._particlesToEmit - Math.floor(this._particlesToEmit);\r\n      }\r\n    }\r\n\r\n    // deferred removal\r\n    for (let i = 0; i < this.deadParticles.length; i++) {\r\n      Util.removeItemFromArray(this.deadParticles[i], this.particles);\r\n      if (this?.scene?.world) {\r\n        this.scene.world.remove(this.deadParticles[i], false);\r\n      }\r\n    }\r\n    this.deadParticles.length = 0;\r\n  }\r\n}\r\n","import { ExcaliburGraphicsContext } from './Context/ExcaliburGraphicsContext';\r\nimport { Scene } from '../Scene';\r\nimport { GraphicsComponent } from './GraphicsComponent';\r\nimport { vec, Vector } from '../Math/vector';\r\nimport { CoordPlane, TransformComponent } from '../EntityComponentSystem/Components/TransformComponent';\r\nimport { Entity } from '../EntityComponentSystem/Entity';\r\nimport { Camera } from '../Camera';\r\nimport { AddedEntity, isAddedSystemEntity, RemovedEntity, System, SystemType } from '../EntityComponentSystem';\r\nimport { Engine } from '../Engine';\r\nimport { GraphicsGroup } from '.';\r\nimport { Particle } from '../Particles';\r\nimport { ParallaxComponent } from './ParallaxComponent';\r\n\r\nexport class GraphicsSystem extends System<TransformComponent | GraphicsComponent> {\r\n  public readonly types = ['ex.transform', 'ex.graphics'] as const;\r\n  public readonly systemType = SystemType.Draw;\r\n  public priority = 0;\r\n  private _token = 0;\r\n  private _graphicsContext: ExcaliburGraphicsContext;\r\n  private _camera: Camera;\r\n  private _engine: Engine;\r\n\r\n  private _sortedTransforms: TransformComponent[] = [];\r\n  public get sortedTransforms() {\r\n    return this._sortedTransforms;\r\n  }\r\n\r\n  public initialize(scene: Scene): void {\r\n    this._camera = scene.camera;\r\n    this._engine = scene.engine;\r\n  }\r\n\r\n  private _zHasChanged = false;\r\n  private _zIndexUpdate = () => {\r\n    this._zHasChanged = true;\r\n  };\r\n\r\n  public preupdate(): void {\r\n    // Graphics context could be switched to fallback in a new frame\r\n    this._graphicsContext = this._engine.graphicsContext;\r\n    if (this._zHasChanged) {\r\n      this._sortedTransforms.sort((a, b) => {\r\n        return a.z - b.z;\r\n      });\r\n      this._zHasChanged = false;\r\n    }\r\n  }\r\n\r\n  public notify(entityAddedOrRemoved: AddedEntity | RemovedEntity): void {\r\n    if (isAddedSystemEntity(entityAddedOrRemoved)) {\r\n      const tx = entityAddedOrRemoved.data.get(TransformComponent);\r\n      this._sortedTransforms.push(tx);\r\n      tx.zIndexChanged$.subscribe(this._zIndexUpdate);\r\n      this._zHasChanged = true;\r\n    } else {\r\n      const tx = entityAddedOrRemoved.data.get(TransformComponent);\r\n      tx.zIndexChanged$.unsubscribe(this._zIndexUpdate);\r\n      const index = this._sortedTransforms.indexOf(tx);\r\n      if (index > -1) {\r\n        this._sortedTransforms.splice(index, 1);\r\n      }\r\n    }\r\n  }\r\n\r\n  public update(_entities: Entity[], delta: number): void {\r\n    this._token++;\r\n    let graphics: GraphicsComponent;\r\n\r\n    // This is a performance enhancement, most things are in world space\r\n    // so if we can only do this once saves a ton of transform updates\r\n    this._graphicsContext.save();\r\n    if (this._camera) {\r\n      this._camera.draw(this._graphicsContext);\r\n    }\r\n    for (const transform of this._sortedTransforms) {\r\n      const entity = transform.owner as Entity;\r\n\r\n      // If the entity is offscreen skip\r\n      if (entity.hasTag('ex.offscreen')) {\r\n        continue;\r\n      }\r\n\r\n      graphics = entity.get(GraphicsComponent);\r\n      // Exit if graphics set to not visible\r\n      if (!graphics.visible) {\r\n        continue;\r\n      }\r\n\r\n      // This optionally sets our camera based on the entity coord plan (world vs. screen)\r\n      if (transform.coordPlane === CoordPlane.Screen) {\r\n        this._graphicsContext.restore();\r\n      }\r\n\r\n      this._graphicsContext.save();\r\n\r\n      // Tick any graphics state (but only once) for animations and graphics groups\r\n      graphics.update(delta, this._token);\r\n\r\n      // Apply parallax\r\n      const parallax = entity.get(ParallaxComponent);\r\n      if (parallax) {\r\n        // We use the Tiled formula\r\n        // https://doc.mapeditor.org/en/latest/manual/layers/#parallax-scrolling-factor\r\n        // cameraPos * (1 - parallaxFactor)\r\n        const oneMinusFactor = Vector.One.sub(parallax.parallaxFactor);\r\n        const parallaxOffset = this._camera.pos.scale(oneMinusFactor);\r\n        this._graphicsContext.translate(parallaxOffset.x, parallaxOffset.y);\r\n      }\r\n\r\n      // Position the entity\r\n      this._applyTransform(entity);\r\n\r\n      // Optionally run the onPreDraw graphics lifecycle draw\r\n      if (graphics.onPreDraw) {\r\n        graphics.onPreDraw(this._graphicsContext, delta);\r\n      }\r\n\r\n      // TODO remove this hack on the particle redo\r\n      const particleOpacity = (entity instanceof Particle) ? entity.opacity : 1;\r\n      this._graphicsContext.opacity = graphics.opacity * particleOpacity;\r\n\r\n      // Draw the graphics component\r\n      this._drawGraphicsComponent(graphics);\r\n\r\n      // Optionally run the onPostDraw graphics lifecycle draw\r\n      if (graphics.onPostDraw) {\r\n        graphics.onPostDraw(this._graphicsContext, delta);\r\n      }\r\n\r\n      this._graphicsContext.restore();\r\n\r\n      // Reset the transform back to the original world space\r\n      if (transform.coordPlane === CoordPlane.Screen) {\r\n        this._graphicsContext.save();\r\n        if (this._camera) {\r\n          this._camera.draw(this._graphicsContext);\r\n        }\r\n      }\r\n    }\r\n    this._graphicsContext.restore();\r\n  }\r\n\r\n  private _drawGraphicsComponent(graphicsComponent: GraphicsComponent) {\r\n    if (graphicsComponent.visible) {\r\n      // this should be moved to the graphics system\r\n      for (const layer of graphicsComponent.layers.get()) {\r\n        for (const { graphic, options } of layer.graphics) {\r\n          let anchor = graphicsComponent.anchor;\r\n          let offset = graphicsComponent.offset;\r\n          if (options?.anchor) {\r\n            anchor = options.anchor;\r\n          }\r\n          if (options?.offset) {\r\n            offset = options.offset;\r\n          }\r\n          // See https://github.com/excaliburjs/Excalibur/pull/619 for discussion on this formula\r\n          const offsetX = -graphic.width * anchor.x + offset.x;\r\n          const offsetY = -graphic.height * anchor.y + offset.y;\r\n\r\n          graphic?.draw(this._graphicsContext, offsetX + layer.offset.x, offsetY + layer.offset.y);\r\n\r\n          if (this._engine?.isDebug && this._engine.debug.graphics.showBounds) {\r\n            const offset = vec(offsetX + layer.offset.x, offsetY + layer.offset.y);\r\n            if (graphic instanceof GraphicsGroup) {\r\n              for (const g of graphic.members) {\r\n                g.graphic?.localBounds.translate(offset.add(g.pos)).draw(this._graphicsContext, this._engine.debug.graphics.boundsColor);\r\n              }\r\n            } else {\r\n              /* istanbul ignore next */\r\n              graphic?.localBounds.translate(offset).draw(this._graphicsContext, this._engine.debug.graphics.boundsColor);\r\n            }\r\n          }\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * This applies the current entity transform to the graphics context\r\n   * @param entity\r\n   */\r\n  private _applyTransform(entity: Entity): void {\r\n    const ancestors = entity.getAncestors();\r\n    for (const ancestor of ancestors) {\r\n      const transform = ancestor?.get(TransformComponent);\r\n      if (transform) {\r\n        this._graphicsContext.z = transform.z;\r\n        this._graphicsContext.translate(transform.pos.x, transform.pos.y);\r\n        this._graphicsContext.scale(transform.scale.x, transform.scale.y);\r\n        this._graphicsContext.rotate(transform.rotation);\r\n      }\r\n    }\r\n  }\r\n}\r\n","import { Engine } from '../Engine';\r\nimport { Scene } from '../Scene';\r\nimport { Camera } from '../Camera';\r\nimport { MotionComponent } from '../EntityComponentSystem/Components/MotionComponent';\r\nimport { ColliderComponent } from '../Collision/ColliderComponent';\r\nimport { CoordPlane, Entity, TransformComponent } from '../EntityComponentSystem';\r\nimport { System, SystemType } from '../EntityComponentSystem/System';\r\nimport { ExcaliburGraphicsContext } from '../Graphics/Context/ExcaliburGraphicsContext';\r\nimport { vec, Vector } from '../Math/vector';\r\nimport { toDegrees } from '../Math/util';\r\nimport { BodyComponent, CollisionSystem, CompositeCollider, GraphicsComponent, Particle } from '..';\r\nimport { DebugGraphicsComponent } from '../Graphics/DebugGraphicsComponent';\r\n\r\nexport class DebugSystem extends System<TransformComponent> {\r\n  public readonly types = ['ex.transform'] as const;\r\n  public readonly systemType = SystemType.Draw;\r\n  public priority = 999; // lowest priority\r\n  private _graphicsContext: ExcaliburGraphicsContext;\r\n  private _collisionSystem: CollisionSystem;\r\n  private _camera: Camera;\r\n  private _engine: Engine;\r\n\r\n  public initialize(scene: Scene): void {\r\n    this._graphicsContext = scene.engine.graphicsContext;\r\n    this._camera = scene.camera;\r\n    this._engine = scene.engine;\r\n    this._collisionSystem = scene.world.systemManager.get(CollisionSystem);\r\n  }\r\n\r\n  update(entities: Entity[], _delta: number): void {\r\n    if (!this._engine.isDebug) {\r\n      return;\r\n    }\r\n\r\n    const filterSettings = this._engine.debug.filter;\r\n\r\n    let id: number;\r\n    let name: string;\r\n    const entitySettings = this._engine.debug.entity;\r\n\r\n    let tx: TransformComponent;\r\n    const txSettings = this._engine.debug.transform;\r\n\r\n    let motion: MotionComponent;\r\n    const motionSettings = this._engine.debug.motion;\r\n\r\n    let colliderComp: ColliderComponent;\r\n    const colliderSettings = this._engine.debug.collider;\r\n\r\n    const physicsSettings = this._engine.debug.physics;\r\n\r\n    let graphics: GraphicsComponent;\r\n    const graphicsSettings = this._engine.debug.graphics;\r\n\r\n    let debugDraw: DebugGraphicsComponent;\r\n\r\n    let body: BodyComponent;\r\n    const bodySettings = this._engine.debug.body;\r\n\r\n    const cameraSettings = this._engine.debug.camera;\r\n    for (const entity of entities) {\r\n      if (entity.hasTag('offscreen')) {\r\n        // skip offscreen entities\r\n        continue;\r\n      }\r\n      if (entity instanceof Particle) {\r\n        // Particles crush the renderer :(\r\n        continue;\r\n      }\r\n      if (filterSettings.useFilter) {\r\n        const allIds = filterSettings.ids.length === 0;\r\n        const idMatch = allIds || filterSettings.ids.includes(entity.id);\r\n        if (!idMatch) {\r\n          continue;\r\n        }\r\n        const allNames = filterSettings.nameQuery === '';\r\n        const nameMatch = allNames || entity.name.includes(filterSettings.nameQuery);\r\n        if (!nameMatch) {\r\n          continue;\r\n        }\r\n      }\r\n\r\n      let cursor = Vector.Zero;\r\n      const lineHeight = vec(0, 16);\r\n      id = entity.id;\r\n      name = entity.name;\r\n      tx = entity.get(TransformComponent);\r\n\r\n      // This optionally sets our camera based on the entity coord plan (world vs. screen)\r\n      this._pushCameraTransform(tx);\r\n\r\n      this._graphicsContext.save();\r\n\r\n      this._applyTransform(entity);\r\n      if (tx) {\r\n        if (txSettings.showAll || txSettings.showPosition) {\r\n          this._graphicsContext.debug.drawPoint(Vector.Zero, { size: 4, color: txSettings.positionColor });\r\n        }\r\n        if (txSettings.showAll || txSettings.showPositionLabel) {\r\n          this._graphicsContext.debug.drawText(`pos${tx.pos.toString(2)}`, cursor);\r\n          cursor = cursor.add(lineHeight);\r\n        }\r\n        if (txSettings.showAll || txSettings.showZIndex) {\r\n          this._graphicsContext.debug.drawText(`z(${tx.z.toFixed(1)})`, cursor);\r\n          cursor = cursor.add(lineHeight);\r\n        }\r\n\r\n        if (entitySettings.showAll || entitySettings.showId) {\r\n          this._graphicsContext.debug.drawText(`id(${id}) ${tx.parent ? 'child of id(' + tx.parent?.owner?.id + ')' : ''}`, cursor);\r\n          cursor = cursor.add(lineHeight);\r\n        }\r\n\r\n        if (entitySettings.showAll || entitySettings.showName) {\r\n          this._graphicsContext.debug.drawText(`name(${name})`, cursor);\r\n          cursor = cursor.add(lineHeight);\r\n        }\r\n\r\n        if (txSettings.showAll || txSettings.showRotation) {\r\n          this._graphicsContext.drawLine(\r\n            Vector.Zero,\r\n            Vector.fromAngle(tx.rotation).scale(50).add(Vector.Zero),\r\n            txSettings.rotationColor,\r\n            2\r\n          );\r\n          this._graphicsContext.debug.drawText(`rot deg(${toDegrees(tx.rotation).toFixed(2)})`, cursor);\r\n          cursor = cursor.add(lineHeight);\r\n        }\r\n\r\n        if (txSettings.showAll || txSettings.showScale) {\r\n          this._graphicsContext.drawLine(Vector.Zero, tx.scale.add(Vector.Zero), txSettings.scaleColor, 2);\r\n        }\r\n      }\r\n\r\n      graphics = entity.get(GraphicsComponent);\r\n      if (graphics) {\r\n        if (graphicsSettings.showAll || graphicsSettings.showBounds) {\r\n          const bounds = graphics.localBounds;\r\n          bounds.draw(this._graphicsContext, graphicsSettings.boundsColor);\r\n        }\r\n      }\r\n\r\n      debugDraw = entity.get(DebugGraphicsComponent);\r\n      if (debugDraw) {\r\n        if (!debugDraw.useTransform) {\r\n          this._graphicsContext.restore();\r\n        }\r\n        debugDraw.draw(this._graphicsContext);\r\n        if (!debugDraw.useTransform) {\r\n          this._graphicsContext.save();\r\n          this._applyTransform(entity);\r\n        }\r\n      }\r\n\r\n      body = entity.get(BodyComponent);\r\n      if (body) {\r\n        if (bodySettings.showAll || bodySettings.showCollisionGroup) {\r\n          this._graphicsContext.debug.drawText(`collision group(${body.group.name})`, cursor);\r\n          cursor = cursor.add(lineHeight);\r\n        }\r\n\r\n        if (bodySettings.showAll || bodySettings.showCollisionType) {\r\n          this._graphicsContext.debug.drawText(`collision type(${body.collisionType})`, cursor);\r\n          cursor = cursor.add(lineHeight);\r\n        }\r\n\r\n        if (bodySettings.showAll || bodySettings.showMass) {\r\n          this._graphicsContext.debug.drawText(`mass(${body.mass})`, cursor);\r\n          cursor = cursor.add(lineHeight);\r\n        }\r\n\r\n        if (bodySettings.showAll || bodySettings.showMotion) {\r\n          this._graphicsContext.debug.drawText(`motion(${body.sleepMotion})`, cursor);\r\n          cursor = cursor.add(lineHeight);\r\n        }\r\n\r\n        if (bodySettings.showAll || bodySettings.showSleeping) {\r\n          this._graphicsContext.debug.drawText(`sleeping(${body.canSleep ? body.sleeping: 'cant sleep'})`, cursor);\r\n          cursor = cursor.add(lineHeight);\r\n        }\r\n      }\r\n\r\n      this._graphicsContext.restore();\r\n\r\n      motion = entity.get(MotionComponent);\r\n      if (motion) {\r\n        if (motionSettings.showAll || motionSettings.showVelocity) {\r\n          this._graphicsContext.debug.drawText(`vel${motion.vel.toString(2)}`, cursor.add(tx.globalPos));\r\n          this._graphicsContext.drawLine(tx.globalPos, tx.globalPos.add(motion.vel), motionSettings.velocityColor, 2);\r\n          cursor = cursor.add(lineHeight);\r\n        }\r\n\r\n        if (motionSettings.showAll || motionSettings.showAcceleration) {\r\n          this._graphicsContext.drawLine(tx.globalPos, tx.globalPos.add(motion.acc), motionSettings.accelerationColor, 2);\r\n        }\r\n      }\r\n\r\n      // Colliders live in world space already so after the restore()\r\n      colliderComp = entity.get(ColliderComponent);\r\n      if (colliderComp) {\r\n        const collider = colliderComp.get();\r\n        if ((colliderSettings.showAll || colliderSettings.showGeometry) && collider) {\r\n          collider.debug(this._graphicsContext, colliderSettings.geometryColor);\r\n        }\r\n        if (colliderSettings.showAll || colliderSettings.showBounds) {\r\n          if (collider instanceof CompositeCollider) {\r\n            const colliders = collider.getColliders();\r\n            for (const collider of colliders) {\r\n              const bounds = collider.bounds;\r\n              const pos = vec(bounds.left, bounds.top);\r\n              this._graphicsContext.debug.drawRect(pos.x, pos.y, bounds.width, bounds.height, { color: colliderSettings.boundsColor });\r\n              if (colliderSettings.showAll || colliderSettings.showOwner) {\r\n                this._graphicsContext.debug.drawText(`owner id(${collider.owner.id})`, pos);\r\n              }\r\n            }\r\n            colliderComp.bounds.draw(this._graphicsContext, colliderSettings.boundsColor);\r\n          } else if (collider) {\r\n            const bounds = colliderComp.bounds;\r\n            const pos = vec(bounds.left, bounds.top);\r\n            this._graphicsContext.debug.drawRect(pos.x, pos.y, bounds.width, bounds.height, { color: colliderSettings.boundsColor });\r\n            if (colliderSettings.showAll || colliderSettings.showOwner) {\r\n              this._graphicsContext.debug.drawText(`owner id(${colliderComp.owner.id})`, pos);\r\n            }\r\n          }\r\n        }\r\n      }\r\n\r\n      this._popCameraTransform(tx);\r\n    }\r\n\r\n    this._graphicsContext.save();\r\n    this._camera.draw(this._graphicsContext);\r\n    if (physicsSettings.showAll || physicsSettings.showBroadphaseSpacePartitionDebug) {\r\n      this._collisionSystem.debug(this._graphicsContext);\r\n    }\r\n    if (physicsSettings.showAll || physicsSettings.showCollisionContacts || physicsSettings.showCollisionNormals) {\r\n      for (const [_, contact] of this._engine.debug.stats.currFrame.physics.contacts) {\r\n        if (physicsSettings.showAll || physicsSettings.showCollisionContacts) {\r\n          for (const point of contact.points) {\r\n            this._graphicsContext.debug.drawPoint(point, { size: 5, color: physicsSettings.collisionContactColor });\r\n          }\r\n        }\r\n\r\n        if (physicsSettings.showAll || physicsSettings.showCollisionNormals) {\r\n          for (const point of contact.points) {\r\n            this._graphicsContext.debug.drawLine(point, contact.normal.scale(30).add(point), {\r\n              color: physicsSettings.collisionNormalColor\r\n            });\r\n          }\r\n        }\r\n      }\r\n    }\r\n    this._graphicsContext.restore();\r\n\r\n    if (cameraSettings) {\r\n      this._graphicsContext.save();\r\n      this._camera.draw(this._graphicsContext);\r\n      if (cameraSettings.showAll || cameraSettings.showFocus) {\r\n        this._graphicsContext.drawCircle(this._camera.pos, 4, cameraSettings.focusColor);\r\n      }\r\n      if (cameraSettings.showAll || cameraSettings.showZoom) {\r\n        this._graphicsContext.debug.drawText(`zoom(${this._camera.zoom})`, this._camera.pos);\r\n      }\r\n      this._graphicsContext.restore();\r\n    }\r\n\r\n    this._graphicsContext.flush();\r\n  }\r\n\r\n  /**\r\n   * This applies the current entity transform to the graphics context\r\n   * @param entity\r\n   */\r\n  private _applyTransform(entity: Entity): void {\r\n    const ancestors = entity.getAncestors();\r\n    for (const ancestor of ancestors) {\r\n      const transform = ancestor?.get(TransformComponent);\r\n      if (transform) {\r\n        this._graphicsContext.translate(transform.pos.x, transform.pos.y);\r\n        this._graphicsContext.scale(transform.scale.x, transform.scale.y);\r\n        this._graphicsContext.rotate(transform.rotation);\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Applies the current camera transform if in world coordinates\r\n   * @param transform\r\n   */\r\n  private _pushCameraTransform(transform: TransformComponent) {\r\n    // Establish camera offset per entity\r\n    if (transform.coordPlane === CoordPlane.World) {\r\n      this._graphicsContext.save();\r\n      if (this._camera) {\r\n        this._camera.draw(this._graphicsContext);\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Resets the current camera transform if in world coordinates\r\n   * @param transform\r\n   */\r\n  private _popCameraTransform(transform: TransformComponent) {\r\n    if (transform.coordPlane === CoordPlane.World) {\r\n      // Apply camera world offset\r\n      this._graphicsContext.restore();\r\n    }\r\n  }\r\n}\r\n","import { ColliderComponent } from '../Collision/ColliderComponent';\r\nimport { Engine } from '../Engine';\r\nimport {\r\n  System,\r\n  TransformComponent,\r\n  SystemType,\r\n  Entity,\r\n  CoordPlane,\r\n  AddedEntity,\r\n  RemovedEntity,\r\n  isAddedSystemEntity\r\n} from '../EntityComponentSystem';\r\nimport { GraphicsComponent } from '../Graphics/GraphicsComponent';\r\nimport { Scene } from '../Scene';\r\nimport { PointerComponent } from './PointerComponent';\r\nimport { PointerEventReceiver } from './PointerEventReceiver';\r\nimport { PointerEvent } from './PointerEvent';\r\n\r\n/**\r\n * The PointerSystem is responsible for dispatching pointer events to entities\r\n * that need them.\r\n *\r\n * The PointerSystem can be optionally configured by the [[PointerComponent]], by default Entities use\r\n * the [[Collider]]'s shape for pointer events.\r\n */\r\nexport class PointerSystem extends System<TransformComponent | PointerComponent> {\r\n  public readonly types = ['ex.transform', 'ex.pointer'] as const;\r\n  public readonly systemType = SystemType.Update;\r\n  public priority = -1;\r\n\r\n  private _engine: Engine;\r\n  private _receiver: PointerEventReceiver;\r\n\r\n  /**\r\n   * Optionally override component configuration for all entities\r\n   */\r\n  public overrideUseColliderShape = false;\r\n  /**\r\n   * Optionally override component configuration for all entities\r\n   */\r\n  public overrideUseGraphicsBounds = false;\r\n\r\n  public lastFrameEntityToPointers = new Map<number, number[]>();\r\n  public currentFrameEntityToPointers = new Map<number, number[]>();\r\n\r\n  public initialize(scene: Scene): void {\r\n    this._engine = scene.engine;\r\n  }\r\n\r\n  private _sortedTransforms: TransformComponent[] = [];\r\n  private _sortedEntities: Entity[] = [];\r\n\r\n  private _zHasChanged = false;\r\n  private _zIndexUpdate = () => {\r\n    this._zHasChanged = true;\r\n  };\r\n\r\n  public preupdate(): void {\r\n    // event receiver might change per frame\r\n    this._receiver = this._engine.input.pointers;\r\n    if (this._zHasChanged) {\r\n      this._sortedTransforms.sort((a, b) => {\r\n        return b.z - a.z;\r\n      });\r\n      this._sortedEntities = this._sortedTransforms.map(t => t.owner);\r\n      this._zHasChanged = false;\r\n    }\r\n  }\r\n\r\n  public notify(entityAddedOrRemoved: AddedEntity | RemovedEntity): void {\r\n    if (isAddedSystemEntity(entityAddedOrRemoved)) {\r\n      const tx = entityAddedOrRemoved.data.get(TransformComponent);\r\n      this._sortedTransforms.push(tx);\r\n      this._sortedEntities.push(tx.owner);\r\n      tx.zIndexChanged$.subscribe(this._zIndexUpdate);\r\n      this._zHasChanged = true;\r\n    } else {\r\n      const tx = entityAddedOrRemoved.data.get(TransformComponent);\r\n      tx.zIndexChanged$.unsubscribe(this._zIndexUpdate);\r\n      const index = this._sortedTransforms.indexOf(tx);\r\n      if (index > -1) {\r\n        this._sortedTransforms.splice(index, 1);\r\n        this._sortedEntities.splice(index, 1);\r\n      }\r\n    }\r\n  }\r\n\r\n  public entityCurrentlyUnderPointer(entity: Entity, pointerId: number) {\r\n    return this.currentFrameEntityToPointers.has(entity.id) &&\r\n           this.currentFrameEntityToPointers.get(entity.id).includes(pointerId);\r\n  }\r\n\r\n  public entityWasUnderPointer(entity: Entity, pointerId: number) {\r\n    return this.lastFrameEntityToPointers.has(entity.id) &&\r\n           this.lastFrameEntityToPointers.get(entity.id).includes(pointerId);\r\n  }\r\n\r\n  public entered(entity: Entity, pointerId: number) {\r\n    return this.entityCurrentlyUnderPointer(entity, pointerId) &&\r\n           !this.lastFrameEntityToPointers.has(entity.id);\r\n  }\r\n\r\n  public left(entity: Entity, pointerId: number) {\r\n    return !this.currentFrameEntityToPointers.has(entity.id) &&\r\n            this.entityWasUnderPointer(entity, pointerId);\r\n  }\r\n\r\n  public addPointerToEntity(entity: Entity, pointerId: number) {\r\n    if (!this.currentFrameEntityToPointers.has(entity.id)) {\r\n      this.currentFrameEntityToPointers.set(entity.id, [pointerId]);\r\n      return;\r\n    }\r\n    const pointers = this.currentFrameEntityToPointers.get(entity.id);\r\n    this.currentFrameEntityToPointers.set(entity.id, pointers.concat(pointerId));\r\n  }\r\n\r\n  public update(_entities: Entity[]): void {\r\n    // Locate all the pointer/entity mappings\r\n    this._processPointerToEntity(this._sortedEntities);\r\n\r\n    // Dispatch pointer events on entities\r\n    this._dispatchEvents(this._sortedEntities);\r\n\r\n    // Clear last frame's events\r\n    this._receiver.update();\r\n    this.lastFrameEntityToPointers.clear();\r\n    this.lastFrameEntityToPointers = new Map<number, number[]>(this.currentFrameEntityToPointers);\r\n    this.currentFrameEntityToPointers.clear();\r\n    this._receiver.clear();\r\n  }\r\n\r\n  private _processPointerToEntity(entities: Entity[]) {\r\n    let transform: TransformComponent;\r\n    let collider: ColliderComponent;\r\n    let graphics: GraphicsComponent;\r\n    let pointer: PointerComponent;\r\n\r\n    // TODO probably a spatial partition optimization here to quickly query bounds for pointer\r\n    // doesn't seem to cause issues tho for perf\r\n\r\n    // Pre-process find entities under pointers\r\n    for (const entity of entities) {\r\n      transform = entity.get(TransformComponent);\r\n      pointer = entity.get(PointerComponent) ?? new PointerComponent;\r\n      // Check collider contains pointer\r\n      collider = entity.get(ColliderComponent);\r\n      if (collider && (pointer.useColliderShape || this.overrideUseColliderShape)) {\r\n        const geom = collider.get();\r\n        if (geom) {\r\n          for (const [pointerId, pos] of this._receiver.currentFramePointerCoords.entries()) {\r\n            if (geom.contains(transform.coordPlane === CoordPlane.World ? pos.worldPos : pos.screenPos)) {\r\n              this.addPointerToEntity(entity, pointerId);\r\n            }\r\n          }\r\n        }\r\n      }\r\n\r\n      // Check graphics contains pointer\r\n      graphics = entity.get(GraphicsComponent);\r\n      if (graphics && (pointer.useGraphicsBounds || this.overrideUseGraphicsBounds)) {\r\n        const graphicBounds = graphics.localBounds.transform(transform.getGlobalMatrix());\r\n        for (const [pointerId, pos] of this._receiver.currentFramePointerCoords.entries()) {\r\n          if (graphicBounds.contains(transform.coordPlane === CoordPlane.World ? pos.worldPos : pos.screenPos)) {\r\n            this.addPointerToEntity(entity, pointerId);\r\n          }\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  private _processDownAndEmit(entity: Entity): Map<number, PointerEvent> {\r\n    const lastDownPerPointer = new Map<number, PointerEvent>();\r\n    // Loop through down and dispatch to entities\r\n    for (const event of this._receiver.currentFrameDown) {\r\n      if (event.active && entity.active && this.entityCurrentlyUnderPointer(entity, event.pointerId)) {\r\n        entity.events.emit('pointerdown', event as any);\r\n        if (this._receiver.isDragStart(event.pointerId)) {\r\n          entity.events.emit('pointerdragstart', event as any);\r\n        }\r\n      }\r\n      lastDownPerPointer.set(event.pointerId, event);\r\n    }\r\n    return lastDownPerPointer;\r\n  }\r\n\r\n  private _processUpAndEmit(entity: Entity): Map<number, PointerEvent> {\r\n    const lastUpPerPointer = new Map<number, PointerEvent>();\r\n    // Loop through up and dispatch to entities\r\n    for (const event of this._receiver.currentFrameUp) {\r\n      if (event.active && entity.active && this.entityCurrentlyUnderPointer(entity, event.pointerId)) {\r\n        entity.events.emit('pointerup', event as any);\r\n        if (this._receiver.isDragEnd(event.pointerId)) {\r\n          entity.events.emit('pointerdragend', event as any);\r\n        }\r\n      }\r\n      lastUpPerPointer.set(event.pointerId, event);\r\n    }\r\n    return lastUpPerPointer;\r\n  }\r\n\r\n  private _processMoveAndEmit(entity: Entity): Map<number, PointerEvent> {\r\n    const lastMovePerPointer = new Map<number, PointerEvent>();\r\n    // Loop through move and dispatch to entities\r\n    for (const event of this._receiver.currentFrameMove) {\r\n      if (event.active && entity.active && this.entityCurrentlyUnderPointer(entity, event.pointerId)) {\r\n        // move\r\n        entity.events.emit('pointermove', event as any);\r\n\r\n        if (this._receiver.isDragging(event.pointerId)) {\r\n          entity.events.emit('pointerdragmove', event as any);\r\n        }\r\n      }\r\n      lastMovePerPointer.set(event.pointerId, event);\r\n    }\r\n    return lastMovePerPointer;\r\n  }\r\n\r\n  private _processEnterLeaveAndEmit(entity: Entity, lastUpDownMoveEvents: PointerEvent[]) {\r\n    // up, down, and move are considered for enter and leave\r\n    for (const event of lastUpDownMoveEvents) {\r\n      // enter\r\n      if (event.active && entity.active && this.entered(entity, event.pointerId)) {\r\n        entity.events.emit('pointerenter', event as any);\r\n        if (this._receiver.isDragging(event.pointerId)) {\r\n          entity.events.emit('pointerdragenter', event as any);\r\n        }\r\n        break;\r\n      }\r\n      if (event.active && entity.active &&\r\n          // leave can happen on move\r\n          (this.left(entity, event.pointerId) ||\r\n          // or leave can happen on pointer up\r\n          (this.entityCurrentlyUnderPointer(entity, event.pointerId) && event.type === 'up'))) {\r\n        entity.events.emit('pointerleave', event as any);\r\n        if (this._receiver.isDragging(event.pointerId)) {\r\n          entity.events.emit('pointerdragleave', event as any);\r\n        }\r\n        break;\r\n      }\r\n    }\r\n  }\r\n\r\n  private _processCancelAndEmit(entity: Entity) {\r\n    // cancel\r\n    for (const event of this._receiver.currentFrameCancel) {\r\n      if (event.active && entity.active && this.entityCurrentlyUnderPointer(entity, event.pointerId)){\r\n        entity.events.emit('pointercancel', event as any);\r\n      }\r\n    }\r\n  }\r\n\r\n  private _processWheelAndEmit(entity: Entity) {\r\n    // wheel\r\n    for (const event of this._receiver.currentFrameWheel) {\r\n      // Currently the wheel only fires under the primary pointer '0'\r\n      if (event.active && entity.active && this.entityCurrentlyUnderPointer(entity, 0)) {\r\n        entity.events.emit('pointerwheel', event as any);\r\n      }\r\n    }\r\n  }\r\n\r\n  private _dispatchEvents(entities: Entity[]) {\r\n    const lastFrameEntities = new Set(this.lastFrameEntityToPointers.keys());\r\n    const currentFrameEntities = new Set(this.currentFrameEntityToPointers.keys());\r\n    // Filter preserves z order\r\n    const entitiesWithEvents = entities.filter(e => lastFrameEntities.has(e.id) || currentFrameEntities.has(e.id));\r\n    let lastMovePerPointer: Map<number, PointerEvent>;\r\n    let lastUpPerPointer: Map<number, PointerEvent>;\r\n    let lastDownPerPointer: Map<number, PointerEvent>;\r\n    // Dispatch events in entity z order\r\n    for (const entity of entitiesWithEvents) {\r\n      lastDownPerPointer = this._processDownAndEmit(entity);\r\n\r\n      lastUpPerPointer = this._processUpAndEmit(entity);\r\n\r\n      lastMovePerPointer = this._processMoveAndEmit(entity);\r\n\r\n      const lastUpDownMoveEvents = [\r\n        ...lastMovePerPointer.values(),\r\n        ...lastDownPerPointer.values(),\r\n        ...lastUpPerPointer.values()\r\n      ];\r\n      this._processEnterLeaveAndEmit(entity, lastUpDownMoveEvents);\r\n\r\n      this._processCancelAndEmit(entity);\r\n\r\n      this._processWheelAndEmit(entity);\r\n    }\r\n  }\r\n}","import { Entity } from '../EntityComponentSystem';\r\nimport { AddedEntity, isAddedSystemEntity, RemovedEntity, System, SystemType } from '../EntityComponentSystem/System';\r\nimport { ActionsComponent } from './ActionsComponent';\r\n\r\n\r\nexport class ActionsSystem extends System<ActionsComponent> {\r\n  public readonly types = ['ex.actions'] as const;\r\n  systemType = SystemType.Update;\r\n  priority = -1;\r\n\r\n  private _actions: ActionsComponent[] = [];\r\n  public notify(entityAddedOrRemoved: AddedEntity | RemovedEntity): void {\r\n    if (isAddedSystemEntity(entityAddedOrRemoved)) {\r\n      const action = entityAddedOrRemoved.data.get(ActionsComponent);\r\n      this._actions.push(action);\r\n    } else {\r\n      const action = entityAddedOrRemoved.data.get(ActionsComponent);\r\n      const index = this._actions.indexOf(action);\r\n      if (index > -1) {\r\n        this._actions.splice(index, 1);\r\n      }\r\n    }\r\n  }\r\n\r\n  update(_entities: Entity[], delta: number): void {\r\n    for (const actions of this._actions) {\r\n      actions.update(delta);\r\n    }\r\n  }\r\n}","import { Component } from '../EntityComponentSystem/Component';\r\nimport { IsometricMap } from './IsometricMap';\r\n\r\nexport class IsometricEntityComponent extends Component<'ex.isometricentity'> {\r\n  public readonly type = 'ex.isometricentity';\r\n  /**\r\n   * Vertical \"height\" in the isometric world\r\n   */\r\n  public elevation: number = 0;\r\n\r\n  public map: IsometricMap;\r\n\r\n  /**\r\n   * Specify the isometric map to use to position this entity's z-index\r\n   * @param map\r\n   */\r\n  constructor(map: IsometricMap) {\r\n    super();\r\n    this.map = map;\r\n  }\r\n}","import { System, SystemType } from '../EntityComponentSystem/System';\r\nimport { Entity } from '../EntityComponentSystem/Entity';\r\nimport { TransformComponent } from '../EntityComponentSystem/Components/TransformComponent';\r\nimport { IsometricEntityComponent } from './IsometricEntityComponent';\r\n\r\n\r\nexport class IsometricEntitySystem extends System<TransformComponent | IsometricEntityComponent> {\r\n  public readonly types = ['ex.transform', 'ex.isometricentity'] as const;\r\n  public readonly systemType = SystemType.Update;\r\n  priority: number = 99;\r\n  update(entities: Entity[], _delta: number): void {\r\n    let transform: TransformComponent;\r\n    let iso: IsometricEntityComponent;\r\n    for (const entity of entities) {\r\n      transform = entity.get(TransformComponent);\r\n      iso = entity.get(IsometricEntityComponent);\r\n\r\n      const maxZindexPerElevation = Math.max(iso.map.columns * iso.map.tileWidth, iso.map.rows * iso.map.tileHeight);\r\n\r\n      const newZ = maxZindexPerElevation * iso.elevation + transform.pos.y;\r\n      transform.z = newZ;\r\n    }\r\n  }\r\n}","import { GraphicsComponent } from './GraphicsComponent';\r\nimport { EnterViewPortEvent, ExitViewPortEvent } from '../Events';\r\nimport { Scene } from '../Scene';\r\nimport { Entity } from '../EntityComponentSystem/Entity';\r\nimport { TransformComponent, CoordPlane } from '../EntityComponentSystem/Components/TransformComponent';\r\nimport { Camera } from '../Camera';\r\nimport { System, SystemType } from '../EntityComponentSystem/System';\r\nimport { ParallaxComponent } from './ParallaxComponent';\r\nimport { Vector } from '../Math/vector';\r\n\r\nexport class OffscreenSystem extends System<TransformComponent | GraphicsComponent> {\r\n  public readonly types = ['ex.transform', 'ex.graphics'] as const;\r\n  public systemType = SystemType.Draw;\r\n  priority: number = -1;\r\n  private _camera: Camera;\r\n\r\n  public initialize(scene: Scene): void {\r\n    this._camera = scene.camera;\r\n  }\r\n\r\n  update(entities: Entity[]): void {\r\n    let transform: TransformComponent;\r\n    let graphics: GraphicsComponent;\r\n    let maybeParallax: ParallaxComponent;\r\n\r\n    for (const entity of entities) {\r\n      graphics = entity.get(GraphicsComponent);\r\n      transform = entity.get(TransformComponent);\r\n      maybeParallax = entity.get(ParallaxComponent);\r\n\r\n      let parallaxOffset: Vector;\r\n      if (maybeParallax) {\r\n        // We use the Tiled formula\r\n        // https://doc.mapeditor.org/en/latest/manual/layers/#parallax-scrolling-factor\r\n        // cameraPos * (1 - parallaxFactor)\r\n        const oneMinusFactor = Vector.One.sub(maybeParallax.parallaxFactor);\r\n        parallaxOffset = this._camera.pos.scale(oneMinusFactor);\r\n      }\r\n\r\n      // Figure out if entities are offscreen\r\n      const entityOffscreen = this._isOffscreen(transform, graphics, parallaxOffset);\r\n      if (entityOffscreen && !entity.hasTag('ex.offscreen')) {\r\n        entity.eventDispatcher.emit('exitviewport', new ExitViewPortEvent(entity));\r\n        entity.addTag('ex.offscreen');\r\n      }\r\n\r\n      if (!entityOffscreen && entity.hasTag('ex.offscreen')) {\r\n        entity.eventDispatcher.emit('enterviewport', new EnterViewPortEvent(entity));\r\n        entity.removeTag('ex.offscreen');\r\n      }\r\n    }\r\n  }\r\n\r\n  private _isOffscreen(transform: TransformComponent, graphics: GraphicsComponent, parallaxOffset: Vector) {\r\n    if (transform.coordPlane === CoordPlane.World) {\r\n      let bounds = graphics.localBounds;\r\n      if (parallaxOffset) {\r\n        bounds = bounds.translate(parallaxOffset);\r\n      }\r\n      const transformedBounds = bounds.transform(transform.getGlobalMatrix());\r\n      const graphicsOffscreen = !this._camera.viewport.overlaps(transformedBounds);\r\n      return graphicsOffscreen;\r\n    } else {\r\n      // TODO screen coordinates\r\n      return false;\r\n    }\r\n  }\r\n\r\n}","import { isScreenElement, ScreenElement } from './ScreenElement';\r\nimport {\r\n  InitializeEvent,\r\n  ActivateEvent,\r\n  DeactivateEvent,\r\n  PreUpdateEvent,\r\n  PostUpdateEvent,\r\n  PreDrawEvent,\r\n  PostDrawEvent,\r\n  PreDebugDrawEvent,\r\n  PostDebugDrawEvent,\r\n  GameEvent\r\n} from './Events';\r\nimport { Logger } from './Util/Log';\r\nimport { Timer } from './Timer';\r\nimport { Engine } from './Engine';\r\nimport { TileMap } from './TileMap';\r\nimport { Camera } from './Camera';\r\nimport { Actor } from './Actor';\r\nimport { Class } from './Class';\r\nimport { CanInitialize, CanActivate, CanDeactivate, CanUpdate, CanDraw } from './Interfaces/LifecycleEvents';\r\nimport * as Util from './Util/Util';\r\nimport * as Events from './Events';\r\nimport { Trigger } from './Trigger';\r\nimport { SystemType } from './EntityComponentSystem/System';\r\nimport { World } from './EntityComponentSystem/World';\r\nimport { MotionSystem } from './Collision/MotionSystem';\r\nimport { CollisionSystem } from './Collision/CollisionSystem';\r\nimport { Entity } from './EntityComponentSystem/Entity';\r\nimport { GraphicsSystem } from './Graphics/GraphicsSystem';\r\nimport { DebugSystem } from './Debug/DebugSystem';\r\nimport { PointerSystem } from './Input/PointerSystem';\r\nimport { ActionsSystem } from './Actions/ActionsSystem';\r\nimport { IsometricEntitySystem } from './TileMap/IsometricEntitySystem';\r\nimport { OffscreenSystem } from './Graphics/OffscreenSystem';\r\nimport { ExcaliburGraphicsContext } from './Graphics';\r\n/**\r\n * [[Actor|Actors]] are composed together into groupings called Scenes in\r\n * Excalibur. The metaphor models the same idea behind real world\r\n * actors in a scene. Only actors in scenes will be updated and drawn.\r\n *\r\n * Typical usages of a scene include: levels, menus, loading screens, etc.\r\n */\r\nexport class Scene extends Class implements CanInitialize, CanActivate, CanDeactivate, CanUpdate, CanDraw {\r\n  private _logger: Logger = Logger.getInstance();\r\n  /**\r\n   * Gets or sets the current camera for the scene\r\n   */\r\n  public camera: Camera = new Camera();\r\n\r\n  /**\r\n   * The ECS world for the scene\r\n   */\r\n  public world = new World(this);\r\n\r\n  /**\r\n   * The actors in the current scene\r\n   */\r\n  public get actors(): readonly Actor[] {\r\n    return this.world.entityManager.entities.filter((e) => {\r\n      return e instanceof Actor;\r\n    }) as Actor[];\r\n  }\r\n\r\n  /**\r\n   * The entities in the current scene\r\n   */\r\n  public get entities(): readonly Entity[] {\r\n    return this.world.entityManager.entities;\r\n  }\r\n\r\n  /**\r\n   * The triggers in the current scene\r\n   */\r\n  public get triggers(): readonly Trigger[] {\r\n    return this.world.entityManager.entities.filter((e) => {\r\n      return e instanceof Trigger;\r\n    }) as Trigger[];\r\n  }\r\n\r\n  /**\r\n   * The [[TileMap]]s in the scene, if any\r\n   */\r\n  public get tileMaps(): readonly TileMap[] {\r\n    return this.world.entityManager.entities.filter((e) => {\r\n      return e instanceof TileMap;\r\n    }) as TileMap[];\r\n  }\r\n\r\n  /**\r\n   * Access to the Excalibur engine\r\n   */\r\n  public engine: Engine;\r\n\r\n  private _isInitialized: boolean = false;\r\n  private _timers: Timer[] = [];\r\n  public get timers(): readonly Timer[] {\r\n    return this._timers;\r\n  }\r\n  private _cancelQueue: Timer[] = [];\r\n\r\n  constructor() {\r\n    super();\r\n    // Initialize systems\r\n\r\n    // Update\r\n    this.world.add(new ActionsSystem());\r\n    this.world.add(new MotionSystem());\r\n    this.world.add(new CollisionSystem());\r\n    this.world.add(new PointerSystem());\r\n    this.world.add(new IsometricEntitySystem());\r\n    // Draw\r\n    this.world.add(new OffscreenSystem());\r\n    this.world.add(new GraphicsSystem());\r\n    this.world.add(new DebugSystem());\r\n  }\r\n\r\n  public on(eventName: Events.initialize, handler: (event: InitializeEvent<Scene>) => void): void;\r\n  public on(eventName: Events.activate, handler: (event: ActivateEvent) => void): void;\r\n  public on(eventName: Events.deactivate, handler: (event: DeactivateEvent) => void): void;\r\n  public on(eventName: Events.preupdate, handler: (event: PreUpdateEvent<Scene>) => void): void;\r\n  public on(eventName: Events.postupdate, handler: (event: PostUpdateEvent<Scene>) => void): void;\r\n  public on(eventName: Events.predraw, handler: (event: PreDrawEvent) => void): void;\r\n  public on(eventName: Events.postdraw, handler: (event: PostDrawEvent) => void): void;\r\n  public on(eventName: Events.predebugdraw, handler: (event: PreDebugDrawEvent) => void): void;\r\n  public on(eventName: Events.postdebugdraw, handler: (event: PostDebugDrawEvent) => void): void;\r\n  public on(eventName: string, handler: (event: GameEvent<any>) => void): void;\r\n  public on(eventName: string, handler: (event: any) => void): void {\r\n    super.on(eventName, handler);\r\n  }\r\n\r\n  public once(eventName: Events.initialize, handler: (event: InitializeEvent<Scene>) => void): void;\r\n  public once(eventName: Events.activate, handler: (event: ActivateEvent) => void): void;\r\n  public once(eventName: Events.deactivate, handler: (event: DeactivateEvent) => void): void;\r\n  public once(eventName: Events.preupdate, handler: (event: PreUpdateEvent<Scene>) => void): void;\r\n  public once(eventName: Events.postupdate, handler: (event: PostUpdateEvent<Scene>) => void): void;\r\n  public once(eventName: Events.predraw, handler: (event: PreDrawEvent) => void): void;\r\n  public once(eventName: Events.postdraw, handler: (event: PostDrawEvent) => void): void;\r\n  public once(eventName: Events.predebugdraw, handler: (event: PreDebugDrawEvent) => void): void;\r\n  public once(eventName: Events.postdebugdraw, handler: (event: PostDebugDrawEvent) => void): void;\r\n  public once(eventName: string, handler: (event: GameEvent<any>) => void): void;\r\n  public once(eventName: string, handler: (event: any) => void): void {\r\n    super.once(eventName, handler);\r\n  }\r\n\r\n  public off(eventName: Events.initialize, handler?: (event: InitializeEvent<Scene>) => void): void;\r\n  public off(eventName: Events.activate, handler?: (event: ActivateEvent) => void): void;\r\n  public off(eventName: Events.deactivate, handler?: (event: DeactivateEvent) => void): void;\r\n  public off(eventName: Events.preupdate, handler?: (event: PreUpdateEvent<Scene>) => void): void;\r\n  public off(eventName: Events.postupdate, handler?: (event: PostUpdateEvent<Scene>) => void): void;\r\n  public off(eventName: Events.predraw, handler?: (event: PreDrawEvent) => void): void;\r\n  public off(eventName: Events.postdraw, handler?: (event: PostDrawEvent) => void): void;\r\n  public off(eventName: Events.predebugdraw, handler?: (event: PreDebugDrawEvent) => void): void;\r\n  public off(eventName: Events.postdebugdraw, handler?: (event: PostDebugDrawEvent) => void): void;\r\n  public off(eventName: string, handler?: (event: GameEvent<any>) => void): void;\r\n  public off(eventName: string, handler?: (event: any) => void): void {\r\n    super.off(eventName, handler);\r\n  }\r\n\r\n  /**\r\n   * This is called before the first update of the [[Scene]]. Initializes scene members like the camera. This method is meant to be\r\n   * overridden. This is where initialization of child actors should take place.\r\n   */\r\n  public onInitialize(_engine: Engine): void {\r\n    // will be overridden\r\n  }\r\n\r\n  /**\r\n   * This is called when the scene is made active and started. It is meant to be overridden,\r\n   * this is where you should setup any DOM UI or event handlers needed for the scene.\r\n   */\r\n  public onActivate(_oldScene: Scene, _newScene: Scene): void {\r\n    // will be overridden\r\n  }\r\n\r\n  /**\r\n   * This is called when the scene is made transitioned away from and stopped. It is meant to be overridden,\r\n   * this is where you should cleanup any DOM UI or event handlers needed for the scene.\r\n   */\r\n  public onDeactivate(_oldScene: Scene, _newScene: Scene): void {\r\n    // will be overridden\r\n  }\r\n\r\n  /**\r\n   * Safe to override onPreUpdate lifecycle event handler. Synonymous with `.on('preupdate', (evt) =>{...})`\r\n   *\r\n   * `onPreUpdate` is called directly before a scene is updated.\r\n   */\r\n  public onPreUpdate(_engine: Engine, _delta: number): void {\r\n    // will be overridden\r\n  }\r\n\r\n  /**\r\n   * Safe to override onPostUpdate lifecycle event handler. Synonymous with `.on('preupdate', (evt) =>{...})`\r\n   *\r\n   * `onPostUpdate` is called directly after a scene is updated.\r\n   */\r\n  public onPostUpdate(_engine: Engine, _delta: number): void {\r\n    // will be overridden\r\n  }\r\n\r\n  /**\r\n   * Safe to override onPreDraw lifecycle event handler. Synonymous with `.on('preupdate', (evt) =>{...})`\r\n   *\r\n   * `onPreDraw` is called directly before a scene is drawn.\r\n   *\r\n   */\r\n  public onPreDraw(_ctx: ExcaliburGraphicsContext, _delta: number): void {\r\n    // will be overridden\r\n  }\r\n\r\n  /**\r\n   * Safe to override onPostDraw lifecycle event handler. Synonymous with `.on('preupdate', (evt) =>{...})`\r\n   *\r\n   * `onPostDraw` is called directly after a scene is drawn.\r\n   *\r\n   */\r\n  public onPostDraw(_ctx: ExcaliburGraphicsContext, _delta: number): void {\r\n    // will be overridden\r\n  }\r\n\r\n  /**\r\n   * Initializes actors in the scene\r\n   */\r\n  private _initializeChildren(): void {\r\n    for (const child of this.entities) {\r\n      child._initialize(this.engine);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Gets whether or not the [[Scene]] has been initialized\r\n   */\r\n  public get isInitialized(): boolean {\r\n    return this._isInitialized;\r\n  }\r\n\r\n  /**\r\n   * It is not recommended that internal excalibur methods be overridden, do so at your own risk.\r\n   *\r\n   * Initializes the scene before the first update, meant to be called by engine not by users of\r\n   * Excalibur\r\n   * @internal\r\n   */\r\n  public _initialize(engine: Engine) {\r\n    if (!this.isInitialized) {\r\n      this.engine = engine;\r\n      // Initialize camera first\r\n      this.camera._initialize(engine);\r\n\r\n      this.world.systemManager.initialize();\r\n\r\n      // This order is important! we want to be sure any custom init that add actors\r\n      // fire before the actor init\r\n      this.onInitialize.call(this, engine);\r\n      this._initializeChildren();\r\n\r\n      this._logger.debug('Scene.onInitialize', this, engine);\r\n      this.eventDispatcher.emit('initialize', new InitializeEvent(engine, this));\r\n      this._isInitialized = true;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * It is not recommended that internal excalibur methods be overridden, do so at your own risk.\r\n   *\r\n   * Activates the scene with the base behavior, then calls the overridable `onActivate` implementation.\r\n   * @internal\r\n   */\r\n  public _activate(oldScene: Scene, newScene: Scene): void {\r\n    this._logger.debug('Scene.onActivate', this);\r\n    this.onActivate(oldScene, newScene);\r\n  }\r\n\r\n  /**\r\n   * It is not recommended that internal excalibur methods be overridden, do so at your own risk.\r\n   *\r\n   * Deactivates the scene with the base behavior, then calls the overridable `onDeactivate` implementation.\r\n   * @internal\r\n   */\r\n  public _deactivate(oldScene: Scene, newScene: Scene): void {\r\n    this._logger.debug('Scene.onDeactivate', this);\r\n    this.onDeactivate(oldScene, newScene);\r\n  }\r\n\r\n  /**\r\n   * It is not recommended that internal excalibur methods be overridden, do so at your own risk.\r\n   *\r\n   * Internal _preupdate handler for [[onPreUpdate]] lifecycle event\r\n   * @internal\r\n   */\r\n  public _preupdate(_engine: Engine, delta: number): void {\r\n    this.emit('preupdate', new PreUpdateEvent(_engine, delta, this));\r\n    this.onPreUpdate(_engine, delta);\r\n  }\r\n\r\n  /**\r\n   *  It is not recommended that internal excalibur methods be overridden, do so at your own risk.\r\n   *\r\n   * Internal _preupdate handler for [[onPostUpdate]] lifecycle event\r\n   * @internal\r\n   */\r\n  public _postupdate(_engine: Engine, delta: number): void {\r\n    this.emit('postupdate', new PostUpdateEvent(_engine, delta, this));\r\n    this.onPostUpdate(_engine, delta);\r\n  }\r\n\r\n  /**\r\n   * It is not recommended that internal excalibur methods be overridden, do so at your own risk.\r\n   *\r\n   * Internal _predraw handler for [[onPreDraw]] lifecycle event\r\n   *\r\n   * @internal\r\n   */\r\n  public _predraw(_ctx: ExcaliburGraphicsContext, _delta: number): void {\r\n    this.emit('predraw', new PreDrawEvent(_ctx, _delta, this));\r\n    this.onPreDraw(_ctx, _delta);\r\n  }\r\n\r\n  /**\r\n   * It is not recommended that internal excalibur methods be overridden, do so at your own risk.\r\n   *\r\n   * Internal _postdraw handler for [[onPostDraw]] lifecycle event\r\n   *\r\n   * @internal\r\n   */\r\n  public _postdraw(_ctx: ExcaliburGraphicsContext, _delta: number): void {\r\n    this.emit('postdraw', new PostDrawEvent(_ctx, _delta, this));\r\n    this.onPostDraw(_ctx, _delta);\r\n  }\r\n\r\n  /**\r\n   * Updates all the actors and timers in the scene. Called by the [[Engine]].\r\n   * @param engine  Reference to the current Engine\r\n   * @param delta   The number of milliseconds since the last update\r\n   */\r\n  public update(engine: Engine, delta: number) {\r\n    this._preupdate(engine, delta);\r\n\r\n    // TODO differed entity removal for timers\r\n    let i: number, len: number;\r\n    // Remove timers in the cancel queue before updating them\r\n    for (i = 0, len = this._cancelQueue.length; i < len; i++) {\r\n      this.removeTimer(this._cancelQueue[i]);\r\n    }\r\n    this._cancelQueue.length = 0;\r\n\r\n    // Cycle through timers updating timers\r\n    for (const timer of this._timers) {\r\n      timer.update(delta);\r\n    }\r\n\r\n    this.world.update(SystemType.Update, delta);\r\n\r\n    // Camera last keeps renders smooth that are based on entity/actor\r\n    if (this.camera) {\r\n      this.camera.update(engine, delta);\r\n    }\r\n\r\n    this._collectActorStats(engine);\r\n\r\n    this._postupdate(engine, delta);\r\n  }\r\n\r\n  /**\r\n   * Draws all the actors in the Scene. Called by the [[Engine]].\r\n   *\r\n   * @param ctx    The current rendering context\r\n   * @param delta  The number of milliseconds since the last draw\r\n   */\r\n  public draw(ctx: ExcaliburGraphicsContext, delta: number) {\r\n    this._predraw(ctx, delta);\r\n\r\n    this.world.update(SystemType.Draw, delta);\r\n\r\n    if (this.engine?.isDebug) {\r\n      this.debugDraw(ctx);\r\n    }\r\n    this._postdraw(ctx, delta);\r\n  }\r\n\r\n  /**\r\n   * Draws all the actors' debug information in the Scene. Called by the [[Engine]].\r\n   * @param ctx  The current rendering context\r\n   */\r\n  /* istanbul ignore next */\r\n  public debugDraw(ctx: ExcaliburGraphicsContext) {\r\n    this.emit('predebugdraw', new PreDebugDrawEvent(ctx, this));\r\n    // pass\r\n    this.emit('postdebugdraw', new PostDebugDrawEvent(ctx, this));\r\n  }\r\n\r\n  /**\r\n   * Checks whether an actor is contained in this scene or not\r\n   */\r\n  public contains(actor: Actor): boolean {\r\n    return this.actors.indexOf(actor) > -1;\r\n  }\r\n\r\n  /**\r\n   * Adds a [[Timer]] to the current [[Scene]].\r\n   * @param timer  The timer to add to the current [[Scene]].\r\n   */\r\n  public add(timer: Timer): void;\r\n\r\n  /**\r\n   * Adds a [[TileMap]] to the [[Scene]], once this is done the [[TileMap]] will be drawn and updated.\r\n   */\r\n  public add(tileMap: TileMap): void;\r\n\r\n  /**\r\n   * Adds a [[Trigger]] to the [[Scene]], once this is done the [[Trigger]] will listen for interactions with other actors.\r\n   * @param trigger\r\n   */\r\n  public add(trigger: Trigger): void;\r\n\r\n  /**\r\n   * Adds an actor to the scene, once this is done the [[Actor]] will be drawn and updated.\r\n   * @param actor  The actor to add to the current scene\r\n   */\r\n  public add(actor: Actor): void;\r\n\r\n  public add(entity: Entity): void;\r\n\r\n  /**\r\n   * Adds a [[ScreenElement]] to the scene.\r\n   * @param screenElement  The ScreenElement to add to the current scene\r\n   */\r\n  public add(screenElement: ScreenElement): void;\r\n  public add(entity: any): void {\r\n    this.emit('entityadded', { target: entity } as any);\r\n    this.world.add(entity);\r\n    entity.scene = this;\r\n    if (entity instanceof Timer) {\r\n      if (!Util.contains(this._timers, entity)) {\r\n        this.addTimer(entity);\r\n      }\r\n      return;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Removes a [[Timer]] from the current scene, it will no longer be updated.\r\n   * @param timer  The timer to remove to the current scene.\r\n   */\r\n  public remove(timer: Timer): void;\r\n\r\n  /**\r\n   * Removes a [[TileMap]] from the scene, it will no longer be drawn or updated.\r\n   * @param tileMap {TileMap}\r\n   */\r\n  public remove(tileMap: TileMap): void;\r\n\r\n  /**\r\n   * Removes an actor from the scene, it will no longer be drawn or updated.\r\n   * @param actor  The actor to remove from the current scene.\r\n   */\r\n  public remove(actor: Actor): void;\r\n\r\n  public remove(entity: Entity): void;\r\n\r\n  /**\r\n   * Removes a [[ScreenElement]] to the scene, it will no longer be drawn or updated\r\n   * @param screenElement  The ScreenElement to remove from the current scene\r\n   */\r\n  public remove(screenElement: ScreenElement): void;\r\n  public remove(entity: any): void {\r\n    if (entity instanceof Entity) {\r\n      this.emit('entityremoved', { target: entity } as any);\r\n      this.world.remove(entity);\r\n    }\r\n    if (entity instanceof Timer) {\r\n      this.removeTimer(entity);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Removes all entities and timers from the scene, optionally indicate whether deferred should or shouldn't be used.\r\n   *\r\n   * By default entities use deferred removal\r\n   * @param deferred\r\n   */\r\n  public clear(deferred: boolean = true): void {\r\n    for (const entity of this.entities) {\r\n      this.world.remove(entity, deferred);\r\n    }\r\n    for (const timer of this.timers) {\r\n      this.removeTimer(timer);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Adds a [[Timer]] to the scene\r\n   * @param timer  The timer to add\r\n   */\r\n  public addTimer(timer: Timer): Timer {\r\n    this._timers.push(timer);\r\n    timer.scene = this;\r\n    return timer;\r\n  }\r\n\r\n  /**\r\n   * Removes a [[Timer]] from the scene.\r\n   * @warning Can be dangerous, use [[cancelTimer]] instead\r\n   * @param timer  The timer to remove\r\n   */\r\n  public removeTimer(timer: Timer): Timer {\r\n    const i = this._timers.indexOf(timer);\r\n    if (i !== -1) {\r\n      this._timers.splice(i, 1);\r\n    }\r\n    return timer;\r\n  }\r\n\r\n  /**\r\n   * Cancels a [[Timer]], removing it from the scene nicely\r\n   * @param timer  The timer to cancel\r\n   */\r\n  public cancelTimer(timer: Timer): Timer {\r\n    this._cancelQueue.push(timer);\r\n    return timer;\r\n  }\r\n\r\n  /**\r\n   * Tests whether a [[Timer]] is active in the scene\r\n   */\r\n  public isTimerActive(timer: Timer): boolean {\r\n    return this._timers.indexOf(timer) > -1 && !timer.complete;\r\n  }\r\n\r\n  public isCurrentScene(): boolean {\r\n    if (this.engine) {\r\n      return this.engine.currentScene === this;\r\n    }\r\n    return false;\r\n  }\r\n\r\n  private _collectActorStats(engine: Engine) {\r\n    const screenElements = this.actors.filter((a) => a instanceof ScreenElement) as ScreenElement[];\r\n    for (const _ui of screenElements) {\r\n      engine.stats.currFrame.actors.ui++;\r\n    }\r\n\r\n    for (const actor of this.actors) {\r\n      engine.stats.currFrame.actors.alive++;\r\n      for (const child of actor.children) {\r\n        if (isScreenElement(child as Actor)) {\r\n          // TODO not true\r\n          engine.stats.currFrame.actors.ui++;\r\n        } else {\r\n          engine.stats.currFrame.actors.alive++;\r\n        }\r\n      }\r\n    }\r\n  }\r\n}\r\n","\r\n\r\nexport enum ColorBlindnessMode {\r\n  Protanope = 'Protanope',\r\n  Deuteranope = 'Deuteranope',\r\n  Tritanope = 'Tritanope'\r\n}\r\n","import { Shader } from '../Context/shader';\r\nimport { VertexBuffer } from '../Context/vertex-buffer';\r\nimport { VertexLayout } from '../Context/vertex-layout';\r\n\r\n/**\r\n * Helper that defines a whole screen renderer, just provide a fragment source!\r\n *\r\n * Currently supports 1 varying\r\n * - vec2 a_texcoord between 0-1 which corresponds to screen position\r\n */\r\nexport class ScreenShader {\r\n  private _shader: Shader;\r\n  private _buffer: VertexBuffer;\r\n  private _layout: VertexLayout;\r\n  constructor(fragmentSource: string) {\r\n    this._shader = new Shader({\r\n      vertexSource: `#version 300 es\r\n      in vec2 a_position;\r\n      in vec2 a_texcoord;\r\n      out vec2 v_texcoord;\r\n\r\n      void main() {\r\n        gl_Position = vec4(a_position, 0.0, 1.0);\r\n        // Pass the texcoord to the fragment shader.\r\n        v_texcoord = a_texcoord;\r\n      }`,\r\n      fragmentSource: fragmentSource\r\n    });\r\n    this._shader.compile();\r\n    // Setup memory layout\r\n    this._buffer = new VertexBuffer({\r\n      type: 'static',\r\n      // clip space quad + uv since we don't need a camera\r\n      data: new Float32Array([\r\n        -1, -1,          0, 0,\r\n        -1, 1,           0, 1,\r\n        1, -1,           1, 0,\r\n\r\n        1, -1,            1, 0,\r\n        -1, 1,           0, 1,\r\n        1, 1,            1, 1\r\n      ])\r\n    });\r\n    this._layout = new VertexLayout({\r\n      shader: this._shader,\r\n      vertexBuffer: this._buffer,\r\n      attributes: [\r\n        ['a_position', 2],\r\n        ['a_texcoord', 2]\r\n      ]\r\n    });\r\n    this._buffer.upload();\r\n  }\r\n\r\n  public getShader() {\r\n    return this._shader;\r\n  }\r\n  public getLayout() {\r\n    return this._layout;\r\n  }\r\n}","import colorBlindCorrectSource from './color-blind-fragment.glsl';\r\nimport { PostProcessor } from './PostProcessor';\r\nimport { ColorBlindnessMode } from './ColorBlindnessMode';\r\nimport { Shader } from '../Context/shader';\r\nimport { VertexLayout } from '../Context/vertex-layout';\r\nimport { ScreenShader } from './ScreenShader';\r\n\r\nexport class ColorBlindnessPostProcessor implements PostProcessor {\r\n  private _shader: ScreenShader;\r\n  private _simulate = false;\r\n  constructor(private _colorBlindnessMode: ColorBlindnessMode, simulate = false) {\r\n    this._simulate = simulate;\r\n  }\r\n\r\n  initialize(_gl: WebGLRenderingContext): void {\r\n    this._shader = new ScreenShader(colorBlindCorrectSource);\r\n    this.simulate = this._simulate;\r\n    this.colorBlindnessMode = this._colorBlindnessMode;\r\n  }\r\n\r\n  getShader(): Shader {\r\n    return this._shader.getShader();\r\n  }\r\n\r\n  getLayout(): VertexLayout {\r\n    return this._shader.getLayout();\r\n  }\r\n\r\n  set colorBlindnessMode(colorBlindMode: ColorBlindnessMode) {\r\n    this._colorBlindnessMode = colorBlindMode;\r\n    if (this._shader) {\r\n      const shader = this._shader.getShader();\r\n      shader.use();\r\n      if (this._colorBlindnessMode === ColorBlindnessMode.Protanope) {\r\n        shader.setUniformInt('u_type', 0);\r\n      } else if (this._colorBlindnessMode === ColorBlindnessMode.Deuteranope) {\r\n        shader.setUniformInt('u_type', 1);\r\n      } else if (this._colorBlindnessMode === ColorBlindnessMode.Tritanope) {\r\n        shader.setUniformInt('u_type', 2);\r\n      }\r\n    }\r\n  }\r\n\r\n  get colorBlindnessMode(): ColorBlindnessMode {\r\n    return this._colorBlindnessMode;\r\n  }\r\n\r\n  set simulate(value: boolean) {\r\n    this._simulate = value;\r\n    if (this._shader) {\r\n\r\n      const shader = this._shader.getShader();\r\n      shader.use();\r\n      shader.setUniformBoolean('u_simulate', value);\r\n    }\r\n  }\r\n\r\n  get simulate(): boolean {\r\n    return this._simulate;\r\n  }\r\n}\r\n","import { ColorBlindnessMode } from '../Graphics/PostProcessor/ColorBlindnessMode';\r\nimport { ColorBlindnessPostProcessor } from '../Graphics/PostProcessor/ColorBlindnessPostProcessor';\r\nimport { Engine } from '../Engine';\r\nimport { ExcaliburGraphicsContextWebGL } from '..';\r\n\r\nexport interface DebugFlags {\r\n  colorBlindMode: ColorBlindFlags;\r\n}\r\n\r\nexport class ColorBlindFlags {\r\n  private _engine: Engine;\r\n  private _colorBlindPostProcessor: ColorBlindnessPostProcessor;\r\n\r\n  constructor(engine: Engine) {\r\n    this._engine = engine;\r\n    this._colorBlindPostProcessor = new ColorBlindnessPostProcessor(ColorBlindnessMode.Protanope);\r\n  }\r\n\r\n  /**\r\n   * Correct colors for a specified color blindness\r\n   * @param colorBlindness\r\n   */\r\n  public correct(colorBlindness: ColorBlindnessMode) {\r\n    if (this._engine.graphicsContext instanceof ExcaliburGraphicsContextWebGL) {\r\n      this.clear();\r\n      this._colorBlindPostProcessor.colorBlindnessMode = colorBlindness;\r\n      this._colorBlindPostProcessor.simulate = false;\r\n      this._engine.graphicsContext.addPostProcessor(this._colorBlindPostProcessor);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Simulate colors for a specified color blindness\r\n   * @param colorBlindness\r\n   */\r\n  public simulate(colorBlindness: ColorBlindnessMode) {\r\n    if (this._engine.graphicsContext instanceof ExcaliburGraphicsContextWebGL) {\r\n      this.clear();\r\n      this._colorBlindPostProcessor.colorBlindnessMode = colorBlindness;\r\n      this._colorBlindPostProcessor.simulate = true;\r\n      this._engine.graphicsContext.addPostProcessor(this._colorBlindPostProcessor);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Remove color blindness post processor\r\n   */\r\n  public clear() {\r\n    this._engine.graphicsContext.removePostProcessor(this._colorBlindPostProcessor);\r\n  }\r\n}\r\n","import { DebugFlags, ColorBlindFlags } from './DebugFlags';\r\nimport { Engine } from '../Engine';\r\nimport { Color } from '../Color';\r\nimport { CollisionContact } from '../Collision/Detection/CollisionContact';\r\nimport { StandardClock, TestClock } from '..';\r\n\r\n/**\r\n * Debug stats containing current and previous frame statistics\r\n */\r\nexport interface DebugStats {\r\n  currFrame: FrameStats;\r\n  prevFrame: FrameStats;\r\n}\r\n\r\n/**\r\n * Represents a frame's individual statistics\r\n */\r\nexport interface FrameStatistics {\r\n  /**\r\n   * The number of the frame\r\n   */\r\n  id: number;\r\n\r\n  /**\r\n   * Gets the frame's delta (time since last frame scaled by [[Engine.timescale]]) (in ms)\r\n   */\r\n  delta: number;\r\n\r\n  /**\r\n   * Gets the frame's frames-per-second (FPS)\r\n   */\r\n  fps: number;\r\n\r\n  /**\r\n   * Duration statistics (in ms)\r\n   */\r\n  duration: FrameDurationStats;\r\n\r\n  /**\r\n   * Actor statistics\r\n   */\r\n  actors: FrameActorStats;\r\n\r\n  /**\r\n   * Physics statistics\r\n   */\r\n  physics: PhysicsStatistics;\r\n\r\n  /**\r\n   * Graphics statistics\r\n   */\r\n  graphics: GraphicsStatistics;\r\n}\r\n\r\n/**\r\n * Represents actor stats for a frame\r\n */\r\nexport interface FrameActorStats {\r\n  /**\r\n   * Gets the frame's number of actors (alive)\r\n   */\r\n  alive: number;\r\n\r\n  /**\r\n   * Gets the frame's number of actors (killed)\r\n   */\r\n  killed: number;\r\n\r\n  /**\r\n   * Gets the frame's number of remaining actors (alive - killed)\r\n   */\r\n  remaining: number;\r\n\r\n  /**\r\n   * Gets the frame's number of UI actors\r\n   */\r\n  ui: number;\r\n\r\n  /**\r\n   * Gets the frame's number of total actors (remaining + UI)\r\n   */\r\n  total: number;\r\n}\r\n\r\n/**\r\n * Represents duration stats for a frame\r\n */\r\nexport interface FrameDurationStats {\r\n  /**\r\n   * Gets the frame's total time to run the update function (in ms)\r\n   */\r\n  update: number;\r\n\r\n  /**\r\n   * Gets the frame's total time to run the draw function (in ms)\r\n   */\r\n  draw: number;\r\n\r\n  /**\r\n   * Gets the frame's total render duration (update + draw duration) (in ms)\r\n   */\r\n  total: number;\r\n}\r\n\r\n/**\r\n * Represents physics stats for the current frame\r\n */\r\nexport interface PhysicsStatistics {\r\n  /**\r\n   * Gets the number of broadphase collision pairs which\r\n   */\r\n  pairs: number;\r\n\r\n  /**\r\n   * Gets the number of actual collisions\r\n   */\r\n  collisions: number;\r\n\r\n  /**\r\n   * Copy of the current frame contacts (only updated if debug is toggled on)\r\n   */\r\n  contacts: Map<string, CollisionContact>;\r\n\r\n  /**\r\n   * Gets the number of fast moving bodies using raycast continuous collisions in the scene\r\n   */\r\n  fastBodies: number;\r\n\r\n  /**\r\n   * Gets the number of bodies that had a fast body collision resolution\r\n   */\r\n  fastBodyCollisions: number;\r\n\r\n  /**\r\n   * Gets the time it took to calculate the broadphase pairs\r\n   */\r\n  broadphase: number;\r\n\r\n  /**\r\n   * Gets the time it took to calculate the narrowphase\r\n   */\r\n  narrowphase: number;\r\n}\r\n\r\nexport interface GraphicsStatistics {\r\n  drawCalls: number;\r\n  drawnImages: number;\r\n}\r\n\r\n/**\r\n * Debug statistics and flags for Excalibur. If polling these values, it would be\r\n * best to do so on the `postupdate` event for [[Engine]], after all values have been\r\n * updated during a frame.\r\n */\r\nexport class Debug implements DebugFlags {\r\n  private _engine: Engine;\r\n\r\n  constructor(engine: Engine) {\r\n    this._engine = engine;\r\n\r\n    this.colorBlindMode = new ColorBlindFlags(this._engine);\r\n  }\r\n\r\n  /**\r\n   * Switch the current excalibur clock with the [[TestClock]] and return\r\n   * it in the same running state.\r\n   *\r\n   * This is useful when you need to debug frame by frame.\r\n   */\r\n  public useTestClock(): TestClock {\r\n    const clock = this._engine.clock;\r\n    const wasRunning = clock.isRunning();\r\n    clock.stop();\r\n\r\n    const testClock = clock.toTestClock();\r\n    if (wasRunning) {\r\n      testClock.start();\r\n    }\r\n    this._engine.clock = testClock;\r\n    return testClock;\r\n  }\r\n\r\n  /**\r\n   * Switch the current excalibur clock with the [[StandardClock]] and\r\n   * return it in the same running state.\r\n   *\r\n   * This is useful when you need to switch back to normal mode after\r\n   * debugging.\r\n   */\r\n  public useStandardClock(): StandardClock {\r\n    const currentClock = this._engine.clock;\r\n    const wasRunning = currentClock.isRunning();\r\n    currentClock.stop();\r\n\r\n    const standardClock = currentClock.toStandardClock();\r\n    if (wasRunning) {\r\n      standardClock.start();\r\n    }\r\n    this._engine.clock = standardClock;\r\n    return standardClock;\r\n  }\r\n\r\n  /**\r\n   * Performance statistics\r\n   */\r\n  public stats: DebugStats = {\r\n    /**\r\n     * Current frame statistics. Engine reuses this instance, use [[FrameStats.clone]] to copy frame stats.\r\n     * Best accessed on [[postframe]] event. See [[FrameStats]]\r\n     */\r\n    currFrame: new FrameStats(),\r\n\r\n    /**\r\n     * Previous frame statistics. Engine reuses this instance, use [[FrameStats.clone]] to copy frame stats.\r\n     * Best accessed on [[preframe]] event. Best inspected on engine event `preframe`. See [[FrameStats]]\r\n     */\r\n    prevFrame: new FrameStats()\r\n  };\r\n\r\n  /**\r\n   * Correct or simulate color blindness using [[ColorBlindnessPostProcessor]].\r\n   * @warning Will reduce FPS.\r\n   */\r\n  public colorBlindMode: ColorBlindFlags;\r\n\r\n  /**\r\n   * Filter debug context to named entities or entity ids\r\n   */\r\n  public filter: { useFilter: boolean; nameQuery: string; ids: number[] } = {\r\n    /**\r\n     * Toggle filter on or off (default off) must be on for DebugDraw to use filters\r\n     */\r\n    useFilter: false,\r\n    /**\r\n     * Query for entities by name, if the entity name contains `nameQuery` it will be included\r\n     */\r\n    nameQuery: '',\r\n    /**\r\n     * Query for Entity ids, if the id matches it will be included\r\n     */\r\n    ids: []\r\n  };\r\n\r\n  /**\r\n   * Entity debug settings\r\n   */\r\n  public entity = {\r\n    showAll: false,\r\n    showId: true,\r\n    showName: false\r\n  };\r\n\r\n  /**\r\n   * Transform component debug settings\r\n   */\r\n  public transform = {\r\n    showAll: false,\r\n\r\n    showPosition: false,\r\n    showPositionLabel: false,\r\n    positionColor: Color.Yellow,\r\n\r\n    showZIndex: false,\r\n\r\n    showScale: false,\r\n    scaleColor: Color.Green,\r\n\r\n    showRotation: false,\r\n    rotationColor: Color.Blue\r\n  };\r\n\r\n  /**\r\n   * Graphics component debug settings\r\n   */\r\n  public graphics = {\r\n    showAll: false,\r\n\r\n    showBounds: true,\r\n    boundsColor: Color.Yellow\r\n  };\r\n\r\n  /**\r\n   * Collider component debug settings\r\n   */\r\n  public collider = {\r\n    showAll: false,\r\n\r\n    showBounds: true,\r\n    boundsColor: Color.Blue,\r\n\r\n    showOwner: false,\r\n\r\n    showGeometry: true,\r\n    geometryColor: Color.Green\r\n  };\r\n\r\n  /**\r\n   * Physics simulation debug settings\r\n   */\r\n  public physics = {\r\n    showAll: false,\r\n\r\n    showBroadphaseSpacePartitionDebug: false,\r\n\r\n    showCollisionNormals: false,\r\n    collisionNormalColor: Color.Cyan,\r\n\r\n    showCollisionContacts: true,\r\n    collisionContactColor: Color.Red\r\n  };\r\n\r\n  /**\r\n   * Motion component debug settings\r\n   */\r\n  public motion = {\r\n    showAll: false,\r\n\r\n    showVelocity: false,\r\n    velocityColor: Color.Yellow,\r\n\r\n    showAcceleration: false,\r\n    accelerationColor: Color.Red\r\n  };\r\n\r\n  /**\r\n   * Body component debug settings\r\n   */\r\n  public body = {\r\n    showAll: false,\r\n\r\n    showCollisionGroup: false,\r\n    showCollisionType: false,\r\n    showSleeping: false,\r\n    showMotion: false,\r\n    showMass: false\r\n  };\r\n\r\n  /**\r\n   * Camera debug settings\r\n   */\r\n  public camera = {\r\n    showAll: false,\r\n\r\n    showFocus: false,\r\n    focusColor: Color.Red,\r\n\r\n    showZoom: false\r\n  };\r\n}\r\n\r\n/**\r\n * Implementation of a frame's stats. Meant to have values copied via [[FrameStats.reset]], avoid\r\n * creating instances of this every frame.\r\n */\r\nexport class FrameStats implements FrameStatistics {\r\n  private _id: number = 0;\r\n  private _delta: number = 0;\r\n  private _fps: number = 0;\r\n  private _actorStats: FrameActorStats = {\r\n    alive: 0,\r\n    killed: 0,\r\n    ui: 0,\r\n    get remaining() {\r\n      return this.alive - this.killed;\r\n    },\r\n    get total() {\r\n      return this.remaining + this.ui;\r\n    }\r\n  };\r\n  private _durationStats: FrameDurationStats = {\r\n    update: 0,\r\n    draw: 0,\r\n    get total() {\r\n      return this.update + this.draw;\r\n    }\r\n  };\r\n\r\n  private _physicsStats: PhysicsStats = new PhysicsStats();\r\n\r\n  private _graphicsStats: GraphicsStatistics = {\r\n    drawCalls: 0,\r\n    drawnImages: 0\r\n  };\r\n\r\n  /**\r\n   * Zero out values or clone other IFrameStat stats. Allows instance reuse.\r\n   *\r\n   * @param [otherStats] Optional stats to clone\r\n   */\r\n  public reset(otherStats?: FrameStatistics) {\r\n    if (otherStats) {\r\n      this.id = otherStats.id;\r\n      this.delta = otherStats.delta;\r\n      this.fps = otherStats.fps;\r\n      this.actors.alive = otherStats.actors.alive;\r\n      this.actors.killed = otherStats.actors.killed;\r\n      this.actors.ui = otherStats.actors.ui;\r\n      this.duration.update = otherStats.duration.update;\r\n      this.duration.draw = otherStats.duration.draw;\r\n      this._physicsStats.reset(otherStats.physics);\r\n      this.graphics.drawCalls = otherStats.graphics.drawCalls;\r\n      this.graphics.drawnImages = otherStats.graphics.drawnImages;\r\n    } else {\r\n      this.id = this.delta = this.fps = 0;\r\n      this.actors.alive = this.actors.killed = this.actors.ui = 0;\r\n      this.duration.update = this.duration.draw = 0;\r\n      this._physicsStats.reset();\r\n      this.graphics.drawnImages = this.graphics.drawCalls = 0;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Provides a clone of this instance.\r\n   */\r\n  public clone(): FrameStats {\r\n    const fs = new FrameStats();\r\n\r\n    fs.reset(this);\r\n\r\n    return fs;\r\n  }\r\n\r\n  /**\r\n   * Gets the frame's id\r\n   */\r\n  public get id() {\r\n    return this._id;\r\n  }\r\n\r\n  /**\r\n   * Sets the frame's id\r\n   */\r\n  public set id(value: number) {\r\n    this._id = value;\r\n  }\r\n\r\n  /**\r\n   * Gets the frame's delta (time since last frame)\r\n   */\r\n  public get delta() {\r\n    return this._delta;\r\n  }\r\n\r\n  /**\r\n   * Sets the frame's delta (time since last frame). Internal use only.\r\n   * @internal\r\n   */\r\n  public set delta(value: number) {\r\n    this._delta = value;\r\n  }\r\n\r\n  /**\r\n   * Gets the frame's frames-per-second (FPS)\r\n   */\r\n  public get fps() {\r\n    return this._fps;\r\n  }\r\n\r\n  /**\r\n   * Sets the frame's frames-per-second (FPS). Internal use only.\r\n   * @internal\r\n   */\r\n  public set fps(value: number) {\r\n    this._fps = value;\r\n  }\r\n\r\n  /**\r\n   * Gets the frame's actor statistics\r\n   */\r\n  public get actors() {\r\n    return this._actorStats;\r\n  }\r\n\r\n  /**\r\n   * Gets the frame's duration statistics\r\n   */\r\n  public get duration() {\r\n    return this._durationStats;\r\n  }\r\n\r\n  /**\r\n   * Gets the frame's physics statistics\r\n   */\r\n  public get physics() {\r\n    return this._physicsStats;\r\n  }\r\n\r\n  /**\r\n   * Gets the frame's graphics statistics\r\n   */\r\n  public get graphics() {\r\n    return this._graphicsStats;\r\n  }\r\n}\r\n\r\nexport class PhysicsStats implements PhysicsStatistics {\r\n  private _pairs: number = 0;\r\n  private _collisions: number = 0;\r\n  private _contacts: Map<string, CollisionContact> = new Map();\r\n  private _fastBodies: number = 0;\r\n  private _fastBodyCollisions: number = 0;\r\n  private _broadphase: number = 0;\r\n  private _narrowphase: number = 0;\r\n\r\n  /**\r\n   * Zero out values or clone other IPhysicsStats stats. Allows instance reuse.\r\n   *\r\n   * @param [otherStats] Optional stats to clone\r\n   */\r\n  public reset(otherStats?: PhysicsStatistics) {\r\n    if (otherStats) {\r\n      this.pairs = otherStats.pairs;\r\n      this.collisions = otherStats.collisions;\r\n      this.contacts = otherStats.contacts;\r\n      this.fastBodies = otherStats.fastBodies;\r\n      this.fastBodyCollisions = otherStats.fastBodyCollisions;\r\n      this.broadphase = otherStats.broadphase;\r\n      this.narrowphase = otherStats.narrowphase;\r\n    } else {\r\n      this.pairs = this.collisions = this.fastBodies = 0;\r\n      this.fastBodyCollisions = this.broadphase = this.narrowphase = 0;\r\n      this.contacts.clear();\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Provides a clone of this instance.\r\n   */\r\n  public clone(): PhysicsStatistics {\r\n    const ps = new PhysicsStats();\r\n\r\n    ps.reset(this);\r\n\r\n    return ps;\r\n  }\r\n\r\n  public get pairs(): number {\r\n    return this._pairs;\r\n  }\r\n\r\n  public set pairs(value: number) {\r\n    this._pairs = value;\r\n  }\r\n\r\n  public get collisions(): number {\r\n    return this._collisions;\r\n  }\r\n\r\n  public set collisions(value: number) {\r\n    this._collisions = value;\r\n  }\r\n\r\n  public get contacts(): Map<string, CollisionContact> {\r\n    return this._contacts;\r\n  }\r\n\r\n  public set contacts(contacts: Map<string, CollisionContact>) {\r\n    this._contacts = contacts;\r\n  }\r\n\r\n  public get fastBodies(): number {\r\n    return this._fastBodies;\r\n  }\r\n\r\n  public set fastBodies(value: number) {\r\n    this._fastBodies = value;\r\n  }\r\n\r\n  public get fastBodyCollisions(): number {\r\n    return this._fastBodyCollisions;\r\n  }\r\n\r\n  public set fastBodyCollisions(value: number) {\r\n    this._fastBodyCollisions = value;\r\n  }\r\n\r\n  public get broadphase(): number {\r\n    return this._broadphase;\r\n  }\r\n\r\n  public set broadphase(value: number) {\r\n    this._broadphase = value;\r\n  }\r\n\r\n  public get narrowphase(): number {\r\n    return this._narrowphase;\r\n  }\r\n\r\n  public set narrowphase(value: number) {\r\n    this._narrowphase = value;\r\n  }\r\n}\r\n","/**\r\n * Determines the scope of handling mouse/touch events.\r\n */\r\n\r\nexport enum PointerScope {\r\n  /**\r\n   * Handle events on the `canvas` element only. Events originating outside the\r\n   * `canvas` will not be handled.\r\n   */\r\n  Canvas = 'Canvas',\r\n\r\n  /**\r\n   * Handles events on the entire document. All events will be handled by Excalibur.\r\n   */\r\n  Document = 'Document'\r\n}\r\n","import { Class } from './../Class';\r\nimport { GameEvent, GamepadConnectEvent, GamepadDisconnectEvent, GamepadButtonEvent, GamepadAxisEvent } from '../Events';\r\nimport * as Events from '../Events';\r\n\r\n/**\r\n * Excalibur leverages the HTML5 Gamepad API [where it is supported](http://caniuse.com/#feat=gamepad)\r\n * to provide controller support for your games.\r\n */\r\nexport class Gamepads extends Class {\r\n  /**\r\n   * Whether or not to poll for Gamepad input (default: `false`)\r\n   */\r\n  public enabled = false;\r\n\r\n  /**\r\n   * Whether or not Gamepad API is supported\r\n   */\r\n  public supported = !!(<any>navigator).getGamepads;\r\n\r\n  /**\r\n   * The minimum value an axis has to move before considering it a change\r\n   */\r\n  public static MinAxisMoveThreshold = 0.05;\r\n\r\n  private _gamePadTimeStamps = [0, 0, 0, 0];\r\n  private _oldPads: Gamepad[] = [];\r\n  private _pads: Gamepad[] = [];\r\n  private _initSuccess: boolean = false;\r\n  private _navigator: NavigatorGamepads = <any>navigator;\r\n  private _minimumConfiguration: GamepadConfiguration = null;\r\n\r\n  constructor() {\r\n    super();\r\n  }\r\n\r\n  public init() {\r\n    if (!this.supported) {\r\n      return;\r\n    }\r\n    if (this._initSuccess) {\r\n      return;\r\n    }\r\n\r\n    // In Chrome, this will return 4 undefined items until a button is pressed\r\n    // In FF, this will not return any items until a button is pressed\r\n    this._oldPads = this._clonePads(this._navigator.getGamepads());\r\n    if (this._oldPads.length && this._oldPads[0]) {\r\n      this._initSuccess = true;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Sets the minimum gamepad configuration, for example {axis: 4, buttons: 4} means\r\n   * this game requires at minimum 4 axis inputs and 4 buttons, this is not restrictive\r\n   * all other controllers with more axis or buttons are valid as well. If no minimum\r\n   * configuration is set all pads are valid.\r\n   */\r\n  public setMinimumGamepadConfiguration(config: GamepadConfiguration): void {\r\n    this._enableAndUpdate(); // if config is used, implicitly enable\r\n    this._minimumConfiguration = config;\r\n  }\r\n\r\n  /**\r\n   * When implicitly enabled, set the enabled flag and run an update so information is updated\r\n   */\r\n  private _enableAndUpdate() {\r\n    if (!this.enabled) {\r\n      this.enabled = true;\r\n      this.update();\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Checks a navigator gamepad against the minimum configuration if present.\r\n   */\r\n  private _isGamepadValid(pad: NavigatorGamepad): boolean {\r\n    if (!this._minimumConfiguration) {\r\n      return true;\r\n    }\r\n    if (!pad) {\r\n      return false;\r\n    }\r\n    const axesLength = pad.axes.filter((value) => {\r\n      return typeof value !== undefined;\r\n    }).length;\r\n\r\n    const buttonLength = pad.buttons.filter((value) => {\r\n      return typeof value !== undefined;\r\n    }).length;\r\n    return axesLength >= this._minimumConfiguration.axis && buttonLength >= this._minimumConfiguration.buttons && pad.connected;\r\n  }\r\n\r\n  public on(eventName: Events.connect, handler: (event: GamepadConnectEvent) => void): void;\r\n  public on(eventName: Events.disconnect, handler: (event: GamepadDisconnectEvent) => void): void;\r\n  public on(eventName: Events.button, handler: (event: GamepadButtonEvent) => void): void;\r\n  public on(eventName: Events.axis, handler: (event: GamepadAxisEvent) => void): void;\r\n  public on(eventName: string, handler: (event: GameEvent<any>) => void): void;\r\n  public on(eventName: string, handler: (event: any) => void): void {\r\n    this._enableAndUpdate(); // implicitly enable\r\n    super.on(eventName, handler);\r\n  }\r\n\r\n  public off(eventName: string, handler?: (event: GameEvent<any>) => void) {\r\n    this._enableAndUpdate(); // implicitly enable\r\n    super.off(eventName, handler);\r\n  }\r\n\r\n  /**\r\n   * Updates Gamepad state and publishes Gamepad events\r\n   */\r\n  public update() {\r\n    if (!this.enabled || !this.supported) {\r\n      return;\r\n    }\r\n    this.init();\r\n\r\n    const gamepads = this._navigator.getGamepads();\r\n\r\n    for (let i = 0; i < gamepads.length; i++) {\r\n      if (!gamepads[i]) {\r\n        const gamepad = this.at(i);\r\n        // If was connected, but now isn't emit the disconnect event\r\n        if (gamepad.connected) {\r\n          this.eventDispatcher.emit('disconnect', new GamepadDisconnectEvent(i, gamepad));\r\n        }\r\n        // Reset connection status\r\n        gamepad.connected = false;\r\n        continue;\r\n      } else {\r\n        if (!this.at(i).connected && this._isGamepadValid(gamepads[i])) {\r\n          this.eventDispatcher.emit('connect', new GamepadConnectEvent(i, this.at(i)));\r\n        }\r\n        // Set connection status\r\n        this.at(i).connected = true;\r\n      }\r\n\r\n      // Only supported in Chrome\r\n      if (gamepads[i].timestamp && gamepads[i].timestamp === this._gamePadTimeStamps[i]) {\r\n        continue;\r\n      }\r\n\r\n      this._gamePadTimeStamps[i] = gamepads[i].timestamp;\r\n\r\n      // Add reference to navigator gamepad\r\n      this.at(i).navigatorGamepad = gamepads[i];\r\n\r\n      // Buttons\r\n      let b: string, bi: number, a: string, ai: number, value: number;\r\n\r\n      for (b in Buttons) {\r\n        bi = <any>Buttons[b];\r\n        if (typeof bi === 'number') {\r\n          if (gamepads[i].buttons[bi]) {\r\n            value = gamepads[i].buttons[bi].value;\r\n            if (value !== this._oldPads[i].getButton(bi)) {\r\n              if (gamepads[i].buttons[bi].pressed) {\r\n                this.at(i).updateButton(bi, value);\r\n                this.at(i).eventDispatcher.emit('button', new GamepadButtonEvent(bi, value, this.at(i)));\r\n              } else {\r\n                this.at(i).updateButton(bi, 0);\r\n              }\r\n            }\r\n          }\r\n        }\r\n      }\r\n\r\n      // Axes\r\n      for (a in Axes) {\r\n        ai = <any>Axes[a];\r\n        if (typeof ai === 'number') {\r\n          value = gamepads[i].axes[ai];\r\n          if (value !== this._oldPads[i].getAxes(ai)) {\r\n            this.at(i).updateAxes(ai, value);\r\n            this.at(i).eventDispatcher.emit('axis', new GamepadAxisEvent(ai, value, this.at(i)));\r\n          }\r\n        }\r\n      }\r\n\r\n      this._oldPads[i] = this._clonePad(gamepads[i]);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Safely retrieves a Gamepad at a specific index and creates one if it doesn't yet exist\r\n   */\r\n  public at(index: number): Gamepad {\r\n    this._enableAndUpdate(); // implicitly enable gamepads when at() is called\r\n    if (index >= this._pads.length) {\r\n      // Ensure there is a pad to retrieve\r\n      for (let i = this._pads.length - 1, max = index; i < max; i++) {\r\n        this._pads.push(new Gamepad());\r\n        this._oldPads.push(new Gamepad());\r\n      }\r\n    }\r\n\r\n    return this._pads[index];\r\n  }\r\n\r\n  /**\r\n   * Returns a list of all valid gamepads that meet the minimum configuration requirement.\r\n   */\r\n  public getValidGamepads(): Gamepad[] {\r\n    this._enableAndUpdate();\r\n    const result: Gamepad[] = [];\r\n    for (let i = 0; i < this._pads.length; i++) {\r\n      if (this._isGamepadValid(this.at(i).navigatorGamepad) && this.at(i).connected) {\r\n        result.push(this.at(i));\r\n      }\r\n    }\r\n    return result;\r\n  }\r\n\r\n  /**\r\n   * Gets the number of connected gamepads\r\n   */\r\n  public count() {\r\n    return this._pads.filter((p) => p.connected).length;\r\n  }\r\n\r\n  private _clonePads(pads: NavigatorGamepad[]): Gamepad[] {\r\n    const arr = [];\r\n    for (let i = 0, len = pads.length; i < len; i++) {\r\n      arr.push(this._clonePad(pads[i]));\r\n    }\r\n    return arr;\r\n  }\r\n\r\n  /**\r\n   * Fastest way to clone a known object is to do it yourself\r\n   */\r\n  private _clonePad(pad: NavigatorGamepad): Gamepad {\r\n    let i, len;\r\n    const clonedPad = new Gamepad();\r\n\r\n    if (!pad) {\r\n      return clonedPad;\r\n    }\r\n\r\n    for (i = 0, len = pad.buttons.length; i < len; i++) {\r\n      if (pad.buttons[i]) {\r\n        clonedPad.updateButton(i, pad.buttons[i].value);\r\n      }\r\n    }\r\n    for (i = 0, len = pad.axes.length; i < len; i++) {\r\n      clonedPad.updateAxes(i, pad.axes[i]);\r\n    }\r\n\r\n    return clonedPad;\r\n  }\r\n}\r\n\r\n/**\r\n * Gamepad holds state information for a connected controller. See [[Gamepads]]\r\n * for more information on handling controller input.\r\n */\r\nexport class Gamepad extends Class {\r\n  public connected = false;\r\n  public navigatorGamepad: NavigatorGamepad;\r\n  private _buttons: number[] = new Array(16);\r\n  private _axes: number[] = new Array(4);\r\n\r\n  constructor() {\r\n    super();\r\n\r\n    for (let i = 0; i < this._buttons.length; i++) {\r\n      this._buttons[i] = 0;\r\n    }\r\n    for (let i = 0; i < this._axes.length; i++) {\r\n      this._axes[i] = 0;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Whether or not the given button is pressed\r\n   * @param button     The button to query\r\n   * @param threshold  The threshold over which the button is considered to be pressed\r\n   */\r\n  public isButtonPressed(button: Buttons, threshold: number = 1) {\r\n    return this._buttons[button] >= threshold;\r\n  }\r\n\r\n  /**\r\n   * Gets the given button value between 0 and 1\r\n   */\r\n  public getButton(button: Buttons) {\r\n    return this._buttons[button];\r\n  }\r\n\r\n  /**\r\n   * Gets the given axis value between -1 and 1. Values below\r\n   * [[MinAxisMoveThreshold]] are considered 0.\r\n   */\r\n  public getAxes(axes: Axes) {\r\n    const value = this._axes[axes];\r\n\r\n    if (Math.abs(value) < Gamepads.MinAxisMoveThreshold) {\r\n      return 0;\r\n    } else {\r\n      return value;\r\n    }\r\n  }\r\n\r\n  public updateButton(buttonIndex: number, value: number) {\r\n    this._buttons[buttonIndex] = value;\r\n  }\r\n\r\n  public updateAxes(axesIndex: number, value: number) {\r\n    this._axes[axesIndex] = value;\r\n  }\r\n}\r\n\r\n/**\r\n * Gamepad Buttons enumeration\r\n */\r\nexport enum Buttons {\r\n  /**\r\n   * Face 1 button (e.g. A)\r\n   */\r\n  Face1 = 0,\r\n  /**\r\n   * Face 2 button (e.g. B)\r\n   */\r\n  Face2 = 1,\r\n  /**\r\n   * Face 3 button (e.g. X)\r\n   */\r\n  Face3 = 2,\r\n  /**\r\n   * Face 4 button (e.g. Y)\r\n   */\r\n  Face4 = 3,\r\n  /**\r\n   * Left bumper button\r\n   */\r\n  LeftBumper = 4,\r\n  /**\r\n   * Right bumper button\r\n   */\r\n  RightBumper = 5,\r\n  /**\r\n   * Left trigger button\r\n   */\r\n  LeftTrigger = 6,\r\n  /**\r\n   * Right trigger button\r\n   */\r\n  RightTrigger = 7,\r\n  /**\r\n   * Select button\r\n   */\r\n  Select = 8,\r\n  /**\r\n   * Start button\r\n   */\r\n  Start = 9,\r\n  /**\r\n   * Left analog stick press (e.g. L3)\r\n   */\r\n  LeftStick = 10,\r\n  /**\r\n   * Right analog stick press (e.g. R3)\r\n   */\r\n  RightStick = 11,\r\n  /**\r\n   * D-pad up\r\n   */\r\n  DpadUp = 12,\r\n  /**\r\n   * D-pad down\r\n   */\r\n  DpadDown = 13,\r\n  /**\r\n   * D-pad left\r\n   */\r\n  DpadLeft = 14,\r\n  /**\r\n   * D-pad right\r\n   */\r\n  DpadRight = 15\r\n}\r\n\r\n/**\r\n * Gamepad Axes enumeration\r\n */\r\nexport enum Axes {\r\n  /**\r\n   * Left analogue stick X direction\r\n   */\r\n  LeftStickX = 0,\r\n  /**\r\n   * Left analogue stick Y direction\r\n   */\r\n  LeftStickY = 1,\r\n  /**\r\n   * Right analogue stick X direction\r\n   */\r\n  RightStickX = 2,\r\n  /**\r\n   * Right analogue stick Y direction\r\n   */\r\n  RightStickY = 3\r\n}\r\n\r\n/**\r\n * @internal\r\n */\r\nexport interface NavigatorGamepads {\r\n  getGamepads(): NavigatorGamepad[];\r\n}\r\n\r\n/**\r\n * @internal\r\n */\r\nexport interface NavigatorGamepad {\r\n  axes: number[];\r\n  buttons: NavigatorGamepadButton[];\r\n  connected: boolean;\r\n  id: string;\r\n  index: number;\r\n  mapping: string;\r\n  timestamp: number;\r\n}\r\n\r\n/**\r\n * @internal\r\n */\r\nexport interface NavigatorGamepadButton {\r\n  pressed: boolean;\r\n  value: number;\r\n}\r\n\r\n/**\r\n * @internal\r\n */\r\nexport interface NavigatorGamepadEvent {\r\n  gamepad: NavigatorGamepad;\r\n}\r\n\r\n/**\r\n * @internal\r\n */\r\nexport interface GamepadConfiguration {\r\n  axis: number;\r\n  buttons: number;\r\n}\r\n","export interface NativeEventable {\r\n  addEventListener(name: string, handler: (...any: any[]) => any): any;\r\n  removeEventListener(name: string, handler: (...any: any[]) => any): any;\r\n}\r\n\r\nexport class BrowserComponent<T extends NativeEventable> {\r\n  private _paused = false;\r\n  private _nativeHandlers: { [key: string]: (handler: any) => void } = {};\r\n\r\n  on(eventName: string, handler: (evt: any) => void): void {\r\n    if (this._nativeHandlers[eventName]) {\r\n      this.off(eventName, this._nativeHandlers[eventName]);\r\n    }\r\n    this._nativeHandlers[eventName] = this._decorate(handler);\r\n    this.nativeComponent.addEventListener(eventName, this._nativeHandlers[eventName]);\r\n  }\r\n  off(eventName: string, handler?: (event: any) => void): void {\r\n    if (!handler) {\r\n      handler = this._nativeHandlers[eventName];\r\n    }\r\n    this.nativeComponent.removeEventListener(eventName, handler);\r\n    this._nativeHandlers[eventName] = null;\r\n  }\r\n\r\n  private _decorate(handler: (evt: any) => void): (evt: any) => void {\r\n    return (evt: any) => {\r\n      if (!this._paused) {\r\n        handler(evt);\r\n      }\r\n    };\r\n  }\r\n\r\n  public pause() {\r\n    this._paused = true;\r\n  }\r\n\r\n  public resume() {\r\n    this._paused = false;\r\n  }\r\n\r\n  public clear() {\r\n    for (const event in this._nativeHandlers) {\r\n      this.off(event);\r\n    }\r\n  }\r\n\r\n  constructor(public nativeComponent: T) {}\r\n}\r\n\r\nexport class BrowserEvents {\r\n  private _windowComponent: BrowserComponent<Window>;\r\n  private _documentComponent: BrowserComponent<Document>;\r\n  constructor(private _windowGlobal: Window, private _documentGlobal: Document) {\r\n    this._windowComponent = new BrowserComponent(this._windowGlobal);\r\n    this._documentComponent = new BrowserComponent(this._documentGlobal);\r\n  }\r\n\r\n  public get window(): BrowserComponent<Window> {\r\n    return this._windowComponent;\r\n  }\r\n\r\n  public get document(): BrowserComponent<Document> {\r\n    return this._documentComponent;\r\n  }\r\n\r\n  public pause() {\r\n    this.window.pause();\r\n    this.document.pause();\r\n  }\r\n\r\n  public resume() {\r\n    this.window.resume();\r\n    this.document.resume();\r\n  }\r\n\r\n  public clear() {\r\n    this.window.clear();\r\n    this.document.clear();\r\n  }\r\n}\r\n","import { Engine } from '../Engine';\r\nimport { Vector } from './vector';\r\n\r\nexport class GlobalCoordinates {\r\n  public static fromPagePosition(x: number, y: number, engine: Engine): GlobalCoordinates;\r\n  public static fromPagePosition(pos: Vector, engine: Engine): GlobalCoordinates;\r\n  public static fromPagePosition(xOrPos: number | Vector, yOrEngine: number | Engine, engineOrUndefined?: Engine): GlobalCoordinates {\r\n    let pageX: number;\r\n    let pageY: number;\r\n    let pagePos: Vector;\r\n    let engine: Engine;\r\n\r\n    if (arguments.length === 3) {\r\n      pageX = <number>xOrPos;\r\n      pageY = <number>yOrEngine;\r\n      pagePos = new Vector(pageX, pageY);\r\n      engine = engineOrUndefined;\r\n    } else {\r\n      pagePos = <Vector>xOrPos;\r\n      pageX = pagePos.x;\r\n      pageY = pagePos.y;\r\n      engine = <Engine>yOrEngine;\r\n    }\r\n\r\n    const screenPos = engine.screen.pageToScreenCoordinates(pagePos);\r\n    const worldPos = engine.screen.screenToWorldCoordinates(screenPos);\r\n\r\n    return new GlobalCoordinates(worldPos, pagePos, screenPos);\r\n  }\r\n\r\n  constructor(public worldPos: Vector, public pagePos: Vector, public screenPos: Vector) {}\r\n}\r\n","import { GlobalCoordinates } from '../Math/global-coordinates';\r\nimport { Vector } from '../Math/vector';\r\nimport { PointerButton } from './PointerButton';\r\nimport { PointerType } from './PointerType';\r\n\r\nexport class PointerEvent {\r\n  public active = true;\r\n  public cancel() {\r\n    this.active = false;\r\n  }\r\n\r\n  get pagePos(): Vector {\r\n    return this.coordinates.pagePos;\r\n  }\r\n\r\n  get screenPos(): Vector {\r\n    return this.coordinates.screenPos;\r\n  }\r\n\r\n  get worldPos(): Vector {\r\n    return this.coordinates.worldPos;\r\n  }\r\n\r\n  constructor(\r\n    public type: 'down' | 'up' | 'move' | 'cancel',\r\n    public pointerId: number,\r\n    public button: PointerButton,\r\n    public pointerType: PointerType,\r\n    public coordinates: GlobalCoordinates,\r\n    public nativeEvent: Event) { };\r\n}\r\n","import { WheelDeltaMode } from './WheelDeltaMode';\r\n\r\n\r\nexport class WheelEvent {\r\n  public active = true;\r\n  public cancel() {\r\n    this.active = false;\r\n  }\r\n  constructor(\r\n    public x: number,\r\n    public y: number,\r\n    public pageX: number,\r\n    public pageY: number,\r\n    public screenX: number,\r\n    public screenY: number,\r\n    public index: number,\r\n    public deltaX: number,\r\n    public deltaY: number,\r\n    public deltaZ: number,\r\n    public deltaMode: WheelDeltaMode,\r\n    public ev: Event\r\n  ) { }\r\n}\r\n","import { Class } from '../Class';\r\nimport { Vector } from '../Math/vector';\r\nimport { WheelEvent } from './WheelEvent';\r\nimport { PointerEvent } from './PointerEvent';\r\n\r\nexport class PointerAbstraction extends Class {\r\n\r\n  /**\r\n   * The last position on the document this pointer was at. Can be `null` if pointer was never active.\r\n   */\r\n  public lastPagePos: Vector = Vector.Zero;\r\n\r\n  /**\r\n   * The last position on the screen this pointer was at. Can be `null` if pointer was never active.\r\n   */\r\n  public lastScreenPos: Vector = Vector.Zero;\r\n\r\n  /**\r\n   * The last position in the game world coordinates this pointer was at. Can be `null` if pointer was never active.\r\n   */\r\n  public lastWorldPos: Vector = Vector.Zero;\r\n\r\n  constructor() {\r\n    super();\r\n    this.on('move', this._onPointerMove);\r\n    this.on('down', this._onPointerDown);\r\n  }\r\n\r\n  on(event: 'move', handler: (event: PointerEvent) => void): void;\r\n  on(event: 'down', handler: (event: PointerEvent) => void): void;\r\n  on(event: 'up', handler: (event: PointerEvent) => void): void;\r\n  on(event: 'wheel', handler: (event: WheelEvent) => void): void;\r\n  on(event: string, handler: (event: any) => void): void {\r\n    super.on(event, handler);\r\n  }\r\n\r\n  once(event: 'move', handler: (event: PointerEvent) => void): void;\r\n  once(event: 'down', handler: (event: PointerEvent) => void): void;\r\n  once(event: 'up', handler: (event: PointerEvent) => void): void;\r\n  once(event: 'wheel', handler: (event: WheelEvent) => void): void;\r\n  once(event: string, handler: (event: any) => void): void {\r\n    super.once(event, handler);\r\n  }\r\n\r\n  off(event: 'move', handler?: (event: PointerEvent) => void): void;\r\n  off(event: 'down', handler?: (event: PointerEvent) => void): void;\r\n  off(event: 'up', handler?: (event: PointerEvent) => void): void;\r\n  off(event: 'wheel', handler?: (event: WheelEvent) => void): void;\r\n  off(event: string, handler?: (event: any) => void): void {\r\n    super.off(event, handler);\r\n  }\r\n\r\n  private _onPointerMove = (ev: PointerEvent): void => {\r\n    this.lastPagePos = new Vector(ev.pagePos.x, ev.pagePos.y);\r\n    this.lastScreenPos = new Vector(ev.screenPos.x, ev.screenPos.y);\r\n    this.lastWorldPos = new Vector(ev.worldPos.x, ev.worldPos.y);\r\n  };\r\n\r\n  private _onPointerDown = (ev: PointerEvent): void => {\r\n    this.lastPagePos = new Vector(ev.pagePos.x, ev.pagePos.y);\r\n    this.lastScreenPos = new Vector(ev.screenPos.x, ev.screenPos.y);\r\n    this.lastWorldPos = new Vector(ev.worldPos.x, ev.worldPos.y);\r\n  };\r\n}\r\n","/**\r\n * The mouse button being pressed.\r\n */\r\nexport enum PointerButton {\r\n  Left = 'Left',\r\n  Middle = 'Middle',\r\n  Right = 'Right',\r\n  Unknown = 'Unknown',\r\n  NoButton = 'NoButton'\r\n}\r\n","/**\r\n * The type of pointer for a [[PointerEvent]].\r\n */\r\nexport enum PointerType {\r\n  Touch = 'Touch',\r\n  Mouse = 'Mouse',\r\n  Pen = 'Pen',\r\n  Unknown = 'Unknown'\r\n}\r\n","import { Class } from '../Class';\r\nimport { Engine, ScrollPreventionMode } from '../Engine';\r\nimport { GlobalCoordinates } from '../Math/global-coordinates';\r\nimport { vec, Vector } from '../Math/vector';\r\nimport { PointerEvent } from './PointerEvent';\r\nimport { WheelEvent } from './WheelEvent';\r\nimport { PointerAbstraction } from './PointerAbstraction';\r\n\r\nimport { WheelDeltaMode } from './WheelDeltaMode';\r\nimport { PointerSystem } from './PointerSystem';\r\nimport { NativePointerButton } from './NativePointerButton';\r\nimport { PointerButton } from './PointerButton';\r\nimport { fail } from '../Util/Util';\r\nimport { PointerType } from './PointerType';\r\n\r\n\r\nexport type NativePointerEvent = globalThis.PointerEvent;\r\nexport type NativeMouseEvent = globalThis.MouseEvent;\r\nexport type NativeTouchEvent = globalThis.TouchEvent;\r\nexport type NativeWheelEvent = globalThis.WheelEvent;\r\n\r\n/**\r\n * Is this event a native touch event?\r\n */\r\nfunction isTouchEvent(value: any): value is NativeTouchEvent {\r\n  // Guard for Safari <= 13.1\r\n  return globalThis.TouchEvent && value instanceof globalThis.TouchEvent;\r\n}\r\n\r\n/**\r\n * Is this event a native pointer event\r\n */\r\nfunction isPointerEvent(value: any): value is NativePointerEvent {\r\n  // Guard for Safari <= 13.1\r\n  return globalThis.PointerEvent && value instanceof globalThis.PointerEvent;\r\n}\r\n\r\n/**\r\n * The PointerEventProcessor is responsible for collecting all the events from the canvas and transforming them into GlobalCoordinates\r\n */\r\nexport class PointerEventReceiver extends Class {\r\n  public primary: PointerAbstraction = new PointerAbstraction();\r\n\r\n  private _activeNativePointerIdsToNormalized = new Map<number, number>();\r\n  public lastFramePointerCoords = new Map<number, GlobalCoordinates>();\r\n  public currentFramePointerCoords = new Map<number, GlobalCoordinates>();\r\n\r\n  public currentFramePointerDown = new Map<number, boolean>();\r\n  public lastFramePointerDown = new Map<number, boolean>();\r\n\r\n  public currentFrameDown: PointerEvent[] = [];\r\n  public currentFrameUp: PointerEvent[] = [];\r\n  public currentFrameMove: PointerEvent[] = [];\r\n  public currentFrameCancel: PointerEvent[] = [];\r\n  public currentFrameWheel: WheelEvent[] = [];\r\n\r\n  constructor(public readonly target: GlobalEventHandlers & EventTarget, public engine: Engine) {\r\n    super();\r\n  }\r\n\r\n  /**\r\n   * Creates a new PointerEventReceiver with a new target and engine while preserving existing pointer event\r\n   * handlers.\r\n   * @param target\r\n   * @param engine\r\n   */\r\n  public recreate(target: GlobalEventHandlers & EventTarget, engine: Engine) {\r\n    const eventReceiver = new PointerEventReceiver(target, engine);\r\n    eventReceiver.primary = this.primary;\r\n    eventReceiver._pointers = this._pointers;\r\n    return eventReceiver;\r\n  }\r\n\r\n  private _pointers: PointerAbstraction[] = [this.primary];\r\n  /**\r\n   * Locates a specific pointer by id, creates it if it doesn't exist\r\n   * @param index\r\n   */\r\n  public at(index: number): PointerAbstraction {\r\n    if (index >= this._pointers.length) {\r\n      // Ensure there is a pointer to retrieve\r\n      for (let i = this._pointers.length - 1, max = index; i < max; i++) {\r\n        this._pointers.push(new PointerAbstraction());\r\n      }\r\n    }\r\n    return this._pointers[index];\r\n  }\r\n\r\n  /**\r\n   * The number of pointers currently being tracked by excalibur\r\n   */\r\n  public count(): number {\r\n    return this._pointers.length;\r\n  }\r\n\r\n  /**\r\n   * Is the specified pointer id down this frame\r\n   * @param pointerId\r\n   */\r\n  public isDown(pointerId: number) {\r\n    return this.currentFramePointerDown.get(pointerId) ?? false;\r\n  }\r\n\r\n  /**\r\n   * Was the specified pointer id down last frame\r\n   * @param pointerId\r\n   */\r\n  public wasDown(pointerId: number) {\r\n    return this.lastFramePointerDown.get(pointerId) ?? false;\r\n  }\r\n\r\n  /**\r\n   * Whether the Pointer is currently dragging.\r\n   */\r\n  public isDragging(pointerId: number): boolean {\r\n    return this.isDown(pointerId);\r\n  }\r\n\r\n  /**\r\n   * Whether the Pointer just started dragging.\r\n   */\r\n  public isDragStart(pointerId: number): boolean {\r\n    return this.isDown(pointerId) && !this.wasDown(pointerId);\r\n  }\r\n\r\n  /**\r\n   * Whether the Pointer just ended dragging.\r\n   */\r\n  public isDragEnd(pointerId: number): boolean {\r\n    return !this.isDown(pointerId) && this.wasDown(pointerId);\r\n  }\r\n\r\n  on(event: 'move', handler: (event: PointerEvent) => void): void;\r\n  on(event: 'down', handler: (event: PointerEvent) => void): void;\r\n  on(event: 'up', handler: (event: PointerEvent) => void): void;\r\n  on(event: 'wheel', handler: (event: WheelEvent) => void): void;\r\n  on(event: string, handler: (event: any) => void): void {\r\n    super.on(event, handler);\r\n  }\r\n\r\n  once(event: 'move', handler: (event: PointerEvent) => void): void;\r\n  once(event: 'down', handler: (event: PointerEvent) => void): void;\r\n  once(event: 'up', handler: (event: PointerEvent) => void): void;\r\n  once(event: 'wheel', handler: (event: WheelEvent) => void): void;\r\n  once(event: string, handler: (event: any) => void): void {\r\n    super.once(event, handler);\r\n  }\r\n\r\n  off(event: 'move', handler?: (event: PointerEvent) => void): void;\r\n  off(event: 'down', handler?: (event: PointerEvent) => void): void;\r\n  off(event: 'up', handler?: (event: PointerEvent) => void): void;\r\n  off(event: 'wheel', handler?: (event: WheelEvent) => void): void;\r\n  off(event: string, handler?: (event: any) => void): void {\r\n    super.off(event, handler);\r\n  }\r\n\r\n  /**\r\n   * Called internally by excalibur\r\n   *\r\n   * Updates the current frame pointer info and emits raw pointer events\r\n   *\r\n   * This does not emit events to entities, see PointerSystem\r\n   */\r\n  public update() {\r\n    this.lastFramePointerDown = new Map(this.currentFramePointerDown);\r\n    this.lastFramePointerCoords = new Map(this.currentFramePointerCoords);\r\n\r\n    for (const event of this.currentFrameDown) {\r\n      this.emit('down', event);\r\n      const pointer = this.at(event.pointerId);\r\n      pointer.emit('down', event);\r\n      this.primary.emit('pointerdown', event);\r\n    }\r\n\r\n    for (const event of this.currentFrameUp) {\r\n      this.emit('up', event);\r\n      const pointer = this.at(event.pointerId);\r\n      pointer.emit('up', event);\r\n    }\r\n\r\n    for (const event of this.currentFrameMove) {\r\n      this.emit('move', event);\r\n      const pointer = this.at(event.pointerId);\r\n      pointer.emit('move', event);\r\n    }\r\n\r\n    for (const event of this.currentFrameCancel) {\r\n      this.emit('cancel', event);\r\n      const pointer = this.at(event.pointerId);\r\n      pointer.emit('cancel', event);\r\n    }\r\n\r\n    for (const event of this.currentFrameWheel) {\r\n      this.emit('wheel', event);\r\n      this.primary.emit('pointerwheel', event);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Clears the current frame event and pointer data\r\n   */\r\n  public clear() {\r\n    for (const event of this.currentFrameUp) {\r\n      this.currentFramePointerCoords.delete(event.pointerId);\r\n      const ids = this._activeNativePointerIdsToNormalized.entries();\r\n      for (const [native, normalized] of ids) {\r\n        if (normalized === event.pointerId) {\r\n          this._activeNativePointerIdsToNormalized.delete(native);\r\n        }\r\n      }\r\n    }\r\n    this.currentFrameDown.length = 0;\r\n    this.currentFrameUp.length = 0;\r\n    this.currentFrameMove.length = 0;\r\n    this.currentFrameCancel.length = 0;\r\n    this.currentFrameWheel.length = 0;\r\n  }\r\n\r\n  private _boundHandle = this._handle.bind(this);\r\n  private _boundWheel = this._handleWheel.bind(this);\r\n  /**\r\n   * Initializes the pointer event receiver so that it can start listening to native\r\n   * browser events.\r\n   */\r\n  public init() {\r\n    // Disabling the touch action avoids browser/platform gestures from firing on the canvas\r\n    // It is important on mobile to have touch action 'none'\r\n    // https://stackoverflow.com/questions/48124372/pointermove-event-not-working-with-touch-why-not\r\n    if (this.target === this.engine.canvas) {\r\n      this.engine.canvas.style.touchAction = 'none';\r\n    } else {\r\n      document.body.style.touchAction = 'none';\r\n    }\r\n    // Preferred pointer events\r\n    if (window.PointerEvent) {\r\n      this.target.addEventListener('pointerdown', this._boundHandle);\r\n      this.target.addEventListener('pointerup', this._boundHandle);\r\n      this.target.addEventListener('pointermove', this._boundHandle);\r\n      this.target.addEventListener('pointercancel', this._boundHandle);\r\n    } else {\r\n      // Touch Events\r\n      this.target.addEventListener('touchstart', this._boundHandle);\r\n      this.target.addEventListener('touchend', this._boundHandle);\r\n      this.target.addEventListener('touchmove', this._boundHandle);\r\n      this.target.addEventListener('touchcancel', this._boundHandle);\r\n\r\n      // Mouse Events\r\n      this.target.addEventListener('mousedown', this._boundHandle);\r\n      this.target.addEventListener('mouseup', this._boundHandle);\r\n      this.target.addEventListener('mousemove', this._boundHandle);\r\n    }\r\n\r\n    // MDN MouseWheelEvent\r\n    const wheelOptions = {\r\n      passive: !(\r\n        this.engine.pageScrollPreventionMode === ScrollPreventionMode.All ||\r\n        this.engine.pageScrollPreventionMode === ScrollPreventionMode.Canvas\r\n      )\r\n    };\r\n    if ('onwheel' in document.createElement('div')) {\r\n      // Modern Browsers\r\n      this.target.addEventListener('wheel', this._boundWheel, wheelOptions);\r\n    } else if (document.onmousewheel !== undefined) {\r\n      // Webkit and IE\r\n      this.target.addEventListener('mousewheel', this._boundWheel, wheelOptions);\r\n    } else {\r\n      // Remaining browser and older Firefox\r\n      this.target.addEventListener('MozMousePixelScroll', this._boundWheel, wheelOptions);\r\n    }\r\n  }\r\n\r\n  public detach() {\r\n    // Preferred pointer events\r\n    if (window.PointerEvent) {\r\n      this.target.removeEventListener('pointerdown', this._boundHandle);\r\n      this.target.removeEventListener('pointerup', this._boundHandle);\r\n      this.target.removeEventListener('pointermove', this._boundHandle);\r\n      this.target.removeEventListener('pointercancel', this._boundHandle);\r\n    } else {\r\n      // Touch Events\r\n      this.target.removeEventListener('touchstart', this._boundHandle);\r\n      this.target.removeEventListener('touchend', this._boundHandle);\r\n      this.target.removeEventListener('touchmove', this._boundHandle);\r\n      this.target.removeEventListener('touchcancel', this._boundHandle);\r\n\r\n      // Mouse Events\r\n      this.target.removeEventListener('mousedown', this._boundHandle);\r\n      this.target.removeEventListener('mouseup', this._boundHandle);\r\n      this.target.removeEventListener('mousemove', this._boundHandle);\r\n    }\r\n\r\n    if ('onwheel' in document.createElement('div')) {\r\n      // Modern Browsers\r\n      this.target.removeEventListener('wheel', this._boundWheel);\r\n    } else if (document.onmousewheel !== undefined) {\r\n      // Webkit and IE\r\n      this.target.addEventListener('mousewheel', this._boundWheel);\r\n    } else {\r\n      // Remaining browser and older Firefox\r\n      this.target.addEventListener('MozMousePixelScroll', this._boundWheel);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Take native pointer id and map it to index in active pointers\r\n   * @param nativePointerId\r\n   */\r\n  private _normalizePointerId(nativePointerId: number) {\r\n    // Add to the the native pointer set id\r\n    this._activeNativePointerIdsToNormalized.set(nativePointerId, -1);\r\n\r\n    // Native pointer ids in ascending order\r\n    const currentPointerIds = Array.from(this._activeNativePointerIdsToNormalized.keys()).sort((a, b) => a - b);\r\n\r\n    // The index into sorted ids will be the new id, will always have an id\r\n    const id = currentPointerIds.findIndex(p => p === nativePointerId);\r\n\r\n    // Save the mapping so we can reverse it later\r\n    this._activeNativePointerIdsToNormalized.set(nativePointerId, id);\r\n\r\n    // ignore pointer because game isn't watching\r\n    return id;\r\n  }\r\n\r\n  /**\r\n   * Responsible for handling and parsing pointer events\r\n   */\r\n  private _handle(ev: NativeTouchEvent | NativePointerEvent | NativeMouseEvent) {\r\n    ev.preventDefault();\r\n    const eventCoords = new Map<number, GlobalCoordinates>();\r\n    let button: PointerButton;\r\n    let pointerType: PointerType;\r\n    if (isTouchEvent(ev)) {\r\n      button = PointerButton.Unknown;\r\n      pointerType = PointerType.Touch;\r\n      // https://developer.mozilla.org/en-US/docs/Web/API/TouchEvent\r\n      for (let i = 0; i < ev.changedTouches.length; i++) {\r\n        const touch = ev.changedTouches[i];\r\n        const coordinates = GlobalCoordinates.fromPagePosition(touch.pageX, touch.pageY, this.engine);\r\n        const nativePointerId = i + 1;\r\n        const pointerId = this._normalizePointerId(nativePointerId);\r\n        this.currentFramePointerCoords.set(pointerId, coordinates);\r\n        eventCoords.set(pointerId, coordinates);\r\n      }\r\n    } else {\r\n      button = this._nativeButtonToPointerButton(ev.button);\r\n      pointerType = PointerType.Mouse;\r\n      const coordinates = GlobalCoordinates.fromPagePosition(ev.pageX, ev.pageY, this.engine);\r\n      let nativePointerId = 1;\r\n      if (isPointerEvent(ev)) {\r\n        nativePointerId = ev.pointerId;\r\n        pointerType = this._stringToPointerType(ev.pointerType);\r\n      }\r\n      const pointerId = this._normalizePointerId(nativePointerId);\r\n      this.currentFramePointerCoords.set(pointerId, coordinates);\r\n      eventCoords.set(pointerId, coordinates);\r\n    }\r\n\r\n    for (const [pointerId, coord] of eventCoords.entries()) {\r\n      switch (ev.type) {\r\n        case 'mousedown':\r\n        case 'pointerdown':\r\n        case 'touchstart':\r\n          this.currentFrameDown.push(new PointerEvent('down', pointerId, button, pointerType, coord, ev));\r\n          this.currentFramePointerDown.set(pointerId, true);\r\n          break;\r\n        case 'mouseup':\r\n        case 'pointerup':\r\n        case 'touchend':\r\n          this.currentFrameUp.push(new PointerEvent('up', pointerId, button, pointerType, coord, ev));\r\n          this.currentFramePointerDown.set(pointerId, false);\r\n          break;\r\n        case 'mousemove':\r\n        case 'pointermove':\r\n        case 'touchmove':\r\n          this.currentFrameMove.push(new PointerEvent('move', pointerId, button, pointerType, coord, ev));\r\n          break;\r\n        case 'touchcancel':\r\n        case 'pointercancel':\r\n          this.currentFrameCancel.push(new PointerEvent('cancel', pointerId, button, pointerType, coord, ev));\r\n          break;\r\n      }\r\n    }\r\n  }\r\n\r\n  private _handleWheel(ev: NativeWheelEvent) {\r\n    // Should we prevent page scroll because of this event\r\n    if (\r\n      this.engine.pageScrollPreventionMode === ScrollPreventionMode.All ||\r\n      (this.engine.pageScrollPreventionMode === ScrollPreventionMode.Canvas && ev.target === this.engine.canvas)\r\n    ) {\r\n      ev.preventDefault();\r\n    }\r\n    const screen = this.engine.screen.pageToScreenCoordinates(vec(ev.pageX, ev.pageY));\r\n    const world = this.engine.screen.screenToWorldCoordinates(screen);\r\n\r\n    /**\r\n     * A constant used to normalize wheel events across different browsers\r\n     *\r\n     * This normalization factor is pulled from\r\n     * https://developer.mozilla.org/en-US/docs/Web/Events/wheel#Listening_to_this_event_across_browser\r\n     */\r\n    const ScrollWheelNormalizationFactor = -1 / 40;\r\n\r\n    const deltaX = ev.deltaX || ev.wheelDeltaX * ScrollWheelNormalizationFactor || 0;\r\n    const deltaY =\r\n        ev.deltaY || ev.wheelDeltaY * ScrollWheelNormalizationFactor || ev.wheelDelta * ScrollWheelNormalizationFactor || ev.detail || 0;\r\n    const deltaZ = ev.deltaZ || 0;\r\n    let deltaMode = WheelDeltaMode.Pixel;\r\n\r\n    if (ev.deltaMode) {\r\n      if (ev.deltaMode === 1) {\r\n        deltaMode = WheelDeltaMode.Line;\r\n      } else if (ev.deltaMode === 2) {\r\n        deltaMode = WheelDeltaMode.Page;\r\n      }\r\n    }\r\n\r\n    const we = new WheelEvent(world.x, world.y, ev.pageX, ev.pageY, screen.x, screen.y, 0, deltaX, deltaY, deltaZ, deltaMode, ev);\r\n    this.currentFrameWheel.push(we);\r\n  }\r\n\r\n  /**\r\n   * Triggers an excalibur pointer event in a world space pos\r\n   *\r\n   * Useful for testing pointers in excalibur\r\n   * @param type\r\n   * @param pos\r\n   */\r\n  public triggerEvent(type: 'down' | 'up' | 'move' | 'cancel', pos: Vector) {\r\n    const page = this.engine.screen.worldToPageCoordinates(pos);\r\n    // Send an event to the event receiver\r\n    if (window.PointerEvent) {\r\n      this._handle(new window.PointerEvent('pointer' + type, {\r\n        pointerId: 0,\r\n        clientX: page.x,\r\n        clientY: page.y\r\n      }));\r\n    } else {\r\n      // Safari hack\r\n      this._handle(new window.MouseEvent('mouse' + type, {\r\n        clientX: page.x,\r\n        clientY: page.y\r\n      }));\r\n    }\r\n\r\n    // Force update pointer system\r\n    const pointerSystem = this.engine.currentScene.world.systemManager.get(PointerSystem);\r\n    const transformEntities = this.engine.currentScene.world.queryManager.createQuery(pointerSystem.types);\r\n    pointerSystem.preupdate();\r\n    pointerSystem.update(transformEntities.getEntities());\r\n  }\r\n\r\n  private _nativeButtonToPointerButton(s: NativePointerButton): PointerButton {\r\n    switch (s) {\r\n      case NativePointerButton.NoButton:\r\n        return PointerButton.NoButton;\r\n      case NativePointerButton.Left:\r\n        return PointerButton.Left;\r\n      case NativePointerButton.Middle:\r\n        return PointerButton.Middle;\r\n      case NativePointerButton.Right:\r\n        return PointerButton.Right;\r\n      case NativePointerButton.Unknown:\r\n        return PointerButton.Unknown;\r\n      default:\r\n        return fail(s);\r\n    }\r\n  }\r\n\r\n  private _stringToPointerType(s: string) {\r\n    switch (s) {\r\n      case 'touch':\r\n        return PointerType.Touch;\r\n      case 'mouse':\r\n        return PointerType.Mouse;\r\n      case 'pen':\r\n        return PointerType.Pen;\r\n      default:\r\n        return PointerType.Unknown;\r\n    }\r\n  }\r\n}","export interface FpsSamplerOptions {\r\n  /**\r\n   * Specify the sampling period in milliseconds (default 100)\r\n   */\r\n  samplePeriod?: number;\r\n  /**\r\n   * Specify the initial FPS\r\n   */\r\n  initialFps: number;\r\n\r\n  /**\r\n   * Specify the function used to return the current time (in milliseconds)\r\n   */\r\n  nowFn: () => number;\r\n}\r\n\r\nexport class FpsSampler {\r\n  private _fps: number;\r\n  private _samplePeriod: number = 100;\r\n  private _currentFrameTime: number = 0;\r\n  private _frames: number = 0;\r\n  private _previousSampleTime: number = 0;\r\n  private _beginFrameTime: number = 0;\r\n  private _nowFn: () => number;\r\n\r\n  constructor(options: FpsSamplerOptions) {\r\n    this._fps = options.initialFps;\r\n    this._samplePeriod = options.samplePeriod ?? this._samplePeriod;\r\n    this._currentFrameTime = 1000/options.initialFps;\r\n    this._nowFn = options.nowFn;\r\n    this._previousSampleTime = this._nowFn();\r\n  }\r\n\r\n  /**\r\n   * Start of code block to sample FPS for\r\n   */\r\n  start() {\r\n    this._beginFrameTime = this._nowFn();\r\n  }\r\n\r\n  /**\r\n   * End of code block to sample FPS for\r\n   */\r\n  end() {\r\n    this._frames++;\r\n    const time = this._nowFn();\r\n\r\n    this._currentFrameTime = time - this._beginFrameTime;\r\n\r\n    if (time >= this._previousSampleTime + this._samplePeriod) {\r\n      this._fps = (this._frames * 1000) / (time - this._previousSampleTime);\r\n      this._previousSampleTime = time;\r\n      this._frames = 0;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Return the currently sampled fps over the last sample period, by default every 100ms\r\n   */\r\n  get fps() {\r\n    return this._fps;\r\n  }\r\n\r\n  /**\r\n   * Return the instantaneous fps, this can be less useful because it will fluctuate given the current frames time\r\n   */\r\n  get instant() {\r\n    return 1000 / this._currentFrameTime;\r\n  }\r\n}","import { Logger } from '..';\r\nimport { FpsSampler } from './Fps';\r\n\r\nexport interface ClockOptions {\r\n  /**\r\n   * Define the function you'd like the clock to tick when it is started\r\n   */\r\n  tick: (elapsedMs: number) => any;\r\n  /**\r\n   * Optionally define the fatal exception handler, used if an error is thrown in tick\r\n   */\r\n  onFatalException?: (e: unknown) => any;\r\n  /**\r\n   * Optionally limit the maximum FPS of the clock\r\n   */\r\n  maxFps?: number;\r\n}\r\n\r\n\r\n/**\r\n * Abstract Clock is the base type of all Clocks\r\n *\r\n * It has a few opinions\r\n * 1. It manages the calculation of what \"elapsed\" time means and thus maximum fps\r\n * 2. The default timing api is implemented in now()\r\n *\r\n * To implement your own clock, extend Clock and override start/stop to start and stop the clock, then call update() with whatever\r\n * method is unique to your clock implementation.\r\n */\r\nexport abstract class Clock {\r\n  protected tick: (elapsedMs: number) => any;\r\n  private _onFatalException: (e: unknown) => any = () => { /* default nothing */ };\r\n  private _maxFps: number = Infinity;\r\n  private _lastTime: number = 0;\r\n  public fpsSampler: FpsSampler;\r\n  private _options: ClockOptions;\r\n  private _elapsed: number = 1;\r\n  private _scheduledCbs: [cb: () => any, scheduledTime: number][] = [];\r\n  private _totalElapsed: number = 0;\r\n  constructor(options: ClockOptions) {\r\n    this._options = options;\r\n    this.tick = options.tick;\r\n    this._lastTime = this.now() ?? 0;\r\n    this._maxFps = options.maxFps ?? this._maxFps;\r\n    this._onFatalException = options.onFatalException ?? this._onFatalException;\r\n    this.fpsSampler = new FpsSampler({\r\n      initialFps: 60,\r\n      nowFn: () => this.now()\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Get the elapsed time for the last completed frame\r\n   */\r\n  public elapsed(): number {\r\n    return this._elapsed;\r\n  }\r\n\r\n  /**\r\n   * Get the current time in milliseconds\r\n   */\r\n  public now(): number {\r\n    return performance.now();\r\n  }\r\n\r\n  public toTestClock() {\r\n    const testClock = new TestClock({\r\n      ...this._options,\r\n      defaultUpdateMs: 16.6\r\n    });\r\n    return testClock;\r\n  }\r\n\r\n  public toStandardClock() {\r\n    const clock = new StandardClock({\r\n      ...this._options\r\n    });\r\n    return clock;\r\n  }\r\n\r\n  public setFatalExceptionHandler(handler: (e: unknown) => any) {\r\n    this._onFatalException = handler;\r\n  }\r\n\r\n  /**\r\n   * Schedule a callback to fire given a timeout in milliseconds using the excalibur [[Clock]]\r\n   *\r\n   * This is useful to use over the built in browser `setTimeout` because callbacks will be tied to the\r\n   * excalibur update clock, instead of browser time, this means that callbacks wont fire if the game is\r\n   * stopped or paused.\r\n   *\r\n   * @param cb callback to fire\r\n   * @param timeoutMs Optionally specify a timeout in milliseconds from now, default is 0ms which means the next possible tick\r\n   */\r\n  public schedule(cb: () => any, timeoutMs: number = 0) {\r\n    const scheduledTime = this.now() + timeoutMs;\r\n    this._scheduledCbs.push([cb, scheduledTime]);\r\n  }\r\n\r\n  private _runScheduledCbs() {\r\n    // walk backwards to delete items as we loop\r\n    for (let i = this._scheduledCbs.length - 1; i > -1; i--) {\r\n      if (this._scheduledCbs[i][1] <= this._totalElapsed) {\r\n        this._scheduledCbs[i][0]();\r\n        this._scheduledCbs.splice(i, 1);\r\n      }\r\n    }\r\n  }\r\n\r\n  protected update(overrideUpdateMs?: number): void {\r\n    try {\r\n      this.fpsSampler.start();\r\n      // Get the time to calculate time-elapsed\r\n      const now = this.now();\r\n      let elapsed = now - this._lastTime || 1; // first frame\r\n\r\n      // Constrain fps\r\n      const fpsInterval = (1000 / this._maxFps);\r\n\r\n      // only run frame if enough time has elapsed\r\n      if (elapsed >= fpsInterval) {\r\n        let leftover = 0;\r\n        if (fpsInterval !== 0) {\r\n          leftover = (elapsed % fpsInterval);\r\n          elapsed = elapsed - leftover; // shift elapsed to be \"in phase\" with the current loop fps\r\n        }\r\n\r\n        // Resolves issue #138 if the game has been paused, or blurred for\r\n        // more than a 200 milliseconds, reset elapsed time to 1. This improves reliability\r\n        // and provides more expected behavior when the engine comes back\r\n        // into focus\r\n        if (elapsed > 200) {\r\n          elapsed = 1;\r\n        }\r\n\r\n        // tick the mainloop and run scheduled callbacks\r\n        this._elapsed = overrideUpdateMs || elapsed;\r\n        this._totalElapsed += this._elapsed;\r\n        this._runScheduledCbs();\r\n        this.tick(overrideUpdateMs || elapsed);\r\n\r\n        if (fpsInterval !== 0) {\r\n          this._lastTime = now - leftover;\r\n        } else {\r\n          this._lastTime = now;\r\n        }\r\n        this.fpsSampler.end();\r\n      }\r\n    } catch (e) {\r\n      this._onFatalException(e);\r\n      this.stop();\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Returns if the clock is currently running\r\n   */\r\n  public abstract isRunning(): boolean;\r\n\r\n  /**\r\n   * Start the clock, it will then periodically call the tick(elapsedMilliseconds) since the last tick\r\n   */\r\n  public abstract start(): void;\r\n\r\n  /**\r\n   * Stop the clock, tick() is no longer called\r\n   */\r\n  public abstract stop(): void;\r\n}\r\n\r\n\r\n/**\r\n * The [[StandardClock]] implements the requestAnimationFrame browser api to run the tick()\r\n */\r\nexport class StandardClock extends Clock {\r\n\r\n  private _running = false;\r\n  private _requestId: number;\r\n  constructor(options: ClockOptions) {\r\n    super(options);\r\n  }\r\n\r\n  public isRunning(): boolean {\r\n    return this._running;\r\n  }\r\n\r\n  public start(): void {\r\n    if (this._running) {\r\n      return;\r\n    }\r\n    this._running = true;\r\n    const mainloop = () => {\r\n      // stop the loop\r\n      if (!this._running) {\r\n        return;\r\n      }\r\n      try {\r\n        // request next loop\r\n        this._requestId = window.requestAnimationFrame(mainloop);\r\n        this.update();\r\n      } catch (e) {\r\n        window.cancelAnimationFrame(this._requestId);\r\n        throw e;\r\n      }\r\n    };\r\n\r\n    // begin the first frame\r\n    mainloop();\r\n  }\r\n\r\n  public stop(): void {\r\n    this._running = false;\r\n  }\r\n}\r\n\r\nexport interface TestClockOptions {\r\n  /**\r\n   * Specify the update milliseconds to use for each manual step()\r\n   */\r\n  defaultUpdateMs: number;\r\n}\r\n\r\n/**\r\n * The TestClock is meant for debugging interactions in excalibur that require precise timing to replicate or test\r\n */\r\nexport class TestClock extends Clock {\r\n  private _logger = Logger.getInstance();\r\n  private _updateMs: number;\r\n  private _running: boolean = false;\r\n  private _currentTime = 0;\r\n  constructor(options: ClockOptions & TestClockOptions) {\r\n    super({\r\n      ...options\r\n    });\r\n    this._updateMs = options.defaultUpdateMs;\r\n  }\r\n\r\n  /**\r\n   * Get the current time in milliseconds\r\n   */\r\n  public override now() {\r\n    return this._currentTime ?? 0;\r\n  }\r\n\r\n  public isRunning(): boolean {\r\n    return this._running;\r\n  }\r\n  public start(): void {\r\n    this._running = true;\r\n  }\r\n  public stop(): void {\r\n    this._running = false;\r\n  }\r\n\r\n  /**\r\n   * Manually step the clock forward 1 tick, optionally specify an elapsed time in milliseconds\r\n   * @param overrideUpdateMs\r\n   */\r\n  step(overrideUpdateMs?: number): void {\r\n    const time = overrideUpdateMs ?? this._updateMs;\r\n\r\n    if (this._running) {\r\n      // to be comparable to RAF this needs to be a full blown Task\r\n      // For example, images cannot decode synchronously in a single step\r\n      this.update(time);\r\n      this._currentTime += time;\r\n    } else {\r\n      this._logger.warn('The clock is not running, no step will be performed');\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Run a number of steps that tick the clock, optionally specify an elapsed time in milliseconds\r\n   * @param numberOfSteps\r\n   * @param overrideUpdateMs\r\n   */\r\n  run(numberOfSteps: number, overrideUpdateMs?: number): void {\r\n    for (let i = 0; i < numberOfSteps; i++) {\r\n      this.step(overrideUpdateMs ?? this._updateMs);\r\n    }\r\n  }\r\n}","import toasterCss from './Toaster.css';\r\n\r\n/**\r\n * The Toaster is only meant to be called from inside Excalibur to display messages to players\r\n */\r\nexport class Toaster {\r\n  private _styleBlock: HTMLStyleElement;\r\n  private _container: HTMLDivElement;\r\n  private _toasterCss: string = toasterCss.toString();\r\n\r\n  private _isInitialized = false;\r\n  private _initialize() {\r\n    if (!this._isInitialized) {\r\n      this._container = document.createElement('div');\r\n      this._container.id = 'ex-toast-container';\r\n      document.body.appendChild(this._container);\r\n      this._isInitialized = true;\r\n\r\n      this._styleBlock = document.createElement('style');\r\n      this._styleBlock.textContent = this._toasterCss;\r\n      document.head.appendChild(this._styleBlock);\r\n    }\r\n  }\r\n\r\n  public dispose() {\r\n    this._container.parentElement.removeChild(this._container);\r\n\r\n    this._styleBlock.parentElement.removeChild(this._styleBlock);\r\n\r\n    this._isInitialized = false;\r\n  }\r\n\r\n  private _createFragment(message: string) {\r\n    const toastMessage = document.createElement('span');\r\n    toastMessage.innerText = message;\r\n    return toastMessage;\r\n  }\r\n\r\n  /**\r\n   * Display a toast message to a player\r\n   * @param message Text of the message, messages may have a single \"[LINK]\" to influence placement\r\n   * @param linkTarget Optionally specify a link location\r\n   * @param linkName Optionally specify a name for that link location\r\n   */\r\n  public toast(message: string, linkTarget?: string, linkName?: string) {\r\n    this._initialize();\r\n    const toast = document.createElement('div');\r\n    toast.className = 'ex-toast-message';\r\n\r\n    const messageFragments: HTMLElement[] = message.split('[LINK]').map(message => this._createFragment(message));\r\n\r\n    if (linkTarget) {\r\n      const link = document.createElement('a');\r\n      link.href = linkTarget;\r\n      if (linkName) {\r\n        link.innerText = linkName;\r\n      } else {\r\n        link.innerText = linkTarget;\r\n      }\r\n      messageFragments.splice(1, 0, link);\r\n    }\r\n\r\n    // Assembly message\r\n    const finalMessage = document.createElement('div');\r\n    messageFragments.forEach(message => {\r\n      finalMessage.appendChild(message);\r\n    });\r\n    toast.appendChild(finalMessage);\r\n\r\n    // Dismiss button\r\n    const dismissBtn = document.createElement('button');\r\n    dismissBtn.innerText = 'x';\r\n    dismissBtn.addEventListener('click', () => {\r\n      this._container.removeChild(toast);\r\n    });\r\n    toast.appendChild(dismissBtn);\r\n\r\n    // Escape to dismiss\r\n    const keydownHandler = (evt: KeyboardEvent) => {\r\n      if (evt.key === 'Escape') {\r\n        try {\r\n          this._container.removeChild(toast);\r\n        } catch {\r\n          // pass\r\n        }\r\n      }\r\n      document.removeEventListener('keydown', keydownHandler);\r\n    };\r\n    document.addEventListener('keydown', keydownHandler);\r\n\r\n    // Insert into container\r\n    const first = this._container.firstChild;\r\n    this._container.insertBefore(toast, first);\r\n  }\r\n}","import { EX_VERSION } from './';\r\nimport { Flags } from './Flags';\r\nimport { polyfill } from './Polyfill';\r\npolyfill();\r\nimport { CanUpdate, CanDraw, CanInitialize } from './Interfaces/LifecycleEvents';\r\nimport { Loadable } from './Interfaces/Loadable';\r\nimport { Vector } from './Math/vector';\r\nimport { Screen, DisplayMode, ScreenDimension, Resolution } from './Screen';\r\nimport { ScreenElement } from './ScreenElement';\r\nimport { Actor } from './Actor';\r\nimport { Timer } from './Timer';\r\nimport { TileMap } from './TileMap';\r\nimport { Loader } from './Loader';\r\nimport { Detector } from './Util/Detector';\r\nimport {\r\n  VisibleEvent,\r\n  HiddenEvent,\r\n  GameStartEvent,\r\n  GameStopEvent,\r\n  PreUpdateEvent,\r\n  PostUpdateEvent,\r\n  PreFrameEvent,\r\n  PostFrameEvent,\r\n  GameEvent,\r\n  DeactivateEvent,\r\n  ActivateEvent,\r\n  PreDrawEvent,\r\n  PostDrawEvent,\r\n  InitializeEvent\r\n} from './Events';\r\nimport { Logger, LogLevel } from './Util/Log';\r\nimport { Color } from './Color';\r\nimport { Scene } from './Scene';\r\nimport { Entity } from './EntityComponentSystem/Entity';\r\nimport { Debug, DebugStats } from './Debug/Debug';\r\nimport { Class } from './Class';\r\nimport * as Input from './Input/Index';\r\nimport * as Events from './Events';\r\nimport { BrowserEvents } from './Util/Browser';\r\nimport { ExcaliburGraphicsContext, ExcaliburGraphicsContext2DCanvas, ExcaliburGraphicsContextWebGL, TextureLoader } from './Graphics';\r\nimport { PointerEventReceiver } from './Input/PointerEventReceiver';\r\nimport { Clock, StandardClock } from './Util/Clock';\r\nimport { ImageFiltering } from './Graphics/Filtering';\r\nimport { GraphicsDiagnostics } from './Graphics/GraphicsDiagnostics';\r\nimport { Toaster } from './Util/Toaster';\r\n\r\n/**\r\n * Enum representing the different mousewheel event bubble prevention\r\n */\r\nexport enum ScrollPreventionMode {\r\n  /**\r\n   * Do not prevent any page scrolling\r\n   */\r\n  None,\r\n  /**\r\n   * Prevent page scroll if mouse is over the game canvas\r\n   */\r\n  Canvas,\r\n  /**\r\n   * Prevent all page scrolling via mouse wheel\r\n   */\r\n  All\r\n}\r\n\r\n/**\r\n * Defines the available options to configure the Excalibur engine at constructor time.\r\n */\r\nexport interface EngineOptions {\r\n  /**\r\n   * Optionally configure the width of the viewport in css pixels\r\n   */\r\n  width?: number;\r\n\r\n  /**\r\n   * Optionally configure the height of the viewport in css pixels\r\n   */\r\n  height?: number;\r\n\r\n  /**\r\n   * Optionally configure the width & height of the viewport in css pixels.\r\n   * Use `viewport` instead of [[EngineOptions.width]] and [[EngineOptions.height]], or vice versa.\r\n   */\r\n  viewport?: ScreenDimension;\r\n\r\n  /**\r\n   * Optionally specify the size the logical pixel resolution, if not specified it will be width x height.\r\n   * See [[Resolution]] for common presets.\r\n   */\r\n  resolution?: ScreenDimension;\r\n\r\n  /**\r\n   * Optionally specify antialiasing (smoothing), by default true (smooth pixels)\r\n   *\r\n   *  * `true` - useful for high resolution art work you would like smoothed, this also hints excalibur to load images\r\n   * with [[ImageFiltering.Blended]]\r\n   *\r\n   *  * `false` - useful for pixel art style art work you would like sharp, this also hints excalibur to load images\r\n   * with [[ImageFiltering.Pixel]]\r\n   */\r\n  antialiasing?: boolean;\r\n\r\n  /**\r\n   * Optionally upscale the number of pixels in the canvas. Normally only useful if you need a smoother look to your assets, especially\r\n   * [[Text]].\r\n   *\r\n   * **WARNING** It is recommended you try using `antialiasing: true` before adjusting pixel ratio. Pixel ratio will consume more memory\r\n   * and on mobile may break if the internal size of the canvas exceeds 4k pixels in width or height.\r\n   *\r\n   * Default is based the display's pixel ratio, for example a HiDPI screen might have the value 2;\r\n   */\r\n  pixelRatio?: number;\r\n\r\n  /**\r\n   * Optionally configure the native canvas transparent backdrop\r\n   */\r\n  enableCanvasTransparency?: boolean;\r\n\r\n  /**\r\n   * Optionally specify the target canvas DOM element to render the game in\r\n   */\r\n  canvasElementId?: string;\r\n\r\n  /**\r\n   * Optionally specify the target canvas DOM element directly\r\n   */\r\n  canvasElement?: HTMLCanvasElement;\r\n\r\n  /**\r\n   * Optionally snap drawings to nearest pixel\r\n   */\r\n  snapToPixel?: boolean;\r\n\r\n  /**\r\n   * The [[DisplayMode]] of the game, by default [[DisplayMode.FitScreen]] with aspect ratio 4:3 (800x600).\r\n   * Depending on this value, [[width]] and [[height]] may be ignored.\r\n   */\r\n  displayMode?: DisplayMode;\r\n\r\n  /**\r\n   * Configures the pointer scope. Pointers scoped to the 'Canvas' can only fire events within the canvas viewport; whereas, 'Document'\r\n   * (default) scoped will fire anywhere on the page.\r\n   */\r\n  pointerScope?: Input.PointerScope;\r\n\r\n  /**\r\n   * Suppress boot up console message, which contains the \"powered by Excalibur message\"\r\n   */\r\n  suppressConsoleBootMessage?: boolean;\r\n\r\n  /**\r\n   * Suppress minimum browser feature detection, it is not recommended users of excalibur switch this off. This feature ensures that\r\n   * the currently running browser meets the minimum requirements for running excalibur. This can be useful if running on non-standard\r\n   * browsers or if there is a bug in excalibur preventing execution.\r\n   */\r\n  suppressMinimumBrowserFeatureDetection?: boolean;\r\n\r\n  /**\r\n   * Suppress HiDPI auto detection and scaling, it is not recommended users of excalibur switch off this feature. This feature detects\r\n   * and scales the drawing canvas appropriately to accommodate HiDPI screens.\r\n   */\r\n  suppressHiDPIScaling?: boolean;\r\n\r\n  /**\r\n   * Suppress play button, it is not recommended users of excalibur switch this feature. Some browsers require a user gesture (like a click)\r\n   * for certain browser features to work like web audio.\r\n   */\r\n  suppressPlayButton?: boolean;\r\n\r\n  /**\r\n   * Scroll prevention method.\r\n   */\r\n  scrollPreventionMode?: ScrollPreventionMode;\r\n\r\n  /**\r\n   * Optionally set the background color\r\n   */\r\n  backgroundColor?: Color;\r\n\r\n  /**\r\n   * Optionally set the maximum fps if not set Excalibur will go as fast as the device allows.\r\n   *\r\n   * You may want to constrain max fps if your game cannot maintain fps consistently, it can look and feel better to have a 30fps game than\r\n   * one that bounces between 30fps and 60fps\r\n   */\r\n  maxFps?: number;\r\n\r\n  /**\r\n   * Default `true`, optionally configure excalibur to use optimal draw call sorting, to opt out set this to `false`.\r\n   *\r\n   * Excalibur will automatically sort draw calls by z and priority into renderer batches for maximal draw performance,\r\n   * this can disrupt a specific desired painter order.\r\n   */\r\n  useDrawSorting?: boolean;\r\n\r\n  /**\r\n   * Optionally configure how excalibur handles poor performance on a player's browser\r\n   */\r\n  configurePerformanceCanvas2DFallback?: {\r\n    /**\r\n     * By default `true`, this will switch the internal graphics context to Canvas2D which can improve performance on non hardware\r\n     * accelerated browsers.\r\n     */\r\n    allow: boolean;\r\n    /**\r\n     * By default `false`, if set to `true` a dialogue will be presented to the player about their browser and how to potentially\r\n     * address any issues.\r\n     */\r\n    showPlayerMessage: boolean;\r\n    /**\r\n     * Default `{ numberOfFrames: 100, fps: 20 }`, optionally configure excalibur to fallback to the 2D Canvas renderer\r\n     * if bad performance is detected.\r\n     *\r\n     * In this example of the default if excalibur is running at 20fps or less for 100 frames it will trigger the fallback to the 2D\r\n     * Canvas renderer.\r\n     */\r\n    threshold: { numberOfFrames: number, fps: number };\r\n  }\r\n}\r\n\r\n/**\r\n * The Excalibur Engine\r\n *\r\n * The [[Engine]] is the main driver for a game. It is responsible for\r\n * starting/stopping the game, maintaining state, transmitting events,\r\n * loading resources, and managing the scene.\r\n */\r\nexport class Engine extends Class implements CanInitialize, CanUpdate, CanDraw {\r\n  /**\r\n   * Excalibur browser events abstraction used for wiring to native browser events safely\r\n   */\r\n  public browser: BrowserEvents;\r\n\r\n  /**\r\n   * Screen abstraction\r\n   */\r\n  public screen: Screen;\r\n\r\n  /**\r\n   * Direct access to the engine's canvas element\r\n   */\r\n  public canvas: HTMLCanvasElement;\r\n\r\n  /**\r\n   * Direct access to the ExcaliburGraphicsContext used for drawing things to the screen\r\n   */\r\n  public graphicsContext: ExcaliburGraphicsContext;\r\n\r\n  /**\r\n   * Direct access to the canvas element ID, if an ID exists\r\n   */\r\n  public canvasElementId: string;\r\n\r\n  /**\r\n   * Optionally set the maximum fps if not set Excalibur will go as fast as the device allows.\r\n   *\r\n   * You may want to constrain max fps if your game cannot maintain fps consistently, it can look and feel better to have a 30fps game than\r\n   * one that bounces between 30fps and 60fps\r\n   */\r\n  public maxFps: number = Number.POSITIVE_INFINITY;\r\n\r\n  /**\r\n   * Direct access to the excalibur clock\r\n   */\r\n  public clock: Clock;\r\n\r\n  /**\r\n   * The width of the game canvas in pixels (physical width component of the\r\n   * resolution of the canvas element)\r\n   */\r\n  public get canvasWidth(): number {\r\n    return this.screen.canvasWidth;\r\n  }\r\n\r\n  /**\r\n   * Returns half width of the game canvas in pixels (half physical width component)\r\n   */\r\n  public get halfCanvasWidth(): number {\r\n    return this.screen.halfCanvasWidth;\r\n  }\r\n\r\n  /**\r\n   * The height of the game canvas in pixels, (physical height component of\r\n   * the resolution of the canvas element)\r\n   */\r\n  public get canvasHeight(): number {\r\n    return this.screen.canvasHeight;\r\n  }\r\n\r\n  /**\r\n   * Returns half height of the game canvas in pixels (half physical height component)\r\n   */\r\n  public get halfCanvasHeight(): number {\r\n    return this.screen.halfCanvasHeight;\r\n  }\r\n\r\n  /**\r\n   * Returns the width of the engine's visible drawing surface in pixels including zoom and device pixel ratio.\r\n   */\r\n  public get drawWidth(): number {\r\n    return this.screen.drawWidth;\r\n  }\r\n\r\n  /**\r\n   * Returns half the width of the engine's visible drawing surface in pixels including zoom and device pixel ratio.\r\n   */\r\n  public get halfDrawWidth(): number {\r\n    return this.screen.halfDrawWidth;\r\n  }\r\n\r\n  /**\r\n   * Returns the height of the engine's visible drawing surface in pixels including zoom and device pixel ratio.\r\n   */\r\n  public get drawHeight(): number {\r\n    return this.screen.drawHeight;\r\n  }\r\n\r\n  /**\r\n   * Returns half the height of the engine's visible drawing surface in pixels including zoom and device pixel ratio.\r\n   */\r\n  public get halfDrawHeight(): number {\r\n    return this.screen.halfDrawHeight;\r\n  }\r\n\r\n  /**\r\n   * Returns whether excalibur detects the current screen to be HiDPI\r\n   */\r\n  public get isHiDpi(): boolean {\r\n    return this.screen.isHiDpi;\r\n  }\r\n\r\n  /**\r\n   * Access engine input like pointer, keyboard, or gamepad\r\n   */\r\n  public input: Input.EngineInput;\r\n\r\n  /**\r\n   * Access Excalibur debugging functionality.\r\n   *\r\n   * Useful when you want to debug different aspects of built in engine features like\r\n   *   * Transform\r\n   *   * Graphics\r\n   *   * Colliders\r\n   */\r\n  public debug: Debug;\r\n\r\n  /**\r\n   * Access [[stats]] that holds frame statistics.\r\n   */\r\n  public get stats(): DebugStats {\r\n    return this.debug.stats;\r\n  }\r\n\r\n  /**\r\n   * The current [[Scene]] being drawn and updated on screen\r\n   */\r\n  public currentScene: Scene;\r\n\r\n  /**\r\n   * The default [[Scene]] of the game, use [[Engine.goToScene]] to transition to different scenes.\r\n   */\r\n  public readonly rootScene: Scene;\r\n\r\n  /**\r\n   * Contains all the scenes currently registered with Excalibur\r\n   */\r\n  public readonly scenes: { [key: string]: Scene } = {};\r\n\r\n  /**\r\n   * Indicates whether the engine is set to fullscreen or not\r\n   */\r\n  public get isFullscreen(): boolean {\r\n    return this.screen.isFullScreen;\r\n  }\r\n\r\n  /**\r\n   * Indicates the current [[DisplayMode]] of the engine.\r\n   */\r\n  public get displayMode(): DisplayMode {\r\n    return this.screen.displayMode;\r\n  }\r\n\r\n  private _suppressPlayButton: boolean = false;\r\n  /**\r\n   * Returns the calculated pixel ration for use in rendering\r\n   */\r\n  public get pixelRatio(): number {\r\n    return this.screen.pixelRatio;\r\n  }\r\n\r\n  /**\r\n   * Indicates whether audio should be paused when the game is no longer visible.\r\n   */\r\n  public pauseAudioWhenHidden: boolean = true;\r\n\r\n  /**\r\n   * Indicates whether the engine should draw with debug information\r\n   */\r\n  private _isDebug: boolean = false;\r\n  public get isDebug(): boolean {\r\n    return this._isDebug;\r\n  }\r\n\r\n  /**\r\n   * Sets the background color for the engine.\r\n   */\r\n  public backgroundColor: Color;\r\n\r\n  /**\r\n   * Sets the Transparency for the engine.\r\n   */\r\n  public enableCanvasTransparency: boolean = true;\r\n\r\n  /**\r\n   * Hints the graphics context to truncate fractional world space coordinates\r\n   */\r\n  public get snapToPixel(): boolean {\r\n    return this.graphicsContext.snapToPixel;\r\n  };\r\n\r\n  public set snapToPixel(shouldSnapToPixel: boolean) {\r\n    this.graphicsContext.snapToPixel = shouldSnapToPixel;\r\n  };\r\n\r\n  /**\r\n   * The action to take when a fatal exception is thrown\r\n   */\r\n  public onFatalException = (e: any) => {\r\n    Logger.getInstance().fatal(e);\r\n  };\r\n\r\n  /**\r\n   * The mouse wheel scroll prevention mode\r\n   */\r\n  public pageScrollPreventionMode: ScrollPreventionMode;\r\n\r\n  private _logger: Logger;\r\n\r\n  private _toaster: Toaster = new Toaster();\r\n\r\n  // this determines whether excalibur is compatible with your browser\r\n  private _compatible: boolean;\r\n\r\n  private _timescale: number = 1.0;\r\n\r\n  // loading\r\n  private _loader: Loader;\r\n\r\n  private _isInitialized: boolean = false;\r\n\r\n  private _deferredGoTo: string = null;\r\n\r\n  public on(eventName: 'fallbackgraphicscontext', handler: (event: ExcaliburGraphicsContext2DCanvas) => void): void;\r\n  public on(eventName: Events.initialize, handler: (event: Events.InitializeEvent<Engine>) => void): void;\r\n  public on(eventName: Events.visible, handler: (event: VisibleEvent) => void): void;\r\n  public on(eventName: Events.hidden, handler: (event: HiddenEvent) => void): void;\r\n  public on(eventName: Events.start, handler: (event: GameStartEvent) => void): void;\r\n  public on(eventName: Events.stop, handler: (event: GameStopEvent) => void): void;\r\n  public on(eventName: Events.preupdate, handler: (event: PreUpdateEvent<Engine>) => void): void;\r\n  public on(eventName: Events.postupdate, handler: (event: PostUpdateEvent<Engine>) => void): void;\r\n  public on(eventName: Events.preframe, handler: (event: PreFrameEvent) => void): void;\r\n  public on(eventName: Events.postframe, handler: (event: PostFrameEvent) => void): void;\r\n  public on(eventName: Events.predraw, handler: (event: PreDrawEvent) => void): void;\r\n  public on(eventName: Events.postdraw, handler: (event: PostDrawEvent) => void): void;\r\n  public on(eventName: string, handler: (event: GameEvent<any>) => void): void;\r\n  public on(eventName: string, handler: (event: any) => void): void {\r\n    super.on(eventName, handler);\r\n  }\r\n\r\n  public once(eventName: 'fallbackgraphicscontext', handler: (event: ExcaliburGraphicsContext2DCanvas) => void): void;\r\n  public once(eventName: Events.initialize, handler: (event: Events.InitializeEvent<Engine>) => void): void;\r\n  public once(eventName: Events.visible, handler: (event: VisibleEvent) => void): void;\r\n  public once(eventName: Events.hidden, handler: (event: HiddenEvent) => void): void;\r\n  public once(eventName: Events.start, handler: (event: GameStartEvent) => void): void;\r\n  public once(eventName: Events.stop, handler: (event: GameStopEvent) => void): void;\r\n  public once(eventName: Events.preupdate, handler: (event: PreUpdateEvent<Engine>) => void): void;\r\n  public once(eventName: Events.postupdate, handler: (event: PostUpdateEvent<Engine>) => void): void;\r\n  public once(eventName: Events.preframe, handler: (event: PreFrameEvent) => void): void;\r\n  public once(eventName: Events.postframe, handler: (event: PostFrameEvent) => void): void;\r\n  public once(eventName: Events.predraw, handler: (event: PreDrawEvent) => void): void;\r\n  public once(eventName: Events.postdraw, handler: (event: PostDrawEvent) => void): void;\r\n  public once(eventName: string, handler: (event: GameEvent<any>) => void): void;\r\n  public once(eventName: string, handler: (event: any) => void): void {\r\n    super.once(eventName, handler);\r\n  }\r\n\r\n  public off(eventName: 'fallbackgraphicscontext', handler?: (event: ExcaliburGraphicsContext2DCanvas) => void): void;\r\n  public off(eventName: Events.initialize, handler?: (event: Events.InitializeEvent<Engine>) => void): void;\r\n  public off(eventName: Events.visible, handler?: (event: VisibleEvent) => void): void;\r\n  public off(eventName: Events.hidden, handler?: (event: HiddenEvent) => void): void;\r\n  public off(eventName: Events.start, handler?: (event: GameStartEvent) => void): void;\r\n  public off(eventName: Events.stop, handler?: (event: GameStopEvent) => void): void;\r\n  public off(eventName: Events.preupdate, handler?: (event: PreUpdateEvent<Engine>) => void): void;\r\n  public off(eventName: Events.postupdate, handler?: (event: PostUpdateEvent<Engine>) => void): void;\r\n  public off(eventName: Events.preframe, handler?: (event: PreFrameEvent) => void): void;\r\n  public off(eventName: Events.postframe, handler?: (event: PostFrameEvent) => void): void;\r\n  public off(eventName: Events.predraw, handler?: (event: PreDrawEvent) => void): void;\r\n  public off(eventName: Events.postdraw, handler?: (event: PostDrawEvent) => void): void;\r\n  public off(eventName: string, handler?: (event: GameEvent<any>) => void): void;\r\n  public off(eventName: string, handler?: (event: any) => void): void {\r\n    super.off(eventName, handler);\r\n  }\r\n\r\n  /**\r\n   * Default [[EngineOptions]]\r\n   */\r\n  private static _DEFAULT_ENGINE_OPTIONS: EngineOptions = {\r\n    width: 0,\r\n    height: 0,\r\n    enableCanvasTransparency: true,\r\n    useDrawSorting: true,\r\n    configurePerformanceCanvas2DFallback: {\r\n      allow: true,\r\n      showPlayerMessage: false,\r\n      threshold: { fps: 20, numberOfFrames: 100 }\r\n    },\r\n    canvasElementId: '',\r\n    canvasElement: undefined,\r\n    snapToPixel: false,\r\n    pointerScope: Input.PointerScope.Canvas,\r\n    suppressConsoleBootMessage: null,\r\n    suppressMinimumBrowserFeatureDetection: null,\r\n    suppressHiDPIScaling: null,\r\n    suppressPlayButton: null,\r\n    scrollPreventionMode: ScrollPreventionMode.Canvas,\r\n    backgroundColor: Color.fromHex('#2185d0') // Excalibur blue\r\n  };\r\n\r\n  private _originalOptions: EngineOptions = {};\r\n  public readonly _originalDisplayMode: DisplayMode;\r\n\r\n  /**\r\n   * Creates a new game using the given [[EngineOptions]]. By default, if no options are provided,\r\n   * the game will be rendered full screen (taking up all available browser window space).\r\n   * You can customize the game rendering through [[EngineOptions]].\r\n   *\r\n   * Example:\r\n   *\r\n   * ```js\r\n   * var game = new ex.Engine({\r\n   *   width: 0, // the width of the canvas\r\n   *   height: 0, // the height of the canvas\r\n   *   enableCanvasTransparency: true, // the transparencySection of the canvas\r\n   *   canvasElementId: '', // the DOM canvas element ID, if you are providing your own\r\n   *   displayMode: ex.DisplayMode.FullScreen, // the display mode\r\n   *   pointerScope: ex.Input.PointerScope.Document, // the scope of capturing pointer (mouse/touch) events\r\n   *   backgroundColor: ex.Color.fromHex('#2185d0') // background color of the engine\r\n   * });\r\n   *\r\n   * // call game.start, which is a Promise\r\n   * game.start().then(function () {\r\n   *   // ready, set, go!\r\n   * });\r\n   * ```\r\n   */\r\n  constructor(options?: EngineOptions) {\r\n    super();\r\n\r\n    options = { ...Engine._DEFAULT_ENGINE_OPTIONS, ...options };\r\n    this._originalOptions = options;\r\n\r\n    Flags.freeze();\r\n\r\n    // Initialize browser events facade\r\n    this.browser = new BrowserEvents(window, document);\r\n\r\n    // Check compatibility\r\n    const detector = new Detector();\r\n    if (!options.suppressMinimumBrowserFeatureDetection && !(this._compatible = detector.test())) {\r\n      const message = document.createElement('div');\r\n      message.innerText = 'Sorry, your browser does not support all the features needed for Excalibur';\r\n      document.body.appendChild(message);\r\n\r\n      detector.failedTests.forEach(function (test) {\r\n        const testMessage = document.createElement('div');\r\n        testMessage.innerText = 'Browser feature missing ' + test;\r\n        document.body.appendChild(testMessage);\r\n      });\r\n\r\n      if (options.canvasElementId) {\r\n        const canvas = document.getElementById(options.canvasElementId);\r\n        if (canvas) {\r\n          canvas.parentElement.removeChild(canvas);\r\n        }\r\n      }\r\n\r\n      return;\r\n    } else {\r\n      this._compatible = true;\r\n    }\r\n\r\n    // Use native console API for color fun\r\n    // eslint-disable-next-line no-console\r\n    if (console.log && !options.suppressConsoleBootMessage) {\r\n      // eslint-disable-next-line no-console\r\n      console.log(\r\n        `%cPowered by Excalibur.js (v${EX_VERSION})`,\r\n        'background: #176BAA; color: white; border-radius: 5px; padding: 15px; font-size: 1.5em; line-height: 80px;'\r\n      );\r\n      // eslint-disable-next-line no-console\r\n      console.log('\\n\\\r\n      /| ________________\\n\\\r\nO|===|* >________________>\\n\\\r\n      \\\\|');\r\n      // eslint-disable-next-line no-console\r\n      console.log('Visit', 'http://excaliburjs.com', 'for more information');\r\n    }\r\n\r\n    // Suppress play button\r\n    if (options.suppressPlayButton) {\r\n      this._suppressPlayButton = true;\r\n    }\r\n\r\n    this._logger = Logger.getInstance();\r\n\r\n    // If debug is enabled, let's log browser features to the console.\r\n    if (this._logger.defaultLevel === LogLevel.Debug) {\r\n      detector.logBrowserFeatures();\r\n    }\r\n\r\n    this._logger.debug('Building engine...');\r\n\r\n    this.canvasElementId = options.canvasElementId;\r\n\r\n    if (options.canvasElementId) {\r\n      this._logger.debug('Using Canvas element specified: ' + options.canvasElementId);\r\n      this.canvas = <HTMLCanvasElement>document.getElementById(options.canvasElementId);\r\n    } else if (options.canvasElement) {\r\n      this._logger.debug('Using Canvas element specified:', options.canvasElement);\r\n      this.canvas = options.canvasElement;\r\n    } else {\r\n      this._logger.debug('Using generated canvas element');\r\n      this.canvas = <HTMLCanvasElement>document.createElement('canvas');\r\n    }\r\n\r\n    let displayMode = options.displayMode ?? DisplayMode.Fixed;\r\n    if ((options.width && options.height) || options.viewport) {\r\n      if (options.displayMode === undefined) {\r\n        displayMode = DisplayMode.Fixed;\r\n      }\r\n      this._logger.debug('Engine viewport is size ' + options.width + ' x ' + options.height);\r\n    } else if (!options.displayMode) {\r\n      this._logger.debug('Engine viewport is fit');\r\n      displayMode = DisplayMode.FitScreen;\r\n    }\r\n\r\n    this._originalDisplayMode = displayMode;\r\n\r\n    // Canvas 2D fallback can be flagged on\r\n    let useCanvasGraphicsContext = Flags.isEnabled('use-canvas-context');\r\n    if (!useCanvasGraphicsContext) {\r\n      // Attempt webgl first\r\n      try {\r\n        this.graphicsContext = new ExcaliburGraphicsContextWebGL({\r\n          canvasElement: this.canvas,\r\n          enableTransparency: this.enableCanvasTransparency,\r\n          smoothing: options.antialiasing,\r\n          backgroundColor: options.backgroundColor,\r\n          snapToPixel: options.snapToPixel,\r\n          useDrawSorting: options.useDrawSorting\r\n        });\r\n      } catch (e) {\r\n        this._logger.warn(\r\n          `Excalibur could not load webgl for some reason (${(e as Error).message}) and loaded a Canvas 2D fallback. ` +\r\n          `Some features of Excalibur will not work in this mode. \\n\\n` +\r\n          'Read more about this issue at https://excaliburjs.com/docs/webgl'\r\n        );\r\n        // fallback to canvas in case of failure\r\n        useCanvasGraphicsContext = true;\r\n      }\r\n    }\r\n\r\n    if (useCanvasGraphicsContext) {\r\n      this.graphicsContext = new ExcaliburGraphicsContext2DCanvas({\r\n        canvasElement: this.canvas,\r\n        enableTransparency: this.enableCanvasTransparency,\r\n        smoothing: options.antialiasing,\r\n        backgroundColor: options.backgroundColor,\r\n        snapToPixel: options.snapToPixel,\r\n        useDrawSorting: options.useDrawSorting\r\n      });\r\n    }\r\n\r\n    this.screen = new Screen({\r\n      canvas: this.canvas,\r\n      context: this.graphicsContext,\r\n      antialiasing: options.antialiasing ?? true,\r\n      browser: this.browser,\r\n      viewport: options.viewport ?? (options.width && options.height ? { width: options.width, height: options.height } : Resolution.SVGA),\r\n      resolution: options.resolution,\r\n      displayMode,\r\n      pixelRatio: options.suppressHiDPIScaling ? 1 : (options.pixelRatio ?? null)\r\n    });\r\n\r\n    // Set default filtering based on antialiasing\r\n    TextureLoader.filtering = options.antialiasing ? ImageFiltering.Blended : ImageFiltering.Pixel;\r\n\r\n    if (options.backgroundColor) {\r\n      this.backgroundColor = options.backgroundColor.clone();\r\n    }\r\n\r\n    this.maxFps = options.maxFps ?? this.maxFps;\r\n\r\n    this.clock = new StandardClock({\r\n      maxFps: this.maxFps,\r\n      tick: this._mainloop.bind(this),\r\n      onFatalException: (e) => this.onFatalException(e)\r\n    });\r\n\r\n    this.enableCanvasTransparency = options.enableCanvasTransparency;\r\n\r\n    this._loader = new Loader();\r\n    this._loader.wireEngine(this);\r\n    this.debug = new Debug(this);\r\n\r\n    this._initialize(options);\r\n\r\n    this.rootScene = this.currentScene = new Scene();\r\n\r\n    this.addScene('root', this.rootScene);\r\n    (window as any).___EXCALIBUR_DEVTOOL = this;\r\n  }\r\n\r\n  private _performanceThresholdTriggered = false;\r\n  private _fpsSamples: number[] = [];\r\n  private _monitorPerformanceThresholdAndTriggerFallback() {\r\n    const { allow, threshold, showPlayerMessage } = this._originalOptions.configurePerformanceCanvas2DFallback;\r\n    if (!Flags.isEnabled('use-canvas-context') && allow && this.ready && !this._performanceThresholdTriggered) {\r\n      // Calculate Average fps for last X number of frames after start\r\n      if (this._fpsSamples.length === threshold.numberOfFrames) {\r\n        this._fpsSamples.splice(0, 1);\r\n      }\r\n      this._fpsSamples.push(this.clock.fpsSampler.fps);\r\n      let total = 0;\r\n      for (let i = 0; i < this._fpsSamples.length; i++) {\r\n        total += this._fpsSamples[i];\r\n      }\r\n      const average = total / this._fpsSamples.length;\r\n\r\n      if (this._fpsSamples.length === threshold.numberOfFrames) {\r\n        if (average <= threshold.fps) {\r\n          this._performanceThresholdTriggered = true;\r\n          this._logger.warn(\r\n            `Switching to browser 2D Canvas fallback due to performance. Some features of Excalibur will not work in this mode.\\n` +\r\n            'this might mean your browser doesn\\'t have webgl enabled or hardware acceleration is unavailable.\\n\\n' +\r\n            'If in Chrome:\\n' +\r\n            '  * Visit Settings > Advanced > System, and ensure \"Use Hardware Acceleration\" is checked.\\n'+\r\n            '  * Visit chrome://flags/#ignore-gpu-blocklist and ensure \"Override software rendering list\" is \"enabled\"\\n' +\r\n            'If in Firefox, visit about:config\\n' +\r\n            '  * Ensure webgl.disabled = false\\n' +\r\n            '  * Ensure webgl.force-enabled = true\\n' +\r\n            '  * Ensure layers.acceleration.force-enabled = true\\n\\n' +\r\n            'Read more about this issue at https://excaliburjs.com/docs/performance'\r\n          );\r\n\r\n          if (showPlayerMessage) {\r\n            this._toaster.toast(\r\n              'Excalibur is encountering performance issues. '+\r\n              'It\\'s possible that your browser doesn\\'t have hardware acceleration enabled. ' +\r\n              'Visit [LINK] for more information and potential solutions.',\r\n              'https://excaliburjs.com/docs/performance'\r\n            );\r\n          }\r\n          this.useCanvas2DFallback();\r\n          this.emit('fallbackgraphicscontext', this.graphicsContext);\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Switches the engine's graphics context to the 2D Canvas.\r\n   * @warning Some features of Excalibur will not work in this mode.\r\n   */\r\n  public useCanvas2DFallback() {\r\n    // Swap out the canvas\r\n    const newCanvas = this.canvas.cloneNode(false) as HTMLCanvasElement;\r\n    this.canvas.parentNode.replaceChild(newCanvas, this.canvas);\r\n    this.canvas = newCanvas;\r\n\r\n    const options = this._originalOptions;\r\n    const displayMode = this._originalDisplayMode;\r\n\r\n    // New graphics context\r\n    this.graphicsContext = new ExcaliburGraphicsContext2DCanvas({\r\n      canvasElement: this.canvas,\r\n      enableTransparency: this.enableCanvasTransparency,\r\n      smoothing: options.antialiasing,\r\n      backgroundColor: options.backgroundColor,\r\n      snapToPixel: options.snapToPixel,\r\n      useDrawSorting: options.useDrawSorting\r\n    });\r\n\r\n    // Reset screen\r\n    if (this.screen) {\r\n      this.screen.dispose();\r\n    }\r\n\r\n    this.screen = new Screen({\r\n      canvas: this.canvas,\r\n      context: this.graphicsContext,\r\n      antialiasing: options.antialiasing ?? true,\r\n      browser: this.browser,\r\n      viewport: options.viewport ?? (options.width && options.height ? { width: options.width, height: options.height } : Resolution.SVGA),\r\n      resolution: options.resolution,\r\n      displayMode,\r\n      pixelRatio: options.suppressHiDPIScaling ? 1 : (options.pixelRatio ?? null)\r\n    });\r\n    this.screen.setCurrentCamera(this.currentScene.camera);\r\n\r\n    // Reset pointers\r\n    this.input.pointers.detach();\r\n    const pointerTarget = options && options.pointerScope === Input.PointerScope.Document ? document : this.canvas;\r\n    this.input.pointers = this.input.pointers.recreate(pointerTarget, this);\r\n    this.input.pointers.init();\r\n  }\r\n\r\n  /**\r\n   * Returns a BoundingBox of the top left corner of the screen\r\n   * and the bottom right corner of the screen.\r\n   */\r\n  public getWorldBounds() {\r\n    return this.screen.getWorldBounds();\r\n  }\r\n\r\n  /**\r\n   * Gets the current engine timescale factor (default is 1.0 which is 1:1 time)\r\n   */\r\n  public get timescale() {\r\n    return this._timescale;\r\n  }\r\n\r\n  /**\r\n   * Sets the current engine timescale factor. Useful for creating slow-motion effects or fast-forward effects\r\n   * when using time-based movement.\r\n   */\r\n  public set timescale(value: number) {\r\n    if (value <= 0) {\r\n      Logger.getInstance().error('Cannot set engine.timescale to a value of 0 or less than 0.');\r\n      return;\r\n    }\r\n\r\n    this._timescale = value;\r\n  }\r\n\r\n  /**\r\n   * Adds a [[Timer]] to the [[currentScene]].\r\n   * @param timer  The timer to add to the [[currentScene]].\r\n   */\r\n  public addTimer(timer: Timer): Timer {\r\n    return this.currentScene.addTimer(timer);\r\n  }\r\n\r\n  /**\r\n   * Removes a [[Timer]] from the [[currentScene]].\r\n   * @param timer  The timer to remove to the [[currentScene]].\r\n   */\r\n  public removeTimer(timer: Timer): Timer {\r\n    return this.currentScene.removeTimer(timer);\r\n  }\r\n\r\n  /**\r\n   * Adds a [[Scene]] to the engine, think of scenes in Excalibur as you\r\n   * would levels or menus.\r\n   *\r\n   * @param key  The name of the scene, must be unique\r\n   * @param scene The scene to add to the engine\r\n   */\r\n  public addScene(key: string, scene: Scene) {\r\n    if (this.scenes[key]) {\r\n      this._logger.warn('Scene', key, 'already exists overwriting');\r\n    }\r\n    this.scenes[key] = scene;\r\n  }\r\n\r\n  /**\r\n   * Removes a [[Scene]] instance from the engine\r\n   * @param scene  The scene to remove\r\n   */\r\n  public removeScene(scene: Scene): void;\r\n  /**\r\n   * Removes a scene from the engine by key\r\n   * @param key  The scene key to remove\r\n   */\r\n  public removeScene(key: string): void;\r\n  /**\r\n   * @internal\r\n   */\r\n  public removeScene(entity: any): void {\r\n    if (entity instanceof Scene) {\r\n      // remove scene\r\n      for (const key in this.scenes) {\r\n        if (this.scenes.hasOwnProperty(key)) {\r\n          if (this.scenes[key] === entity) {\r\n            delete this.scenes[key];\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n    if (typeof entity === 'string') {\r\n      // remove scene\r\n      delete this.scenes[entity];\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Adds a [[Scene]] to the engine, think of scenes in Excalibur as you\r\n   * would levels or menus.\r\n   * @param sceneKey  The key of the scene, must be unique\r\n   * @param scene     The scene to add to the engine\r\n   */\r\n  public add(sceneKey: string, scene: Scene): void;\r\n  /**\r\n   * Adds a [[Timer]] to the [[currentScene]].\r\n   * @param timer  The timer to add to the [[currentScene]].\r\n   */\r\n  public add(timer: Timer): void;\r\n  /**\r\n   * Adds a [[TileMap]] to the [[currentScene]], once this is done the TileMap\r\n   * will be drawn and updated.\r\n   */\r\n  public add(tileMap: TileMap): void;\r\n  /**\r\n   * Adds an actor to the [[currentScene]] of the game. This is synonymous\r\n   * to calling `engine.currentScene.add(actor)`.\r\n   *\r\n   * Actors can only be drawn if they are a member of a scene, and only\r\n   * the [[currentScene]] may be drawn or updated.\r\n   *\r\n   * @param actor  The actor to add to the [[currentScene]]\r\n   */\r\n  public add(actor: Actor): void;\r\n\r\n  public add(entity: Entity): void;\r\n\r\n  /**\r\n   * Adds a [[ScreenElement]] to the [[currentScene]] of the game,\r\n   * ScreenElements do not participate in collisions, instead the\r\n   * remain in the same place on the screen.\r\n   * @param screenElement  The ScreenElement to add to the [[currentScene]]\r\n   */\r\n  public add(screenElement: ScreenElement): void;\r\n  public add(entity: any): void {\r\n    if (arguments.length === 2) {\r\n      this.addScene(<string>arguments[0], <Scene>arguments[1]);\r\n      return;\r\n    }\r\n    if (this._deferredGoTo && this.scenes[this._deferredGoTo]) {\r\n      this.scenes[this._deferredGoTo].add(entity);\r\n    } else {\r\n      this.currentScene.add(entity);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Removes a scene instance from the engine\r\n   * @param scene  The scene to remove\r\n   */\r\n  public remove(scene: Scene): void;\r\n  /**\r\n   * Removes a scene from the engine by key\r\n   * @param sceneKey  The scene to remove\r\n   */\r\n  public remove(sceneKey: string): void;\r\n  /**\r\n   * Removes a [[Timer]] from the [[currentScene]].\r\n   * @param timer  The timer to remove to the [[currentScene]].\r\n   */\r\n  public remove(timer: Timer): void;\r\n  /**\r\n   * Removes a [[TileMap]] from the [[currentScene]], it will no longer be drawn or updated.\r\n   */\r\n  public remove(tileMap: TileMap): void;\r\n  /**\r\n   * Removes an actor from the [[currentScene]] of the game. This is synonymous\r\n   * to calling `engine.currentScene.removeChild(actor)`.\r\n   * Actors that are removed from a scene will no longer be drawn or updated.\r\n   *\r\n   * @param actor  The actor to remove from the [[currentScene]].\r\n   */\r\n  public remove(actor: Actor): void;\r\n  /**\r\n   * Removes a [[ScreenElement]] to the scene, it will no longer be drawn or updated\r\n   * @param screenElement  The ScreenElement to remove from the [[currentScene]]\r\n   */\r\n  public remove(screenElement: ScreenElement): void;\r\n  public remove(entity: any): void {\r\n    if (entity instanceof Entity) {\r\n      this.currentScene.remove(entity);\r\n    }\r\n\r\n    if (entity instanceof Scene) {\r\n      this.removeScene(entity);\r\n    }\r\n\r\n    if (typeof entity === 'string') {\r\n      this.removeScene(entity);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Changes the currently updating and drawing scene to a different,\r\n   * named scene. Calls the [[Scene]] lifecycle events.\r\n   * @param key  The key of the scene to transition to.\r\n   */\r\n  public goToScene(key: string): void {\r\n    // if not yet initialized defer goToScene\r\n    if (!this.isInitialized) {\r\n      this._deferredGoTo = key;\r\n      return;\r\n    }\r\n\r\n    if (this.scenes[key]) {\r\n      const oldScene = this.currentScene;\r\n      const newScene = this.scenes[key];\r\n\r\n      this._logger.debug('Going to scene:', key);\r\n\r\n      // only deactivate when initialized\r\n      if (this.currentScene.isInitialized) {\r\n        this.currentScene._deactivate.apply(this.currentScene, [oldScene, newScene]);\r\n        this.currentScene.eventDispatcher.emit('deactivate', new DeactivateEvent(newScene, this.currentScene));\r\n      }\r\n\r\n      // set current scene to new one\r\n      this.currentScene = newScene;\r\n      this.screen.setCurrentCamera(newScene.camera);\r\n\r\n      // initialize the current scene if has not been already\r\n      this.currentScene._initialize(this);\r\n\r\n      this.currentScene._activate.apply(this.currentScene, [oldScene, newScene]);\r\n      this.currentScene.eventDispatcher.emit('activate', new ActivateEvent(oldScene, this.currentScene));\r\n    } else {\r\n      this._logger.error('Scene', key, 'does not exist!');\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Transforms the current x, y from screen coordinates to world coordinates\r\n   * @param point  Screen coordinate to convert\r\n   */\r\n  public screenToWorldCoordinates(point: Vector): Vector {\r\n    return this.screen.screenToWorldCoordinates(point);\r\n  }\r\n\r\n  /**\r\n   * Transforms a world coordinate, to a screen coordinate\r\n   * @param point  World coordinate to convert\r\n   */\r\n  public worldToScreenCoordinates(point: Vector): Vector {\r\n    return this.screen.worldToScreenCoordinates(point);\r\n  }\r\n\r\n  /**\r\n   * Initializes the internal canvas, rendering context, display mode, and native event listeners\r\n   */\r\n  private _initialize(options?: EngineOptions) {\r\n    this.pageScrollPreventionMode = options.scrollPreventionMode;\r\n\r\n    // initialize inputs\r\n    const pointerTarget = options && options.pointerScope === Input.PointerScope.Document ? document : this.canvas;\r\n    this.input = {\r\n      keyboard: new Input.Keyboard(),\r\n      pointers: new PointerEventReceiver(pointerTarget, this),\r\n      gamepads: new Input.Gamepads()\r\n    };\r\n    this.input.keyboard.init();\r\n    this.input.pointers.init();\r\n    this.input.gamepads.init();\r\n\r\n    // Issue #385 make use of the visibility api\r\n    // https://developer.mozilla.org/en-US/docs/Web/Guide/User_experience/Using_the_Page_Visibility_API\r\n\r\n    let hidden: keyof HTMLDocument, visibilityChange: string;\r\n    if (typeof document.hidden !== 'undefined') {\r\n      // Opera 12.10 and Firefox 18 and later support\r\n      hidden = 'hidden';\r\n      visibilityChange = 'visibilitychange';\r\n    } else if ('msHidden' in document) {\r\n      hidden = <keyof HTMLDocument>'msHidden';\r\n      visibilityChange = 'msvisibilitychange';\r\n    } else if ('webkitHidden' in document) {\r\n      hidden = <keyof HTMLDocument>'webkitHidden';\r\n      visibilityChange = 'webkitvisibilitychange';\r\n    }\r\n\r\n    this.browser.document.on(visibilityChange, () => {\r\n      if (document[hidden]) {\r\n        this.eventDispatcher.emit('hidden', new HiddenEvent(this));\r\n        this._logger.debug('Window hidden');\r\n      } else {\r\n        this.eventDispatcher.emit('visible', new VisibleEvent(this));\r\n        this._logger.debug('Window visible');\r\n      }\r\n    });\r\n\r\n    if (!this.canvasElementId && !options.canvasElement) {\r\n      document.body.appendChild(this.canvas);\r\n    }\r\n  }\r\n\r\n  public onInitialize(_engine: Engine) {\r\n    // Override me\r\n  }\r\n\r\n  /**\r\n   * If supported by the browser, this will set the antialiasing flag on the\r\n   * canvas. Set this to `false` if you want a 'jagged' pixel art look to your\r\n   * image resources.\r\n   * @param isSmooth  Set smoothing to true or false\r\n   */\r\n  public setAntialiasing(isSmooth: boolean) {\r\n    this.screen.antialiasing = isSmooth;\r\n  }\r\n\r\n  /**\r\n   * Return the current smoothing status of the canvas\r\n   */\r\n  public getAntialiasing(): boolean {\r\n    return this.screen.antialiasing;\r\n  }\r\n\r\n  /**\r\n   * Gets whether the actor is Initialized\r\n   */\r\n  public get isInitialized(): boolean {\r\n    return this._isInitialized;\r\n  }\r\n\r\n  private _overrideInitialize(engine: Engine) {\r\n    if (!this.isInitialized) {\r\n      this.onInitialize(engine);\r\n      super.emit('initialize', new InitializeEvent(engine, this));\r\n      this._isInitialized = true;\r\n      if (this._deferredGoTo) {\r\n        this.goToScene(this._deferredGoTo);\r\n      } else {\r\n        this.goToScene('root');\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Updates the entire state of the game\r\n   * @param delta  Number of milliseconds elapsed since the last update.\r\n   */\r\n  private _update(delta: number) {\r\n    if (!this.ready) {\r\n      // suspend updates until loading is finished\r\n      this._loader.update(this, delta);\r\n      // Update input listeners\r\n      this.input.keyboard.update();\r\n      this.input.gamepads.update();\r\n      return;\r\n    }\r\n\r\n\r\n    // Publish preupdate events\r\n    this._preupdate(delta);\r\n\r\n    // process engine level events\r\n    this.currentScene.update(this, delta);\r\n\r\n    // Publish update event\r\n    this._postupdate(delta);\r\n\r\n    // Update input listeners\r\n    this.input.keyboard.update();\r\n    this.input.gamepads.update();\r\n  }\r\n\r\n  /**\r\n   * @internal\r\n   */\r\n  public _preupdate(delta: number) {\r\n    this.emit('preupdate', new PreUpdateEvent(this, delta, this));\r\n    this.onPreUpdate(this, delta);\r\n  }\r\n\r\n  public onPreUpdate(_engine: Engine, _delta: number) {\r\n    // Override me\r\n  }\r\n\r\n  /**\r\n   * @internal\r\n   */\r\n  public _postupdate(delta: number) {\r\n    this.emit('postupdate', new PostUpdateEvent(this, delta, this));\r\n    this.onPostUpdate(this, delta);\r\n  }\r\n\r\n  public onPostUpdate(_engine: Engine, _delta: number) {\r\n    // Override me\r\n  }\r\n\r\n  /**\r\n   * Draws the entire game\r\n   * @param delta  Number of milliseconds elapsed since the last draw.\r\n   */\r\n  private _draw(delta: number) {\r\n    this.graphicsContext.beginDrawLifecycle();\r\n    this.graphicsContext.clear();\r\n    this._predraw(this.graphicsContext, delta);\r\n\r\n    // Drawing nothing else while loading\r\n    if (!this._isReady) {\r\n      this._loader.canvas.draw(this.graphicsContext, 0, 0);\r\n      this.graphicsContext.flush();\r\n      return;\r\n    }\r\n\r\n    // TODO move to graphics systems?\r\n    this.graphicsContext.backgroundColor = this.backgroundColor;\r\n\r\n    this.currentScene.draw(this.graphicsContext, delta);\r\n\r\n    this._postdraw(this.graphicsContext, delta);\r\n\r\n    // Flush any pending drawings\r\n    this.graphicsContext.flush();\r\n    this.graphicsContext.endDrawLifecycle();\r\n\r\n    this._checkForScreenShots();\r\n  }\r\n\r\n  /**\r\n   * @internal\r\n   */\r\n  public _predraw(_ctx: ExcaliburGraphicsContext, delta: number) {\r\n    this.emit('predraw', new PreDrawEvent(_ctx, delta, this));\r\n    this.onPreDraw(_ctx, delta);\r\n  }\r\n\r\n  public onPreDraw(_ctx: ExcaliburGraphicsContext, _delta: number) {\r\n    // Override me\r\n  }\r\n\r\n  /**\r\n   * @internal\r\n   */\r\n  public _postdraw(_ctx: ExcaliburGraphicsContext, delta: number) {\r\n    this.emit('postdraw', new PostDrawEvent(_ctx, delta, this));\r\n    this.onPostDraw(_ctx, delta);\r\n  }\r\n\r\n  public onPostDraw(_ctx: ExcaliburGraphicsContext, _delta: number) {\r\n    // Override me\r\n  }\r\n\r\n  /**\r\n   * Enable or disable Excalibur debugging functionality.\r\n   * @param toggle a value that debug drawing will be changed to\r\n   */\r\n  public showDebug(toggle: boolean): void {\r\n    this._isDebug = toggle;\r\n  }\r\n\r\n  /**\r\n   * Toggle Excalibur debugging functionality.\r\n   */\r\n  public toggleDebug(): boolean {\r\n    this._isDebug = !this._isDebug;\r\n    return this._isDebug;\r\n  }\r\n\r\n  private _loadingComplete: boolean = false;\r\n\r\n  /**\r\n   * Returns true when loading is totally complete and the player has clicked start\r\n   */\r\n  public get loadingComplete() {\r\n    return this._loadingComplete;\r\n  }\r\n\r\n  private _isReady = false;\r\n  public get ready() {\r\n    return this._isReady;\r\n  }\r\n  private _isReadyResolve: () => any;\r\n  private _isReadyPromise = new Promise<void>(resolve => {\r\n    this._isReadyResolve = resolve;\r\n  });\r\n  public isReady(): Promise<void> {\r\n    return this._isReadyPromise;\r\n  }\r\n\r\n\r\n  /**\r\n   * Starts the internal game loop for Excalibur after loading\r\n   * any provided assets.\r\n   * @param loader  Optional [[Loader]] to use to load resources. The default loader is [[Loader]], override to provide your own\r\n   * custom loader.\r\n   *\r\n   * Note: start() only resolves AFTER the user has clicked the play button\r\n   */\r\n  public async start(loader?: Loader): Promise<void> {\r\n    if (!this._compatible) {\r\n      throw new Error('Excalibur is incompatible with your browser');\r\n    }\r\n\r\n    // Wire loader if we have it\r\n    if (loader) {\r\n      // Push the current user entered resolution/viewport\r\n      this.screen.pushResolutionAndViewport();\r\n\r\n      // Configure resolution for loader, it expects resolution === viewport\r\n      this.screen.resolution = this.screen.viewport;\r\n      this.screen.applyResolutionAndViewport();\r\n      this._loader = loader;\r\n      this._loader.suppressPlayButton = this._suppressPlayButton || this._loader.suppressPlayButton;\r\n      this._loader.wireEngine(this);\r\n    }\r\n\r\n    // Start the excalibur clock which drives the mainloop\r\n    // has started is a slight misnomer, it's really mainloop started\r\n    this._logger.debug('Starting game clock...');\r\n    this.browser.resume();\r\n    this.clock.start();\r\n    this._logger.debug('Game clock started');\r\n\r\n    if (loader) {\r\n      await this.load(this._loader);\r\n      this._loadingComplete = true;\r\n\r\n      // reset back to previous user resolution/viewport\r\n      this.screen.popResolutionAndViewport();\r\n      this.screen.applyResolutionAndViewport();\r\n    }\r\n\r\n    this._loadingComplete = true;\r\n\r\n    // Initialize before ready\r\n    this._overrideInitialize(this);\r\n\r\n    this._isReady = true;\r\n\r\n    this._isReadyResolve();\r\n    this.emit('start', new GameStartEvent(this));\r\n    return this._isReadyPromise;\r\n  }\r\n\r\n  private _mainloop(elapsed: number) {\r\n    this.emit('preframe', new PreFrameEvent(this, this.stats.prevFrame));\r\n    const delta = elapsed * this.timescale;\r\n\r\n    // reset frame stats (reuse existing instances)\r\n    const frameId = this.stats.prevFrame.id + 1;\r\n    this.stats.currFrame.reset();\r\n    this.stats.currFrame.id = frameId;\r\n    this.stats.currFrame.delta = delta;\r\n    this.stats.currFrame.fps = this.clock.fpsSampler.fps;\r\n    GraphicsDiagnostics.clear();\r\n\r\n    const beforeUpdate = this.clock.now();\r\n    this._update(delta);\r\n    const afterUpdate = this.clock.now();\r\n    this._draw(delta);\r\n    const afterDraw = this.clock.now();\r\n\r\n    this.stats.currFrame.duration.update = afterUpdate - beforeUpdate;\r\n    this.stats.currFrame.duration.draw = afterDraw - afterUpdate;\r\n    this.stats.currFrame.graphics.drawnImages = GraphicsDiagnostics.DrawnImagesCount;\r\n    this.stats.currFrame.graphics.drawCalls = GraphicsDiagnostics.DrawCallCount;\r\n\r\n    this.emit('postframe', new PostFrameEvent(this, this.stats.currFrame));\r\n    this.stats.prevFrame.reset(this.stats.currFrame);\r\n\r\n    this._monitorPerformanceThresholdAndTriggerFallback();\r\n  }\r\n\r\n  /**\r\n   * Stops Excalibur's main loop, useful for pausing the game.\r\n   */\r\n  public stop() {\r\n    if (this.clock.isRunning()) {\r\n      this.emit('stop', new GameStopEvent(this));\r\n      this.browser.pause();\r\n      this.clock.stop();\r\n      this._logger.debug('Game stopped');\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Returns the Engine's running status, Useful for checking whether engine is running or paused.\r\n   */\r\n  public isRunning() {\r\n    return this.clock.isRunning();\r\n  }\r\n\r\n\r\n  private _screenShotRequests: { preserveHiDPIResolution: boolean, resolve: (image: HTMLImageElement) => void }[] = [];\r\n  /**\r\n   * Takes a screen shot of the current viewport and returns it as an\r\n   * HTML Image Element.\r\n   * @param preserveHiDPIResolution in the case of HiDPI return the full scaled backing image, by default false\r\n   */\r\n  public screenshot(preserveHiDPIResolution = false): Promise<HTMLImageElement> {\r\n    const screenShotPromise = new Promise<HTMLImageElement>((resolve) => {\r\n      this._screenShotRequests.push({preserveHiDPIResolution, resolve});\r\n    });\r\n    return screenShotPromise;\r\n  }\r\n\r\n  private _checkForScreenShots() {\r\n    // We must grab the draw buffer before we yield to the browser\r\n    // the draw buffer is cleared after compositing\r\n    // the reason for the asynchrony is setting `preserveDrawingBuffer: true`\r\n    // forces the browser to copy buffers which can have a mass perf impact on mobile\r\n    for (const request of this._screenShotRequests) {\r\n      const finalWidth = request.preserveHiDPIResolution ? this.canvas.width : this.screen.resolution.width;\r\n      const finalHeight = request.preserveHiDPIResolution ? this.canvas.height : this.screen.resolution.height;\r\n      const screenshot = document.createElement('canvas');\r\n      screenshot.width = finalWidth;\r\n      screenshot.height = finalHeight;\r\n      const ctx = screenshot.getContext('2d');\r\n      ctx.drawImage(this.canvas, 0, 0, finalWidth, finalHeight);\r\n\r\n      const result = new Image();\r\n      const raw = screenshot.toDataURL('image/png');\r\n      result.src = raw;\r\n      request.resolve(result);\r\n    }\r\n    // Reset state\r\n    this._screenShotRequests.length = 0;\r\n  }\r\n\r\n  /**\r\n   * Another option available to you to load resources into the game.\r\n   * Immediately after calling this the game will pause and the loading screen\r\n   * will appear.\r\n   * @param loader  Some [[Loadable]] such as a [[Loader]] collection, [[Sound]], or [[Texture]].\r\n   */\r\n  public async load(loader: Loadable<any>): Promise<void> {\r\n    try {\r\n      await loader.load();\r\n    } catch (e) {\r\n      this._logger.error('Error loading resources, things may not behave properly', e);\r\n      await Promise.resolve();\r\n    }\r\n  }\r\n}","import { GameEvent } from '../Events';\r\nimport { Sound } from '../Resources/Sound/Sound';\r\nimport { Actor } from '../Actor';\r\nimport { WebAudioInstance } from '../Resources/Sound/WebAudioInstance';\r\n\r\nexport class MediaEvent extends GameEvent<Sound> {\r\n  /**\r\n   * Media event cannot bubble\r\n   */\r\n  public set bubbles(_value: boolean) {\r\n    // stubbed\r\n  }\r\n  /**\r\n   * Media event cannot bubble\r\n   */\r\n  public get bubbles(): boolean {\r\n    return false;\r\n  }\r\n  /**\r\n   * Media event cannot bubble, so they have no path\r\n   */\r\n  protected get _path(): Actor[] {\r\n    return null;\r\n  }\r\n  /**\r\n   * Media event cannot bubble, so they have no path\r\n   */\r\n  protected set _path(_val: Actor[]) {\r\n    // stubbed\r\n  }\r\n\r\n  constructor(public target: Sound, protected _name: string = 'MediaEvent') {\r\n    super();\r\n  }\r\n\r\n  /**\r\n   * Prevents event from bubbling\r\n   */\r\n  public stopPropagation(): void {\r\n    /**\r\n     * Stub\r\n     */\r\n  }\r\n  /**\r\n   * Action, that calls when event happens\r\n   */\r\n  public action(): void {\r\n    /**\r\n     * Stub\r\n     */\r\n  }\r\n  /**\r\n   * Propagate event further through event path\r\n   */\r\n  public propagate(): void {\r\n    /**\r\n     * Stub\r\n     */\r\n  }\r\n\r\n  public layPath(_actor: Actor): void {\r\n    /**\r\n     * Stub\r\n     */\r\n  }\r\n}\r\n\r\nexport class NativeSoundEvent extends MediaEvent {\r\n  constructor(target: Sound, public track?: WebAudioInstance) {\r\n    super(target, 'NativeSoundEvent');\r\n  }\r\n}\r\n\r\nexport class NativeSoundProcessedEvent extends MediaEvent {\r\n  public data: string | AudioBuffer;\r\n\r\n  constructor(target: Sound, private _processedData: string | AudioBuffer) {\r\n    super(target, 'NativeSoundProcessedEvent');\r\n\r\n    this.data = this._processedData;\r\n  }\r\n}\r\n","import { Engine } from './Engine';\r\nimport { Color } from './Color';\r\nimport { vec, Vector } from './Math/vector';\r\nimport { Text } from './Graphics/Text';\r\nimport { GraphicsComponent, SpriteFont } from './Graphics';\r\nimport { Font } from './Graphics/Font';\r\nimport { Actor } from './Actor';\r\nimport { ActorArgs } from '.';\r\n\r\n/**\r\n * Option for creating a label\r\n */\r\nexport interface LabelOptions {\r\n  /**\r\n   * Specify the label text\r\n   */\r\n  text?: string;\r\n  /**\r\n   * Specify the color of the text (does not apply to SpriteFonts)\r\n   */\r\n  color?: Color;\r\n  x?: number;\r\n  y?: number;\r\n  pos?: Vector;\r\n  /**\r\n   * Optionally specify a sprite font, will take precedence over any other [[Font]]\r\n   */\r\n  spriteFont?: SpriteFont;\r\n  /**\r\n   * Specify a custom font\r\n   */\r\n  font?: Font\r\n}\r\n\r\n/**\r\n * Labels are the way to draw small amounts of text to the screen. They are\r\n * actors and inherit all of the benefits and capabilities.\r\n */\r\nexport class Label extends Actor {\r\n  private _font: Font = new Font();\r\n  private _text: Text = new Text({ text: '', font: this._font });\r\n\r\n  public get font(): Font {\r\n    return this._font;\r\n  }\r\n\r\n  public set font(newFont: Font) {\r\n    this._font = newFont;\r\n    this._text.font = newFont;\r\n  }\r\n\r\n  /**\r\n   * The text to draw.\r\n   */\r\n  public get text(): string {\r\n    return this._text.text;\r\n  }\r\n\r\n  public set text(text: string) {\r\n    this._text.text = text;\r\n  }\r\n\r\n  public override get color(): Color {\r\n    return this._text.color;\r\n  }\r\n\r\n  public override set color(color: Color) {\r\n    if (this._text) {\r\n      this._text.color = color;\r\n    }\r\n  }\r\n\r\n  public get opacity(): number {\r\n    return this._text.opacity;\r\n  }\r\n\r\n  public set opacity(opacity: number) {\r\n    this._text.opacity = opacity;\r\n  }\r\n\r\n  private _spriteFont: SpriteFont;\r\n  /**\r\n   * The [[SpriteFont]] to use, if any. Overrides [[Font|font]] if present.\r\n   */\r\n  public get spriteFont(): SpriteFont {\r\n    return this._spriteFont;\r\n  }\r\n\r\n  public set spriteFont(sf: SpriteFont) {\r\n    if (sf) {\r\n      this._spriteFont = sf;\r\n      this._text.font = this._spriteFont;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Build a new label\r\n   * @param options\r\n   */\r\n  constructor(options?: LabelOptions & ActorArgs) {\r\n    super(options);\r\n    const {text, pos, x, y, spriteFont, font, color} = options;\r\n\r\n    this.pos = pos ?? (x && y ? vec(x, y) : this.pos);\r\n    this.text = text ?? this.text;\r\n    this.font = font ?? this.font;\r\n    this.spriteFont = spriteFont ?? this.spriteFont;\r\n    this._text.color = color ?? this.color;\r\n    const gfx = this.get(GraphicsComponent);\r\n    gfx.anchor = Vector.Zero;\r\n    gfx.use(this._text);\r\n  }\r\n\r\n  public _initialize(engine: Engine) {\r\n    super._initialize(engine);\r\n  }\r\n\r\n  /**\r\n   * Returns the width of the text in the label (in pixels);\r\n   */\r\n  public getTextWidth(): number {\r\n    return this._text.width;\r\n  }\r\n}\r\n","import { BodyComponent, BoundingBox, Collider, ColliderComponent, CollisionType, Color, CompositeCollider, vec, Vector } from '..';\r\nimport { TransformComponent } from '../EntityComponentSystem/Components/TransformComponent';\r\nimport { Entity } from '../EntityComponentSystem/Entity';\r\nimport { DebugGraphicsComponent, ExcaliburGraphicsContext, Graphic, GraphicsComponent } from '../Graphics';\r\nimport { IsometricEntityComponent } from './IsometricEntityComponent';\r\n\r\nexport class IsometricTile extends Entity {\r\n  /**\r\n   * Indicates whether this tile is solid\r\n   */\r\n  public solid: boolean = false;\r\n\r\n  private _gfx: GraphicsComponent;\r\n  private _tileBounds = new BoundingBox();\r\n  private _graphics: Graphic[] = [];\r\n  public getGraphics(): readonly Graphic[] {\r\n    return this._graphics;\r\n  }\r\n  /**\r\n   * Tile graphics\r\n   */\r\n  public addGraphic(graphic: Graphic) {\r\n    this._graphics.push(graphic);\r\n    this._gfx.visible = true;\r\n    this._gfx.localBounds = this._recalculateBounds();\r\n  }\r\n\r\n  private _recalculateBounds(): BoundingBox {\r\n    let bounds = this._tileBounds.clone();\r\n    for (const graphic of this._graphics) {\r\n      const offset = vec(\r\n        this.map.graphicsOffset.x - this.map.tileWidth / 2,\r\n        this.map.graphicsOffset.y - (this.map.renderFromTopOfGraphic ? 0 : (graphic.height - this.map.tileHeight)));\r\n      bounds = bounds.combine(graphic.localBounds.translate(offset));\r\n    }\r\n    return bounds;\r\n  }\r\n\r\n  public removeGraphic(graphic: Graphic) {\r\n    const index = this._graphics.indexOf(graphic);\r\n    if (index > -1) {\r\n      this._graphics.splice(index, 1);\r\n    }\r\n    this._gfx.localBounds = this._recalculateBounds();\r\n  }\r\n\r\n  public clearGraphics() {\r\n    this._graphics.length = 0;\r\n    this._gfx.visible = false;\r\n    this._gfx.localBounds = this._recalculateBounds();\r\n  }\r\n\r\n  /**\r\n   * Tile colliders\r\n   */\r\n  private _colliders: Collider[] = [];\r\n  public getColliders(): readonly Collider[] {\r\n    return this._colliders;\r\n  }\r\n\r\n  /**\r\n   * Adds a collider to the IsometricTile\r\n   *\r\n   * **Note!** the [[Tile.solid]] must be set to true for it to act as a \"fixed\" collider\r\n   * @param collider\r\n   */\r\n  public addCollider(collider: Collider) {\r\n    this._colliders.push(collider);\r\n    this.map.flagCollidersDirty();\r\n  }\r\n\r\n  /**\r\n   * Removes a collider from the IsometricTile\r\n   * @param collider\r\n   */\r\n  public removeCollider(collider: Collider) {\r\n    const index = this._colliders.indexOf(collider);\r\n    if (index > -1) {\r\n      this._colliders.splice(index, 1);\r\n    }\r\n    this.map.flagCollidersDirty();\r\n  }\r\n\r\n  /**\r\n   * Clears all colliders from the IsometricTile\r\n   */\r\n  public clearColliders(): void {\r\n    this._colliders.length = 0;\r\n    this.map.flagCollidersDirty();\r\n  }\r\n\r\n  /**\r\n   * Integer tile x coordinate\r\n   */\r\n  public readonly x: number;\r\n  /**\r\n   * Integer tile y coordinate\r\n   */\r\n  public readonly y: number;\r\n  /**\r\n   * Reference to the [[IsometricMap]] this tile is part of\r\n   */\r\n  public readonly map: IsometricMap;\r\n\r\n  private _transform: TransformComponent;\r\n  private _isometricEntityComponent: IsometricEntityComponent;\r\n\r\n  /**\r\n   * Returns the top left corner of the [[IsometricTile]] in world space\r\n   */\r\n  public get pos(): Vector {\r\n    return this.map.tileToWorld(vec(this.x, this.y));\r\n  }\r\n\r\n  /**\r\n   * Returns the center of the [[IsometricTile]]\r\n   */\r\n  public get center(): Vector {\r\n    return this.pos.add(vec(0, this.map.tileHeight / 2));\r\n  }\r\n\r\n  /**\r\n   * Construct a new IsometricTile\r\n   * @param x tile coordinate in x (not world position)\r\n   * @param y tile coordinate in y (not world position)\r\n   * @param graphicsOffset offset that tile should be shifted by (default (0, 0))\r\n   * @param map reference to owning IsometricMap\r\n   */\r\n  constructor(x: number, y: number, graphicsOffset: Vector | null, map: IsometricMap) {\r\n    super([\r\n      new TransformComponent(),\r\n      new GraphicsComponent({\r\n        offset: graphicsOffset ?? Vector.Zero,\r\n        onPostDraw: (gfx, elapsed) => this.draw(gfx, elapsed)\r\n      }),\r\n      new IsometricEntityComponent(map)\r\n    ]);\r\n    this.x = x;\r\n    this.y = y;\r\n    this.map = map;\r\n    this._transform = this.get(TransformComponent);\r\n    this._isometricEntityComponent = this.get(IsometricEntityComponent);\r\n\r\n    const halfTileWidth = this.map.tileWidth / 2;\r\n    const halfTileHeight = this.map.tileHeight / 2;\r\n    // See https://clintbellanger.net/articles/isometric_math/ for formula\r\n    // The x position shifts left with every y step\r\n    const xPos = (this.x - this.y) * halfTileWidth;\r\n    // The y position needs to go down with every x step\r\n    const yPos = (this.x + this.y) * halfTileHeight;\r\n    this._transform.pos = vec(xPos, yPos);\r\n    this._isometricEntityComponent.elevation = 0;\r\n\r\n    this._gfx = this.get(GraphicsComponent);\r\n    this._gfx.visible = false; // start not visible\r\n    const totalWidth = this.map.tileWidth;\r\n    const totalHeight = this.map.tileHeight;\r\n\r\n    // initial guess at gfx bounds based on the tile\r\n    const offset = vec(0, (this.map.renderFromTopOfGraphic ? totalHeight : 0));\r\n    this._gfx.localBounds = this._tileBounds = new BoundingBox({\r\n      left: -totalWidth / 2,\r\n      top: -totalHeight,\r\n      right: totalWidth / 2,\r\n      bottom: totalHeight\r\n    }).translate(offset);\r\n  }\r\n\r\n  draw(gfx: ExcaliburGraphicsContext, _elapsed: number) {\r\n    const halfTileWidth = this.map.tileWidth / 2;\r\n    gfx.save();\r\n    // shift left origin to corner of map, not the left corner of the first sprite\r\n    gfx.translate(-halfTileWidth, 0);\r\n    for (const graphic of this._graphics) {\r\n      graphic.draw(\r\n        gfx,\r\n        this.map.graphicsOffset.x,\r\n        this.map.graphicsOffset.y - (this.map.renderFromTopOfGraphic ? 0 : (graphic.height - this.map.tileHeight)));\r\n    }\r\n    gfx.restore();\r\n  }\r\n}\r\n\r\nexport interface IsometricMapOptions {\r\n  /**\r\n   * Optionally name the isometric tile map\r\n   */\r\n  name?: string;\r\n  /**\r\n   * Optionally specify the position of the isometric tile map\r\n   */\r\n  pos?: Vector;\r\n  /**\r\n   * Optionally render from the top of the graphic, by default tiles are rendered from the bottom\r\n   */\r\n  renderFromTopOfGraphic?: boolean;\r\n  /**\r\n   * Optionally present a graphics offset, this can be useful depending on your tile graphics\r\n   */\r\n  graphicsOffset?: Vector;\r\n  /**\r\n   * Width of an individual tile in pixels, this should be the width of the parallelogram of the base of the tile art asset.\r\n   */\r\n  tileWidth: number;\r\n  /**\r\n   * Height of an individual tile in pixels, this should be the height of the parallelogram of the base of the tile art asset.\r\n   */\r\n  tileHeight: number;\r\n  /**\r\n   * The number of tile columns, or the number of tiles wide\r\n   */\r\n  columns: number;\r\n  /**\r\n   * The number of tile  rows, or the number of tiles high\r\n   */\r\n  rows: number;\r\n}\r\n\r\n/**\r\n * The IsometricMap is a special tile map that provides isometric rendering support to Excalibur\r\n *\r\n * The tileWidth and tileHeight should be the height and width in pixels of the parallelogram of the base of the tile art asset.\r\n * The tileWidth and tileHeight is not necessarily the same as your graphic pixel width and height.\r\n *\r\n * Please refer to the docs https://excaliburjs.com for more details calculating what your tile width and height should be given\r\n * your art assets.\r\n */\r\nexport class IsometricMap extends Entity {\r\n  /**\r\n   * Width of individual tile in pixels\r\n   */\r\n  public readonly tileWidth: number;\r\n  /**\r\n   * Height of individual tile in pixels\r\n   */\r\n  public readonly tileHeight: number;\r\n  /**\r\n   * Number of tiles wide\r\n   */\r\n  public readonly columns: number;\r\n  /**\r\n   * Number of tiles high\r\n   */\r\n  public readonly rows: number;\r\n  /**\r\n   * List containing all of the tiles in IsometricMap\r\n   */\r\n  public readonly tiles: IsometricTile[];\r\n\r\n  /**\r\n   * Render the tile graphic from the top instead of the bottom\r\n   *\r\n   * default is `false` meaning rendering from the bottom\r\n   */\r\n  public renderFromTopOfGraphic: boolean = false;\r\n  public graphicsOffset: Vector = vec(0, 0);\r\n\r\n  /**\r\n   * Isometric map [[TransformComponent]]\r\n   */\r\n  public transform: TransformComponent;\r\n\r\n  /**\r\n   * Isometric map [[ColliderComponent]]\r\n   */\r\n  public collider: ColliderComponent;\r\n\r\n  private _composite: CompositeCollider;\r\n\r\n  constructor(options: IsometricMapOptions) {\r\n    super([\r\n      new TransformComponent(),\r\n      new BodyComponent({\r\n        type: CollisionType.Fixed\r\n      }),\r\n      new ColliderComponent(),\r\n      new DebugGraphicsComponent((ctx) => this.debug(ctx), false)\r\n    ], options.name);\r\n    const { pos, tileWidth, tileHeight, columns: width, rows: height, renderFromTopOfGraphic, graphicsOffset } = options;\r\n\r\n    this.transform = this.get(TransformComponent);\r\n    if (pos) {\r\n      this.transform.pos = pos;\r\n    }\r\n\r\n    this.collider = this.get(ColliderComponent);\r\n    if (this.collider) {\r\n      this.collider.set(this._composite = new CompositeCollider([]));\r\n    }\r\n\r\n\r\n    this.renderFromTopOfGraphic = renderFromTopOfGraphic ?? this.renderFromTopOfGraphic;\r\n    this.graphicsOffset = graphicsOffset ?? this.graphicsOffset;\r\n\r\n    this.tileWidth = tileWidth;\r\n    this.tileHeight = tileHeight;\r\n    this.columns = width;\r\n    this.rows = height;\r\n\r\n    this.tiles = new Array(width * height);\r\n\r\n    // build up tile representation\r\n    for (let y = 0; y < height; y++) {\r\n      for (let x = 0; x < width; x++) {\r\n        const tile = new IsometricTile(x, y, this.graphicsOffset, this);\r\n        this.tiles[x + y * width] = tile;\r\n        this.addChild(tile);\r\n        // TODO row/columns helpers\r\n      }\r\n    }\r\n  }\r\n\r\n  public update(): void {\r\n    if (this._collidersDirty) {\r\n      this.updateColliders();\r\n      this._collidersDirty = false;\r\n    }\r\n  }\r\n\r\n  private _collidersDirty = false;\r\n  public flagCollidersDirty() {\r\n    this._collidersDirty = true;\r\n  }\r\n\r\n  private _originalOffsets = new WeakMap<Collider, Vector>();\r\n  private _getOrSetColliderOriginalOffset(collider: Collider): Vector {\r\n    if (!this._originalOffsets.has(collider)) {\r\n      const originalOffset = collider.offset;\r\n      this._originalOffsets.set(collider, originalOffset);\r\n      return originalOffset;\r\n    } else {\r\n      return this._originalOffsets.get(collider);\r\n    }\r\n  }\r\n  public updateColliders() {\r\n    this._composite.clearColliders();\r\n    const pos = this.get(TransformComponent).pos;\r\n    for (const tile of this.tiles) {\r\n      if (tile.solid) {\r\n        for (const collider of tile.getColliders()) {\r\n          const originalOffset = this._getOrSetColliderOriginalOffset(collider);\r\n          collider.offset = this.tileToWorld(vec(tile.x, tile.y))\r\n            .sub(pos)\r\n            .add(originalOffset)\r\n            .sub(vec(this.tileWidth / 2, this.tileHeight)); // We need to unshift height based on drawing\r\n          collider.owner = this;\r\n          this._composite.addCollider(collider);\r\n        }\r\n      }\r\n    }\r\n    this.collider.update();\r\n  }\r\n\r\n  /**\r\n   * Convert world space coordinates to the tile x, y coordinate\r\n   * @param worldCoordinate\r\n   */\r\n  public worldToTile(worldCoordinate: Vector): Vector {\r\n    worldCoordinate = worldCoordinate.sub(this.transform.globalPos);\r\n\r\n    const halfTileWidth = this.tileWidth / 2;\r\n    const halfTileHeight = this.tileHeight / 2;\r\n    // See https://clintbellanger.net/articles/isometric_math/ for formula\r\n    return vec(\r\n      ~~((worldCoordinate.x / halfTileWidth + (worldCoordinate.y / halfTileHeight)) / 2),\r\n      ~~((worldCoordinate.y / halfTileHeight - (worldCoordinate.x / halfTileWidth)) / 2));\r\n  }\r\n\r\n  /**\r\n   * Given a tile coordinate, return the top left corner in world space\r\n   * @param tileCoordinate\r\n   */\r\n  public tileToWorld(tileCoordinate: Vector): Vector {\r\n    const halfTileWidth = this.tileWidth / 2;\r\n    const halfTileHeight = this.tileHeight / 2;\r\n    // The x position shifts left with every y step\r\n    const xPos = (tileCoordinate.x - tileCoordinate.y) * halfTileWidth;\r\n    // The y position needs to go down with every x step\r\n    const yPos = (tileCoordinate.x + tileCoordinate.y) * halfTileHeight;\r\n    return vec(xPos, yPos).add(this.transform.pos);\r\n  }\r\n\r\n  /**\r\n   * Returns the [[IsometricTile]] by its x and y coordinates\r\n   */\r\n  public getTile(x: number, y: number): IsometricTile | null {\r\n    if (x < 0 || y < 0 || x >= this.columns || y >= this.rows) {\r\n      return null;\r\n    }\r\n    return this.tiles[x + y * this.columns];\r\n  }\r\n\r\n  /**\r\n   * Returns the [[IsometricTile]] by testing a point in world coordinates,\r\n   * returns `null` if no Tile was found.\r\n   */\r\n  public getTileByPoint(point: Vector): IsometricTile | null {\r\n    const tileCoord = this.worldToTile(point);\r\n    const tile = this.getTile(tileCoord.x, tileCoord.y);\r\n    return tile;\r\n  }\r\n\r\n  private _getMaxZIndex(): number {\r\n    let maxZ = Number.NEGATIVE_INFINITY;\r\n    for (const tile of this.tiles) {\r\n      const currentZ = tile.get(TransformComponent).z;\r\n      if (currentZ > maxZ) {\r\n        maxZ =  currentZ;\r\n      }\r\n    }\r\n    return maxZ;\r\n  }\r\n\r\n  /**\r\n   * Debug draw for IsometricMap, called internally by excalibur when debug mode is toggled on\r\n   * @param gfx\r\n   */\r\n  public debug(gfx: ExcaliburGraphicsContext) {\r\n    gfx.save();\r\n    gfx.z = this._getMaxZIndex() + 0.5;\r\n    for (let y = 0; y < this.rows + 1; y++) {\r\n      const left = this.tileToWorld(vec(0, y));\r\n      const right = this.tileToWorld(vec(this.columns, y));\r\n      gfx.drawLine(left, right, Color.Red, 2);\r\n    }\r\n\r\n    for (let x = 0; x < this.columns + 1; x++) {\r\n      const top = this.tileToWorld(vec(x, 0));\r\n      const bottom = this.tileToWorld(vec(x, this.rows));\r\n      gfx.drawLine(top, bottom, Color.Red, 2);\r\n    }\r\n\r\n    for (const tile of this.tiles) {\r\n      gfx.drawCircle(this.tileToWorld(vec(tile.x, tile.y)), 3, Color.Yellow);\r\n    }\r\n    gfx.restore();\r\n  }\r\n}","import { CollisionGroup } from './CollisionGroup';\r\n\r\n/**\r\n * Static class for managing collision groups in excalibur, there is a maximum of 32 collision groups possible in excalibur\r\n */\r\nexport class CollisionGroupManager {\r\n  // using bitmasking the maximum number of groups is 32, because that is the highest 32bit integer that JS can present.\r\n  private static _STARTING_BIT = 0b1 | 0;\r\n  private static _MAX_GROUPS = 32;\r\n  private static _CURRENT_GROUP = 1;\r\n  private static _CURRENT_BIT = CollisionGroupManager._STARTING_BIT;\r\n  private static _GROUPS: Map<string, CollisionGroup> = new Map<string, CollisionGroup>();\r\n\r\n  /**\r\n   * Create a new named collision group up to a max of 32.\r\n   * @param name Name for the collision group\r\n   * @param mask Optionally provide your own 32-bit mask, if none is provide the manager will generate one\r\n   */\r\n  public static create(name: string, mask?: number) {\r\n    if (this._CURRENT_GROUP > this._MAX_GROUPS) {\r\n      throw new Error(`Cannot have more than ${this._MAX_GROUPS} collision groups`);\r\n    }\r\n    if (this._GROUPS.get(name)) {\r\n      throw new Error(`Collision group ${name} already exists`);\r\n    }\r\n    const group = new CollisionGroup(name, this._CURRENT_BIT, mask !== undefined ? mask : ~this._CURRENT_BIT);\r\n    this._CURRENT_BIT = (this._CURRENT_BIT << 1) | 0;\r\n    this._CURRENT_GROUP++;\r\n    this._GROUPS.set(name, group);\r\n    return group;\r\n  }\r\n\r\n  /**\r\n   * Get all collision groups currently tracked by excalibur\r\n   */\r\n  public static get groups(): CollisionGroup[] {\r\n    return Array.from(this._GROUPS.values());\r\n  }\r\n\r\n  /**\r\n   * Get a collision group by it's name\r\n   * @param name\r\n   */\r\n  public static groupByName(name: string) {\r\n    return this._GROUPS.get(name);\r\n  }\r\n\r\n  /**\r\n   * Resets the managers internal group management state\r\n   */\r\n  public static reset() {\r\n    this._GROUPS = new Map<string, CollisionGroup>();\r\n    this._CURRENT_BIT = this._STARTING_BIT;\r\n    this._CURRENT_GROUP = 1;\r\n  }\r\n}\r\n","import { Audio } from './Audio';\r\n\r\nexport type ExResponseType = '' | 'arraybuffer' | 'blob' | 'document' | 'json' | 'text';\r\n\r\nexport interface ExResponseTypesLookup {\r\n  [name: string]: ExResponseType;\r\n}\r\n\r\nexport class ExResponse {\r\n  public static type: ExResponseTypesLookup = {\r\n    any: '',\r\n    blob: 'blob',\r\n    json: 'json',\r\n    text: 'text',\r\n    document: 'document',\r\n    arraybuffer: 'arraybuffer'\r\n  };\r\n}\r\n\r\n/**\r\n * Represents an audio implementation like [[WebAudioInstance]]\r\n */\r\nexport interface AudioImplementation {\r\n  /**\r\n   * XHR response type\r\n   */\r\n  responseType: ExResponseType;\r\n\r\n  /**\r\n   * Processes raw data and transforms into sound data\r\n   */\r\n  processData(data: Blob | ArrayBuffer): Promise<string | AudioBuffer>;\r\n\r\n  /**\r\n   * Factory method that returns an instance of a played audio track\r\n   */\r\n  createInstance(data: string | AudioBuffer): Audio;\r\n}\r\n","import { Engine } from './../Engine';\r\nimport * as Events from './../Events';\r\nimport { Scene } from '../Scene';\r\nimport { ExcaliburGraphicsContext } from '../Graphics';\r\n\r\n// eslint-disable-next-line @typescript-eslint/naming-convention\r\nexport interface _initialize {\r\n  _initialize(engine: Engine): void;\r\n}\r\n\r\n/**\r\n * Type guard checking for internal initialize method\r\n * @internal\r\n * @param a\r\n */\r\nexport function has_initialize(a: any): a is _initialize {\r\n  return !!a._initialize;\r\n}\r\n\r\nexport interface OnInitialize {\r\n  onInitialize(engine: Engine): void;\r\n}\r\n\r\n/**\r\n *\r\n */\r\nexport function hasOnInitialize(a: any): a is OnInitialize {\r\n  return !!a.onInitialize;\r\n}\r\n\r\n// eslint-disable-next-line @typescript-eslint/naming-convention\r\nexport interface _preupdate {\r\n  _preupdate(engine: Engine, delta: number): void;\r\n}\r\n\r\n/**\r\n *\r\n */\r\nexport function has_preupdate(a: any): a is _preupdate {\r\n  return !!a._preupdate;\r\n}\r\n\r\nexport interface OnPreUpdate {\r\n  onPreUpdate(engine: Engine, delta: number): void;\r\n}\r\n\r\n/**\r\n *\r\n */\r\nexport function hasOnPreUpdate(a: any): a is OnPreUpdate {\r\n  return !!a.onPreUpdate;\r\n}\r\n\r\n// eslint-disable-next-line @typescript-eslint/naming-convention\r\nexport interface _postupdate {\r\n  _postupdate(engine: Engine, delta: number): void;\r\n}\r\n\r\n/**\r\n *\r\n */\r\nexport function has_postupdate(a: any): a is _postupdate {\r\n  return !!a.onPostUpdate;\r\n}\r\n\r\nexport interface OnPostUpdate {\r\n  onPostUpdate(engine: Engine, delta: number): void;\r\n}\r\n\r\n/**\r\n *\r\n */\r\nexport function hasOnPostUpdate(a: any): a is OnPostUpdate {\r\n  return !!a.onPostUpdate;\r\n}\r\n\r\nexport interface CanInitialize {\r\n  /**\r\n   * Overridable implementation\r\n   */\r\n  onInitialize(_engine: Engine): void;\r\n\r\n  /**\r\n   * Event signatures\r\n   */\r\n  on(eventName: Events.initialize, handler: (event: Events.InitializeEvent<any>) => void): void;\r\n  once(eventName: Events.initialize, handler: (event: Events.InitializeEvent<any>) => void): void;\r\n  off(eventName: Events.initialize, handler?: (event: Events.InitializeEvent<any>) => void): void;\r\n}\r\n\r\nexport interface CanActivate {\r\n  /**\r\n   * Overridable implementation\r\n   */\r\n  onActivate(oldScene: Scene, newScene: Scene): void;\r\n\r\n  /**\r\n   * Event signatures\r\n   */\r\n  on(eventName: Events.activate, handler: (event: Events.ActivateEvent) => void): void;\r\n  once(eventName: Events.activate, handler: (event: Events.ActivateEvent) => void): void;\r\n  off(eventName: Events.activate, handler?: (event: Events.ActivateEvent) => void): void;\r\n}\r\n\r\nexport interface CanDeactivate {\r\n  /**\r\n   * Overridable implementation\r\n   */\r\n  onDeactivate(oldScene: Scene, newScene: Scene): void;\r\n\r\n  /**\r\n   * Event signature\r\n   */\r\n  on(eventName: Events.deactivate, handler: (event: Events.DeactivateEvent) => void): void;\r\n  once(eventName: Events.deactivate, handler: (event: Events.DeactivateEvent) => void): void;\r\n  off(eventName: Events.deactivate, handler?: (event: Events.DeactivateEvent) => void): void;\r\n}\r\n\r\nexport interface CanUpdate {\r\n  /**\r\n   * Overridable implementation\r\n   */\r\n  onPreUpdate(_engine: Engine, _delta: number): void;\r\n\r\n  /**\r\n   * Event signature\r\n   */\r\n  on(eventName: Events.preupdate, handler: (event: Events.PreUpdateEvent<any>) => void): void;\r\n  once(eventName: Events.preupdate, handler: (event: Events.PreUpdateEvent<any>) => void): void;\r\n  off(eventName: Events.preupdate, handler?: (event: Events.PreUpdateEvent<any>) => void): void;\r\n\r\n  /**\r\n   * Overridable implementation\r\n   */\r\n  onPostUpdate(_engine: Engine, _delta: number): void;\r\n\r\n  /**\r\n   * Event signatures\r\n   */\r\n  on(eventName: Events.postupdate, handler: (event: Events.PostUpdateEvent<any>) => void): void;\r\n  once(eventName: Events.postupdate, handler: (event: Events.PostUpdateEvent<any>) => void): void;\r\n  off(eventName: Events.postupdate, handler?: (event: Events.PostUpdateEvent<any>) => void): void;\r\n}\r\n\r\nexport interface OnPreDraw {\r\n  /**\r\n   * Overridable implementation\r\n   */\r\n  onPreDraw(_ctx: ExcaliburGraphicsContext, _delta: number): void;\r\n\r\n  /**\r\n   * Event signatures\r\n   */\r\n  on(eventName: Events.predraw, handler: (event: Events.PreDrawEvent) => void): void;\r\n  once(eventName: Events.predraw, handler: (event: Events.PreDrawEvent) => void): void;\r\n  off(eventName: Events.predraw, handler?: (event: Events.PreDrawEvent) => void): void;\r\n}\r\n\r\nexport interface OnPostDraw {\r\n  /**\r\n   * Overridable implementation\r\n   */\r\n  onPostDraw(_ctx: ExcaliburGraphicsContext, _delta: number): void;\r\n\r\n  /**\r\n   * Event signatures\r\n   */\r\n  on(eventName: Events.postdraw, handler: (event: Events.PostDrawEvent) => void): void;\r\n  once(eventName: Events.postdraw, handler: (event: Events.PostDrawEvent) => void): void;\r\n  off(eventName: Events.postdraw, handler?: (event: Events.PostDrawEvent) => void): void;\r\n}\r\n\r\nexport interface CanDraw extends OnPreDraw, OnPostDraw {\r\n  on(eventName: Events.predraw, handler: (event: Events.PreDrawEvent) => void): void;\r\n  on(eventName: Events.postdraw, handler: (event: Events.PostDrawEvent) => void): void;\r\n\r\n  once(eventName: Events.predraw, handler: (event: Events.PreDrawEvent) => void): void;\r\n  once(eventName: Events.postdraw, handler: (event: Events.PostDrawEvent) => void): void;\r\n\r\n  off(eventName: Events.predraw, handler?: (event: Events.PreDrawEvent) => void): void;\r\n  off(eventName: Events.postdraw, handler?: (event: Events.PostDrawEvent) => void): void;\r\n}\r\n\r\n/**\r\n *\r\n */\r\nexport function hasPreDraw(a: any): a is OnPreDraw {\r\n  return !!a.onPreDraw;\r\n}\r\n\r\n/**\r\n *\r\n */\r\nexport function hasPostDraw(a: any): a is OnPostDraw {\r\n  return !!a.onPostDraw;\r\n}\r\n\r\nexport interface CanBeKilled {\r\n  /**\r\n   * Overridable implementation\r\n   */\r\n  onPreKill(_scene: Scene): void;\r\n\r\n  /**\r\n   * Event signatures\r\n   */\r\n  on(eventName: Events.prekill, handler: (event: Events.PreKillEvent) => void): void;\r\n  once(eventName: Events.prekill, handler: (event: Events.PreKillEvent) => void): void;\r\n  off(eventName: Events.prekill, handler: (event: Events.PreKillEvent) => void): void;\r\n\r\n  /**\r\n   * Overridable implementation\r\n   */\r\n  onPostKill(_scene: Scene): void;\r\n\r\n  /**\r\n   * Event signatures\r\n   */\r\n  on(eventName: Events.postkill, handler: (event: Events.PostKillEvent) => void): void;\r\n  once(eventName: Events.postkill, handler: (event: Events.PostKillEvent) => void): void;\r\n  off(eventName: Events.postkill, handler: (event: Events.PostKillEvent) => void): void;\r\n}\r\n","import { Audio } from '../../Interfaces/Audio';\r\nimport { clamp } from '../../Math/util';\r\nimport { AudioContextFactory } from './AudioContext';\r\n\r\n/**\r\n * Internal class representing a Web Audio AudioBufferSourceNode instance\r\n * @see https://developer.mozilla.org/en-US/docs/Web/API/Web_Audio_API\r\n */\r\nexport class WebAudioInstance implements Audio {\r\n  private _volume = 1;\r\n  private _duration: number | undefined = undefined;\r\n\r\n  private _playingPromise: Promise<boolean>;\r\n  private _playingResolve: (value: boolean) => void;\r\n\r\n  private _loop = false;\r\n  public set loop(value: boolean) {\r\n    this._loop = value;\r\n\r\n    if (this._instance) {\r\n      this._instance.loop = value;\r\n      this._wireUpOnEnded();\r\n    }\r\n  }\r\n  public get loop(): boolean {\r\n    return this._loop;\r\n  }\r\n\r\n  public set volume(value: number) {\r\n    value = clamp(value, 0, 1.0);\r\n\r\n    this._volume = value;\r\n\r\n    if (this._isPlaying && this._volumeNode.gain.setTargetAtTime) {\r\n      // https://developer.mozilla.org/en-US/docs/Web/API/AudioParam/setTargetAtTime\r\n      // After each .1 seconds timestep, the target value will ~63.2% closer to the target value.\r\n      // This exponential ramp provides a more pleasant transition in gain\r\n      this._volumeNode.gain.setTargetAtTime(value, this._audioContext.currentTime, 0.1);\r\n    } else {\r\n      this._volumeNode.gain.value = value;\r\n    }\r\n  }\r\n  public get volume(): number {\r\n    return this._volume;\r\n  }\r\n\r\n  public set duration(value: number | undefined) {\r\n    this._duration = value;\r\n  }\r\n\r\n  /**\r\n   * Duration of the sound, in seconds.\r\n   */\r\n  public get duration() {\r\n    return this._duration;\r\n  }\r\n\r\n  private get _playbackRate(): number {\r\n    return this._instance ? 1 / (this._instance.playbackRate.value || 1.0) : null;\r\n  }\r\n\r\n  private _isPlaying = false;\r\n  private _isPaused = false;\r\n  private _instance: AudioBufferSourceNode;\r\n  private _audioContext: AudioContext = AudioContextFactory.create();\r\n  private _volumeNode = this._audioContext.createGain();\r\n  private _startTime: number;\r\n\r\n  /**\r\n   * Current playback offset (in seconds)\r\n   */\r\n  private _currentOffset = 0;\r\n\r\n  constructor(private _src: AudioBuffer) {\r\n    this._createNewBufferSource();\r\n  }\r\n\r\n  public isPlaying() {\r\n    return this._isPlaying;\r\n  }\r\n\r\n  // eslint-disable-next-line @typescript-eslint/no-empty-function\r\n  public play(playStarted: () => any = () => {}) {\r\n    if (this._isPaused) {\r\n      this._resumePlayBack();\r\n      playStarted();\r\n    }\r\n\r\n    if (!this._isPlaying) {\r\n      this._startPlayBack();\r\n      playStarted();\r\n    }\r\n\r\n    return this._playingPromise;\r\n  }\r\n\r\n  public pause() {\r\n    if (!this._isPlaying) {\r\n      return;\r\n    }\r\n\r\n    this._isPaused = true;\r\n    this._isPlaying = false;\r\n\r\n    this._instance.stop(0);\r\n    // Playback rate will be a scale factor of how fast/slow the audio is being played\r\n    // default is 1.0\r\n    // we need to invert it to get the time scale\r\n\r\n    this._setPauseOffset();\r\n  }\r\n\r\n  public stop() {\r\n    if (!this._isPlaying) {\r\n      return;\r\n    }\r\n\r\n    this._isPlaying = false;\r\n    this._isPaused = false;\r\n\r\n    this._currentOffset = 0;\r\n    this._instance.stop(0);\r\n\r\n    // handler will not be wired up if we were looping\r\n    if (!this._instance.onended) {\r\n      this._handleOnEnded();\r\n    }\r\n  }\r\n\r\n  private _startPlayBack() {\r\n    this._isPlaying = true;\r\n    this._isPaused = false;\r\n    this._playingPromise = new Promise<boolean>((resolve) => {\r\n      this._playingResolve = resolve;\r\n    });\r\n\r\n    if (!this._instance) {\r\n      this._createNewBufferSource();\r\n    }\r\n\r\n    this._rememberStartTime();\r\n\r\n    this._volumeNode.connect(this._audioContext.destination);\r\n    this._instance.start(0, 0);\r\n    this._currentOffset = 0;\r\n\r\n    this._wireUpOnEnded();\r\n  }\r\n\r\n  private _resumePlayBack() {\r\n    if (!this._isPaused) {\r\n      return;\r\n    }\r\n\r\n    this._isPaused = false;\r\n    this._isPlaying = true;\r\n\r\n    // a buffer source can only be started once\r\n    // so we need to dispose of the previous instance before\r\n    // \"resuming\" the next one\r\n    this._instance.onended = null; // dispose of any previous event handler\r\n    this._createNewBufferSource();\r\n\r\n    const duration = this._playbackRate * this._src.duration;\r\n    const restartTime = this._currentOffset % duration;\r\n\r\n    this._rememberStartTime(restartTime * -1000);\r\n    this._instance.start(0, restartTime);\r\n    this._wireUpOnEnded();\r\n  }\r\n\r\n  private _wireUpOnEnded() {\r\n    if (!this.loop) {\r\n      this._instance.onended = () => this._handleOnEnded();\r\n    }\r\n  }\r\n\r\n  private _handleOnEnded() {\r\n    // pausing calls stop(0) which triggers onended event\r\n    // so we don't \"resolve\" yet (when we resume we'll try again)\r\n    if (!this._isPaused) {\r\n      this._isPlaying = false;\r\n      this._playingResolve(true);\r\n    }\r\n  }\r\n\r\n  private _rememberStartTime(amend?: number) {\r\n    this._startTime = new Date().getTime() + (amend | 0);\r\n  }\r\n\r\n  private _setPauseOffset() {\r\n    this._currentOffset = ((new Date().getTime() - this._startTime) * this._playbackRate) / 1000; // in seconds\r\n  }\r\n\r\n  private _createNewBufferSource() {\r\n    this._instance = this._audioContext.createBufferSource();\r\n    this._instance.buffer = this._src;\r\n    this._instance.loop = this.loop;\r\n    this._instance.playbackRate.setValueAtTime(1.0, 0);\r\n\r\n    this._instance.connect(this._volumeNode);\r\n  }\r\n}\r\n","import { Logger } from './Log';\r\n\r\n/**\r\n * Whether or not the browser can play this file as HTML5 Audio\r\n */\r\nexport function canPlayFile(file: string): boolean {\r\n  try {\r\n    const a = new Audio();\r\n    const filetype = /.*\\.([A-Za-z0-9]+)$/;\r\n    const type = file.match(filetype)[1];\r\n    if (a.canPlayType('audio/' + type)) {\r\n      return true;\r\n    } else {\r\n      return false;\r\n    }\r\n  } catch (e) {\r\n    Logger.getInstance().warn('Cannot determine audio support, assuming no support for the Audio Tag', e);\r\n    return false;\r\n  }\r\n}\r\n","import { ExResponse } from '../../Interfaces/AudioImplementation';\r\nimport { Audio } from '../../Interfaces/Audio';\r\nimport { Engine } from '../../Engine';\r\nimport { Resource } from '../Resource';\r\nimport { WebAudioInstance } from './WebAudioInstance';\r\nimport { AudioContextFactory } from './AudioContext';\r\nimport { NativeSoundEvent, NativeSoundProcessedEvent } from '../../Events/MediaEvents';\r\nimport { canPlayFile } from '../../Util/Sound';\r\nimport { Loadable } from '../../Interfaces/Index';\r\nimport { Logger } from '../../Util/Log';\r\nimport { Class } from '../../Class';\r\n\r\n/**\r\n * The [[Sound]] object allows games built in Excalibur to load audio\r\n * components, from soundtracks to sound effects. [[Sound]] is an [[Loadable]]\r\n * which means it can be passed to a [[Loader]] to pre-load before a game or level.\r\n */\r\nexport class Sound extends Class implements Audio, Loadable<AudioBuffer> {\r\n  public logger: Logger = Logger.getInstance();\r\n  public data: AudioBuffer;\r\n  private _resource: Resource<ArrayBuffer>;\r\n  /**\r\n   * Indicates whether the clip should loop when complete\r\n   * @param value  Set the looping flag\r\n   */\r\n  public set loop(value: boolean) {\r\n    this._loop = value;\r\n\r\n    for (const track of this._tracks) {\r\n      track.loop = this._loop;\r\n    }\r\n\r\n    this.logger.debug('Set loop for all instances of sound', this.path, 'to', this._loop);\r\n  }\r\n  public get loop(): boolean {\r\n    return this._loop;\r\n  }\r\n\r\n  public set volume(value: number) {\r\n    this._volume = value;\r\n\r\n    for (const track of this._tracks) {\r\n      track.volume = this._volume;\r\n    }\r\n\r\n    this.emit('volumechange', new NativeSoundEvent(this));\r\n\r\n    this.logger.debug('Set loop for all instances of sound', this.path, 'to', this._volume);\r\n  }\r\n  public get volume(): number {\r\n    return this._volume;\r\n  }\r\n\r\n  public get duration(): number | undefined {\r\n    return this._duration;\r\n  }\r\n\r\n  /**\r\n   * Return array of Current AudioInstances playing or being paused\r\n   */\r\n  public get instances(): Audio[] {\r\n    return this._tracks;\r\n  }\r\n\r\n  public get path() {\r\n    return this._resource.path;\r\n  }\r\n\r\n  public set path(val: string) {\r\n    this._resource.path = val;\r\n  }\r\n\r\n  private _loop = false;\r\n  private _volume = 1;\r\n  private _duration: number | undefined = undefined;\r\n  private _isStopped = false;\r\n  private _isPaused = false;\r\n  private _tracks: Audio[] = [];\r\n  private _engine: Engine;\r\n  private _wasPlayingOnHidden: boolean = false;\r\n  private _audioContext = AudioContextFactory.create();\r\n\r\n  /**\r\n   * @param paths A list of audio sources (clip.wav, clip.mp3, clip.ogg) for this audio clip. This is done for browser compatibility.\r\n   */\r\n  constructor(...paths: string[]) {\r\n    super();\r\n    this._resource = new Resource('', ExResponse.type.arraybuffer);\r\n    /**\r\n     * Chrome : MP3, WAV, Ogg\r\n     * Firefox : WAV, Ogg,\r\n     * IE : MP3, WAV coming soon\r\n     * Safari MP3, WAV, Ogg\r\n     */\r\n    for (const path of paths) {\r\n      if (canPlayFile(path)) {\r\n        this.path = path;\r\n        break;\r\n      }\r\n    }\r\n\r\n    if (!this.path) {\r\n      this.logger.warn('This browser does not support any of the audio files specified:', paths.join(', '));\r\n      this.logger.warn('Attempting to use', paths[0]);\r\n      this.path = paths[0]; // select the first specified\r\n    }\r\n  }\r\n\r\n  public isLoaded() {\r\n    return !!this.data;\r\n  }\r\n\r\n  public async load(): Promise<AudioBuffer> {\r\n    if (this.data) {\r\n      return this.data;\r\n    }\r\n    const arraybuffer = await this._resource.load();\r\n    const audiobuffer = await this.decodeAudio(arraybuffer.slice(0));\r\n    this._duration = typeof audiobuffer === 'object' ? audiobuffer.duration : undefined;\r\n    this.emit('processed', new NativeSoundProcessedEvent(this, audiobuffer));\r\n    return this.data = audiobuffer;\r\n  }\r\n\r\n  public async decodeAudio(data: ArrayBuffer): Promise<AudioBuffer> {\r\n    try {\r\n      return await this._audioContext.decodeAudioData(data.slice(0));\r\n    } catch (e) {\r\n      this.logger.error(\r\n        'Unable to decode ' +\r\n          ' this browser may not fully support this format, or the file may be corrupt, ' +\r\n          'if this is an mp3 try removing id3 tags and album art from the file.'\r\n      );\r\n      return await Promise.reject();\r\n    }\r\n  }\r\n\r\n  public wireEngine(engine: Engine) {\r\n    if (engine) {\r\n      this._engine = engine;\r\n\r\n      this._engine.on('hidden', () => {\r\n        if (engine.pauseAudioWhenHidden && this.isPlaying()) {\r\n          this._wasPlayingOnHidden = true;\r\n          this.pause();\r\n        }\r\n      });\r\n\r\n      this._engine.on('visible', () => {\r\n        if (engine.pauseAudioWhenHidden && this._wasPlayingOnHidden) {\r\n          this.play();\r\n          this._wasPlayingOnHidden = false;\r\n        }\r\n      });\r\n\r\n      this._engine.on('start', () => {\r\n        this._isStopped = false;\r\n      });\r\n\r\n      this._engine.on('stop', () => {\r\n        this.stop();\r\n        this._isStopped = true;\r\n      });\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Returns how many instances of the sound are currently playing\r\n   */\r\n  public instanceCount(): number {\r\n    return this._tracks.length;\r\n  }\r\n\r\n  /**\r\n   * Whether or not the sound is playing right now\r\n   */\r\n  public isPlaying(): boolean {\r\n    return this._tracks.some((t) => t.isPlaying());\r\n  }\r\n\r\n  /**\r\n   * Play the sound, returns a promise that resolves when the sound is done playing\r\n   * An optional volume argument can be passed in to play the sound. Max volume is 1.0\r\n   */\r\n  public play(volume?: number): Promise<boolean> {\r\n    if (!this.isLoaded()) {\r\n      this.logger.warn('Cannot start playing. Resource', this.path, 'is not loaded yet');\r\n\r\n      return Promise.resolve(true);\r\n    }\r\n\r\n    if (this._isStopped) {\r\n      this.logger.warn('Cannot start playing. Engine is in a stopped state.');\r\n      return Promise.resolve(false);\r\n    }\r\n\r\n    this.volume = volume || this.volume;\r\n\r\n    if (this._isPaused) {\r\n      return this._resumePlayback();\r\n    } else {\r\n      return this._startPlayback();\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Stop the sound, and do not rewind\r\n   */\r\n  public pause() {\r\n    if (!this.isPlaying()) {\r\n      return;\r\n    }\r\n\r\n    for (const track of this._tracks) {\r\n      track.pause();\r\n    }\r\n\r\n    this._isPaused = true;\r\n\r\n    this.emit('pause', new NativeSoundEvent(this));\r\n\r\n    this.logger.debug('Paused all instances of sound', this.path);\r\n  }\r\n\r\n  /**\r\n   * Stop the sound if it is currently playing and rewind the track. If the sound is not playing, rewinds the track.\r\n   */\r\n  public stop() {\r\n    for (const track of this._tracks) {\r\n      track.stop();\r\n    }\r\n\r\n    this.emit('stop', new NativeSoundEvent(this));\r\n\r\n    this._isPaused = false;\r\n    this._tracks.length = 0;\r\n    this.logger.debug('Stopped all instances of sound', this.path);\r\n  }\r\n\r\n\r\n\r\n  /**\r\n   * Get Id of provided AudioInstance in current trackList\r\n   * @param track [[Audio]] which Id is to be given\r\n   */\r\n  public getTrackId(track: Audio): number {\r\n    return this._tracks.indexOf(track);\r\n  }\r\n\r\n  private async _resumePlayback(): Promise<boolean> {\r\n    if (this._isPaused) {\r\n      const resumed: Promise<boolean>[] = [];\r\n      // ensure we resume *current* tracks (if paused)\r\n      for (const track of this._tracks) {\r\n        resumed.push(track.play());\r\n      }\r\n\r\n      this._isPaused = false;\r\n\r\n      this.emit('resume', new NativeSoundEvent(this));\r\n\r\n      this.logger.debug('Resuming paused instances for sound', this.path, this._tracks);\r\n      // resolve when resumed tracks are done\r\n      await Promise.all(resumed);\r\n    }\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * Starts playback, returns a promise that resolves when playback is complete\r\n   */\r\n  private async _startPlayback(): Promise<boolean> {\r\n    const track = await this._getTrackInstance(this.data);\r\n\r\n    const complete = await track.play(() => {\r\n      this.emit('playbackstart', new NativeSoundEvent(this, track));\r\n      this.logger.debug('Playing new instance for sound', this.path);\r\n    });\r\n\r\n    // when done, remove track\r\n    this.emit('playbackend', new NativeSoundEvent(this, track));\r\n    this._tracks.splice(this.getTrackId(track), 1);\r\n\r\n    return complete;\r\n  }\r\n\r\n  private _getTrackInstance(data: AudioBuffer): WebAudioInstance {\r\n    const newTrack = new WebAudioInstance(data);\r\n\r\n    newTrack.loop = this.loop;\r\n    newTrack.volume = this.volume;\r\n    newTrack.duration = this.duration;\r\n\r\n    this._tracks.push(newTrack);\r\n\r\n    return newTrack;\r\n  }\r\n}\r\n","import { Resource } from './Resource';\r\nimport { Sprite } from '../Graphics/Sprite';\r\nimport { Color } from '../Color';\r\nimport { SpriteSheet } from '../Graphics/SpriteSheet';\r\nimport { Animation } from '../Graphics/Animation';\r\nimport { Loadable } from '../Interfaces/Index';\r\nimport { ImageSource } from '../Graphics/ImageSource';\r\nimport { range } from '../Math/util';\r\n/**\r\n * The [[Texture]] object allows games built in Excalibur to load image resources.\r\n * [[Texture]] is an [[Loadable]] which means it can be passed to a [[Loader]]\r\n * to pre-load before starting a level or game.\r\n */\r\nexport class Gif implements Loadable<ImageSource[]> {\r\n  private _resource: Resource<ArrayBuffer>;\r\n\r\n  /**\r\n   * The width of the texture in pixels\r\n   */\r\n  public width: number;\r\n\r\n  /**\r\n   * The height of the texture in pixels\r\n   */\r\n  public height: number;\r\n\r\n\r\n  private _stream: Stream = null;\r\n  private _gif: ParseGif = null;\r\n  private _textures: ImageSource[] = [];\r\n  private _animation: Animation = null;\r\n  private _transparentColor: Color = null;\r\n\r\n  public data: ImageSource[];\r\n\r\n  /**\r\n   * @param path       Path to the image resource\r\n   * @param color      Optionally set the color to treat as transparent the gif, by default [[Color.Magenta]]\r\n   * @param bustCache  Optionally load texture with cache busting\r\n   */\r\n  constructor(public path: string, public color: Color = Color.Magenta, public bustCache = true) {\r\n    this._resource = new Resource(path, 'arraybuffer', bustCache);\r\n    this._transparentColor = color;\r\n  }\r\n\r\n  /**\r\n   * Begins loading the texture and returns a promise to be resolved on completion\r\n   */\r\n  public async load(): Promise<ImageSource[]> {\r\n    const arraybuffer = await this._resource.load();\r\n    this._stream = new Stream(arraybuffer);\r\n    this._gif = new ParseGif(this._stream, this._transparentColor);\r\n    const images = this._gif.images.map(i => new ImageSource(i.src, false));\r\n\r\n    // Load all textures\r\n    await Promise.all(images.map(t => t.load()));\r\n    return this.data = this._textures = images;\r\n  }\r\n\r\n  public isLoaded() {\r\n    return !!this.data;\r\n  }\r\n\r\n  /**\r\n   * Return a frame of the gif as a sprite by id\r\n   * @param id\r\n   */\r\n  public toSprite(id: number = 0): Sprite {\r\n    const sprite = this._textures[id].toSprite();\r\n    return sprite;\r\n  }\r\n\r\n  /**\r\n   * Return the gif as a spritesheet\r\n   */\r\n  public toSpriteSheet(): SpriteSheet {\r\n    const sprites: Sprite[] = this._textures.map((image) => {\r\n      return image.toSprite();\r\n    });\r\n    return new SpriteSheet({ sprites });\r\n  }\r\n\r\n  /**\r\n   * Transform the GIF into an animation with duration per frame\r\n   */\r\n  public toAnimation(durationPerFrameMs: number): Animation {\r\n    const spriteSheet: SpriteSheet = this.toSpriteSheet();\r\n    const length = spriteSheet.sprites.length;\r\n    this._animation = Animation.fromSpriteSheet(spriteSheet, range(0, length), durationPerFrameMs);\r\n    return this._animation;\r\n  }\r\n\r\n  public get readCheckBytes(): number[] {\r\n    return this._gif.checkBytes;\r\n  }\r\n}\r\n\r\nexport interface GifFrame {\r\n  sentinel: number;\r\n  type: string;\r\n  leftPos: number;\r\n  topPos: number;\r\n  width: number;\r\n  height: number;\r\n  lctFlag: boolean;\r\n  interlaced: boolean;\r\n  sorted: boolean;\r\n  reserved: boolean[];\r\n  lctSize: number;\r\n  lzwMinCodeSize: number;\r\n  pixels: number[];\r\n}\r\n\r\nconst bitsToNum = (ba: any) => {\r\n  return ba.reduce(function (s: number, n: number) {\r\n    return s * 2 + n;\r\n  }, 0);\r\n};\r\n\r\nconst byteToBitArr = (bite: any) => {\r\n  const a = [];\r\n  for (let i = 7; i >= 0; i--) {\r\n    a.push(!!(bite & (1 << i)));\r\n  }\r\n  return a;\r\n};\r\n\r\nexport class Stream {\r\n  data: any = null;\r\n  len: number = 0;\r\n  position: number = 0;\r\n\r\n  constructor(dataArray: ArrayBuffer) {\r\n    this.data = new Uint8Array(dataArray);\r\n    this.len = this.data.byteLength;\r\n    if (this.len === 0) {\r\n      throw new Error('No data loaded from file');\r\n    }\r\n  }\r\n\r\n  public readByte = () => {\r\n    if (this.position >= this.data.byteLength) {\r\n      throw new Error('Attempted to read past end of stream.');\r\n    }\r\n    return this.data[this.position++];\r\n  };\r\n\r\n  public readBytes = (n: number) => {\r\n    const bytes = [];\r\n    for (let i = 0; i < n; i++) {\r\n      bytes.push(this.readByte());\r\n    }\r\n    return bytes;\r\n  };\r\n\r\n  public read = (n: number) => {\r\n    let s = '';\r\n    for (let i = 0; i < n; i++) {\r\n      s += String.fromCharCode(this.readByte());\r\n    }\r\n    return s;\r\n  };\r\n\r\n  public readUnsigned = () => {\r\n    // Little-endian.\r\n    const a = this.readBytes(2);\r\n    return (a[1] << 8) + a[0];\r\n  };\r\n}\r\n\r\nconst lzwDecode = function (minCodeSize: number, data: any) {\r\n  // TODO: Now that the GIF parser is a bit different, maybe this should get an array of bytes instead of a String?\r\n  let pos = 0; // Maybe this streaming thing should be merged with the Stream?\r\n\r\n  const readCode = function (size: number) {\r\n    let code = 0;\r\n    for (let i = 0; i < size; i++) {\r\n      if (data.charCodeAt(pos >> 3) & (1 << (pos & 7))) {\r\n        code |= 1 << i;\r\n      }\r\n      pos++;\r\n    }\r\n    return code;\r\n  };\r\n\r\n  const output: any[] = [];\r\n\r\n  const clearCode = 1 << minCodeSize;\r\n  const eoiCode = clearCode + 1;\r\n\r\n  let codeSize = minCodeSize + 1;\r\n\r\n  let dict: any[] = [];\r\n\r\n  const clear = function () {\r\n    dict = [];\r\n    codeSize = minCodeSize + 1;\r\n    for (let i = 0; i < clearCode; i++) {\r\n      dict[i] = [i];\r\n    }\r\n    dict[clearCode] = [];\r\n    dict[eoiCode] = null;\r\n  };\r\n\r\n  let code;\r\n  let last;\r\n\r\n  while (true) {\r\n    last = code;\r\n    code = readCode(codeSize);\r\n    if (code === clearCode) {\r\n      clear();\r\n      continue;\r\n    }\r\n    if (code === eoiCode) {\r\n      break;\r\n    }\r\n\r\n    if (code < dict.length) {\r\n      if (last !== clearCode) {\r\n        dict.push(dict[last].concat(dict[code][0]));\r\n      }\r\n    } else {\r\n      if (code !== dict.length) {\r\n        throw new Error('Invalid LZW code.');\r\n      }\r\n      dict.push(dict[last].concat(dict[last][0]));\r\n    }\r\n    output.push.apply(output, dict[code]);\r\n\r\n    if (dict.length === 1 << codeSize && codeSize < 12) {\r\n      // If we're at the last code and codeSize is 12, the next code will be a clearCode, and it'll be 12 bits long.\r\n      codeSize++;\r\n    }\r\n  }\r\n\r\n  // I don't know if this is technically an error, but some GIFs do it.\r\n  //if (Math.ceil(pos / 8) !== data.length) throw new Error('Extraneous LZW bytes.');\r\n  return output;\r\n};\r\n\r\n// The actual parsing; returns an object with properties.\r\nexport class ParseGif {\r\n  private _st: Stream = null;\r\n  private _handler: any = {};\r\n  private _transparentColor: Color = null;\r\n  public frames: GifFrame[] = [];\r\n  public images: HTMLImageElement[] = [];\r\n  public globalColorTable: any[] = [];\r\n  public checkBytes: number[] = [];\r\n\r\n  constructor(stream: Stream, color: Color = Color.Magenta) {\r\n    this._st = stream;\r\n    this._handler = {};\r\n    this._transparentColor = color;\r\n    this.parseHeader();\r\n    this.parseBlock();\r\n  }\r\n\r\n  // LZW (GIF-specific)\r\n  parseColorTable = (entries: any) => {\r\n    // Each entry is 3 bytes, for RGB.\r\n    const ct = [];\r\n    for (let i = 0; i < entries; i++) {\r\n      const rgb: number[] = this._st.readBytes(3);\r\n      const rgba =\r\n        '#' +\r\n        rgb\r\n          .map((x: any) => {\r\n            const hex = x.toString(16);\r\n            return hex.length === 1 ? '0' + hex : hex;\r\n          })\r\n          .join('');\r\n      ct.push(rgba);\r\n    }\r\n    return ct;\r\n  };\r\n\r\n  readSubBlocks = () => {\r\n    let size, data;\r\n    data = '';\r\n    do {\r\n      size = this._st.readByte();\r\n      data += this._st.read(size);\r\n    } while (size !== 0);\r\n    return data;\r\n  };\r\n\r\n  parseHeader = () => {\r\n    const hdr: any = {\r\n      sig: null,\r\n      ver: null,\r\n      width: null,\r\n      height: null,\r\n      colorRes: null,\r\n      globalColorTableSize: null,\r\n      gctFlag: null,\r\n      sorted: null,\r\n      globalColorTable: [],\r\n      bgColor: null,\r\n      pixelAspectRatio: null // if not 0, aspectRatio = (pixelAspectRatio + 15) / 64\r\n    };\r\n\r\n    hdr.sig = this._st.read(3);\r\n    hdr.ver = this._st.read(3);\r\n    if (hdr.sig !== 'GIF') {\r\n      throw new Error('Not a GIF file.'); // XXX: This should probably be handled more nicely.\r\n    }\r\n\r\n    hdr.width = this._st.readUnsigned();\r\n    hdr.height = this._st.readUnsigned();\r\n\r\n    const bits = byteToBitArr(this._st.readByte());\r\n    hdr.gctFlag = bits.shift();\r\n    hdr.colorRes = bitsToNum(bits.splice(0, 3));\r\n    hdr.sorted = bits.shift();\r\n    hdr.globalColorTableSize = bitsToNum(bits.splice(0, 3));\r\n\r\n    hdr.bgColor = this._st.readByte();\r\n    hdr.pixelAspectRatio = this._st.readByte(); // if not 0, aspectRatio = (pixelAspectRatio + 15) / 64\r\n\r\n    if (hdr.gctFlag) {\r\n      hdr.globalColorTable = this.parseColorTable(1 << (hdr.globalColorTableSize + 1));\r\n      this.globalColorTable = hdr.globalColorTable;\r\n    }\r\n    if (this._handler.hdr && this._handler.hdr(hdr)) {\r\n      this.checkBytes.push(this._handler.hdr);\r\n    }\r\n  };\r\n\r\n  parseExt = (block: any) => {\r\n    const parseGCExt = (block: any) => {\r\n      this.checkBytes.push(this._st.readByte()); // Always 4\r\n\r\n      const bits = byteToBitArr(this._st.readByte());\r\n      block.reserved = bits.splice(0, 3); // Reserved; should be 000.\r\n      block.disposalMethod = bitsToNum(bits.splice(0, 3));\r\n      block.userInput = bits.shift();\r\n      block.transparencyGiven = bits.shift();\r\n\r\n      block.delayTime = this._st.readUnsigned();\r\n\r\n      block.transparencyIndex = this._st.readByte();\r\n\r\n      block.terminator = this._st.readByte();\r\n\r\n      if (this._handler.gce && this._handler.gce(block)) {\r\n        this.checkBytes.push(this._handler.gce);\r\n      }\r\n    };\r\n\r\n    const parseComExt = (block: any) => {\r\n      block.comment = this.readSubBlocks();\r\n      if (this._handler.com && this._handler.com(block)) {\r\n        this.checkBytes.push(this._handler.com);\r\n      }\r\n    };\r\n\r\n    const parsePTExt = (block: any) => {\r\n      this.checkBytes.push(this._st.readByte()); // Always 12\r\n      block.ptHeader = this._st.readBytes(12);\r\n      block.ptData = this.readSubBlocks();\r\n      if (this._handler.pte && this._handler.pte(block)) {\r\n        this.checkBytes.push(this._handler.pte);\r\n      }\r\n    };\r\n\r\n    const parseAppExt = (block: any) => {\r\n      const parseNetscapeExt = (block: any) => {\r\n        this.checkBytes.push(this._st.readByte()); // Always 3\r\n        block.unknown = this._st.readByte(); // Q: Always 1? What is this?\r\n        block.iterations = this._st.readUnsigned();\r\n        block.terminator = this._st.readByte();\r\n        if (this._handler.app && this._handler.app.NETSCAPE && this._handler.app.NETSCAPE(block)) {\r\n          this.checkBytes.push(this._handler.app);\r\n        }\r\n      };\r\n\r\n      const parseUnknownAppExt = (block: any) => {\r\n        block.appData = this.readSubBlocks();\r\n        // FIXME: This won't work if a handler wants to match on any identifier.\r\n        if (this._handler.app && this._handler.app[block.identifier] && this._handler.app[block.identifier](block)) {\r\n          this.checkBytes.push(this._handler.app[block.identifier]);\r\n        }\r\n      };\r\n\r\n      this.checkBytes.push(this._st.readByte()); // Always 11\r\n      block.identifier = this._st.read(8);\r\n      block.authCode = this._st.read(3);\r\n      switch (block.identifier) {\r\n        case 'NETSCAPE':\r\n          parseNetscapeExt(block);\r\n          break;\r\n        default:\r\n          parseUnknownAppExt(block);\r\n          break;\r\n      }\r\n    };\r\n\r\n    const parseUnknownExt = (block: any) => {\r\n      block.data = this.readSubBlocks();\r\n      if (this._handler.unknown && this._handler.unknown(block)) {\r\n        this.checkBytes.push(this._handler.unknown);\r\n      }\r\n    };\r\n\r\n    block.label = this._st.readByte();\r\n    switch (block.label) {\r\n      case 0xf9:\r\n        block.extType = 'gce';\r\n        parseGCExt(block);\r\n        break;\r\n      case 0xfe:\r\n        block.extType = 'com';\r\n        parseComExt(block);\r\n        break;\r\n      case 0x01:\r\n        block.extType = 'pte';\r\n        parsePTExt(block);\r\n        break;\r\n      case 0xff:\r\n        block.extType = 'app';\r\n        parseAppExt(block);\r\n        break;\r\n      default:\r\n        block.extType = 'unknown';\r\n        parseUnknownExt(block);\r\n        break;\r\n    }\r\n  };\r\n\r\n  parseImg = (img: any) => {\r\n    const deinterlace = (pixels: any, width: any) => {\r\n      // Of course this defeats the purpose of interlacing. And it's *probably*\r\n      // the least efficient way it's ever been implemented. But nevertheless...\r\n\r\n      const newPixels = new Array(pixels.length);\r\n      const rows = pixels.length / width;\r\n      const cpRow = (toRow: any, fromRow: any) => {\r\n        const fromPixels = pixels.slice(fromRow * width, (fromRow + 1) * width);\r\n        newPixels.splice.apply(newPixels, [toRow * width, width].concat(fromPixels));\r\n      };\r\n\r\n      const offsets = [0, 4, 2, 1];\r\n      const steps = [8, 8, 4, 2];\r\n\r\n      let fromRow = 0;\r\n      for (let pass = 0; pass < 4; pass++) {\r\n        for (let toRow = offsets[pass]; toRow < rows; toRow += steps[pass]) {\r\n          cpRow(toRow, fromRow);\r\n          fromRow++;\r\n        }\r\n      }\r\n\r\n      return newPixels;\r\n    };\r\n\r\n    img.leftPos = this._st.readUnsigned();\r\n    img.topPos = this._st.readUnsigned();\r\n    img.width = this._st.readUnsigned();\r\n    img.height = this._st.readUnsigned();\r\n\r\n    const bits = byteToBitArr(this._st.readByte());\r\n    img.lctFlag = bits.shift();\r\n    img.interlaced = bits.shift();\r\n    img.sorted = bits.shift();\r\n    img.reserved = bits.splice(0, 2);\r\n    img.lctSize = bitsToNum(bits.splice(0, 3));\r\n\r\n    if (img.lctFlag) {\r\n      img.lct = this.parseColorTable(1 << (img.lctSize + 1));\r\n    }\r\n\r\n    img.lzwMinCodeSize = this._st.readByte();\r\n\r\n    const lzwData = this.readSubBlocks();\r\n\r\n    img.pixels = lzwDecode(img.lzwMinCodeSize, lzwData);\r\n\r\n    if (img.interlaced) {\r\n      // Move\r\n      img.pixels = deinterlace(img.pixels, img.width);\r\n    }\r\n\r\n    this.frames.push(img);\r\n    this.arrayToImage(img);\r\n    if (this._handler.img && this._handler.img(img)) {\r\n      this.checkBytes.push(this._handler);\r\n    }\r\n  };\r\n\r\n  public parseBlock = () => {\r\n    const block = {\r\n      sentinel: this._st.readByte(),\r\n      type: ''\r\n    };\r\n    const blockChar = String.fromCharCode(block.sentinel);\r\n    switch (blockChar) {\r\n      case '!':\r\n        block.type = 'ext';\r\n        this.parseExt(block);\r\n        break;\r\n      case ',':\r\n        block.type = 'img';\r\n        this.parseImg(block);\r\n        break;\r\n      case ';':\r\n        block.type = 'eof';\r\n        if (this._handler.eof && this._handler.eof(block)) {\r\n          this.checkBytes.push(this._handler.eof);\r\n        }\r\n        break;\r\n      default:\r\n        throw new Error('Unknown block: 0x' + block.sentinel.toString(16));\r\n    }\r\n\r\n    if (block.type !== 'eof') {\r\n      this.parseBlock();\r\n    }\r\n  };\r\n\r\n  arrayToImage = (frame: GifFrame) => {\r\n    let count = 0;\r\n    const c = document.createElement('canvas');\r\n    c.id = count.toString();\r\n    c.width = frame.width;\r\n    c.height = frame.height;\r\n    count++;\r\n    const context = c.getContext('2d');\r\n    const pixSize = 1;\r\n    let y = 0;\r\n    let x = 0;\r\n    for (let i = 0; i < frame.pixels.length; i++) {\r\n      if (x % frame.width === 0) {\r\n        y++;\r\n        x = 0;\r\n      }\r\n      if (this.globalColorTable[frame.pixels[i]] === this._transparentColor.toHex()) {\r\n        context.fillStyle = `rgba(0, 0, 0, 0)`;\r\n      } else {\r\n        context.fillStyle = this.globalColorTable[frame.pixels[i]];\r\n      }\r\n\r\n      context.fillRect(x, y, pixSize, pixSize);\r\n      x++;\r\n    }\r\n    const img = new Image();\r\n    img.src = c.toDataURL();\r\n    this.images.push(img);\r\n  };\r\n}\r\n","import { BoundingBox } from '../Collision/BoundingBox';\r\nimport { Color } from '../Color';\r\nimport { Vector } from '../Math/vector';\r\nimport { ExcaliburGraphicsContext } from './Context/ExcaliburGraphicsContext';\r\nimport { Graphic } from './Graphic';\r\n\r\nexport interface LineOptions {\r\n  start: Vector;\r\n  end: Vector;\r\n  color?: Color;\r\n  thickness?: number;\r\n}\r\nexport class Line extends Graphic {\r\n  readonly start: Vector;\r\n  readonly end: Vector;\r\n  color: Color = Color.Black;\r\n  thickness: number = 1;\r\n  constructor(options: LineOptions) {\r\n    super();\r\n    const { start, end, color, thickness } = options;\r\n    this.start = start;\r\n    this.end = end;\r\n    this.color = color ?? this.color;\r\n    this.thickness = thickness ?? this.thickness;\r\n    const { width, height } = BoundingBox.fromPoints([start, end]);\r\n    this.width = width;\r\n    this.height = height;\r\n  }\r\n\r\n  protected _drawImage(ctx: ExcaliburGraphicsContext, _x: number, _y: number): void {\r\n    ctx.drawLine(this.start, this.end, this.color, this.thickness);\r\n  }\r\n\r\n  clone(): Line {\r\n    return new Line({\r\n      start: this.start,\r\n      end: this.end,\r\n      color: this.color,\r\n      thickness: this.thickness\r\n    });\r\n  }\r\n}","import { ImageFiltering } from '.';\r\nimport { Vector, vec } from '../Math/vector';\r\nimport { Raster, RasterOptions } from './Raster';\r\n\r\nexport interface PolygonOptions {\r\n  points: Vector[];\r\n}\r\n\r\n/**\r\n * A polygon [[Graphic]] for drawing arbitrary polygons to the [[ExcaliburGraphicsContext]]\r\n *\r\n * Polygons default to [[ImageFiltering.Blended]]\r\n */\r\nexport class Polygon extends Raster {\r\n  private _points: Vector[];\r\n  public get points(): Vector[] {\r\n    return this._points;\r\n  }\r\n  public set points(points: Vector[]) {\r\n    this._points = points;\r\n    const min = this.minPoint;\r\n    this.width = this._points.reduce((max, p) => Math.max(p.x, max), 0) - min.x;\r\n    this.height = this._points.reduce((max, p) => Math.max(p.y, max), 0) - min.y;\r\n    this.flagDirty();\r\n  }\r\n\r\n  public get minPoint() {\r\n    const minX = this._points.reduce((min, p) => Math.min(p.x, min), Infinity);\r\n    const minY = this._points.reduce((min, p) => Math.min(p.y, min), Infinity);\r\n    return vec(minX, minY);\r\n  }\r\n\r\n  constructor(options: RasterOptions & PolygonOptions) {\r\n    super(options);\r\n    this.points = options.points;\r\n    this.filtering = ImageFiltering.Blended;\r\n    this.rasterize();\r\n  }\r\n\r\n  public clone(): Polygon {\r\n    return new Polygon({\r\n      points: this.points.map((p) => p.clone()),\r\n      ...this.cloneGraphicOptions(),\r\n      ...this.cloneRasterOptions()\r\n    });\r\n  }\r\n\r\n  execute(ctx: CanvasRenderingContext2D): void {\r\n    if (this.points && this.points.length) {\r\n      ctx.beginPath();\r\n      // Iterate through the supplied points and construct a 'polygon'\r\n      const min = this.minPoint.negate();\r\n      const firstPoint = this.points[0].add(min);\r\n      ctx.moveTo(firstPoint.x, firstPoint.y);\r\n      this.points.forEach((point) => {\r\n        ctx.lineTo(point.x + min.x, point.y + min.y);\r\n      });\r\n      ctx.lineTo(firstPoint.x, firstPoint.y);\r\n      ctx.closePath();\r\n      if (this.color) {\r\n        ctx.fill();\r\n      }\r\n      if (this.strokeColor) {\r\n        ctx.stroke();\r\n      }\r\n    }\r\n  }\r\n}\r\n","/**\r\n * The current Excalibur version string\r\n * @description `process.env.__EX_VERSION` gets replaced by Webpack on build\r\n */\r\nexport const EX_VERSION = process.env.__EX_VERSION;\r\nimport { polyfill } from './Polyfill';\r\npolyfill();\r\n\r\n// This file is used as the bundle entry point and exports everything\r\n// that will be exposed as the `ex` global variable.\r\nexport * from './Flags';\r\nexport * from './Id';\r\nexport * from './Engine';\r\nexport * from './Screen';\r\nexport { Actor, ActorArgs } from './Actor';\r\nexport * from './Math/Index';\r\nexport * from './Camera';\r\nexport * from './Class';\r\nexport * from './Configurable';\r\nexport * from './Debug/index';\r\nexport * from './EventDispatcher';\r\nexport * from './Events/MediaEvents';\r\nexport * from './Events';\r\nexport * from './Label';\r\nexport { FontStyle, FontUnit, TextAlign, BaseAlign } from './Graphics/FontCommon';\r\nexport * from './Loader';\r\nexport { Particle, ParticleEmitter, ParticleArgs, ParticleEmitterArgs, EmitterType } from './Particles';\r\nexport * from './Collision/Physics';\r\nexport * from './Scene';\r\n\r\nexport * from './TileMap/index';\r\n\r\nexport * from './Timer';\r\nexport * from './Trigger';\r\nexport * from './ScreenElement';\r\n\r\nexport * from './Actions/Index';\r\nexport * from './Collision/Index';\r\n\r\nexport * from './Interfaces/Index';\r\nexport * from './Resources/Index';\r\n\r\nexport * from './EntityComponentSystem/index';\r\n\r\nexport * from './Color';\r\n\r\nexport * from './Graphics/index';\r\n\r\n// ex.Events namespace\r\nimport * as events from './Events';\r\nexport { events as Events };\r\n\r\n// ex.Input namespace\r\nimport * as input from './Input/Index';\r\nexport { input as Input };\r\nexport { PointerComponent } from './Input/Index';\r\nexport { PointerSystem } from './Input/PointerSystem';\r\n\r\n// ex.Util namespaces\r\nimport * as util from './Util/Index';\r\nexport { util as Util };\r\n\r\nexport * from './Util/Browser';\r\nexport * from './Util/Decorators';\r\nexport * from './Util/Detector';\r\nexport * from './Util/EasingFunctions';\r\nexport * from './Util/Observable';\r\nexport * from './Util/Log';\r\nexport * from './Util/Pool';\r\nexport * from './Util/Fps';\r\nexport * from './Util/Clock';\r\nexport * from './Util/WebAudio';\r\nexport * from './Util/Toaster';\r\n\r\n// ex.Deprecated\r\n// import * as deprecated from './Deprecated';\r\n// export { deprecated as Deprecated };\r\n// export * from './Deprecated';\r\n","module.exports = new __parcel__URL__(require('./helpers/bundle-manifest').resolve(\"f10Mh\")).toString();","module.exports = new __parcel__URL__(require('./helpers/bundle-manifest').resolve(\"1E0I3\")).toString();","module.exports = new __parcel__URL__(require('./helpers/bundle-manifest').resolve(\"38rEr\")).toString();","module.exports = new __parcel__URL__(require('./helpers/bundle-manifest').resolve(\"hcv2s\")).toString();","module.exports = new __parcel__URL__(require('./helpers/bundle-manifest').resolve(\"jDWyM\")).toString();","module.exports = new __parcel__URL__(require('./helpers/bundle-manifest').resolve(\"lxy2T\")).toString();","module.exports = new __parcel__URL__(require('./helpers/bundle-manifest').resolve(\"kicyl\")).toString();","import * as ex from 'excalibur';\n\nimport beetle from \"./images/beetle.png\";\nimport dirtFrontImageSrc from \"./images/dirt_front.png\";\nimport dirtBackImageSrc from \"./images/dirt_back.png\";\n\nimport groundDigWavSource from \"./sounds/dig.wav\";\nimport groundDigMp3Source from \"./sounds/dig.mp3\";\nimport clankWavSource from \"./sounds/clank.wav\";\nimport clankMp3Source from \"./sounds/clank.mp3\";\n\nexport const Resources = {\n    BeetleImage: new ex.ImageSource(beetle),\n    DirtForegroundImage: new ex.ImageSource(dirtFrontImageSrc),\n    DirtBackgroundImage: new ex.ImageSource(dirtBackImageSrc),\n    // Sounds\n    DigSound: new ex.Sound(groundDigWavSource, groundDigMp3Source),\n    ClankSound: new ex.Sound(clankMp3Source, clankWavSource),\n}\n\n","import * as ex from 'excalibur';\nimport { Resources } from './resources';\nimport { DirtGrid } from './dirt-grid';\nimport { EasingFunctions, RotationType, Vector } from 'excalibur';\n\nexport class Beetle extends ex.Actor {\n    animation!: ex.Animation;\n    dir: ex.Vector = Vector.Right;\n    moving: boolean = false;\n\n    constructor(public tileX: number, public tileY: number, private grid: DirtGrid) {\n        const worldPosFromTile = grid.background.getTile(tileX, tileY).pos;\n        super({\n            name: 'Beetle',\n            pos: worldPosFromTile.add(ex.vec(32, 32)) // shift half a tile from the top left\n        });\n        grid.digTile(tileX, tileY);\n    }\n\n    onInitialize(engine: ex.Engine) {\n        const sheet = ex.SpriteSheet.fromImageSource({\n            image: Resources.BeetleImage,\n            grid: {\n                spriteWidth: 64,\n                spriteHeight: 64,\n                rows: 1,\n                columns: 3,\n            },\n        });\n\n        this.animation = ex.Animation.fromSpriteSheet(\n            sheet,\n            [0, 1, 2],\n            100,\n            ex.AnimationStrategy.PingPong\n        );\n        this.graphics.use(this.animation);\n\n        engine.input.keyboard.on(\"hold\", (evt) => {\n            let dir = Vector.Down;\n            switch (evt.key) {\n                case ex.Input.Keys.A:\n                case ex.Input.Keys.Left:\n                    dir = Vector.Left;\n                    break;\n                case ex.Input.Keys.D:\n                case ex.Input.Keys.Right:\n                    dir = Vector.Right;\n                    break;\n                case ex.Input.Keys.S:\n                case ex.Input.Keys.Down:\n                    dir = Vector.Down;\n                    break;\n                case ex.Input.Keys.W:\n                case ex.Input.Keys.Up:\n                    dir = Vector.Up;\n                    break;\n                default:\n                    return;\n            }\n            this.dir = dir;\n            this.moveInDirection(dir);\n        });\n    }\n\n    /**\n     * Direction is one of four values for down: (0, 1), left: (1, 0), up: (0, -1), or right: (-1, 0)\n     * @param direction \n     */\n    moveInDirection(direction: Vector) {\n        const newTileCoord = direction.add(ex.vec(this.tileX, this.tileY));\n        const futureTile = this.grid.foreground.getTile(newTileCoord.x, newTileCoord.y);\n\n        // If the tile is off grid don't move\n        if (futureTile) {\n            if (!this.moving) {\n                this.moving = true;\n            } else {\n                return;\n            }\n            Resources.DigSound.play();\n            this.grid.digTile(futureTile.x, futureTile.y);\n            // Tile x,y are the tile coordinates\n            this.tileX = futureTile.x;\n            this.tileY = futureTile.y;\n\n            this.actions.rotateTo(\n                Math.atan2(direction.y, direction.x),\n                Math.PI * 4,\n                RotationType.ShortestPath\n            ).easeTo(\n                // Tile pos is the world pixel position of the tile\n                futureTile.pos.add(ex.vec(32, 32)),\n                500,\n                EasingFunctions.EaseInOutCubic\n            ).callMethod(() => {\n                this.moving = false;\n            });\n        } else {\n            Resources.ClankSound.play();\n        }\n    }\n}","import * as ex from 'excalibur';\nimport { Level } from './level';\nimport { Resources } from './resources';\n\nexport class DirtGrid {\n    public foreground!: ex.TileMap;\n    public background!: ex.TileMap;\n    constructor(level: Level) {\n        const foregroundDirt = Resources.DirtForegroundImage.toSprite();\n        const backgroundDirt = Resources.DirtBackgroundImage.toSprite();\n\n        this.foreground = new ex.TileMap({\n            name: 'foreground',\n            pos: ex.vec(0, 0),\n            rows: 10,\n            columns: 10,\n            tileWidth: 64,\n            tileHeight: 64\n        });\n        this.foreground.z = 0;\n\n        for (let tile of this.foreground.tiles) {\n            tile.addGraphic(foregroundDirt);\n        }\n\n        this.background = new ex.TileMap({\n            name: 'background',\n            pos: ex.vec(0, 0),\n            rows: 10,\n            columns: 10,\n            tileWidth: 64,\n            tileHeight: 64\n        });\n        this.background.z = -1;\n        for (let tile of this.background.tiles) {\n            tile.addGraphic(backgroundDirt);\n        }\n\n        level.add(this.background);\n        level.add(this.foreground);\n    }\n\n    digTile(tileX: number, tileY: number) {\n        this.foreground.getTile(tileX, tileY).clearGraphics();\n    }\n}","import * as ex from 'excalibur';\nimport { Level } from './level';\nimport { Resources } from './resources';\n\nconst engine = new ex.Engine({\n    width: 600,\n    height: 400,\n    displayMode: ex.DisplayMode.FitScreenAndFill,\n    antialiasing: false\n});\n\nconst level = new Level();\nengine.addScene(\"main\", level);\nengine.goToScene(\"main\");\n\nconst loader = new ex.Loader();\nfor (const resource of Object.values(Resources)) {\n    loader.addResource(resource);\n}\n\nengine.start(loader);","import * as ex from \"excalibur\";\nimport { Beetle } from \"./beetle\";\nimport { DirtGrid } from \"./dirt-grid\";\n\nexport class Level extends ex.Scene {\n    grid!: DirtGrid;\n    beetle!: Beetle;\n\n    onInitialize(): void {\n        this.grid = new DirtGrid(this);\n        this.beetle = new Beetle(4, 4, this.grid)\n        this.add(this.beetle);\n\n        this.camera.strategy.elasticToActor(this.beetle, .8, .9);\n    }\n}"],"names":["$18c11f3350a906ea$export$6503ec6e8aabbaf","$18c11f3350a906ea$export$f7ad0328861e2f03","$18c11f3350a906ea$var$mapping","pairs","keys","Object","i","length","id","resolved","Error","parcelRequire","register","JSON","parse","__webpack_require__1","entryUnbind","module","exports","__webpack_require__2","path","global","__webpack_require__3","isCallable","tryToString","TypeError","argument","__webpack_require__4","isObject","String","toIndexedObject","__webpack_require__5","toAbsoluteIndex","lengthOfArrayLike","createMethod","IS_INCLUDES","$this","el","fromIndex","value","O","index","includes","indexOf","fails","__webpack_require__6","METHOD_NAME","method","call","__webpack_require__7","createProperty","Array","max","Math","start","end","k","fin","undefined","result","n","arraySlice","__webpack_require__8","floor","mergeSort","array","comparefn","middle","insertionSort","merge","element","j","left","right","llength","rlength","lindex","rindex","uncurryThis","__webpack_require__9","toString","stringSlice","slice","it","__webpack_require__10","TO_STRING_TAG_SUPPORT","classofRaw","TO_STRING_TAG","wellKnownSymbol","CORRECT_ARGUMENTS","arguments","tag","key","error","tryGet","callee","hasOwn","__webpack_require__11","ownKeys","getOwnPropertyDescriptorModule","definePropertyModule","target","source","exceptions","defineProperty","f","getOwnPropertyDescriptor","DESCRIPTORS","__webpack_require__12","createPropertyDescriptor","object","bitmap","enumerable","configurable","writable","toPropertyKey","__webpack_require__13","propertyKey","__webpack_require__14","createNonEnumerableProperty","makeBuiltIn","setGlobal","options","unsafe","simple","noTargetGet","name","__webpack_require__15","get","__webpack_require__16","document","EXISTS","createElement","firefox","__webpack_require__17","match","UA","__webpack_require__18","test","getBuiltIn","__webpack_require__19","version","__webpack_require__20","userAgent","process","Deno","versions","v8","split","webkit","__webpack_require__21","__webpack_require__22","CONSTRUCTOR","METHOD","prototype","__webpack_require__23","defineBuiltIn","copyConstructorProperties","isForced","targetProperty","sourceProperty","descriptor","TARGET","GLOBAL","STATIC","stat","forced","sham","exec","__webpack_require__24","bind","hasOwnProperty","NATIVE_BIND","__webpack_require__25","Function","apply","__webpack_require__26","FunctionPrototype","getDescriptor","PROPER","CONFIGURABLE","__webpack_require__27","fn","__webpack_require__28","aFunction","namespace","aCallable","__webpack_require__29","V","P","func","check","globalThis","window","self","__webpack_require__30","g","this","__webpack_require__31","toObject","__webpack_require__32","a","__webpack_require__33","classof","propertyIsEnumerable","__webpack_require__34","store","functionToString","inspectSource","set","has","NATIVE_WEAK_MAP","__webpack_require__35","shared","sharedKey","hiddenKeys","OBJECT_ALREADY_INITIALIZED","WeakMap","state","wmget","wmhas","wmset","metadata","facade","STATE","enforce","getterFor","TYPE","type","__webpack_require__36","replacement","feature","detection","data","normalize","POLYFILL","NATIVE","string","replace","toLowerCase","__webpack_require__37","__webpack_require__38","isPrototypeOf","USE_SYMBOL_AS_UID","$Symbol","toLength","__webpack_require__39","obj","__webpack_require__40","CONFIGURABLE_FUNCTION_NAME","InternalStateModule","enforceInternalState","getInternalState","CONFIGURABLE_LENGTH","TEMPLATE","getter","setter","arity","constructor","join","V8_VERSION","__webpack_require__41","getOwnPropertySymbols","symbol","Symbol","__webpack_require__42","__webpack_require__43","IE8_DOM_DEFINE","V8_PROTOTYPE_DEFINE_BUG","anObject","$defineProperty","$getOwnPropertyDescriptor","ENUMERABLE","WRITABLE","Attributes","current","__webpack_require__44","propertyIsEnumerableModule","internalObjectKeys","__webpack_require__45","concat","getOwnPropertyNames","__webpack_require__46","__webpack_require__47","push","names","__webpack_require__48","enumBugKeys","$propertyIsEnumerable","NASHORN_BUG","__webpack_require__49","input","pref","val","valueOf","__webpack_require__50","getOwnPropertyNamesModule","getOwnPropertySymbolsModule","__webpack_require__51","__webpack_require__52","__webpack_require__53","__webpack_require__54","uid","__webpack_require__55","SHARED","IS_PURE","__webpack_require__56","mode","copyright","license","toIntegerOrInfinity","__webpack_require__57","min","integer","IndexedObject","__webpack_require__58","requireObjectCoercible","ceil","number","__webpack_require__59","__webpack_require__60","__webpack_require__61","isSymbol","getMethod","ordinaryToPrimitive","TO_PRIMITIVE","exoticToPrim","toPrimitive","__webpack_require__62","__webpack_require__63","__webpack_require__64","__webpack_require__65","__webpack_require__66","postfix","random","NATIVE_SYMBOL","__webpack_require__67","iterator","__webpack_require__68","__webpack_require__69","WellKnownSymbolsStore","symbolFor","createWellKnownSymbol","withoutSetter","description","$","__webpack_require__70","internalSort","arrayMethodIsStrict","FF","IE_OR_EDGE","V8","WEBKIT","un$Sort","sort","FAILS_ON_UNDEFINED","FAILS_ON_NULL","STRICT_METHOD","STABLE_SORT","code","chr","fromCharCode","v","b","charAt","proto","itemsLength","items","arrayLength","x","y","getSortCompare","__webpack_require__71","nativeKeys","___CSS_LOADER_EXPORT___","_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default","_node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default","sources","mappings","sourcesContent","sourceRoot","__WEBPACK_DEFAULT_EXPORT__","cssWithMappingToString","list","map","item","content","needLayer","modules","media","dedupe","supports","layer","alreadyImportedModules","_k","cssMapping","btoa","base64","unescape","encodeURIComponent","stringify","sourceMapping","sourceURLs","$2c23f148d58cd887$var$__webpack_module_cache__","$2c23f148d58cd887$var$__webpack_require__","moduleId","cachedModule","$2c23f148d58cd887$var$__webpack_modules__","__esModule","d","definition","o","e","prop","r","toStringTag","LogLevel1","LogLevel","Side","polyfill","requestAnimationFrame","webkitRequestAnimationFrame","mozRequestAnimationFrame","callback","setInterval","cancelAnimationFrame","webkitCancelAnimationFrame","mozCancelAnimationFrame","AudioContext","webkitAudioContext","replaceMe","decodeAudioData","arrayBuffer","Promise","resolve","reject","mozAudioContext","msAudioContext","oAudioContext","devicePixelRatio","Flags","enable","_FROZEN","_FLAGS","flagName","createId","_x","_y","Zero","Vector","One","Half","Up","Down","Left","Right","angle","cos","sin","vec","isNaN","Infinity","vec1","vec2","sqrt","pow","static","vector","tolerance","abs","squareDistance","size","distance","newLength","scale","setTo","add","sizeOrScale","cross","num","perpendicular","atan2","anchor","sinAngle","cosAngle","fixed","toFixed","_appenders","defaultLevel","Info","Logger","_INSTANCE","addAppender","ConsoleAppender","appender","level","args","len","log","Debug","_log","warn","Warn","Fatal","console","consoleArgs","unshift","width","height","_messages","_canvas","innerWidth","innerHeight","style","position","_ctx","getContext","body","appendChild","message","clearRect","pos","opacity","fillStyle","fillText","Color","parseInt","parseFloat","hex","h","s","l","HSLColor","toRGBA","factor","temp","fromRGBA","saturate","color","newR","newG","newB","newA","color1","invert","color2","multiply","format","toHSLA","toHex","c","_componentToHex","clone","Black","fromHex","White","Gray","LightGray","DarkGray","Yellow","Orange","Red","Vermilion","Rose","Magenta","Violet","Blue","Azure","Viridian","Transparent","ExcaliburBlue","p","q","t","hue2rgb","Side1","getOpposite","side","Top","Bottom","None","fromDirection","direction","directions","directionEnum","Number","MAX_VALUE","maxIndex","dot","BoundingBox","leftOrOptions","top","bottom","intersection","points","minX","minY","maxX","maxY","hasZeroDimensions","center","translate","rotate","point","getPoints","fromPoints","shifted","transform","matrix","matFirstColumn","vec11","xa","xb","matSecondColumn","ya","yb","matrixPos","getPosition","topLeft","bottomRight","results","ray","farClipDistance","tmin","tmax","xinv","dir","yinv","tx1","tx2","ty1","ty2","other","dimensions","contains","totalBoundingBox","combine","equals","overlapX","overlapY","bb","intersect","getSideFromIntersection","drawRect","oTop","parent","offsetLeft","offsetParent","calcOffsetLeft","offsetTop","calcOffsetTop","oLeft","addItemToArray","removeItemFromArray","splice","fail","delay1","milliseconds","clock","_a","schedule","setTimeout","seed","_lowerMask","_upperMask","_w","_n","_m","_u","_s","_b","_t","_c","_l","_f","_mt","Date","now","_index","mag01","BITMASK32","_twist","nextInt","next","likelihood","pickOne","pickSet","numPicks","allowDuplicates","_pickSetWithDuplicates","_pickSetWithoutDuplicates","currentPick","tempArray","swap","randomIndex","range","d4","d6","d8","d10","d12","d20","TwoPI","PI","frac","sign","clamp","canonicalizeAngle","tmpAngle","toDegrees","radians","toRadians","degrees","from","to","randomInRange","Random","floating","randomIntInRange","round","MatrixLocations1","MatrixLocations","EventTypes","Matrix","Float32Array","_scaleSignX","_scaleSignY","near","far","mat","dest","DOMMatrix","identity","sx","sy","angleRadians","vectorOrMatrix","resultX","resultY","a11","a21","a31","a41","a12","a22","a32","a42","a13","a23","a33","a43","a14","a24","a34","a44","b11","b21","b31","b41","b12","b22","b32","b42","b13","b23","b33","b43","b14","b24","b34","b44","getScale","sine","cosine","currentScale","getScaleY","getScaleX","xscale","yscale","setScaleX","setScaleY","getBasisDeterminant","inverseDet","m","tx","ty","_transforms","_currentTransform","pop","_states","_currentState","_getDefaultState","z","save","_cloneState","EventTypes1","GameEvent","_bubbles","bubbles","stopPropagation","super","PostKillEvent","GameStartEvent","GameStopEvent","ctx","delta","PostDebugDrawEvent","PreUpdateEvent","engine","PostUpdateEvent","prevStats","stats","gamepad","button","GamepadAxisEvent","axis","topic","handler","PreCollisionEvent","actor","contact","ContactEndEvent","CollisionPreSolveEvent","oldScene","newScene","EnterTriggerEvent","_handlers","_wiredEventDispatchers","event","eventName","emit","SubscribeEvent","eventHandlers","UnsubscribeEvent","on","ev","off","wire","eventDispatcher","responseType","bustCache","getInstance","EventDispatcher","uri","load","logger","debug","events","request","XMLHttpRequest","open","_cacheBust","addEventListener","status","response","statusText","send","watch","change","__isProxy","Proxy","watchAny","_d","_e","Graphic","_ID","_transformStale","showDebug","_flipHorizontal","_flipVertical","_rotation","_scale","_origin","_width","_height","origin","flipHorizontal","flipVertical","rotation","cloneGraphicOptions","localBounds","fromDimension","ex","_preDraw","_drawImage","_postDraw","reset","_rotate","scaleDirX","scaleDirY","restore","_dirty","image","sourceView","destSize","_updateSpriteDimensions","ready","then","Sprite","newWidth","newHeight","nativeWidth","nativeHeight","isLoaded","drawImage","isPowerOfTwo","nextHighestPowerOfTwo","ensurePowerOfTwo","getGlTypeSizeBytes","gl","FLOAT","SHORT","UNSIGNED_SHORT","BYTE","UNSIGNED_BYTE","getAttributeComponentSize","LOW_FLOAT","HIGH_FLOAT","FLOAT_VEC2","FLOAT_VEC3","FLOAT_VEC4","ImageFiltering1","context","TextureLoader","_GL","_MAX_TEXTURE_SIZE","getParameter","MAX_TEXTURE_SIZE","_TEXTURE_MAP","filtering","forceUpdate","tex","bindTexture","TEXTURE_2D","toPowerOfTwoImage","texImage2D","RGBA","createTexture","checkImageSizeSupportedAndLog","UNPACK_PREMULTIPLY_ALPHA_WEBGL","texParameteri","TEXTURE_WRAP_S","CLAMP_TO_EDGE","TEXTURE_WRAP_T","filterMode","TEXTURE_MIN_FILTER","Pixel","NEAREST","LINEAR","TEXTURE_MAG_FILTER","deleteTexture","potCanvas","_POT_CANVAS","potCtx","_POT_CTX","originalSrc","dataset","_LOGGER","Blended","Map","_logger","Image","_resource","Resource","_filtering","endsWith","_loadedResolve","naturalWidth","naturalHeight","_src","src","async","url","blob","URL","createObjectURL","setAttribute","decode","sprites","rows","columns","spriteIndex","sourceViews","SpriteSheet","spacing","grid","cols","spriteWidth","spriteHeight","originOffset","margin","marginDefaults","offsetDefaults","_text","alphabet","shadow","caseInsensitive","_alreadyWarnedAlphabet","_alreadyWarnedSpriteSheet","spriteSheet","text","textToRender","toLocaleLowerCase","letterIndex","letter","letterSprite","measureText","lines","maxWidthLine","reduce","_getCharacterSprites","sprite","xCursor","yCursor","line","draw","_color","bounds","offset","SpriteFont","_imageSource","ImageSource","fontSheet","_spriteSheet","fromImageSource","_spriteFont","render","_gl","_texture","activeTexture","TEXTURE0","_setupFramebuffer","_frameTexture","frameBuffer","_frameBuffer","frameTexture","attachmentPoint","COLOR_ATTACHMENT0","createFramebuffer","bindFramebuffer","FRAMEBUFFER","framebufferTexture2D","disable","RenderSource","viewport","ExcaliburWebGLContextAccessor","uniforms","attributes","_compiled","vertexSource","fragmentSource","compiled","useProgram","program","Shader","_ACTIVE_SHADER_INSTANCE","vertexShader","_compileShader","VERTEX_SHADER","fragmentShader","FRAGMENT_SHADER","_createProgram","getAttributes","attribute","getUniforms","uniform","uniformCount","getProgramParameter","ACTIVE_UNIFORMS","getActiveUniform","uniformLocation","getUniformLocation","glType","location","attributeCount","ACTIVE_ATTRIBUTES","getActiveAttrib","attributeLocation","getAttribLocation","getAttributePointerType","normalized","slotNumber","texture","setUniformInt","setUniform","uniformType","isCurrentlyBound","createProgram","attachShader","linkProgram","LINK_STATUS","getProgramInfoLog","typeName","shader","createShader","shaderSource","compileShader","getShaderParameter","COMPILE_STATUS","errorInfo","getShaderInfoLog","_processSourceForError","errorLineStart","search","errorLineEnd","_","error2","buffer","createBuffer","bufferData","bindBuffer","ARRAY_BUFFER","STATIC_DRAW","DYNAMIC_DRAW","count","bufferSubData","_layout","_attributes","_vertexTotalSizeBytes","vertexBuffer","_vertexBuffer","_shader","initialize","totalVertexSizeBytes","shaderAttributes","attrib","componentsPerVertex","vertAttribute","typeSize","uploadBuffer","upload","vert","vertexAttribPointer","enableVertexAttribArray","DrawCallCount","DrawnImagesCount","LineRenderer","priority","_maxLines","_vertexIndex","_lineCount","_context","compile","use","setUniformMatrix","ortho","VertexBuffer","VertexLayout","_isFull","flush","getTransform","finalStart","finalEnd","drawArrays","LINES","GraphicsDiagnostics","_maxPoints","_pointCount","_buffer","finalPoint","POINTS","ScreenPassPainter","postprocessor","getShader","getLayout","TRIANGLES","numberOfQuads","useUint16","ELEMENT_ARRAY_BUFFER","totalVertices","maxUint16","maxUint16Index","bufferGlType","Uint16Array","Uint32Array","currentQuad","MAX_TEXTURE_IMAGE_UNITS","_transformFragmentSource","_maxTextures","transformedFrag","setUniformIntArray","_maxImages","_quads","QuadIndexBuffer","maxTextures","newSource","texturePickerBuilder","_textures","_imageCount","swidth","sheight","dx","dy","dwidth","dheight","_addImageAsTexture","view","sw","sh","snapToPixel","topRight","bottomLeft","textureId","_getTextureIdForImage","potWidth","potHeight","uvx0","uvy0","uvx1","uvy1","_bindTextures","drawElements","RectangleRenderer","_maxRectangles","_rectangleCount","drawLine","drawRectangle","thickness","sub","normal","startTop","halfThick","startBottom","endTop","endBottom","stroke","strokeThickness","hasPendingDraws","_maxCircles","_circleCount","radius","builder","recycler","maxObjects","totalAllocations","objects","disableWarnings","done","poolIndex","_webglCtx","_debugText","DebugText","rectOptions","lineOptions","drawPoint","pointOptions","ExcaliburGraphicsContextWebGL","_renderers","_isDrawLifecycle","useDrawSorting","_drawCallPool","Pool","DrawCall","instance","renderer","TransformStack","StateStack","ExcaliburGraphicsContextWebGLDebug","canvasElement","enableTransparency","smoothing","backgroundColor","failIfMajorPerformanceCaveat","__gl","_init","_state","canvas","_ortho","checkIfResolutionSupported","dim","supported","clearColor","clear","COLOR_BUFFER_BIT","BLEND","blendEquation","FUNC_ADD","blendFunc","ONE","ONE_MINUS_SRC_ALPHA","blendEquationSeparate","blendFuncSeparate","ImageRenderer","CircleRenderer","PointRenderer","_screenRenderer","_renderTarget","RenderTarget","_postProcessTargets","rendererName","_isCurrentRenderer","_currentRenderer","beginDrawLifecycle","endDrawLifecycle","_alreadyWarnedDrawLifecycle","drawCall","_drawCalls","_transform","resolution","setResolution","trace","addPostProcessor","removePostProcessor","_postprocessors","originalSort","firstIndex","findIndex","dc","zIndex","originalSortOrder","oldTransform","oldState","currentRendererName","currentRenderer","values","toRenderSource","renderWithPostProcessor","renderToScreen","_ex","__ctx","strokeStyle","strokeRect","beginPath","moveTo","lineTo","lineWidth","closePath","arc","fill","write","ExcaliburGraphicsContext2DCanvasDebug","alpha","imageSmoothingEnabled","resetTransform","_resolution","globalAlpha","filter","setTransform","toDOMMatrix","_postprocessor","DisplayMode","DisplayMode1","SVGA","Standard","Atari2600","GameBoy","GameBoyAdvance","NintendoDS","NES","SNES","_antialiasing","_resolutionStack","_viewportStack","_isFullScreen","_isDisposed","_listenForPixelRatio","_devicePixelRatio","_calculateDevicePixelRatio","applyResolutionAndViewport","_resizeHandler","_setResolutionAndViewportByDisplayMode","_alreadyWarned","_contentArea","_contentResolution","_displayMode","displayMode","Fixed","graphicsContext","antialiasing","_browser","browser","_pixelRatioOverride","pixelRatio","_applyDisplayMode","_fullscreenChangeHandler","_mediaQueryList","removeListener","_pixelRatioChangeHandler","nativeComponent","matchMedia","once","addListener","dispose","_resizeObserver","disconnect","removeEventListener","isHiDpi","FillContainer","FitContainer","FitContainerAndFill","FitContainerAndZoom","parentElement","_viewport","aspectRatio","setCurrentCamera","camera","_camera","pushResolutionAndViewport","peekViewport","scaledWidth","scaledHeight","imageRendering","updateViewport","ExcaliburGraphicsContext2DCanvas","isSmooth","isFullScreen","requestFullscreen","exitFullscreen","pageToScreenCoordinates","newX","newY","screenHeight","screenWidth","screenToPageCoordinates","screenMarginY","screenMarginX","inverse","worldToScreenCoordinates","screen","screenToWorldCoordinates","getWorldBounds","drawWidth","drawHeight","canvasWidth","halfCanvasWidth","canvasHeight","halfCanvasHeight","zoom","halfDrawWidth","halfDrawHeight","_computeFit","overflow","aspect","adjustedWidth","adjustedHeight","vw","vh","_computeFitAndFill","clientWidth","clientHeight","clip","_computeFitAndZoom","scaleY","maxScaleFactor","scaleX","zoomedWidth","zoomedHeight","Window","ResizeObserver","observe","FillScreen","FitScreen","_computeFitContainer","FitScreenAndFill","_computeFitScreenAndFill","_computeFitContainerAndFill","FitScreenAndZoom","_computeFitScreenAndZoom","_computeFitContainerAndZoom","AudioContextFactory","WebAudio","_UNLOCKED","create","unlockTimeoutTimer","audioContext","resume","createBufferSource","ended","connect","destination","onended","playbackState","isLegacyWebAudioSource","currentTime","PLAYING_STATE","FINISHED_STATE","clearTimeout","eventObject","line1","x1","y1","x2","y2","cap","vector1","br","tl","tr","bl","defaultRadius","quadraticCurveTo","circle1","_g","_h","_j","flagDirty","_lineDash","_padding","quality","strokeColor","lineDash","lineCap","padding","_bitmap","bitmapWidth","bitmapHeight","maybeCtx","dirty","_getTotalWidth","_getTotalHeight","_originalHeight","_originalWidth","_smoothing","_strokeColor","_lineWidth","rasterize","_applyRasterProperties","execute","setLineDash","getLineDash","Raster","_options","Canvas","cloneRasterOptions","cache","Loader","Class","loadables","_resourceList","_playButtonShown","_resourceCount","_numLoaded","_progressCounts","_totalCounts","logo","logoWidth","logoHeight","loadingBarColor","suppressPlayButton","_playButtonStyles","Loader_0","Z","playButtonText","startButtonFactory","buttonElement","getElementById","textContent","display","_isLoadedPromise","_isLoadedResolve","addResources","_image","_imageElement","playButtonRootElement","_playButtonRootElement","_playButtonElement","_playButton","existingRoot","_styleBlock","head","_engine","loadable","addResource","_a1","resizeHandler","_positionPlayButton","evt","click","playButtonClicked","startButtonHandler","hidePlayButton","removeChild","_delta","all","finally","showPlayButton","unlock","markResourceComplete","progress","buttonWidth","buttonHeight","playButtonPosition","fillRect","logoY","logoX","logoPosition","imageHeight","oldAntialias","getAntialiasing","setAntialiasing","loadingX","loadingY","loadingBarPosition","roundRect","progressWidth","REPORTED_FEATURES","_features","failedTests","_criticalTests","canvasSupport","elem","xhr","dataUrlSupport","toDataURL","objectUrlSupport","rgbaSupport","cssText","_warningTest","webAudioSupport","webglSupport","_loadBrowserFeatures","getBrowserFeatures","logBrowserFeatures","msg","arraybuffer","arrayBufferSupport","objecturl","rgba","webaudio","webgl","gamepadapi","navigator","getGamepads","failedCritical","warning","CollisionType","CollisionType1","obsoleteMessage","suppressObsoleteMessages","isEnabled","maxMessages","showStackTrace","obsolete","alternateMethod","property","SyntaxError","DecoratedClass","logMessage","CollisionResolutionStrategy","BroadphaseStrategy","Integrator","CollisionResolutionStrategy1","BroadphaseStrategy1","Integrator1","Physics","gravity","acc","collisionResolutionStrategy","Arcade","Realistic","dynamicTreeVelocityMultiplyer","dynamicTreeVelocityMultiplier","DynamicAABBTree","integrator","Euler","boundsPadding","positionIterations","velocityIterations","slop","steeringFactor","warmStart","bodiesCanSleepByDefault","surfaceEpsilon","sleepEpsilon","wakeThreshold","sleepBias","checkForFastBodies","disableMinimumSpeedForFastBody","decorators","desc","Reflect","decorate","_getX","getX","_getY","getY","_setX","setX","_setY","setY","newComponent","Component","observers","subscriptions","observer","observersLength","subscriptionsLength","i1","CoordPlane1","_position","VectorView","X","Y","createPosView","posChanged$","notifyAll","createScaleView","coordPlane","World","Observable","_z","getRotation","getGlobalMatrix","globalPos","globalScale","globalRotation","owner","TransformComponent","_recalculate","oldPos","setPosition","oldX","getAffineInverse","oldY","parentTransform","oldz","zIndexChanged$","setRotation","setScale","globalScaleX","globalScaleY","scaleFactor","angularVelocity","torque","inertia","CollisionGroup","category","mask","_name","_category","_mask","collisionGroups","combinedName","combinedCategory","All","colliderA","colliderB","Pair","calculatePairHash","bodyA","BodyComponent","bodyB","group","canCollide","collisionType","PreventCollision","active","collide","collider","idA","idB","projection","overlaps","worldBounds","root","nodes","_insert","leaf","leafAABB","currentRoot","isLeaf","area","getPerimeter","combinedArea","cost","inheritanceCost","leftCost","leftCombined","newArea","oldArea","rightCost","rightCombined","TreeNode","oldParent","newParent","currentNode","_balance","grandParent","sibling","node","untrackCollider","_remove","multdx","vel","multdy","balance","helper","rayCast","Green","numerator","begin","getSlope","divisor","u","getLength","getPoint","time","_dynamicCollisionTree","DynamicTree","_pairs","Set","_collisionPairCache","_colliders","CompositeCollider","colliders","getColliders","trackCollider","hash","targets","potentialColliders","query","_pairExists","pair","physics","collider1","Active","updateDistance","seconds","minDimension","fastBodies","updateVec","centerPoint","furthestPoint","getFurthestPoint","Ray","minCollider","minTranslate","rayCastQuery","hitPoint","isValid","shift","update","fastBodyCollisions","contacts","newContacts","collisions","updated","updateCollider","Collider","__compositeColliderId","_collisionProcessor","DynamicTreeCollisionProcessor","_dynamicAABBTree","addCollider","clearColliders","track","removeCollider","unwire","untrack","worldPos","axes","furthestPoints","bestPoint","maxDistance","mass","totalInertia","getInertia","otherColliders","potentialCollider","getClosestLineBetween","maybeLine","minLength","minLine","minPoint","minDistance","projs","proj","project","newProjection","Projection","LineSegment","slope","intercept","below","sideVector","clipTime","signed","x0","y0","aMinusP","hasPoint","currPoint","threshold","dxc","dyc","dx1","dy1","p0","q0","w0","denom","tClosestParallel","sClosest","tClosest","sDenom","tDenom","polygonA","polygonB","otherWorldPos","otherDirection","thisDirection","negate","rayTowardsOther","rayTowardsThis","thisPoint","otherPoint","thisFace","getClosestFace","otherFace","ClosestLine","face","getEdge","PolygonEdgeClosestLine","polygon","edge","edgeLine","asLine","circle","circlex","circley","circleA","circleB","CircleEdgeClosestLine","circleWorlPos","edgeA","edgeB","edgeLineA","edgeLineB","_naturalRadius","orig","discriminant","toi","toi1","toi2","positiveToi","mintoi","shape","CircleCollider","ClosestLineJumpTable","CircleCircleClosestLine","PolygonCollider","PolygonCircleClosestLine","flip","EdgeCollider","CollisionJumpTable","CollideCircleCircle","CollideCirclePolygon","CollideCircleEdge","getFurthestLocalPoint","scalars","dotProduct","mtv","tangent","localPoints","info","_canceled","sleeping","sleepMotion","setSleeping","isCanceled","SeparatingAxis","polyA","polyB","bestSeparation","bestSide","bestAxis","bestSideIndex","bestOtherPoint","sides","getSides","localSides","getLocalSides","vertB","vertSeparation","distanceToPoint","separation","localSide","sideId","localPoint","polyDir","closestPointOnPoly","minOverlap","minAxis","minIndex","proj1","proj2","overlap","getOverlap","circleAPos","circleBPos","combinedRadius","mvt","local","CollisionContact","findCirclePolygonSeparation","samedir","applyInverse","findSide","findLocalSide","cc","edgeWorld","asLocalLine","da","dda","db","ddb","den","pointOnEdge","dd","pc","linePoly","CollidePolygonPolygon","separationA","findPolygonPolygonSeparation","separationB","incident","reference","refDir","clipRight","clipLeft","xf","shapeA","txA","shapeB","txB","worldPoint","circlePoint","dist","average","_getBodyPos","_getTransformedBegin","_getTransformedEnd","EdgeEdgeClosestLine","CollidePolygonEdge","CollideEdgeEdge","transformedBegin","transformedEnd","_boundsFromBeginEnd","edgeNormal","drawCircle","_transformedPoints","_axes","_sides","_localSides","_globalMatrix","_localBoundsDirty","_isCounterClockwiseWinding","reverse","isConvex","_calculateTransformation","_points","sum","oldPoint","newPoint","oldDirection","orientation","angleSum","entries","polygons","Shape","Polygon","getItem","isPointInTriangle","ab","bc","ca","ap","bp","cp","cross1","cross2","cross3","triangles","vertices","indices","va","vb","vc","leftArm","isEar","vertIndex","getTransformedPoints","currentSide","mostDirection","testRay","accum","PolygonPolygonClosestLine","pts","POSITIVE_INFINITY","faceIndex","_localBounds","denominator","iplusone","crossTerm","minContactTime","contactIndex","contactTime","scalar","firstPoint","Circle","Box","ColliderComponent","$colliderAdded","$colliderRemoved","_collider","flipped","forEach","onAdd","entity","precollision","postcollision","PostCollisionEvent","CollisionStartEvent","CollisionEndEvent","onRemove","poly","useEdgeCollider","Edge","DegreeOfFreedom","RotationType","TextAlign","BaseAlign1","BaseAlign","FontStyle1","FontStyle","Direction","Axis1","Axis","DegreeOfFreedom1","dependencies","MotionComponent","_oldTransform","defaultMass","canSleep","_sleeping","bounciness","friction","useGravity","limitDegreeOfFreedom","oldVel","oldAcc","inverseMass","currentMotion","bias","inverseInertia","motion","oldRotation","impulse","finalImpulse","addEqual","Rotation","distanceFromCenter","applyAngularImpulse","AddedComponent","isAddedComponent","RemovedComponent","isRemovedComponent","components","Entity","_componentsToRemove","_componentTypeToInstance","_componentStringToInstance","_tagsMemo","_typesMemo","componentAdded$","componentRemoved$","_parent","childrenAdded$","childrenRemoved$","_children","_isInitialized","_setName","component","addComponent","kill","tags","addTag","TagComponent","force","removeComponent","_rebuildMemos","added","removed","getAncestors","children","queue","curr","newEntity","types","child","addChild","addTemplate","templateEntity","getComponents","ctor","constuctorType","_notifyAddComponent","componentOrType","_removeComponentByType","delete","_notifyRemoveComponent","isInitialized","InitializeEvent","onPreUpdate","onPostUpdate","_initialize","_preupdate","_postupdate","graphic","tick","_graphics","gfx","nameOrGraphic","getGraphic","graphics","recalculateBounds","copyGraphics","getNames","hide","show","order","currentKeys","GraphicsLayers","_component","_layers","_layerMap","default","GraphicsLayer","_maybeAddLayer","_getLayer","graphicsLayerKeys","visible","onPreDraw","onPostDraw","layers","graphicToSet","offsetX","offsetY","elapsed","idempotencyToken","hasGraphicsTick","Rectangle","_radius","useColliderShape","useGraphicsBounds","easing","duration","Linear","EasingFunctions","CreateReversibleEasingFunction","startValue","endValue","EaseInQuad","EaseOutQuad","EaseInOutQuad","EaseInCubic","EaseOutCubic","EaseInOutCubic","_actions","_completedActions","_entity","action","_currentAction","stop","getActions","elapsedMs","isComplete","Repeat","repeatBuilder","repeat","_stopped","_repeatBuilder","_repeatContext","ActionContext","_actionQueue","getQueue","_repeat","_originalRepeat","clearActions","speed","_started","_start","_tx","_end","_offset","_distance","_dir","_motion","_speed","destx","desty","RotationType1","rotationType","_rotationType","ShortestPath","_currentNonCannonAngle","distance1","distance2","_shortDistance","_longDistance","_shortestPathIsPositive","_direction","LongestPath","Clockwise","CounterClockwise","distanceTravelled","RotateBy","angleRadiansOffset","speedX","speedY","_endX","_endY","_speedX","_speedY","_startX","_startY","_distanceX","_distanceY","directionX","directionY","scaleOffsetX","scaleOffsetY","_startScale","_endScale","_directionX","_directionY","_method","_hasBeenCalled","EaseTo","easingFcn","_currentLerpTime","_lerpDuration","_lerpStart","_lerpEnd","_initialized","Blink","timeVisible","timeNotVisible","numBlinks","_timeVisible","_timeNotVisible","_elapsedTime","_totalTime","GraphicsComponent","_duration","Fade","endOpacity","_endOpacity","_multiplier","delay","_delay","ActionsComponent","entityToFollow","followDistance","_followTx","_current","_followMotion","actorToFollowSpeed","_distanceBetween","_maximumDistance","Meet","actorToMeet","_speedWasSpecified","_meetTx","_meetMotion","actorToMeetSpeed","_queue","ActionQueue","yOrSpeed","speedOrUndefined","xOrPos","MoveTo","yOffsetOrSpeed","yOffset","xOffsetOrVector","xOffset","MoveBy","RotateTo","sizeXOrVector","sizeYOrSpeed","speedXOrUndefined","speedYOrUndefined","sizeX","ScaleTo","sizeY","sizeOffsetXOrVector","sizeOffsetYOrSpeed","sizeOffsetX","sizeOffsetY","ScaleBy","Delay","Die","CallMethod","times","repeatForever","RepeatForever","Follow","easeTo","moveBy","rotateTo","rotateBy","scaleTo","scaleBy","blink","fade","die","callMethod","follow","meet","toPromise","FontUnit1","TextAlign1","Direction1","Font","_o","_p","_q","_r","family","Normal","bold","unit","Px","textAlign","baseAlign","Alphabetic","LeftToRight","_textBounds","_cachedTextMeasurement","_bitmapToTextMeasurement","_textToBitmap","_bitmapUsage","_textFragments","blur","fontString","measurementDirty","cached","rasterProps","_getRasterPropertiesHash","_getTextBitmap","_applyFont","metrics","textHeight","actualBoundingBoxAscent","actualBoundingBoxDescent","lineAdjustedHeight","bottomBounds","measurement","actualBoundingBoxLeft","actualBoundingBoxRight","textBounds","textBaseline","font","shadowColor","shadowBlur","shadowOffsetX","shadowOffsetY","colorOverride","lineHeight","strokeText","textAndHash","textImages","currentX","currentY","clearCache","checkAndClearCache","isNewBitmap","_setDimension","_drawText","frag","_splitTextBitmap","frag1","performance","cacheSize","_textWidth","_textHeight","Text","_font","_calculateDimension","isStale","Actor","config","_anchor","_handleAnchorChange","scene","_draggable","_dragging","_pointerDragStartHandler","_pointerDragEndHandler","_pointerDragMoveHandler","pe","_pointerDragLeaveHandler","collisionGroup","defaults","PointerComponent","Passive","thePos","theVel","theAcc","theAngle","isOffScreen","hasTag","draggable","isDraggable","currentGraphic","_scene","PreKillEvent","onPreKill","onPostKill","_prekill","KillEvent","newZ","getGlobalPos","localCenter","getGlobalScale","getGlobalRotation","recurse","geom","containment","some","otherCollider","me","ScreenElement","Screen","useBoxCollider","useWorld","coords","fcn","interval","repeats","numberOfRepeats","_totalTimeAlive","_running","_numberOfTicks","maxNumberOfRepeats","_complete","Timer","_MAX_ID","_callbacks","complete","newInterval","newNumberOfRepeats","timesRepeated","getTimeRunning","timeToNextAction","timeElapsedTowardNextAction","isRunning","pause","cancelTimer","parallaxFactor","useTransform","_token","_onScreenXStart","_onScreenXEnd","_onScreenYStart","_onScreenYEnd","tiles","_rows","_cols","_collidersDirty","DebugGraphicsComponent","_composite","useCompositeCollider","subscribe","flagCollidersDirty","tileWidth","tileHeight","currentCol","cd","Tile","_getOrSetColliderOriginalOffset","_originalOffsets","originalOffset","tile","solid","prev","getTile","_updateColliders","worldCoordsUpperLeft","worldCoordsLowerRight","maybeParallax","ParallaxComponent","parallaxOffset","oneMinusFactor","currentScene","PreDrawEvent","xEnd","yEnd","graphicsIndex","graphicsLen","getGraphics","PostDrawEvent","grayish","_posDirty","_solid","_pos","clearGraphics","_bounds","StrategyContainer","lockToActor","addStrategy","LockCameraToActorStrategy","LockCameraToActorAxisStrategy","cameraElasticity","cameraFriction","ElasticToActorStrategy","radiusAroundActor","RadiusAroundActorStrategy","limitCameraBounds","box","LimitCameraBoundsStrategy","target1","_cam","_eng","target2","cam","currentFocus","getFocus","target3","focus","cameraVel","stretch","target4","target5","boundSizeChecked","focusX","focusY","Camera","_cameraStrategies","strategy","dz","az","_angularVelocity","_posChanged","_cameraMoving","_isShaking","_shakeMagnitudeX","_shakeMagnitudeY","_shakeDuration","_elapsedShakeTime","_xShake","_yShake","_isZooming","_zoomStart","_zoomEnd","_currentZoomTime","_halfWidth","_halfHeight","_follow","ay","easingFn","_lerpPromise","_lerpResolve","_easing","magnitudeX","magnitudeY","_zoomPromise","_zoomResolve","_zoomEasing","_zoomDuration","cameraStrategy","_screen","currentRes","loadingComplete","res","peekResolution","updateTransform","runStrategies","onInitialize","newZoom","zoomEasing","lerpPoint","CreateVectorEasingFunction","moveEasing","_isDoneShaking","newCanvasWidth","newCanvasHeight","cameraPos","Trigger","opts","triggerDefaults","_dispatchAction","ExitTriggerEvent","_target","SystemType","SystemType1","System","notify","_entityAddedOrRemoved","AddedEntity","isAddedSystemEntity","isRemoveSystemEntity","_world","entities","_entityIndex","_entitiesToRemove","updateEntities","findEntitiesForRemoval","queryManager","addEntity","removeEntity","idOrEntity","deferred","unregister","currFrame","actors","killed","processComponentRemoval","localeCompare","_entities","T","_key","buildTypeKey","matches","RemovedEntity","typesOrEntity","_queries","entityManager","queryType","contain","maybeExistingQuery","getQuery","Query","_addQuery","systems","initialized","systemType","find","system","createQuery","maybeRemoveQuery","s3","preupdate","s1","getEntities","Scene","s2","postupdate","removeSystem","QueryManager","EntityManager","systemManager","SystemManager","Update","updateSystems","processComponentRemovals","processEntityRemovals","entityOrSystem","addSystem","EulerIntegrator","totalAcc","MotionSystem","optionalBody","captureOldTransform","integrate","preSolve","solveVelocity","solvePosition","postSolve","CollisionSolver","opposite","velAdj","normalImpulse","tangentImpulse","normalMass","tangentMass","aToContact","bToContact","aToContactNormal","bToContactNormal","aToContactTangent","bToContactTangent","velA","lastFrameContacts","idToContactConstraint","matchAwake","contact1","finishedContactIds","contactPoints","pointIndex","ContactConstraintPoint","contact2","getContactConstraints","updateMotion","CollisionPostSolveEvent","applyImpulse","constraints","FindContactSeparation","maxCorrection","steeringForce","restitution","impulseDelta","getRelativeVelocity","maxFriction","newImpulse","point2","_realisticSolver","RealisticSolver","_arcadeSolver","ArcadeSolver","_processor","_lastFrameContacts","_currentFrameContacts","_trackCollider","_untrackCollider","colliderComponent","enabled","colliderComp","broadphase","narrowphase","getSolver","solve","compositeId","substring","runContactStartEnd","ContactStartEvent","id1","c1","AnimationStrategy","EmitterType1","EmitterType","AnimationDirection1","AnimationStrategy1","frames","Loop","frameDuration","timeScale","_idempotencyToken","_firstTick","_currentFrame","_timeLeftInFrame","_done","_playing","totalDuration","goToFrame","Animation","_reversed","maybeFrame","currentFrame","frameIndices","durationPerFrameMs","invalidIndices","currentFrameIndex","isPlaying","Backward","Forward","canFinish","End","Freeze","frameNumber","PingPong","elapsedMilliseconds","_nextFrame","members","_updateDimensions","GraphicsGroup","_isAnimationOrGroup","member","maybeAnimation","Configurable","base","assign","props","emitterOrConfig","life","beginColor","endColor","velocity","acceleration","startSize","endSize","particleRotationalVelocity","currentRotation","focusAccel","fadeFlag","_rRate","_gRate","_bRate","_aRate","_currentColor","emitter","particleSize","particleSprite","sizeRate","elapsedMultiplier","isOffscreen","ParticleEmitter","tmpColor","removeParticle","accel","Particle","ParticleImpl","_particlesToEmit","numParticles","isEmitting","particles","deadParticles","minVel","maxVel","minAngle","maxAngle","particleLife","minSize","maxSize","_sprite","emitterType","randomRotation","emitRate","particle","particleCount","_createParticle","world","ranX","ranY","emitParticles","remove","GraphicsSystem","Draw","_sortedTransforms","_zHasChanged","_zIndexUpdate","sortedTransforms","_graphicsContext","entityAddedOrRemoved","unsubscribe","parallax","_applyTransform","particleOpacity","_drawGraphicsComponent","graphicsComponent","isDebug","showBounds","boundsColor","ancestors","ancestor","DebugSystem","_collisionSystem","CollisionSystem","filterSettings","entitySettings","txSettings","motionSettings","colliderSettings","physicsSettings","graphicsSettings","debugDraw","bodySettings","cameraSettings","useFilter","ids","nameQuery","cursor","_pushCameraTransform","showAll","showPosition","positionColor","showPositionLabel","drawText","showZIndex","showId","showName","showRotation","fromAngle","rotationColor","showScale","scaleColor","showCollisionGroup","showCollisionType","showMass","showMotion","showSleeping","showVelocity","velocityColor","showAcceleration","accelerationColor","showGeometry","geometryColor","collider2","showOwner","_popCameraTransform","showBroadphaseSpacePartitionDebug","showCollisionContacts","showCollisionNormals","collisionContactColor","point3","collisionNormalColor","showFocus","focusColor","showZoom","PointerSystem","overrideUseColliderShape","overrideUseGraphicsBounds","lastFrameEntityToPointers","currentFrameEntityToPointers","_sortedEntities","_receiver","pointers","pointerId","entered","entityCurrentlyUnderPointer","entityWasUnderPointer","_processPointerToEntity","_dispatchEvents","pointer","currentFramePointerCoords","screenPos","addPointerToEntity","graphicBounds","currentFrameDown","isDragStart","lastDownPerPointer","lastUpPerPointer","currentFrameUp","isDragEnd","currentFrameMove","isDragging","lastMovePerPointer","lastUpDownMoveEvents","currentFrameCancel","currentFrameWheel","lastFrameEntities","currentFrameEntities","entitiesWithEvents","_processDownAndEmit","_processUpAndEmit","_processMoveAndEmit","_processCancelAndEmit","_processWheelAndEmit","actions","iso","IsometricEntityComponent","elevation","OffscreenSystem","entityOffscreen","_isOffscreen","ExitViewPortEvent","EnterViewPortEvent","removeTag","transformedBounds","ActionsSystem","IsometricEntitySystem","tileMaps","TileMap","_timers","_oldScene","_newScene","onDeactivate","$de39ecf67192eccb$exports","import","meta","$19a3e16862cbabb2$exports","$4718236e27e18176$exports","$ee2f9a046451f577$exports","$19c4e4c76d8bcb31$exports","$b6db5538437aa8f6$exports","$98448c971e82c9d2$exports","$7c4c300842bd4cf2$export$e9a269813a6315a4","BeetleImage","$2c23f148d58cd887$export$280e9a68c3ffd919","$parcel$interopDefault","DirtForegroundImage","DirtBackgroundImage","DigSound","$2c23f148d58cd887$export$85990f0f98a390bb","ClankSound","$241fba3d5d378ac5$export$ab2df81792a3386d","$2c23f148d58cd887$export$f73d3eb6fd876d80","tileX","tileY","background","$2c23f148d58cd887$export$202e0172ed3c7be0","$2c23f148d58cd887$export$9b781de7bf37bf48","moving","digTile","sheet","$2c23f148d58cd887$export$bd73ddfe5f8475d8","animation","$2c23f148d58cd887$export$c35d437ae5945fcd","fromSpriteSheet","$2c23f148d58cd887$export$6cfd78ddb48c90c6","keyboard","$2c23f148d58cd887$export$f5b8910cec6cf069","Keys","A","D","S","W","moveInDirection","newTileCoord","futureTile","foreground","play","$2c23f148d58cd887$export$91397be43fc980cc","$2c23f148d58cd887$export$6ff391a2049fdf40","$089a2616e5e87956$export$504e0225dd484611","foregroundDirt","toSprite","backgroundDirt","$2c23f148d58cd887$export$16ec26812de3ce7a","addGraphic","tile1","$ad2bcec7a0192558$var$engine","$2c23f148d58cd887$export$2c3b404bf3a77a1f","$2c23f148d58cd887$export$4b7264771109adb6","$ad2bcec7a0192558$var$level","$2c23f148d58cd887$export$38af1803e3442a7f","beetle","elasticToActor","addScene","goToScene","$ad2bcec7a0192558$var$loader","$2c23f148d58cd887$export$3b0d6d7590275603","resource"],"version":3,"file":"index.171a732f.js.map"}